---
title: FastAPI
date of creation: 2025-03-26T05:19:00
tags:
  - Framework
  - Framework/Python
  - Python/Backend
  - Developing/Python
read status: true
completion status: false
documentation: https://fastapi.tiangolo.com/ru/
aliases:
  - Fastapi
  - fastapi
---
# FastAPI
---

**FastAPI** — это современный, быстрый (высокопроизводительный) веб-фреймворк для создания [[API]] используя [[Python]], в основе которого лежит стандартная аннотация типов Python.

Ключевые особенности:

- **Скорость**: Очень высокая производительность, на уровне **[[NodeJS]]** и **[[Go]]** (благодаря [[Starlette]] и [[Pydantic]]). [Один из самых быстрых фреймворков Python](https://fastapi.tiangolo.com/ru/#_10).
- **Быстрота разработки**: Увеличьте скорость разработки примерно на 200–300%. *
- **Меньше ошибок**: Сократите примерно на 40% количество ошибок, вызванных человеком (разработчиком). *
- **Интуитивно понятный**: Отличная поддержка редактора. Автозавершение везде. Меньше времени на отладку.
- **Лёгкость**: Разработан так, чтобы его было легко использовать и осваивать. Меньше времени на чтение документации.
- **Краткость**: Сведите к минимуму дублирование кода. Каждый объявленный параметр - определяет несколько функций. Меньше ошибок.
- **Надежность**: Получите готовый к работе код. С автоматической интерактивной документацией.
- **На основе стандартов**: Основан на открытых стандартах API и полностью совместим с ними: [OpenAPI](https://github.com/OAI/OpenAPI-Specification) (ранее известном как [[Swagger]]) и [JSON Schema](https://json-schema.org/).

 ****оценка на основе тестов внутренней команды разработчиков, создающих производственные приложения.***


## Конечные точки
---

**Конечная точка API** — это URL-адрес, по которому сервер или сервис предоставляет доступ к данным или функционалу. В разработке API такие конечные точки часто называют «ручками». То есть, API можно «дергать» разными способами для получения различных данных или выполнения действий.

В FastAPI конечные точки определяются с помощью Python-функций, которые привязываются к [[HTTP-методы|HTTP-методам]], таким как `@app.get()` для обработки запросов GET или `@app.post()` для обработки запросов POST и так далее. Эти функции обрабатывают входящие запросы и генерируют ответы.

Для начала рассмотрим два простых примера: один для получения данных с сервера с помощью GET-запроса, а другой — для отправки данных с помощью POST-запроса.

Пример:

```python
from fastapi import FastAPI

app = FastAPI()

fake_db = [{"username": "vasya", "user_info": "любит плавание"},
            {"username": "kaya", "user_info": "любит видеогры"}]


# Обрабатываем GET-запрос, чтобы вернуть список пользователей
@app.get('/users')
async def get_all_users():
    return fake_db


# Обрабатываем POST-запрос, чтобы добавить нового пользователя
@app.post('/add_user')
async def add_user(username: str, user_info: str):
	fake_db.append({"username": username, "user_info": user_info})            return {"message": "Юзер успешно добавлен в базу данных"}
```

В этом примере:

- Мы создаём [[GET-метод]] для получения списка пользователей с сервера.
- Создаём [[POST-метод]] для добавления нового пользователя в «фейковую» базу данных. Мы передаем параметры как query-параметры (параметры, передаваемые в [[URL]]), но для POST-запросов это не самый привычный способ. Обычно в POST-запросах данные передаются в теле запроса (чаще всего в формате JSON).


### Параметры запроса, пути и тела в FastAPI
---

В FastAPI вы можете работать с разными типами параметров, которые могут быть частью запроса. Существует три основных типа параметров: **параметры пути**, **параметры запроса** и **параметры тела запроса**. Все они выполняют разные функции и используются в разных ситуациях.


#### Параметры пути (Path Parameters)
---

**Параметры пути** — это части [[URL]], которые захватываются и передаются в виде аргументов функции. Эти параметры часто используются для уникальной идентификации ресурса, например, для получения информации о конкретном пользователе по его ID.

Пример: `/users/{user_id}`, где `{user_id}` — это параметр пути.


##### Пример использования параметра пути
---

Допустим, у нас есть API, который позволяет получить информацию о пользователях по их идентификатору. Путь будет выглядеть так:

```python
from fastapi import FastAPI


app = FastAPI()


@app.get('/{user_id}') # тут объявили параметр пути
async def get_user(user_id: int): # тут указали его тип данных
    # какая-то логика работы поиска
    # ...

    return {
        "user_id": user_id,
        "message": f"Информация о пользователе с ID {user_id}"
    }
```

Здесь `{user_id}` — это параметр пути, который будет передан в функцию `get_user` как аргумент `user_id`. В зависимости от того, какой идентификатор вы укажете в [[URL]], будет возвращаться соответствующая информация.


##### Конечная точка для получения информации о пользователе по ID
---

В этом шаге мы создадим конечную точку, которая будет обрабатывать запросы GET для получения информации о пользователе. Мы будем работать с фейковой базой данных (условным словарем), чтобы показать, как можно извлекать данные по идентификатору пользователя.

```python
from fastapi import FastAPI


app = FastAPI()

# Пример фейковой базы данных
fake_users = {
    1: {"username": "john_doe", "email": "john@example.com"},
    2: {"username": "jane_smith", "email": "jane@example.com"},
}


# Конечная точка для получения информации о пользователе по ID
@app.get("/users/{user_id}")
def get_user(user_id: int):
    if user_id in fake_users:
        return fake_users[user_id]

    return {"error": "User not found"}

```

В этой конечной точке мы используем параметр пути `user_id`, чтобы искать пользователя в словаре `fake_users`. Если пользователь найден, мы возвращаем его данные. Если нет — возвращаем условную ошибку с сообщением "User not found". .

Теперь, при обращении по URL вида `http://localhost:8000/users/1`, вы получите информацию о первом пользователе, а если указать несуществующий ID, например `http://localhost:8000/users/99`, будет возвращена ошибка.

Этот пример демонстрирует, как можно взаимодействовать с базой данных или фейковыми данными в FastAPI, выполняя операции поиска или извлечения информации.


###### Как работает запрос
---

Предположим, что ваше приложение запущено на `http://localhost:8000`, и вы хотите получить информацию о пользователе с ID 5. Вы отправляете GET-запрос по следующему URL:

```browser
http://localhost:8000/users/5
```

Ответ будет:

```json
{
  "user_id": 5,
  "message": "Информация о пользователе с ID 5"
}
```

Если вы попробуете использовать другой идентификатор, например, 10, результат изменится:

```browser
http://localhost:8000/users/10
```

Ответ:

```json
{
  "user_id": 10,
  "message": "Информация о пользователе с ID 10"
}
```


###### Как указывать тип данных для параметров пути
---

FastAPI автоматически проверяет типы данных параметров пути. В примере выше мы указали, что параметр `user_id` должен быть целым числом (`int`). Если вы передадите неправильный тип данных, например строку вместо числа, FastAPI автоматически вернет ошибку.

Пример:

```browser
http://localhost:8000/users/abc
```

Ответ:

```json
{
  "detail": [ 
    {
      "loc": ["path", "user_id"],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"} 
  ]
}
```

FastAPI предоставляет множество полезных функций для работы с параметрами пути, позволяя вам быстро создавать динамичные и удобные API.

###### Применение параметров пути в реальных приложениях
---

Параметры пути особенно полезны, когда вы хотите идентифицировать конкретный ресурс или объект, например:

- Получение информации о пользователе по его ID.
- Получение информации о товаре по его SKU.
- Удаление объекта из базы данных по уникальному идентификатору.

Пример с удалением пользователя:

```python
@app.delete('/users/{user_id}')
async def delete_user(user_id: int):
    return {"message": f"Пользователь с ID {user_id} был удален"}
```

Таким образом, параметры пути — это удобный способ динамично работать с URL и извлекать данные из пути запроса, обеспечивая гибкость в создании API.

В следующих шагах мы рассмотрим, как работать с параметрами запроса.


#### Параметры запроса (Query Parameters)
---

**Параметры запроса** — это дополнительные данные, которые передаются в [[URL]] в формате ключ-значение после знака вопроса `?` и они состоят из пар "ключ-значение", например: `limit=10`. Эти параметры часто используются для фильтрации, сортировки или ограничения количества данных, которые возвращает сервер.

Пример: `/users?limit=10&active=true`, где `limit` и `active` — параметры запроса.

Например, если вы хотите ограничить количество возвращаемых пользователей, вы можете использовать параметр запроса `limit`. В этом случае URL будет выглядеть так:

```browser
http://localhost:8000/users/?limit=3.
```


##### Пример работы с параметром запроса
---

Предположим, что у нас есть приложение, которое возвращает список пользователей. Вначале мы добавим параметр запроса, чтобы можно было ограничивать количество возвращаемых пользователей. Вот как это будет выглядеть:

```python
from fastapi import FastAPI


app = FastAPI()

# Пример пользовательских данных (для демонстрационных целей)
fake_users = {
    1: {"username": "john_doe", "email": "john@example.com"},
    2: {"username": "jane_smith", "email": "jane@example.com"},
    3: {"username": "alice_jones", "email": "alice@example.com"},
    4: {"username": "bob_white", "email": "bob@example.com"},
}


# Конечная точка для получения списка пользователей с параметром запроса limit
@app.get("/users/")
def read_users(limit: int = 10):
    # Ограничиваем количество пользователей, через параметр limit
    return dict(list(fake_users.items())[:limit])

```


###### Как работает параметр запроса
---

В этом примере мы добавили параметр запроса `limit`, который ограничивает количество пользователей, которые будут возвращены в ответе. Если вы отправите запрос:

```browser
http://localhost:8000/users/?limit=3
```

Ответ будет содержать только первых трех пользователей:

```json
{
  "1": {"username": "john_doe", "email": "john@example.com"},
  "2": {"username": "jane_smith", "email": "jane@example.com"},
  "3": {"username": "alice_jones", "email": "alice@example.com"}
}
```

Если вы не передадите параметр `limit`, то по умолчанию вернется 10 пользователей (как указано в аргументе функции):

```browser
http://localhost:8000/users/
```

Ответ:

```json
{
  "1": {"username": "john_doe", "email": "john@example.com"},
  "2": {"username": "jane_smith", "email": "jane@example.com"},
  "3": {"username": "alice_jones", "email": "alice@example.com"},    "4": {"username": "bob_white", "email": "bob@example.com"}
}
```


#### Параметры тела запроса (Body Parameters)
---

Параметры тела запроса передаются в теле HTTP-запроса, обычно в формате JSON, и используются для отправки больших данных, таких как объекты или списки. Эти параметры часто используются в POST, PUT и PATCH запросах, когда нужно отправить более сложные данные для создания или обновления ресурсов.

Пример: тело запроса может содержать информацию о пользователе, такую как имя и адрес электронной почты, в формате JSON.

Примеры запросов, которые обычно используют тело запроса:

- **POST** — создание нового ресурса, например, создание нового пользователя или поста.
- **PUT** — обновление существующего ресурса.
- **PATCH** — частичное обновление ресурса.

Когда мы отправляем запрос с телом, оно может быть в разных форматах, но наиболее популярным является **JSON** (JavaScript Object Notation). JSON стал стандартом обмена данными между клиентом и сервером благодаря своей легкости и удобочитаемости.


##### Почему JSON?
---

[[JSON]] — это текстовый формат, который легко читать и писать, а также легко парсится во всех популярных языках программирования. В API JSON используется для передачи данных, поскольку он является стандартом в веб-разработке и предоставляет удобную структуру для сериализации и десериализации данных.

Когда вы отправляете POST-запрос с данными, вы, как правило, используете JSON для того, чтобы данные могли быть интерпретированы сервером. Например, тело запроса может содержать информацию о пользователе в следующем формате:

```json
{
  "username": "john_doe",
  "user_info": "любит петь"
}
```


###### Отправка тела запроса
---

Тело запроса отправляется в HTTP-запросе. Когда вы используете инструменты, такие как **Postman** или **curl**, вы можете явно указать тело запроса, например, отправив JSON-данные в теле POST-запроса. В веб-приложениях, если вы используете JavaScript, это также можно сделать через `fetch` или `XMLHttpRequest`.

Пример отправки запроса через **curl**:

```curl
curl -X POST "http://localhost:8000/add_user" -H "Content-Type: application/json" -d '{"username": "john_doe", "user_info": "любит петь"}'
```

Пример отправки запроса с использованием **JavaScript (fetch)**:

```js
fetch('http://localhost:8000/add_user',{
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    username: 'john_doe',
    user_info: 'любит петь' 
    }) 
});
```


###### Работа с телом запроса в FastAPI
---

В FastAPI для работы с телом запроса вы используете **модели Pydantic**. Эти модели описывают структуру данных, которые вы ожидаете получить, и позволяют FastAPI автоматически проверять их на соответствие. Это также позволяет FastAPI автоматически генерировать документацию, в которой будет описано, какие поля ожидаются.

В примере ниже создается модель `User`, которая будет описывать данные, которые ожидаются в теле запроса.

```python
from fastapi import FastAPI
from pydantic import BaseModel


app = FastAPI()


# Создание модели данных для пользователя
class User(BaseModel):
    username: str
    user_info: str


fake_db = [{"username": "vasya", "user_info": "любит колбасу"},               {"username": "katya", "user_info": "любит петь"}]



@app.get('/users')
async def get_all_users():
    return fake_db 


# Конечная точка для добавления нового пользователя
@app.post('/add_user')
async def add_user(user: User): # Используем модель для валидации                                                           данных
    fake_db.append({"username": user.username, "user_info":                            user.user_info})

    return {"message": "Юзер успешно добавлен в базу данных"}
```


## Pydantic-модели для аннотации типов в FastAPI
---

**[[Pydantic]]** — это Python-библиотека для выполнения валидации данных.

Вы объявляете «форму» данных как классы с атрибутами, и каждый атрибут имеет тип. Затем вы создаёте экземпляр этого класса с некоторыми значениями, и Pydantic проверяет эти значения, преобразует их в соответствующий тип (если данные корректны) и предоставляет вам объект со всеми данными.

==Пример создания модели:==

```python
from datetime import datetime
from pydantic import BaseModel


# Создаём модель данных, которая обычно располагается в файле models.py
class User(BaseModel):
    id: int
    name: str = "John Doe"
    signup_ts: datetime | None = None
    friends: list[int] = []


# Внешние данные, имитирующие входящий JSON
external_data = {
    "id": "123",
    "signup_ts": "2017-06-01 12:22",
    "friends": [1, "2", b"3"],
}

# Имитация распаковки входящих данных в коде приложения
user = User(**external_data)
print(user)

# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print(user.id)
# > 123
```

В этом примере Pydantic автоматически преобразует строку `"123"` в целое число, дату в объект `datetime`, а элементы списка, такие как `"2"` или `b"3"`, в целые числа.


### Использование Pydantic в FastAPI
---

С помощью аннотаций типов в FastAPI вы объявляете параметры запроса, тела запроса, заголовки, зависимости и другие элементы. При этом Pydantic используется для:

- **Поддержки редактора.** Благодаря аннотациям типов IDE могут предоставлять автодополнение и проверку кода.
- **Проверки типов.** Входящие данные автоматически преобразуются к нужным типам.
- **Валидации данных.** Если данные не соответствуют объявленным типам, FastAPI автоматически генерирует ошибку и возвращает её клиенту.
- **Документирования API.** Используя [[OpenAPI]], FastAPI создает интерактивную документацию, где указаны все требования к входящим данным.

==Еще один пример использования модели:==

```python
from datetime import date
from pydantic import BaseModel


# Функция с аннотацией типа параметра, что позволяет получать поддержку проверки типов в IDE
def main(user_id: str):
    return user_id 



# Еще один пример создания модели Pydantic
class User(BaseModel):
    id: int
    name: str
    joined: date


# Модель User может быть использована для создания объектов и распаковки JSON-запросов:
my_user: User = User(id=3, name="John Doe", joined="2018-07-19") second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}
my_second_user: User = User(**second_user_data)
```

==Пример реального использования модели с FastAPI:==

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class User(BaseModel):
    username: str
    message: str


@app.post("/")
async def root(user: User):
    """
    Здесь мы можем с переменной user, которая содержит объект          класса User с соответствующими полями, выполнить любую логику      – например, сохранить информацию в базу данных, передать в         другую функцию и т.д.
    """
    print(f'Мы получили от юзера {user.username} такое сообщение:/            {user.message}')
    return user
```

При отправке [[POST-метод|POST-запроса]] с JSON-данными по корневому адресу FastAPI автоматически проверит соответствие входных данных объявленной модели и вернет ошибку, если что-то не соответствует.

==Пример корректного POST-запроса (JSON):==

```python
{
    "username": "Vasya",
    "message": "I am BATMAN"
}
```


### Зачем нужна валидация входных данных?
---

Проверка входных данных необходима для обеспечения того, чтобы получаемые данные соответствовали вашим ожиданиям. Например:

- Если вы ожидаете строку для хранения в базе данных (например, поле VARCHAR (255) NOT NULL), а получаете число или другой тип – это может привести к ошибкам.
- Если ваше API предназначено для выполнения арифметических операций (например, возведения числа в квадрат), а приходит строка или `None`, попытка выполнить операцию вызовет сбой.
- Если вы ожидаете массив с определенным количеством элементов, а получаете меньше – попытка доступа к несуществующему элементу приведет к ошибке.

Таким образом, валидация данных помогает предотвратить сбои в работе приложения, обеспечивая корректную обработку входящих данных.
