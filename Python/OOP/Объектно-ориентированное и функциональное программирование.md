

## Встроенные функции Python

В Python существует множество функций, которые решают задачу или вычисляют результат для определенных типов объектов, не являясь при этом методами базового класса. Обычно они выполняют вычисления, часто используемые несколькими типами классов. Это утиная типизация в ее лучшем проявлении; эти функции принимают объекты, имеющие определенные атрибуты или методы, и могут выполнять общие операции, используя упомянутые методы. Мы уже использовали много встроенных функций, но сейчас быстро пройдемся по самым важным из них и попутно рассмотрим несколько интересных трюков.


### [Функция `len()`](https://docs.python.org/3/library/functions.html#len)

Одним из простых примеров функций, связанных с методами объектов, является функция `len()` , которая возвращает количество элементов в объекте-контейнере, например в словаре или списке. Вы уже видели ее ранее, она выглядит следующим образом:

`>>> len([1, 2, 3, 4])`
`4`

Так почему же мы должны использовать функцию `len()` вместо метода `__len__( )` ? Очевидно, что `__len__()` - это специальный дандер-метод (англ. dunder - сокращение от douhle-underscore - буквально: «двойное подчеркивание>.>), то есть мы не должны вызывать его напрямую. Но этому должно быть объяснение. Разработчики Python не принимают решения о языковых конструкциях без веских обоснований.

Основная причина - эффективность. При вызове метода `__len__()` объекту необходимо найти этот метод в своем пространстве имен, и если для этого объекта определен специальный метод `__getattribute__()` (который вызывается при каждом обращении к атрибуту или объекту метода), то он также должен быть вызван. Более того, мeтoд `__getattribute__()` может также привносить свои строгости, например отказать в доступе к специальным методам наподобие метода `__lеn__()` ! А вот функция `len()` ни с чем таким не сталкивается. Она вызывает метод `__len__()` базового класса, поэтому вызов `len(myobj)` соответствует вызову `MyObj.__len__(myobj)`.

Запись `len(myobj)`, являющаяся примером использования функционального стиля, для многих является более читабельной, чем записанный в альтернативном стиле метод `myobj.len()`. Одни спорят о непоследовательности этого синтаксиса, а другие предпочитают его для тех немногих общих операций, которые применяются к многочисленным типам коллекций.


### [Функция `reversed()`](https://docs.python.org/3/library/functions.html#reversed)

Функция `reversed()` принимает на вход любую последовательность и возвращает копию этой последовательности в обратном порядке. Обычно она используется в циклах for, когда бывает нужно перебрать элементы от конца к началу.

Подобно функции `len()` , функция `reversed()` вызывает метод класса 
`__reversed__()` . Если такого метода не существует, функция `reversed` сама строит обратную последовательность, вызывая методы `__len__()` и `__getitem__()` , которые используются при определении последовательности. Метод `__reversed__()` нужно переопределять, только если вы хотите как-то по-особому настроить или оптимизировать его работу, что показано в следующем примере:

```python
`>>> class CustomSequence:`
`...     def __init__(self, args):`
`...         self._list = args`
`...     def __len__(self):`
`...         return 5`
`...     def __getitem__(self, index):`
`...         return f"x{index}"`
`...`
`>>> class FunkyBackwards(list):`
`...     def __reversed__(self):`
`...         return "BACKWARDS!"`
```

Давайте проверим эту функцию на трех списках различных видов:

```python
`>>> generic = [1, 2, 3, 4, 5]`
`>>> custom = CustomSequence([6, 7, 8, 9, 10])`
`>>> funkadelic = FunkyBackwards([11, 12, 13, 14, 15])`
`>>>`
`>>> for sequence in generic, custom, funkadelic:`
`...     print(f"{sequence.__class__.__name__}: ", end="")`
`...     for item in reversed(sequence):`
`...         print(f"{item}, ", end="")`
`...     print()`
`...`
`list: 5, 4, 3, 2, 1,`
`CustomSequence: x4, x3, x2, x1, x0,`
`FunkyBackwards: B, A, C, K, W, A, R, D, S, !,`
```

Циклы for в конце выводят обратные версии списка `generic`, а также экземпляров класса `CustomSequence` и класса `FunkyBackwards`. Вывод показывает, что функция reversed работает со всеми тремя объектами, но возвращает очень разные результаты.

Когда мы инвертируем объект `CustomSequence`, для каждого элемента вызывается метод `__getitem__()`, который просто вставляет `х` перед индексом. Для объекта `FunkyBackwards` мeтoд `___reversed__()` возвращает строку, каждый символ которой выводится отдельно в цикле `for`.


### [Функция `enumerate()`](https://docs.python.org/3/library/functions.html#enumerate)

Иногда, например при переборе элементов в контейнере с помощью оператора `for`, оказывается нужен доступ к индексу (позиции в контейнере) текущего обрабатываемого элемента. Оператор `for` не предоставляет индексов, а вот функция `enumerate()` создает последовательность кортежей, где первый объект в каждом кортеже - индекс, а второй - исходный элемент.

Это здорово помогает, поскольку таким образом элементам присваиваются индексы. Поэтому функция отлично подойдет для использования с множествами и словарями, где значениям не присущ индексный порядок. Она также подходит для текстовых файлов, в которых у строки подразумевается наличие ее номера.

Функция enumerate является итерируемой: она возвращает последовательность кортежей. Оператор for разбивает каждый кортеж на два значения, а функция `print()` форматирует их вместе. Здесь использован необязательный аргумент `start=1` в функции `enumerate`, чтобы условная последовательность номеров строк начиналась с единицы.

Мы затронули лишь несколько наиболее важных встроенных функций Python. Как можно заметить, многие из них обращаются к объектно-ориентированным концепциям, в то время как другие относятся к чисто функциональной или процедурной парадигме. В стандартной библиотеке имеется множество других функций; наиболее интересными являются, например, такие:

- `abs()`,`str()`, `repr()`, `pow()` и `divmod()` напрямую связаны со специальными методами `___abs__()`, `__str__()`, `___repr__()`, `__pow__()` и `__divmod__()`;
- `bytes()` , `format()` , `hash()` и `bool(`) также напрямую связаны со специальными методами `__bytes__()`, `__format__()` , `__hash__()` и `__bool__()`.

Другие интересные встроенные функции:

- `all()` и `any()`, которые принимают итерируемый объект и возвращают `True`, если все или любой из элементов расцениваются как `True` (например, непустая строка или список, ненулевое число, объект, не являющийся None, или литерал `True`);
- `eval()`, `ехес()` и `compile()` , которые выполняют строку как код внутри интерпретатора. Будьте осторожны с их использованием: они могут быть небезопасны, поэтому не выполняйте код, предоставленный вам неизвестным пользователем (вообще, лучше всегда считать намерения неизвестных пользователей злоумышленными или неразумными);
- `hasattr()`, `getattr()` , `setattr()` и `delattr()` , которые позволяют манипулировать атрибутами объекта, используя их строковые имена;
- `zip()` , которая принимает две или более последовательности и возвращает новую последовательность кортежей, где каждый кортеж содержит одно значение из каждой исходной последовательности.

И многое другое! Смотрите справочную документацию интерпретатора по каждой из функций, перечисленных в `help("builtins")`.



## Альтернатива перегрузке методов

Одной из отличительных особенностей многих объектно-ориентированных языков программирования является инструмент, называемый перегрузкой методов. ==***Перегрузка методов означает наличие нескольких методов с одним и тем же именем, которые принимают различные наборы параметров.***== В статически типизированных языках это часто оказывается полезно в случаях, когда необходим метод, принимающий, например, или целое число, или строку. В не объектно-ориентированных языках для таких ситуаций могут потребоваться две функции, называемые `add_s` и `add_i`. В статически типизированных объектно-ориентированных языках понадобится два метода, оба с именем `add`, один из которых принимает строки, а другой - целые числа.

Здесь следует различать две разновидности перегрузки:

- перегрузка параметров для обеспечения возможности использования альтернативных типов с помощью подсказок `Union[...]`;
- перегрузка метода путем использования более сложных шаблонов параметров.

Например, метод отправки сообщения электронной почты может быть реализован в двух вариантах. В первом варианте он принимает параметр `from` для адреса электронной почты отправителя. Во втором - вместо этого ищет адрес электронной почты отправителя по умолчанию. Есть языки, которые вынуждают программистов писать несколько методов с одним и тем же именем и разными параметрами. Python не позволяет определять несколько методов с одним и тем же именем, но он предоставляет другой, не менее гибкий способ определения разных вариантов параметров.

При вызове функции значения позиционных параметров должны быть указаны по порядку, ни одно из них не может быть пропущено. Это наиболее распространенный способ указания параметров, он часто использовался в предыдущих примерах:

`>>> def mandatory_params(x, y, z):`
`...     return f"{x=}, {y=}, {z=}"`

Для вызова функции напишите следующее:

`>>> a_variable = 42`
`>>> mandatory_params("a string", a_variable, True)`
`"x='a string', y=42, z=True"`

Python не ставит жестких требований к используемым в коде типам. Это означает, что в качестве значения аргумента может быть передан объект любого типа: объект, контейнер, простейшие типы, даже функции и классы. В предыдущем примере в функцию передается определенная внутри вызова строка, значение переменной и логическое значение.

Как правило, разрабатываемые приложения не являются полностью универсальными. Поэтому разработчики часто включают в код подсказки типов, чтобы сузить область возможных значений. В редких случаях, когда создается что-то действительно универсальное, можно использовать подсказку `typing.Any`. В такой ситуации `mуру` будет понимать, что действительно позволено использовать объект любого типа.

`>>> from typing import Any`
`>>> def mandatory_params(x: Any, y: Any, z: Any) -> str:`
`...     return f"{x=}, {y=}, {z=}"`

Можно использовать определенную в mуру опцию ==`--disallow-any-expr`== для поиска подобных мест в коде. Она поможет найти строки, в которых необходимо прояснить разрешенные для использования типы.


### Значения по умолчанию для параметров

Если мы хотим сделать значение параметра необязательным, можно указать значение по умолчанию. В некоторых других языках (например, Java) требуется второй метод с другим набором параметров. В Python определяется один метод; указать значение по умолчанию для параметра можно с помощью знака равенства. Если вызывающий код не предоставит значение аргумента для параметра, тому будет присвоено значение по умолчанию. То есть вызывающий код может отменить значение по умолчанию, передав уже другое значение. Если в качестве значения по умолчанию для необязательных параметров используется значение `None`, модуль типизации позволяет описать это с помощью подсказки типа ==`Optional`==.

```python
`>>> from typing import Optional`
`>>> def latitude_dms(
    `deg: float, min: float, sec: float = 0.0, dir: Optional[str] = None) -> str:`
`...     if dir is None:`
`...         dir = "N"`
`...     return f"{deg:02.0f} {min+sec/60:05.3f}{dir}"`
```

Первые два параметра являются обязательными и должны быть указаны. Последние же два имеют значения аргументов по умолчанию и могут быть опущены. Есть несколько способов вызова этой функции.

Можно передать все значения аргументов по порядку, как если бы все параметры были позиционными:

`>>> latitude_dms(35, 51, 2.9, "N")`
`'35 51.048N'`

Или, в качестве альтернативы, можно предоставить только обязательные значения аргументов по порядку, позволяя одному из ключевых параметров `(sec)` использовать значение по умолчанию, и обозначить ключевой аргумент для параметра `dir`:

`>>> latitude_dms(38, 57, dir="N")`
`'38 57.000N'`

Здесь использовался синтаксис знака равенства при вызове функции, чтобы пропустить значения по умолчанию, которые нас не интересуют.

Как ни удивительно, но мы даже можем использовать синтаксис знака равенства, чтобы заменить порядок аргументов для позиционных параметров, при условии, что всем параметрам задано значение аргумента:

`>>> latitude_dms(38, 19, dir="N", sec=7)`
`'38 19.117N'`

Иногда бывает полезно создать параметр ключевого аргумента. В таком случае значение аргумента должно быть представлено как ключевой аргумент. Это можно сделать, поставив символ `*` перед всеми необходимыми параметрами:

`>>> def kw_only(x: Any, y: str = "defaultkw", *, a: bool, b: str = "only") -> str:
`...     return f"{x=}, {y=}, {a=}, {b=}"`

Здесь функция имеет один позиционный параметр, `х`, и три параметра ключевых слов: `у`, `а` и `b`. Параметры `х` и `у` являются обязательными, но `а` может быть передан только как ключевой аргумент. `у` и `b` являются необязательными со значениями по умолчанию, но если передан Ь, то он может быть только ключевым аргументом.

Например, эта функция завершится неудачно, если не передать `а`:

`>>> kw_only('x')`
`Traceback (most recent call last):`
`  File "<stdin>", line 1, in <module>`
`TypeError: kw_only() missing 1 required keyword-only argument: 'a'`

Также ошибка возникнет и при использовании `а` в качестве позиционного аргумента:

`>>> kw_only('x', 'y', 'a')`
`Traceback (most recent call last):`
`  File "<stdin>", line 1, in <module>`
`TypeError: kw_only() takes from 1 to 2 positional arguments but 3 were given`

Но язык позволяет использовать `а` и `b` как ключевые аргументы:

`>>> kw_only('x', a='a', b='b')`
`"x='x', y='defaultkw', a='a', b='b'"`

Кроме того, можно пометить параметры как вводимые только позиционно, для этого указать их имена перед символом `/`. Он отделяет позиционные параметры от более гибких параметров, которые следуют за ними.

`>>> def pos_only(x: Any, y: str, /, z: Optional[Any] = None) -> str:`
`...     return f"{x=}, {y=}, {z=}"`

Эта функция требует, чтобы значения аргументов для параметров `х` и `у` были первыми двумя в перечне, именованные аргументы для `х` и `у` специально не допускаются. Вот что произойдет, если мы попробуем следующее:

```python
`>>> pos_only(x=2, y="three")`
`Traceback (most recent call last):`
`  File "<stdin>", line 1, in <module>`
`TypeError: pos_only() got some positional-only arguments passed as keyword arguments: 'x, y'`
`>>> pos_only(2, "three")`
`"x=2, y='three', z=None"`
`>>> pos_only(2, "three", 3.14159)`
`"x=2, y='three', z=3.14159"`
```

Необходимо указать значения аргументов для первых двух параметров, `х` и `у` , позиционно. Третий параметр, `z`, может быть указан позиционно или с помощью ключевого слова.

==Итак, имеется три возможных способа задания параметров==.

- *Только позиционные*: они удобны в нескольких случаях; примеры см. в РЕР 570: https://www.python.org/dev/peps/pep-0570.
- Либо *позиционные*, либо *ключевые*: это поддерживается для большинства параметров. Порядок полезен сам по себе, а ключевые аргументы могут быть использованы для уточнения. Более трех позиционных параметров могут запутать, поэтому длинный список позиционных параметров - не лучшая идея.
- Только *ключевые*: после символа `*` значения аргументов должны содержать ключ. Это полезно для того, чтобы сделать редко используемые параметры более заметными. Можно представить ключевые слова как ключи к словарю.


### Списки переменных аргументов

Значения по умолчанию сами по себе не предоставляют разработчикам всей той гибкости, которую те хотели бы иметь. Одна из особенностей Python - возможность писать методы, принимающие произвольное количество позиционных или ключевых аргументов без их явного именования. Кроме того, в такие функции можно передавать произвольные списки и словари. В других языках подобные аргументы иногда называют переменными аргументами, `varargs`.

Например, мы можем написать функцию, принимающую ссылку или список URL и загружающую неб-страницы. Идея заключается в том, чтобы избежать путаницы, вызванной работой с односвязным списком, если стоит задача загрузить только одну страницу. Вместо того чтобы принимать одно значение со списком [[URL]], можно принимать произвольное количество аргументов, где каждый аргумент - [[URL]]. Для этого надо определить один позиционный параметр, который будет принимать все значения аргументов. Указанный параметр должен быть последним (среди позиционных параметров), и мы в следующем примере пометим его символом `*` в определении функции, как показано ниже:

`>>> def get_pages(*links: str) -> None:`
`...     for link in links:`
`...         url = urlparse(link)`
`...         name = "index.html" if url.path in ("", "/") else url.path`
`...         target = Path(url.netlock.replace(".", "_")) / name`
`...         print(f"Create {target} from {link!r}")`

Символ * в параметре `*links` означает: <я приму любое количество аргументов и помещу их все в кортеж с именем `links`>. Если предоставить только один аргумент, это будет список с одним элементом; если не предоставить никаких аргументов - пустой список. Таким образом, все подобные вызовы функций являются допустимыми:

`>>> get_pages()`
`>>> get_pages("https://www.archlinux.org")`
`Create www_archlinux_org\index.html from 'https://www.archlinux.org'`
`>>> get_pages("https://www.archlinux.org", "https://dusty.phillips.codes"`, `"https://itmybeahack.com")`
`Create www_archlinux_org\index.html from 'https://www.archlinux.org'`
`Create dusty_phillips_codes\index.html from 'https://dusty.phillips.codes`
`Create itmybeahack_com\index.html from 'https://itmybeahack.com'`

Обратите внимание: подсказка типа предполагает, что в данном примере все значения позиционных аргументов имеют один и тот же тип, `str`. Такое случается часто, ведь функция переменных параметров - это не более чем синтаксический сахар, спасающий от написания глупо выглядящего списка. Альтернатива, то есть ситуация, когда тип не является единым для всех элементов кортежа переменных параметров, чревата путаницей: зачем писать функцию, ожидающую сложную коллекцию различных типов, но почему-то не указывать это в определениях параметров? Не пишите такую функцию.

Также можно принимать произвольные аргументы в виде ключевых слов. Они поступают в функцию в виде словаря, в объявлении функции указываются двумя звездочками (как в `**kwargs`). Этот инструмент обычно используется при настройке конфигурации.

Следующий класс позволяет задать набор опций со значениями по умолчанию:

`>>> from typing import Dict, Any`
`>>> class Options(Dict[str, Any]):`
`...     default_options: dict[str, Any] = {`
`...         "port": 21,`
`...         "host": "localhost",`
`...         "username": None,`
`...         "password": None,`
`...         "debug": False,`
`...     }`
`...     def __init__(self, **kwargs: Any) -> None:`
`...         super().__init__(self.default_options)`
`...         self.update(kwargs)`

Указанный класс использует свойство метода `__init__()` . Итак, существует словарь параметров по умолчанию со скучным именем `default_options` , определенный как часть класса. Метод `__init__()` начинает инициализацию данного экземпляра значениями из словаря параметров по умолчанию на уровне класса. Делается это вместо того, чтобы модифицировать словарь напрямую, на случай, если вдруг программист создаст два отдельных набора опций. (Помните, что переменные уровня класса являются общими для всех экземпляров класса.)

После инициализации экземпляра исходными данными на уровне класса `___init__()` использует метод `update()` , унаследованный от суперкласса, чтобы изменить все значения не по умолчанию на те, которые были предоставлены в качестве аргументов ключевых слов. Поскольку значение `kwargs` также является словарем, метод `update()` обрабатывает объединение значений по умолчанию со значениями переопределения.

Вот сеанс, демонстрирующий класс в действии:

`>>> options = Options(username="Gussy", password="hello21", debug=True)`
`>>> options['debug']`
`True`
`>>> options['port']`
`21`
`>>> options['username']`
`'Gussy'`

Доступ к экземпляру опций можно получить, используя синтаксис индексирования словаря. Словарь `Options` включает в себя как значения по умолчанию, так и те, которые заданы с помощью аргументов по ключевым словам.

Обратите внимание, что родительским классом является `typing`. `Dict[str, Any]` , класс для общего словаря, ограниченного строками для ключей. Когда объект `default_options` инициализируется, можно через предложение `from __future__ import annotations` с использованием `dict[str, Any]` сообщить инструменту `mуру`, что ожидать от этой переменной . Важным является и то, что класс полагается на `typing.Dict` как на суперкласс.

Переменная нуждается в подсказке типа, и для задания этой подсказки используется либо класс `typing.Dict`, либо встроенный класс `dict`. Модуль `typing` рекомендуем использовать только в случае крайней необходимости, а встроенные классы - как можно чаще.


### Распаковка аргументов

Есть еще одна хитрость, связанная с позиционными и ключевыми параметрами. Мы уже использовали ее в некоторых из предыдущих примеров, но никогда не поздно привести дополнительные комментарии. Имея список или словарь значений, можно передать последовательность значений в функцию, как если бы они были обычными позиционными или ключевыми аргументами. Взгляните на этот код:

`>>> def show_args(arg1, arg2, arg3="THREE"):`
`...    return f"{arg1=}, {arg2=}, {arg3=}"`

Функция принимает три параметра, один из которых имеет значение по умолчанию. Но ведь, когда имеется список из трех значений аргументов, можно использовать оператор `*` внутри вызова функции, чтобы распаковать его в три аргумента.

Вот как это выглядит, когда функция запускается с `*some_args`, чтобы получить трехэлементную итерацию:

`>>> some_args = range(3)`
`>>> show_args(*some_args)`
`'arg1=0, arg2=1, arg3=2'`

Значение `*some_args` должно соответствовать определению позиционного параметра. Поскольку для `argЗ` есть значение по умолчанию, что делает его необязательным, существует возможность предоставить два или три значения. Если же имеется словарь аргументов, можно использовать синтаксис `**` и распаковать словарь, чтобы предоставить значения аргументов для ключевых параметров. Выглядит это следующим образом:

`>>> more_args = {`
`...     "arg1": "ONE",`
`...     "arg2": "TWO"}`
`>>> show_args(**more_args)`
`"arg1='ONE', arg2='TWO', arg3='THREE'"`

Подобный способ часто бывает полезен при отображении информации, которая была получена из пользовательского ввода или из внешнего источника (например, интернет-страницы или текстового файла) и должна быть предоставлена в функцию или вызов метода. Вместо того чтобы разделять внешний источник данных на отдельные ключевые параметры, код просто предоставляет ключевые аргументы из ключей словаря. Выражение типа `show_args(arg1=more_args['arg1']` , `arg2=more_args['arg2'])` является ошибочным способом сопоставления имени параметра с ключом словаря.

Поскольку словари распаковываются в порядке слева направо, результирующий словарь будет содержать все опции по умолчанию, при этом опции `kwarg` заменят некоторые ключи. Вот пример:

`>>> x = {'a': 1, 'b': 2}`
`>>> y = {'b': 11, 'c': 3}`
`>>> z = {**x, **y}`
`>>> z`
`{'a': 1, 'b': 11, 'c': 3}`

Подобная распаковка словаря является удобным следствием того, как оператор `**` преобразует словарь в именованные параметры для вызова функции.


## Функции - это тоже объекты

Существует множество ситуаций, когда было бы неплохо передать небольшой объект, который затем просто вызывается для выполнения действия. По сути, речь идет об объекте, который является вызываемой функцией. Чаще всего это делается в событийно-ориентированном программировании, например в графических инструментах или асинхронных серверах. Позже, в главах 11 и 12, будут показаны некоторые шаблоны проектирования, использующие этот подход.

В Python нет необходимости оборачивать такие методы в определение класса, потому что функции уже являются объектами ! Мы можем задавать атрибуты функций (хотя это не очень часто практикуется), а также передавать их для последующего вызова. У функций в этом контексте даже есть несколько специальных свойств, к которым можно обращаться напрямую.

Приведем еще один немного надуманный пример, который иногда используется в ==качестве вопроса на собеседовании==:

`>>> def fizz(x: int) -> bool:`
`...     return x % 3 == 0`
`...`
`>>> def buzz(x: int) -> bool:`
`...     return x % 5 == 0`
`...`
`>>> def name_or_number(number: int, *tests: Callable[[int], bool]) -> None:`
`...     for t in tests:`
`...         if t(number):`
`...             return t.__name__`
`...     return str(number)`
`...`
`>>> for i in range(1, 11):`
`...     print(name_or_number(i, fizz, buzz))`
`...`
`1`
`2`
`fizz`
`4`
`buzz`
`fizz`
`7`
`8`
`fizz`
`buzz`

Функции `fizz()` и `buzz()` проверяют, кратен ли переданный параметр х другому числу. Это определяется посредством оператора деления по модулю: если `х` кратен `3`, то `х` делится на `3` без остатка. Иногда в учебниках математики это записывается как `х = 0 (mod З)` . В Python пишут `х % 3 == 0`.

Функция `name_or_number()` принимает любое количество тестовых функций, заданных в качестве значения параметра `tests`. Оператор `for` присваивает каждую функцию из коллекции tests переменной t, затем вычисляет результат ее работы с переданным в нее параметром number. Если значение функции равно `True`, то в качестве результата будет возвращено имя этой функции.

Вот как выглядит подобная функция, когда ее применяют к числу и другой функции:

`>>> name_or_number(1, fizz)`
`'1'`
`>>> name_or_number(3, fizz)`
`'fizz'`
`>>> name_or_number(5, fizz)`
`'5'`

В каждом случае значением параметра tests является `fizz` - кортеж, содержащий только функцию `fizz`. Функция `name_or_number()` вычисляет `t( number)`, где `t` - функция `fizz()` . Если `fizz(number)` истинно, возвращаемым значением будет значение атрибута _name_ функции `fizz` - то есть строка `'fizz'` . Во время выполнения кода имена функций доступны для использования в качестве атрибутов функции.

А что будет, если предоставить несколько функций? Каждая из них применяется к числу до тех пор, пока одна из них не станет истинной:

`>>> name_or_number(5, fizz, buzz)`
`'buzz'`


### Объекты функций и обратные вызовы

Поскольку функции являются объектами верхнего уровня, их часто передают для отложенного выполнения, например до срабатывания определенного условия. Обратные вызовы зачастую применяют при создании пользовательского интерфейса: когда пользователь нажимает на что-то, фреймворк вызывает функцию, чтобы код приложения создал визуальный отклик. Для очень длительных в выполнении задач, таких как передача файлов, часто бывает полезным вернуть приложению статус процесса - количество переданных байтов, - то есть отслеживать текущее состояние процесса.

Используя обратные вызовы, создадим таймер, управляемый событиями, чтобы события происходили через запланированные промежутки времени. Такой подход удобен для [[IoT (Internet of Things)]](Интернет вещей), приложения, работающего на небольшом устройстве на основе `CircuitPython` или `MicroPython`. Разобьем это на две части: задачу и планировщик, который будет выполнять объект функции, хранящийся в задаче:

```python
`import heapq`
`import time`
`from typing import Callable, Any, List, Optional, cast`
`from dataclasses import dataclass, field`

`Callback = Callable[[int], None]`


`@dataclass(frozen=True, order=True)`
`class Task:`
`    sheduled: int`
`    callback: Callback = field(compare=False)`
`    delay: int = field(default=0, compare=False)`
`    limit: int = field(default=1, compare=False)`

    def repeat(self, current_time: int) -> Optional["Task"]:
        if self.delay > 0 and self.limit > 2:
            return Task(
                current_time + self.delay,
                cast(Callback, self.callback),
                self.delay,
                self.limit - 1,
            )
        elif self.delay > 0 and self.limit == 2:
            return Task(
                current_time + self.delay,
                cast(Callback, self.callback),
            )
        else:
            return None
```

В определении класса `Task` есть два обязательных и два необязательных поля. Обязательные поля, `scheduled` и `callback`, определяют запланированное время для выполнения какого-либо действия и функцию обратного вызова - действие, которое должно быть выполнено в запланированное время. Запланированное время имеет тип `int`; для сверхточных операций модуль времени может использовать в качестве времени и число с плавающей запятой. Однако излишние детали здесь лучше проигнорировать. Кроме того, инструмент `mypy` прекрасно знает, что целые числа можно принудительно преобразовывать в числа с плавающей запятой, поэтому в отношении числовых типов не нужно стремиться к сверх точности.

Вот общий класс планировщика Scheduler, который использует объекты Task и связанные с ними функции обратного вызова:

`class Scheduler:`
`    def __init__(self) -> None:`
`        self.tasks: List[Task] = []`

    def enter(self, after: int, task: Callback, delay: int = 0, limit: int = 1) -          > None:
        new_task = Task(after, task, delay, limit)
        heapq.heappush(self.tasks, new_task)

    def run(self) -> None:
        current_time = 0
        while self.tasks:
            next_task = heapq.heappop(self.tasks)
            if (delay := next_task.sheduled - current_time) > 0:
                time.sleep(next_task.sheduled - current_time)
            current_time = next_task.scheduled
            next_task.callback(current_time)
            if again := next_task.repeat(current_time):
                heapq.heappush(self.tasks, again)

Основной особенностью класса `Scheduler` является очередь кучи - список объектов `Task` , хранящихся в определенном порядке. В разделе «Три типа очередей» главы 7 мы уже упоминали об очереди куч и, отмети в, что упорядочение элементов по приоритету делает такую очередь неподходящей для такого варианта использования. Однако здесь структура данных кучи использует гибкость списка для хранения элементов в порядке без необходимости полной сортировки всего списка. В данном случае мы хотим упорядочить элементы к тому времени, когда они потребуются для выполнения: порядок «первый пришел - первый вышел». Когда что-то помещается в очередь кучи, оно вставляется так, чтобы сохранялся временной порядок. Если же элемент вытаскивается из очереди, куча может быть скорректирована, чтобы сохранить первые элементы в начале очереди.

Класс планировщика `Scheduler` предоставляет метод `enter()` для добавления новой задачи в очередь. Этот метод принимает параметр delay, представляющий интервал ожидания перед выполнением задачи обратного вызова, и саму функцию задачи - функцию, которая должна быть выполнена в нужное время. Эта функция задачи должна иметь тип подсказки `Callback`, определенный выше.

Метод `run()` удаляет элементы из очереди в порядке возрастания времени, в течение которого они должны быть выполнены. Если требуемое время достигнуто или миновало, то значение, вычисленное для задержки, будет нулевым или отрицательным, и программе становится не нужно ждать дольше; обратный вызов может быть выполнен немедленно. Если требуемое время еще не наступило, то необходимо ждать до тех пор, пока оно не придет.

В назначенное время будет обновлено текущее время в переменной `current_time`. Произойдет обращение к функции обратного вызова, предусмотренной в объекте Task, а затем проверка, будет ли метод `repeat()` объекта `Task` добавлять в очередь еще одну повторяющуюся задачу.

Важно отметить строки, которые касаются функций обратного вызова. Функция передается как любой другой объект: классы планировщика `Scheduler` и задачи `Task` никогда не знают и не заботятся о том, как изначально называлась функция или где она была определена. Когда приходит время вызвать функцию, планировщик просто вычисляет ее с помощью `new_task.callback(current_time)`. 

Вот набор функций обратного вызова, которые тестируют класс `Scheduler`:

`def format_time(message: str) -> None:`
`    now = datetime.datetime.now()`
`    print(f"{now:%I:%M:%S}: {message}")`


`def one(timer: float) -> None:`
`    format_time("Called One")`


`def two(times: float) -> None:`
`    format_time("Called Two")`


`def three(times: float) -> None:`
`    format_time("Called Three")`


`class Repeater:`
`    def __init__(self) -> None:`
`        self.count = 0`

    def four(self, timer: float) -> None:
        self.count += 1
        format_time(f"Called Four: {self.count}")

Все эти функции соответствуют определению подсказки типа `Callback` , поэтому они хорошо подойдут. В определении класса Repeater есть метод `four()` , который соответствует этому определению. То есть экземпляр класса Repeater также может быть использован.

```python
`>>> s = Scheduler()`
`>>> s.enter(1, one)`
`>>> s.enter(2, one)`
`>>> s.enter(2, two)`
`>>> s.enter(4, two)`
`>>> s.enter(3, three)`
`>>> s.enter(6, three)`
`>>> repeater = Repeater()`
`>>> s.enter(5, repeater.four, delay=1, limit=5)`
`>>> s.run()`
`05:04:14: Called One`
`05:04:15: Called Two`
`05:04:15: Called One`
`05:04:16: Called Three`
`05:04:17: Called Two`
`05:08:29: Called Four: 1`
`05:08:30: Called Three`
`05:08:30: Called Four: 2`
`05:08:31: Called Four: 3`
`05:08:32: Called Four: 4`
`05:08:33: Called Four: 5`
```

Этот код демонстрирует, как несколько обратных вызовов взаимодействуют с таймером.

Класс `Repeater` показывает, что методы также можно использовать в качестве обратных вызовов, поскольку они являются функциями, привязанными к объекту. Использование метода экземпляра класса `Repeater` - это такая же функция, как и любая другая.

Обратите внимание, что некоторые события имеют одинаковое запланированное время выполнения. Например, в расписании через 2 секунды определены обе функции обратного вызова: `one()` и `two()`.
Не существует правила, которое бы решало, какую из двух функций принять к выполнению первой. Алгоритм планировщика состоит в том, чтобы извлечь элемент из очереди кучи, выполнить функцию обратного вызова, затем извлечь другой элемент из очереди кучи; если время начала выполнения элементов совпадает, то выполняется следующая функция обратного вызова. Какой из двух обратных вызовов выполняется первым, а какой вторым - это уже особенность реализации очереди кучи. Если для вашего приложения будет важен порядок, понадобится дополнительный атрибут для различения элементов, запланированных на одно и то же время; часто при этом используется номер приоритета.


### Использование функций для изменения класса

Появление путаницы означает, что вызываемый атрибут можно рассматривать как метод класса. Поскольку обычно существует возможность предоставлять классу дополнительные методы, значит, можно и изменить эти дополнительные методы прямо во время выполнения программы.

Должны ли разработчики так делать? Скорее всего, это все-таки плохая идея, но есть особая ситуация, для которой допустимо сделать исключение и обратиться к этому приему.

К уже созданному объекту можно добавить функцию или изменить уже существующую, как показано ниже.

Должны ли разработчики так делать? Скорее всего, это все-таки плохая идея, но есть особая ситуация, для которой допустимо сделать исключение и обратиться к этому приему.

К уже созданному объекту можно добавить функцию или изменить уже существующую, как показано ниже.

Сначала определим класс А с методом `show_something()`:

`>>> class A:`
`...     def show_something(self):`
`...         print("My class is A")`
`...`
`>>> a_object = A()`
`>>> a_object.show_something()`
`My class is A`

Выглядит так, как и ожидалось. Вызовем метод для экземпляра класса, и функция `print()` выдаст результаты отработки. Теперь изменим этот объект, заменив метод `show_something()`:

`>>> def patched_show_something():`
`...     print("My class is NOT A")`
`...`
`>>> a_object.show_something = pathced_show_something`
`>>> a_object.show_something()`
`My class is NOT A`

Мы изменили объект, введя атрибут, который является вызываемой функцией. При использовании `a_object.show_something()` сначала рассматриваются локальные атрибуты, а затем уже атрибуты класса. Поэтому мы использовали вызываемый атрибут, чтобы создать локализованное исправление для данного экземпляра класса `А`.

Создадим другой экземпляр класса, без исправлений, и увидим, что он все еще использует метод уровня класса:

`>>> b_object = A()`
`>>> b_object.show_something()`
`My class is A`

Если можно исправить объект, то, предположим, можно исправить и класс. И это предположение верно. Вместо замены метода у объектов вполне реально заменить его сразу у класса. При изменении класса необходимо учитывать аргумент `self`, который будет неявно предоставлен методам, определенным в классе.

Очень важно отметить, что исправление класса изменит метод для всех экземпляров этого объекта, даже для тех, которые уже были созданы. Очевидно, что подобная замена методов может быть опасной и запутанной. Кто-то, читая код, увидит, что был вызван метод, и найдет этот метод в исходном классе. Но метод в исходном классе - это не тот метод, который был вызван. Выяснение того, что же произошло на самом деле, рискует превратиться в сложный и утомительный сеанс отладки.

> Код, который люди видят в файле модуля, должен быть кодом, который
  выполняется.

И все же описанная выше техника находит свое применение. Часто замена или добавление методов во время выполнения 
(так называемое **monkey patching** *обезьянье исправление*) используется в автоматизированном тестировании. Скажем, при тестировании клиент-серверного приложения мы можем не захотеть подключаться к серверу во время тестирования клиента, потому что это может привести к случайному переводу средств или отправке неудобных тестовых писем реальным людям.

Вместо этого мы можем настроить наш тестовый код на замену некоторых ключевых методов объекта, посылающего запросы на сервер, так, чтобы он только фиксировал, что эти методы были вызваны. Подробно это будет рассмотрено в главе 13. За пределами узкой сферы тестирования •обезьяньи исправления• обычно являются признаком плохого проектирования.

Иногда •обезьяньи исправления• обоснованно считаются необходимыми при исправлении ошибок в импортированных компонентах. Если имеет место именно такая ситуация, то патч должен быть четко обозначен, чтобы любой, кто смотрит на код, знал, над какой ошибкой работают и когда можно будет убрать исправление. Такой вид кода мы называем •техническим долгом•, поскольку главная сложность в использовании •обезьяньего• патча - *это принятие программистом груза ответственности*.

В случае нашего класса в приведенном примере присутствие подкласса `А` с отдельной реализацией `show_something()` сделало бы ситуацию гораздо более понятной, чем исправление метода.

Мы можем обращаться к определениям классов для создания объектов, которые применяются тем же образом, как если бы они были функциями. Это дает нам еще один путь к использованию небольших, отдельных функций для создания приложений.


### Вызываемые объекты

Вы уже знаете, что функции являются объектами, которым можно задавать атрибуты. По такому же принципу создаются объекты, которые при определенных обстоятельствах вызываются, как если бы они были функцией. Любой объект можно сделать вызываемым, задав ему метод `__саll__()` , принимающий требуемые аргументы. Упростим немного использование класса Repeater из примера с таймером, сделав его вызываемым, как показано ниже:

`class Repeater_2:`
`    def __init__(self) -> None:`
`        self.count = 0`

    def __call__(self, timer: float) -> None:
        self.count += 1
        format_time(f"Called Four: {self.count}")

Эта новая версия класса мало чем отличается от предыдущей; все, что сейчас сделано, - это изменено название функции повторителя нa `__call__` и передан сам объект в качестве вызываемой функции. Как это работает? Посмотрим пример:

`class Repeater_2:`
`    def __init__(self) -> None:`
`        self.count = 0`

    def __call__(self, timer: float) -> None:
        self.count += 1
        format_time(f"Called Four: {self.count}")

`rpt = Repeater_2()`

Итак, здесь создан вызываемый объект `rpt()` . Если попытаться вычислить что то вроде `rpt(1)` , Python вычислит `rpt.__call__(1)` за нас, потому что в классе определен метод `__саll__()` . Выглядит это следующим образом:

`>>> rpt = Repeater_2()`
`>>> rpt(1)`
`06:10:17: Called Four: 1`
`>>> rpt(2)`
`06:10:24: Called Four: 2`
`>>> rpt(3)`
`06:10:27: Called Four: 3`

Вот вам пример использования описанной вариации определения класса Repeater_2 с объектом `Scheduler`:

`s2 = Scheduler()`
`s2.enter(5, Repeater_2(), delay=1, limit=5) 
`s2.run()`

Обратите внимание, что при вызове `enter()` в качестве аргумента передается значение `Repeater_2()` . Эти две круглые скобки создают новый экземпляр класса. Созданный экземпляр имеет метод `__call__()` , который может быть использован объектом класса `Scheduler`. При работе с вызываемыми объектами необходимо создавать экземпляр класса, поскольку вызываемым является сам объект, а не класс.

На данный момент мы с вами рассмотрели два различных типа вызываемых объектов.

1. Функции Python, созданные с помощью оператора `def`.
2. Вызываемые объекты - экземпляры класса с определенным методом `__call__()`.

Как правило, простой оператор `def` - это все, что нужно, этого достаточно. Однако вызываемые объекты могут делать то, чего не может сделать обычная функция. Например, класс `Repeater_2` подсчитывает количество раз, когда он был использован. Обычная функция не имеет состояния. Вызываемый же объект может иметь состояние. Хоть это и желательно использовать с особой осторожностью, некоторые алгоритмы могут значительно повысить производительность за счет сохранения результатов в кэше, а вызываемый объект - это отличный способ сохранить результаты функции, чтобы их не пришлось пересчитывать.


### Ввод/вывод файлов

До сих пор в примерах, которые касались файловой системы, мы работали исключительно с текстовыми файлами, не задумываясь о том, что происходит «за кулисами». Операционные системы представляют файлы в виде последовательности байтов, а не текста. Подробнее связь между байтами и текстом будет рассмотрена в главе 9. Пока же просто примите к сведению, что чтение текстовых данных из файла - это довольно сложный процесс, но в нем Python выполняет большую часть работы за нас.

Концепция файлов появилась задолго до того, как кто-то придумал термин «объектно-ориентированное программирование». Однако Python обернул интерфейс, предоставляемый операционными системами, в приятную абстракцию, которая позволяет нам работать с файловыми (или файлоподобными в терминах утиной типизации) объектами.

Файлы со встроенными оболочками для преобразования байтов в текст - это, конечно, здорово, но будет ужасно неудобно, если файл, который мы намереваемся открыть и с которым собираемся работать как с текстовым, является изображением, исполняемым файлом или другим двоичным файлом, не так ли?

Чтобы открыть двоичный файл, надо изменить строку режима, добавив `"b"`. Таким образом, `"wb"` открывает файл для записи байтов, а `"rb"` позволяет их читать. Они будут вести себя как текстовые библиотеки, но без автоматического кодирования текста в байты. При чтении такого файла он будет возвращать объекты байтов вместо строк `str`, а при попытке записи в него текстового объекта выдаст ошибку.

>Эти строки режима для управления открытием файлов довольно загадочны и не являются ни «питоническими» (присущим и языку Python), н и объектно-ориентированными. Однако они совместимы практически со всеми другими языками программирования, поскольку основаны на старинной стандартной библиотеке ввода-вывода. Файловый ввод/вывод - это одна из основных задач операционной системы, и все языки программирования должны общаться с операционной системой, используя одни и те же системные вызовы .

Поскольку все файлы содержат байты, важно знать, что чтение текста означает преобразование байтов в текстовые символы. Большинство операционных систем для представления символов Unicode, которые Python использует в качестве байтов, используют кодировку UTF-8. В некоторых случаях могут применяться другие кодировки, и нам может потребоваться указать значение аргумента encoding='ср1252' при открытии текстового файла, использующего необычную кодировку.



## Ключевые моменты

- Встроенные функции Python предоставляют доступ к специальным методам, которые могут быть реализованы самыми разными классами. Почти все классы (большинство из них совершенно не связаны между собой) предоставляют реализацию методов `__str__()` и `__repr__()` , а они могут использоваться встроенными функциями `str()` и `repr()`. Существует много подобных функций, где сама функция предоставляется для доступа к реализациям классов, пересекающих границы.
- Некоторые объектно-ориентированные языки полагаются на перегрузку методов - одно и то же имя присваивается нескольким реализациям с различными комбинациями параметров. Python предоставляет возможность создавать код, в котором одно имя метода может иметь необязательные, обязательные, только позиционные и только ключевые параметры. Это обеспечивает невероятную гибкость программирования.
- Функции - это объекты, и их используют так же, как и другие объекты. Их можно, например, предоставлять в качестве значений аргументов, возвращать их из других функций. Функция так же, как и объект, имеет атрибуты.
- Файловый ввод-вывод заставляет нас внимательно посмотреть на то, как происходит взаимодействие с внешними объектами. Файлы всегда состоят из байтов. Python преобразует байты в текст. По умолчанию используется наиболее распространенная кодировка UTF-8, но возможны и любые другие.
- Контекстные менеджеры позволяют убедиться в том, что приложение правильно функционирует даже при возникновении исключений, учитывая тонкости операционной системы. Однако применение этих менеджеров выходит за рамки простой обработки файлов и сетевых соединений. Везде, где есть четкий контекст, где нужна последовательная обработка при вводе или выводе, найдется место и для менеджера контекста.