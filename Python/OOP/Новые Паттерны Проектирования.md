---
date of creation: 2024-06-28T17:39:00
tags:
  - Python
  - OOP/Python
  - Patterns
  - Patterns/Python
  - Python/Patterns
  - Developing/Python
  - Python/OOP
Read status: false
aliases:
  - новые паттерны проектирования
---
---
# Новые паттерны проектирования
2024-06-28




В этой главе вы познакомитесь еще с несколькими паттернами проектирования. Мы вместе рассмотрим примеры их использования и реализацию на Python. Вы освоите следующие темы.

- **[[#Паттерн Адаптер|Паттерн Адаптер]]** ==(Adapter)==
- **[[#Паттерн Фасад|Паттерн Фасад]]** ==(Façade)==
- **[[#Паттерн Легковес|Ленивая инициализация и паттерн Легковес]]** ==(Flyweight)==
- **Паттерн Абстрактная фабрика** ==(Abstract Factory)==
- **Паттерн Компоновщик** ==(Composite)==
- **Паттерн Шаблонный метод** ==(Template)==

Начнем свое изучение с паттерна Адаптер. По сути, он типичный переходник для разных интерфейсов или данных.




## Паттерн Адаптер
---

В отличие от большинства рассмотренных в предыдущей главе паттернов **паттерн Адаптер** предназначен для взаимодействия с уже существующим кодом. Мы не стали разрабатывать совершенно новый набор объектов, реализующих **паттерн Адаптер**. Адаптеры используются для обеспечения совместной работы двух объектов, даже если их интерфейсы несовместимы. Как и адаптеры дисплея, позволяющие подключать зарядный кабель Micro USB к телефону USB-C, адаптер находится между двумя разными интерфейсами, леrко переводя их между собой. ==Единственной целью адаптера является выполнение данного преобразования. Ведь адаптация может повлечь за собой множество задач, таких как преобразование арrументов в другой формат, изменение порядка аргументов, вызов метода с другим именем или предоставление аргументов по умолчанию.==

По структуре **паттерн Адаптер** похож на упрощенный вариант **[[Общие Паттерны Проектирования#Паттерн Декоратор|паттерна Декоратор]]**. Но декораторы обычно предоставляют тот же интерфейс, который они заменяют, тогда как адаптеры служат мостом между двумя разными интерфейсами, что представлено на UМL-диаграмме (рис. 12.1).

>![[Рис. 12.1. Паттерн Адаптер.jpg]]
>           **Рис. 12.1.** Паттерн Адаптер

В данном случае клиентский объект, экземпляр **`Client`**, чтобы сделать что-то полезное, должен работать совместно с другим классом. Для этого используется **`load_data()`** как конкретный пример метода, в котором требуется адаптер. Уже имеется класс **`Implementation`**, который делает все, что необходимо (и чтобы избежать дублирования, мы не будем его переписывать!). Однако существует проблема: класс требует сложной последовательности операций с использованием методов **`read_raw_data()`** , **`parse_raw_d ata()`** и  **`createuseful_object()`**. Класс Adapter реализует простой в использовании интерфейс **`load_data()`** , который скрывает сложность существующего интерфейса, предоставляемого классом **`Implementation`**.

Преимущество такой схемы заключается в том, что весь код, отображающий сопоставляемый ожидаемый и фактический интерфейсы, находится в одном месте - в классе Adapter. В качестве альтернативы можно было бы поместить код в клиента, дополняя его не относящимися к делу деталями реализации. В такой редакции кода при наличии нескольких типов клиентов пришлось бы в нескольких местах выполнять сложную обработку **`loaddata()`** всякий раз, когда какому-то из этих клиентов потребовался бы доступ к классу **`Implementation`**.

Хороший пример **паттерна Адаптер**(реализация на уровне объектов), на примере конвертера весов с русских на британских:

```python
import abc
from abc import ABCMeta
 

class IScale(metaclass=ABCMeta):
    @abc.abstractmethod
    def get_weight(self):
        pass
 

class RussianScales(IScale):
    def __init__(self, cw: float):
        self.__current_weight = cw  

    def get_weight(self) -> float:
        return self.__current_weight
   

class BritishScales:
    def __init__(self, cw: float):
        self.__current_weight = cw 

    def get_weight(self) -> float:
        return self.__current_weight
 

class AdapterForBritishScales(IScale):
    def __init__(self, british_scales: BritishScales):
        self.__british_scales = british_scales

    def get_weight(self) -> float:
        return self.__british_scales.get_weight() * .453  
        

if __name__ == "__main__":
    kg: float = 55.  # кг
    lb: float = 55.  # фунты  

    rScales = RussianScales(kg)
    bScales = AdapterForBritishScales(BritishScales(lb))
  
    print(rScales.get_weight())  # кг
    print(bScales.get_weight())  # кг
```
```output
55.0
24.915
```

### Пример реализации паттерна Адаптер
---

Представьте, что уже существует класс, который принимает временные метки строк в формате ННММSS и вычисляет полезные интервалы с плавающей запятой:

```python
class TimeSince:
    """Expects time as six digits, no punctuation."""

    def parse_time(self, time: str) -> tuple[float, float, float]:
        return (
            float(time[0:2]),
            float(time[2:4]),
            float(time[4:]),
        )

    def __init__(self, starting_time: str) -> None:
        self.hr, self.min, self.sec = self.parse_time(starting_time)
        self.start_seconds = ((self.hr * 60) + self.min) * 60 +                                      self.sec

    def interval(self, log_time: str) -> float:
        log_hr, log_min, log_sec = self.parse_time(log_time)
        log_seconds = ((log_hr * 60) + log_min) * 60 + log_sec
        return log_seconds - self.start_seconds

```

Этот класс выполняет преобразование строки во временной интервал и уже присутствует в приложении, имеет модульные тесты и прекрасно работает. Если вы забудете импортировать аннотации **`from __future__`**, при попытке использовать **`tuple[float, float, float]`** в качестве подсказки типа получите сообщение об ошибке. Не забудьте включить модуль аннотаций в качестве первой строки кода. Например, так:

```python
>>> ts = TimeSince('000123')  # logstarted at 00:01:23
>>> ts.interval('020304')
7301.0
>>> ts.interval('030405')
10962.0
```

Работать с таким неформатированным временем немного неудобно, но ряд устройств Internet of Тhings (IoT) предоставляют именно такие временные строки, отделенные от остальной части даты. Посмотрите, например, на сообщения формата NMEA 0183 от устройства GPS, там даты и время представляют собой неформатированные строки цифр.

У нас имеется старый лог-файл с одного из этих устройств, очевидно созданный несколько лет назад. Необходимо проанализировать этот лог-файл на наличие последовательности сообщений, которые появляются после каждого сообщения `ERROR`, и, кроме того, получить точное время относительно сообщения `ERROR` в качестве анализа основной причины проблемы.

Например:
```python
>>> data = [
...     ("000123", "INFO", "Gila Flats 1959-08-20"),
...     ("000142", "INFO", "test block 15"),
...     ("004201", "ERROR", "intrinsic field chamber door locked"),
...     ("004210.11", "INFO", "generator power active"),
...     ("004232.33", "WARNING", "extra mass detected")
... ]
```

Вычислить временной интервал между сообщением **`ERROR`** и **`WARNING`** сложно, но возможно. У многих программистов достаточно навыков, чтобы производить подобные вычисления. Но, может, лучше проанализировать лог-файл, содержащий относительное время, а не абсолютное? Ниже представлена схема форматирования лог-файла, которую необходимо использовать. Однако здесь вырисовывается проблема, которую мы отметили символами **`???`** :

```python
class LogProcessor:
    def __init__(self, log_entries: list[tuple[str, str, str]]) ->           None:
        self.log_entries = log_entries

    def report(self) -> None:
        first_time, first_sev, first_msg = self.log_entries[0]
        for log_time, severety, message in self.log_entries:
            if severety == "ERROR":
                first_time = log_time
            interval = ??? Need to compute an interval ???
            print(f"{interval:8.2f} | {severety:7s} {message}")
            
```

Класс **`LogProcessor`** кажется правильным. Он перебирает записи лог-файла, сбрасывая переменную **`first_time`** при каждом появлении строки **`ERROR`**. Это гарантирует, что лог-файл отображает позицию ошибки, избавляя нас от необходимости выполнять множество математических вычислений.

Но взгляните повнимательнее: возникает необходимость повторно использовать класс **`TimeSince`**. Он не просто вычисляет интервал между двумя значениями. Существует несколько вариантов реализации данного сценария.

- Для работы со строками времени можно было бы переписать класс **`TimeSince`**. Но тогда возникает риск нарушить код в нашем приложении. Иногда это называется радиусом разбрызгивания - сколько вещей в окружении намокнет, если бросить камень в бассейн? Принцип открытого/закрытого проектирования (один из принципов SOLID, дополнительную информацию можно получить на сайте https://subscription.packtpub.com/book/application_development/9781788835831/4) предполагает, что класс должен быть доступен для расширения, но недоступен для подобных модификаций. Если класс был загружен из `PyPI`, мы можем не изменять его внутреннюю структуру, так как тогда станет невозможно использовать последующие релизные версии. Необходим альтернативный вариант работы внутри другого класса.

- Мы могли бы использовать класс как есть и всякий раз при необходимости вычислить интервалы между сообщением **`ERROR`** и последующими строками лог-файла создавать новый объект **`TimeSince`**. Это выливается в создание большого количества объектов. Представьте, что имеется несколько приложений для анализа лог-файлов, каждое из которых рассматривает различные аспекты сообщений этих файлов. Внесение изменений означает необходимость вернуться и исправить все места, где были созданы объекты **`TimeSince`**. Если в классе **`LogProcessor`** слишком много деталей, связанных с работой класса **`TimeSince`**, нарушается принцип единой ответственности. А также вспомним еще один принцип - Не повторяйся (DRY), который применим и в этом случае.

- Вместо этого можно добавить адаптер, который связывает потребности класса **`LogProcessor`** с методами, доступными в классе **`TimeSince`**.

Решение с **паттерном Адаптер** подразумевает наличие класса с интерфейсом, необходимым для класса **`LogProcessor`**. Он также использует интерфейс, предлагаемый классом **`ТimeSince`**. То есть он представляет собой развитие обоих классов, оставляя их закрытыми для модификации, но доступными для расширения. Например, так, как в следующем фрагменте кода:

```python
from typing import Optional


class IntervalAdapter:
    def __init__(self) -> None:
        self.ts: Optional[TimeSince] = None

    def time_offset(self, start: str, now: str) -> float:
        if self.ts is None:
            self.ts = TimeSince(start)
        else:
            h_m_s = self.ts.parse_time(start)
            if h_m_s != (self.ts.hr, self.ts.min, self.ts.sec):
                self.ts = TimeSince(start)
        return self.ts.interval(now)
```

Этот адаптер создает объект **`ТimeSince`**, когда это необходимо. Если **`TimeSince`** отсутствует, адаптер должен его создать. Если объект **`TimeSince`** уже существует и использует уже установленное начальное время, то экземпляр **`TimeSince`** можно использовать повторно. Однако, как только класс **`LogProcessor`** сместил фокус на новое сообщение об ошибке, возникает необходимость создать новый экземпляр **`TimeSince`**.

Рассмотрим пример окончательного проекта класса **`LogProcessor`** с использованием класса **`IntervalAdapter`**:

```python
class LogProcessor:
    def __init__(self, log_entries: list[tuple[str, str, str]]) -> None:
        self.log_entries = log_entries
        self.time_convert = IntervalAdapter()

    def report(self) -> None:
        first_time, first_sev, first_msg = self.log_entries[0]
        for log_time, severity, message in self.log_entries:
            if severity == "ERROR":
                first_time = log_time
            interval = self.time_convert.time_offset(first_time,                                                         log_time)
            print(f"{interval:8.2f} | {severity:7s} {message}")
```

Здесь в процессе инициализации был создан экземпляр **`IntervalAdapter()`** . Затем этот объект применялся для вычисления каждой временной позиции, а существующий класс **`TimeSince`** повторно использовался без каких-либо модификаций исходного класса, причем класс **`LogProcessor`** не заботился о деталях работы экземпляра **`TimeSince`**.

Также в данном случае мы можем использовать наследование. Можно расширить экземпляр **`ТimeSince`**, чтобы добавить к нему необходимый метод. Альтернатива наследования - неплохая идея. Обратите внимание: похоже, это как раз та ситуация, когда нет единственного правильного ответа. В некоторых случаях имеет смысл обдумать реализацию с наследованием и сравнить ее с реализацией адаптера, проанализировав, какая из них проще.

Для добавления метода к существующему классу вместо наследования мы можем использовать метод *monkey patching*. Python позволяет добавлять новый метод, который предоставляет адаптированный интерфейс, необходимый для вызова кода. То есть внутри оператора **`class`** легко найти определение класса - но это будет не весь класс, используемый во время выполнения. И другие разработчики в случае необходимости будут вынуждены искать в коде место внедрения в класс новой функции. То есть вне модульного тестирования метод *monkey patching* не является хорошей идеей.

Как правило, в качестве адаптера можно использовать функцию. Хотя такой подход явно не соответствует классическому дизайну паттерна проектирования класса Адаптер, иногда этим несоответствием пренебрегают: класс с методом **`__call__()`** является вызываемым объектом, неотличимым от функции. Функция тоже может быть отличным адаптером. Python не требует, чтобы все было определено в классах.

Различие между **паттернами Адаптер и Декоратор** незначительное, но важное. **Паттерн Адаптер**, как правило, расширяет, модифицирует или комбинирует более одного метода из адаптируемых классов. Паттерн Декоратор обычно избегает значительных изменений, сохраняя интерфейс исходного метода, постепенно добавляя функции. Как уже указывалось в [[Общие Паттерны Проектирования]] , паттерн Декоратор следует рассматривать как особый вид адаптера.

Использование класса Адаптер аналогично использованию класса **Стратегия**. Идея состоит в том, что после внесения изменений может понадобиться другой адаптер. Принципиальное отличие заключается в том, что стратегии часто выбираются во время выполнения, а адаптеры выбираются во время разработки и изменяются очень редко.

Следующий паттерн, который мы рассмотрим, похож на Адаптер, так как он также заключает функциональность в новый контейнер. Разница состоит в сложности того, что именно обертывается. **Паттерн Фасад**, как правило, содержит значительно более сложные конструкции.





## Паттерн Фасад
---

**Паттерн Фасад** предназначен для предоставления простого интерфейса сложной системе компонентов. Это структурный паттерн, который предоставляет простой интерфейс к сложной системе объектов, библиотеке или фреймворку. Паттерн Фасад дает возможность определить новый класс, который 'инкапсулирует типичное использование системы, тем самым позволяя избежать дизайна, раскрывающего слишком много деталей реализации, обычно не выраженных явно при взаимодействии объектов. Каждый раз, когда нужен доступ к общей или типичной функциональности, используется упрощенный интерфейс одного объекта. Если другой части проекта требуется доступ к более полной функциональности, код по-прежнему может напрямую взаимодействовать с компонентами и отдельными методами.

UML-диаграмма для **паттерна Фасад** зависит от подсистемы, изображенной в виде пакета **`Big System`**, но в облачном виде диаграмма выглядит так, как это показано на **рис. 12.2.**

>![[Рис. 12.2. Паттерн Фасад.jpg]]
> **Рис. 12.2**. Паттерн Фасад

Паттерн Фасад во многом похож на **[[#Паттерн Адаптер|паттерн Адаптер]]**. Основное отличие заключается в том, что паттерн Фасад абстрагирует более простой интерфейс от сложного, в то время как Адаптер только сопоставляет один существующий интерфейс с другим.

Хороший пример **паттерна Фасад**, на примере интернет-магазина:

```python
class ProviderCommunication:
    def receive(self):
        print("Получение продукции от производителя")

    def payment(self):
        print("Оплата поставщику с удержанием коммисии за продажу                  продукции")
 

class Site:
    def placement(self):
        print("Размещение на сайте")

    def delete(self):
        print("Удаление с сайта")
 

class Database:
    def insert(self):
        print("Запись в базу данных")

    def delete(self):
        print("Удаление из базы данных")
  

class MarketPlace:
    def __init__(self):
        self._provider_cummunication = ProviderCommunication()
        self._site = Site()
        self._database = Database() 

    def product_receive(self):
        self._provider_cummunication.receive()
        self._site.placement()
        self._database.insert() 

    def product_release(self):
        self._provider_cummunication.payment()
        self._site.delete()
        self._database.delete()
  

if __name__ == "__main__":
    market_place = MarketPlace()
    market_place.product_receive()
    
    print()

    market_place.product_release()
```
```powershell
Получение продукции от производителя
Размещение на сайте
Запись в базу данных 

Оплата поставщику с удержанием коммисии за продажу продукции
Удаление с сайта
Удаление из базы данных
```




### Пример реализации паттерна Фасад
---

Все изображения для этой книги были сделаны с помощью PlantUML (https://plantuml.com). Каждая диаграмма начинается с текстового файла и должна быть преобразована в формат PNG. Это двухэтапный процесс, и ниже в коде будет показано, как **паттерн Фасад** применяется для объединения двух процессов.

Первый этап - обход дерева каталогов с поиском всех файлов UML, то есть с расширением `.uml`. Анализируется и содержимое файла на предмет наличия в нем названия диаграмм.

```python
import re
from pathlib import Path
from typing import Iterator, Tuple


class FindUML:
    def __init__(self, base: Path) -> None:
        self.base = base
        self.start_pattern = re.compile(r"@startmul *(.*)")

    def uml_file_iter(self) -> Iterator[tuple[Path, Path]]:
        for source in self.base.glob("**/*.uml"):
            if any(n.startswith(".") for n in source.parts):
                continue
            body = source.read_text()
            for output_name in self.start_pattern.findall(body):
                if output_name:
                    target = source.parent / output_name
                else:
                    target = source.with_suffix(".png")
                yield (
                    source.relative_to(self.base),
                    target.relative_to(self.base)
                )
```

Для класса **`FindUML`** необходим базовый каталог. Метод **`uml_file_iter()`** проходит по всему дереву каталогов, используя метод **`Path.glob()`** . При поиске пропускаются все каталоги, имена которых начинаются с **`.`** , так как к ним часто обращаются в своей работе инструменты **`tox`**, **`mуру`** или **git**. Остальные файлы будут содержать cтpoки **`@startuml`**, а некоторые и строку с именами нескольких выходных файлов.

Большинство файлов UML не создают нескольких файлов. Регулярное выражение **`self.start_pattern`** определяет имя, если оно указано, а итератор выдает кортежи с двумя путями.

Имеется класс, который в качестве подпроцесса запускает прикладную программу PlantUML. Когда Python работает, все это является процессом операционной системы. Опираясь на модуль **`subprocess`**, можно запускать дочерние процессы, которые, в свою очередь, запускают другие бинарные приложения или сценарии оболочки. Например, так:

```python
import subprocess

class PlantUML:
    """
    Default setup is this:

    1.  Download Java Runtime (JRE) for your platform.
        https://www.java.com/en/download/manual.jsp 

    2.  Download the ``plantuml.jar`` and put into your conda                environment ``share`` directory.https://plantuml.com/download

    3.  Use ``conda install graphiz`` to create the ``dot``                  application in your conda environment.

    4.  If necessary, update this script with environment name and           locations
    """

    conda_env_name = "CaseStudy"
    base_env = Path.home() / "miniconda3" / "envs" / "conda_env_name"

    def __init__(
            self,
            graphviz: Path = Path("bin") / "dot",
            plantjar: Path = Path("share") / "plantuml.jar",
    ) -> None:
        self.graphviz = self.base_env / graphviz
        self.plantviz = self.base_env / plantjar  

    def process(self, source: Path) -> None:
        env = {
            "GRAPHVIZ_DOT": str(self.graphviz),
        }
        command = [
            "java", "-jar",
            str(self.plantjar), "-progress",
            str(source)
        ]
        subprocess.run(command, env=env, check=True)
        print()
```

При создании виртуальной среды **`CaseStudy`** работа класса PlantUML зависит от применения `conda`. При использовании других менеджеров виртуальной среды подкласс может предоставлять все необходимые пути модификации. В указанную виртуальную среду нужно установить пакет **`Graphviz`**. Тогда диаграмма будет представлена как файл изображения. Необходимо также скачать файл **`plantuml.jar`**. Поместим его в общий каталог внутри выбранной виртуальной среды. Значение командной переменной предполагает, что среда выполнения Java (JRE) корректно установлена и видна.

Функция **`subprocess.run()`** принимает аргументы командной строки и любые специальные переменные среды, которые необходимо установить. Функция запустит команду в данной среде и проверит полученный код возврата, чтобы убедиться, что программа работает правильно.

Также эти этапы можно использовать отдельно, чтобы найти все файлы UML и создать диаграммы. Поскольку интерфейс немного сложен для понимания, класс, работающий с **паттерном Фасад**, помогает создать полезное приложение командной строки.

```python
class GenerateImages:
    def __init__(self, base: Path) -> None:
        self.finder = FindUML(base)
        self.painter = PlantUML()

    def make_all_images(self) -> None:
        for source, target in self.finder.uml_file_iter():
            if (
                not target.exists()
                or source.stat().st_mtime > target.stat().st_mtime
            ):
                print(f"Processing {source} -> {target}")
                self.painter.process(source)
            else:
                print(f"Skipping {source} -> {target}")
```

Класс **`Generatelmages`** - это удобный фасад, сочетающий в себе функции классов **`FindUML`** и **`PlantUML`**. Он использует метод **`FindUML.uml_file_iter()`** для поиска исходных файлов и выходных файлов изображений. Класс **`GenerateImages`** проверяет время модификации этих файлов, чтобы избежать их обработки, если изображение новее исходного. ( Информацию, касающуюся **`stat().st_mtime`**, пока нельзя считать точной. Метод **`stat()`** класса **`Path`** предоставляет большое количество информации о состоянии файла, а время модификации - лишь часть информации о файле, которую мы можем найти.) Если файл `.uml` создан позже, значит, один из авторов изменил его и изображения необходимо пере-генерировать. Теперь код становится довольно простым:

```python
if __name__ == "__main__":
    g = GenerateImages(Path.cwd())
    g.make_all_images()
```

Хотя **паттерн Фасад** редко упоминается в сообществе Python, он является неотъемлемой частью экосистемы языка. Поскольку Python делает упор на удобочитаемость языка, и язык, и его библиотеки для сложных задач, как правило, предоставляют простые для понимания интерфейсы. Например, циклы **`for`**, списковые включения и генераторы - все это фасады более сложного **протокола [[Паттерн Итератор|Итератор]]**. Реализация **`defaultdict`** - это фасад, который не учитывает исключительные ситуации, когда ключа нет в словаре.

Сторонние запросы или библиотеки **`httpx`** являются мощным фасадом по сравнению с менее читабельными библиотеками **`urllib`** для обработки НТТР. Сам пакет **`urllib`** представляет собой фасад управления текстовым НТТР-протоколом с использованием базового пакета **`socket`**.

**Паттерн Фасад** помогает избежать сложностей. ==Но когда необходимо избежать дублирования данных, имеет смысл обратиться к следующему паттерну проектирования==. Он оптимизирует хранилище при работе с большими объемами данных. Это особенно полезно на очень маленьких компьютерах, типичных для приложений [[IoT (Internet of Things)|IоТ]].






## Паттерн Легковес
---

**Паттерн Легковес** - ==это паттерн оптимизации памяти==. Начинающие Руthоn-разработчики обычно игнорируют такую оптимизацию, предполагая, что об этом позаботится встроенная программа очистки памяти. Для старта в программировании это неплохо - рассчитывать на встроенное управление. Но в некоторых случаях, например при работе с очень большими приложениями по обработке и анализу данных, ограничение объема памяти может стать барьером, и необходимо принимать более активные меры по управлению ее расходованием. В очень маленьких устройствах [[IoT (Internet of Things)|IoT (Internet of Things)]] управление памятью тем более важно.

**Паттерн Легковес** ==гарантирует, что объекты, которые совместно используют состояние, могут претендовать на одну и ту же область памяти.== Обычно это начинают практиковать только после возникновения проблем с памятью. В некоторых случаях имеет смысл с самого начала разработать оптимальное ее распределение. ==Правда, имейте в виду, что преждевременная оптимизация является наиболее эффективным способом создания сложно поддерживаемой программы.==

В некоторых языках **паттерн Легковес** требует внимательного обращения со ссылками на объекты, предотвращения случайного копирования объектов и отслеживания прав собственности на объекты с тем, чтобы гарантировать, что объекты не будут преждевременно удалены. В Python все является объектом и все объекты работают через согласованные ссылки. Дизайн **паттерна Легковес** в Python, как правило, несколько проще, чем в других языках.

Рассмотрим, как это выглядит на UМL-диаграмме (**рис.12.3**).

Объект **`Flyweight`** не имеет собственного определенного состояния. Каждый раз при необходимости выполнить операцию над **`SpecificState`** это состояние передается во **`Flyweight`** вызывающим кодом в качестве значения аргумента. Фабрика, возвращающая экземпляр класса **`Flyweight`**, представляет собой отдельный объект. Цель этого объекта состоит в том, чтобы возвращать отдельные объекты **`Flyweight`**, возможно организованные по какому-либо ключу или индексу.

Иначе говоря, все работает подобно **паттерну Синглтон**, который мы уже обсуждали в [[Общие Паттерны Проектирования]]. Если **`Flyweight`** существует, то он возвращается. В противном случае создается новый. Во многих языках фабрика реализована не как отдельный объект, а как статический метод самого класса **`Flyweight`**.

>![[Рис. 12.3. Паттерн Легковес.jpg]]
>   **Рис. 12.3.** *Паттерн Легковес*

Это можно сравнить с тем, как [[Всемирная паутина|Всемирная паутина]] заменила компьютер, загруженный данными. Раньше приходилось собирать и индексировать документы и файлы, заполняя локальный компьютер копиями исходных данных, работать с физическими носителями, такими как дискеты и компакт-диски. Теперь же можно через веб-сайт получить ссылку на исходные данные, не создавая громоздкой и занимающей много места копии. Поскольку идет работа со ссылкой на исходные данные, их становится легко прочитать на мобильном устройстве. **Паттерн Легковес** для работы со ссылкой на данные - это важный механизм в общей системе доступа к информации.

В отличие от паттерна проектирования **Синглтон**, который должен возвращать только один экземпляр класса, паттерн Легковес может иметь несколько экземпляров классов **`Flyweight`**. Один из подходов состоит в том, чтобы хранить элементы в словаре и предоставлять значения объектам **`Flyweight`** на основе ключа словаря. Другим распространенным подходом в некоторых приложениях **[[IoT (Internet of Things)|IoT]]** является использование буфера элементов. На мощном компьютере выделение и освобождение объектов обходится относительно недорого. Но на небольшом IоТ-компьютере необходимо свести к минимуму создание объектов, а это подразумевает применение **паттерна Легковес**, в котором буфер используется совместно объектами.

Хороший пример **паттерна Легковес**, учет представителей разных компаний, приехавших на конференцию по IT-технологиям.

```python
from typing import List, Dict

  
class Shared:
    def __init__(self, company: str, position: str):
        self.__company = company
        self.__position = position
 
    @property
    def company(self):
        return self.__company

    @property
    def position(self):
        return self.__position 
  

class Unique:
    def __init__(self, name: str, passport: str):
        self.__name = name
        self.__passport = passport  

    @property
    def name(self):
        return self.__name
 
    @property
    def passport(self):
        return self.__passport
  

class Flyweight:
    def __init__(self, shared: Shared):
        self.__shared = shared

    def process(self, unique: Unique):
        print(
            f"Отображаем новые данные: общие -                             {self.__shared.company}_{self.__shared.position},и уникальные        {unique.name}_{unique.passport}"
        )  
    def get_data(self) -> str:
        return self.__shared.company + "_" + self.__shared.position


class FlyweightFactory:
    def get_key(self, shared: Shared):
        return f"{shared.company}_{shared.position}"

    def __init__(self, shareds: List[Shared]):
        self.__flyweights: Dict[str, Flyweight] = {}
        for shared in shareds:
            self.__flyweights[self.get_key(shared)] =                                              Flyweight(shared)

    def get_flyweight(self, shared: Shared):
        key: str = self.get_key(shared)
        if self.__flyweights.get(key) is None:
            print("Фабрика легковесов: общии объект по ключу "
             + key + " не найден. Создаем новый")
            self.__flyweights[key] = Flyweight(shared)
        else:
            print("Фабрика легковесов: Извлекаем данные из имеющихся                   записей по ключу " + key + ".")
        return self.__flyweights[key]
  
    def list_flyweight(self):
        count: int = len(self.__flyweights)
        print(f"\nФабрика легковесов: всего {count} записей:")
        for pair in self.__flyweights.values():
            print(pair.get_data())


def add_specialist_database(
        ff: FlyweightFactory, company: str, position: str, name: str, passport: str
):
    print()
    flyweight = ff.get_flyweight(Shared(company, position))
    flyweight.process(Unique(name, passport))
 

if __name__ == "__main__":
    shared_list: List[Shared] = \
    (Shared("Microsoft", "Управляющий"),
     Shared("Google", "Android-разработчик"),
     Shared("Google", "Web-разработчик"),
     Shared("Apple", "Swift-разработчик"))

    factory = FlyweightFactory(shared_list)
    factory.list_flyweight()
  
    add_specialist_database(
        factory,
        "Google",
        "Web-разработчик",
        "Jack",
        "Ieefana-288311"
    )
    
    add_specialist_database(
        factory,
        "Apple",
        "Управляющий",
        "Antonio",
        "DDCQ-9992336184"
    ) 

    factory.list_flyweight()
```
```output
  
Фабрика легковесов: всего 4 записей:
Microsoft_Управляющий
Google_Android-разработчик
Google_Web-разработчик
Apple_Swift-разработчик 

Фабрика легковесов: Извлекаем данные из имеющихся записей по ключу Google_Web-разработчик.Отображаем новые данные: общие - Google_Web-разработчик,и уникальные Jack_Ieefana-288311

Фабрика легковесов: общии объект по ключу Apple_Управляющий не найден. Создаем новый Отображаем новые данные: общие - Apple_Управляющий,и уникальные Antonio_DDCQ-9992336184 

Фабрика легковесов: всего 5 записей:
Microsoft_Управляющий
Google_Android-разработчик
Google_Web-разработчик
Apple_Swift-разработчик
Apple_Управляющий

```




### Пример реализации паттерна Легковес
---

Начнем с изучения некоторых конкретных классов для устройства [[IoT (Internet of Things)|IoT]], которое работает с сообщениями GPS. Не будем создавать множество отдельных объектов **`Message`** с повторяющимися значениями, взятыми из исходного буфера. Наоборот, необходимо, чтобы объекты **`Flyweight`** способствовали экономии памяти. При этом не забывайте о двух важных особенностях паттерна.

- Объекты **`Flyweight`** повторно используют байты в одном буфере. Это позволяет избежать дублирования данных на маленьком компьютере.
- Для различных типов сообщений классы **`Flyweight`** могут включать различающиеся типы обработки. Например, все сообщения **`GPGGA`**, **`GPGLL`** и **`GPRMC`** содержат информацию о широте и долготе. Несмотря на то что детали сообщений различаются в зависимости от их типа, не стоит создавать отдельные объекты Python для каждого из типов. Обработка каждого случая, когда единственным реальным ее отличием является расположение соответствующих байтов в буфере, требует значительных расходов.

Посмотрите, как описанные принципы выглядят на UМL-диаграмме (**рис. 12.4**).

Для создания экземпляров **`Flyweight`** различных подклассов **`Message`**, которые работают с объектом **`Buffer`**, содержащим байты, считанные из GPS, применяется **`MessageFactory`**. Каждый подкласс имеет доступ к общему объекту **`Buffer`** и создает объект **`Point`**. Однако подклассы имеют уникальные реализации, отражающие особую структуру каждого сообщения.

Имеется дополнительная сложность, уникальная для Python. При наличии нескольких ссылок на экземпляр объекта **`Buffer`** у разработчиков могут возникнуть проблемы. После работы с несколькими сообщениями в каждом из подклассов **`Message`** будут созданы локальные временные данные, включая ссылку на экземпляр **`Buffer`**.

>![[Рис. 12.4. Сообщение GPS на UМL-диаграмме.jpg]]
>    **Рис. 12.4.** Сообщение GPS на UМL-диаграмме

Для примера рассмотрим следующую диаграмму (**рис. 12.5**).

>![[Рис. 12.5. Ссылочная диаграмма.jpg]]
>    **Рис. 12.5.** Ссылочная диаграмма

Некоторое клиентское приложение, изображенное как объект **`Client`**, содержит ссылку на экземпляр **`Buffer`**. Объект **`Client`** считывает в буфер множество GРS-трафика. Кроме того, конкретный экземпляр **`GРGGА`** также содержит ссылку на объект **`Buffer`**, поскольку **`Offset = 0`**, в буфере содержится сообщение **`GPGGA`**. Если **`Offset = 68 и 98`**, там содержатся другие сообщения, которые также будут содержать ссылки на экземпляр **`Buffer`**.

Поскольку **`Buffer`** содержит ссылку на объект **`GPGGA Message`**, а **`Message`** также имеет обратную ссылку на **`Buffer`**, образуется циклическая пара ссылок. Когда клиент перестает использовать **`Buffer`**, счетчик ссылок уменьшается с четырех до трех.

В подобной ситуации нельзя легко удалить **`Buffer`** и его объекты **`Message`**.

Можно решить эту проблему, воспользовавшись модулем слабой ссылки Python. В отличие от обычных (сильных) ссылок при управлении памятью слабая ссылка не учитывается. Допустимо иметь большое количество слабых ссылок на объект, но как только будет удалена последняя обычная ссылка, объект может быть удален из памяти. Это позволяет клиенту начать работу с новым объектом **`Buffer`**, не беспокоясь о том, что прежний объект **`Buffer`** занимает память. Количество сильных ссылок уменьшается с одной до нуля, что позволяет удалить их. Точно так же каждый объект **`Message`** может иметь одну сильную ссылку из объекта **`Buffer`**, поэтому удаление объекта **`Buffer`** удалит и объект **`Message`**

Слабые ссылки - это часть основы среды выполнения Python. Следовательно, они подлежат оптимизации, которая проявляется в нескольких особых случаях. Одна из этих оптимизаций заключается в том, что мы не можем иметь слабую ссылку на объект **`bytes`**, так как расходы на это оказываются необоснованно большими.

В некоторых случаях (таких как рассматриваемый) необходимо создать **адаптер** для базового объекта **`bytes`**, чтобы преобразовать его в объект, имеющий слабые ссылки.

```python
from typing import Sequence, Iterator, overload, Union


class Buffer(Sequence[int]):
    def __init__(self, content: bytes) -> None:
        self.content = content 

    def __len__(self) -> int:
        return len(self.content) 

    def __iter__(self) -> Iterator[int]:
        return iter(self.content)

    @overload
    def __getitem__(self, index: int) -> int:
        ...

    @overload
    def __getitem__(self, index: slice) -> bytes:
        ...

    def __getitem__(self, index: Union[int, slice]) -> Union[int, bytes]:
        return self.content[index]
```

Это определение класса **`Buffer`** в действительности не содержит много нового кода. Мы предоставили три специальных метода, которые делегировали работу базовому объекту **`bytes`**. Абстрактный базовый тип **`Sequence`** предоставляет несколько методов, таких как **`index()`** и **`count()`**.

Три определения перегруженного метода **`__getitem__()`** - это то, как мы сообщаем `mуру` о важном различии между такими выражениями, как **`buffer[i]`** и **`buffer[start:end]`** . Первое выражение получает из буфера один элемент типа **`int`**, второе использует срез и возвращает объект **`bytes`**. Окончательное определение метода **`__getitem__()`** реализует две перегрузки, делегируя работу объекту self.**`contents`**.

Еще в [[Общие Паттерны Проектирования]] вы изучили использование дизайна на основе состояний для получения и вычисления контрольных сумм. Но сейчас для работы с большим объемом быстро поступающих сообщений GPS применим другой подход.

Поступим вот так:
```python
>>> raw = Buffer(b"$GPGLL,3751.65,S,14507.36,E*77")
```

Символ **`$`** обозначает начало сообщения. Символ **`*`** обозначает конец сообщения. Символы, следующие за звездочкой **`*`**, являются значением контрольной суммы. В этом примере мы проигнорируем два байта контрольной суммы, предполагая, что это правильно. Рассмотрим абстрактный класс **`Message`** с некоторыми общими методами, помогающими анализировать сообщения GPS:

```python
import abc
import weakref
from typing import Sequence, Iterator, overload, Union, Optional


class GPSError(Exception):
    ...  
  

class Message(abc.ABC):
    def __init__(self) -> None:
        self.buffer: weakref.ReferenceType[Buffer]
        self.offset: int
        self.end: Optional[int]
        self.commas: list[int]

    def from_buffer(self, buffer: Buffer, offset: int) -> "Message":
        self.buffer = weakref.ref(buffer)
        self.offset = offset
        self.commas = [offset]
        self.end = None
        for index in range(offset, offset + 82):
            if buffer[index] == ord(b","):
                self.commas.append(index)
            elif buffer[index] == ord(b"*"):
                self.commas.append(index)
                self.end = index + 3
                break
        if self.end is None:
            raise GPSError("Incomplete")
        return self

```

Метод **`__init__()`** ничего не делает. Мы предоставили список переменных экземпляра с их типами, но не установили их. Это способ предупредить `mуру` о том, какие переменные экземпляра будут установлены в другом месте класса.

В методе **`from_buffer()`** мы создаем слабую ссылку на экземпляр **`Buffer`**, при этом используя функцию **`weakref.ref()`**. Как отмечалось выше, указанная специальная ссылка не применяется для отслеживания того, сколько места использует объект **`Buffer`**, что позволяет удалять объекты **`Buffer`**, даже если объекты **`Message`** все еще имеют устаревшие ссылки на них.

Метод **`from_buffer()`** сканирует буфер на наличие символов, **`,`** упрощая определение того, где находится каждое поле. При использовании нескольких полей это может сэкономить некоторое время. Если необходимо только одно или два поля, могут опять появиться излишние расходы. В методе **`__getitem__()`** мы разыменовываем слабую ссылку, чтобы отследить объект **`Buffer`**. Обычно объект **`Buffer`** при обработке находится в памяти вместе с некоторыми объектами сообщений. Вычисление **`self.buffer()`** - вызов ссылки как функции - извлекает обычную ссылку, которая используется в теле метода. В конце метода **`__getitem__()`** переменная буфера больше не нужна, и временная ссылка исчезает.

Ниже приведен код клиентского приложения:

```python
while True:
	buffer = Buffer(gps_device.read(1024))
	// обработка сообщение в буфере
```

Переменная **`buffer`** имеет обычную ссылку на объект **`Buffer`**. В идеале это единственная ссылка. Каждый раз, когда выполнится этот оператор присваивания, прежний объект **`Buffer`** будет иметь нулевые ссылки и сможет быть удален из памяти. После оператора присваивания и до того, как будет выполнен метод **`from_buffer( )`** объекта **`Message`**, попытка использовать метод **`__getitem__()`** объекта **`Message`** вызовет исключение **`RuntimeError`**.

Произойдет серьезная и фатальная ошибка, если приложение будет пытаться использовать метод **`__getitem__()`** объекта **`Message`** без предварительного выполнения **`set_fields()`**. Мы сделали это очевидным, намеренно вызвав сбой приложения. После изучения [[Тестирование Объектно-Ориентированных Программ]] вы сможете использовать модульные тесты, чтобы убедиться, что методы применяются в правильном порядке. До тех пор мы должны быть уверены в правильности использования метода **`__getitem__()`**.

Рассмотрим оставшуюся часть абстрактного базового класса **`Message`**, демонстрирующую работу методов, необходимых для извлечения изменений из сообщения:

```python
    def get_fix(self) -> Point:
        return Point.from_bytes(
        self.latitude(), self.lat_n_s(),
        self.longitude(), self.lon_e_w()
        )

    @abc.abstractmethod
    def latitude(self) -> bytes:
        ...

    @abc.abstractmethod
    def lat_n_s(self) -> bytes:
        ...

    @abc.abstractmethod
    def longitude(self) -> bytes:
        ...

    @abc.abstractmethod
    def lon_e_w(self) -> bytes:
        ...
```

Метод **`get_fix()`** делегирует работу четырем отдельным методам, каждый из которых извлекает одно из множества полей сообщения GPS. Также предоставим подклассы, подобные следующим:

```python
class GPGLL(Message):
    def latitude(self) -> bytes:
        return self[1]

    def lat_n_s(self) -> bytes:
        return self[2]

    def longitude(self) -> bytes:
        return self[3]

    def lon_e_w(self) -> bytes:
        return self[4]
```

Этот класс использует метод **`get_field()`** , унаследованный от класса **`Message`**, с целью получения байтов для четырех определенных полей в общей последовательности байтов. Поскольку метод **`get_field()`** оперирует ссылкой на объект **`Buffer`**, нет необходимости дублировать всю последовательность байтов сообщения. Вместо этого возвратимся к объекту **`Buffer`**, чтобы получить данные, избегая загромождения памяти.

Мы пока не рассматривали объект **`Point`**. Оставим его изучение читателям в качестве упражнений. Напомним только, что объект должен преобразовывать строки байтов в полезные числа с плавающей запятой.

Итак, разберем создание подходящего объекта **`Flyweight`** на основе типа сообщения в буфере:

```python
def message_factory(header: bytes) -> Optional[Message]:
    # TODO: Add functools.lru_cache to save storage and time
    if header == b"GPGGA":
        return GPGGA()
    elif header == b"GPGLL":
        return GPGLL()
    elif header == b"GPRMC":
        return GPRMC()
    else:
        return None
```

Для анализа распознанного сообщения надо создать экземпляр одного из наших классов **`Flyweight`**. Мы оставили комментарий, где предлагаем выполнить другое упражнение: используйте **`functools.lru_cache`**, чтобы избежать создания объектов **`Message`**, которые уже доступны.

Проанализируем, как работает **`message_factory()`** :

```python
>>> buffer = Buffer(
...     b"$GPGLL,3751.65,S,14507.36,E*77"
... )
>>> flyweight = message_factory(buffer[1 : 6])
>>> flyweight.__class__.__name__
'GPGLL'
>>> flyweight.from_buffer(buffer, 0)
<gps_messages.GPGLL object at ...>

>>> flyweight.get_fix()
Point(latitude=-37.86083333333333, longitude=145.12266666666667)
>>> print(flyweight.get_fix())
(37°51.6500S, 145°07.3600E)
```

Мы заполнили объект **`Buffer`** несколькими байтами. Имя сообщения представляет собой срез байтов в позициях буфера 1-6. Операция среза создает в данном случае небольшой объект **`bytes`**. Функция **`message_factory()`** найдет одно из определений класса **`Flyweight`** - класс **`GPGLL`**. Затем обращаемся к методу **`from_buffer()`** , чтобы **`Flyweight`** мог сканировать **`Buffer`**, начиная с нулевой позиции, ожидая найти байты , **`,`** чтобы определить для различных полей начальную и конечную точки.

Когда выполняется метод **`get_fix()`** , класс **`GPGLL`** извлекает четыре поля, преобразует значения в полезные градусы и возвращает объект **`Point`**, содержащий два значения с плавающей запятой.

Теперь при необходимости сопоставить это с другими устройствами можно отобразить значение, имеющее градусы и минуты, отделенные друг от друга. Формат вывода `37°51, 6500 ю.ш.` гораздо нагляднее, чем `37, 860833333333333`.



#### Сообщения из буфера
---

Проанализируем содержимое буфера, хранящего последовательность сообщений. Для этого поместим два сообщения **`GPGLL`** в последовательность байтов. В конце строки добавим явные пробельные символы, которые некоторые GРS-устройства включают в поток данных.

```python
>>> buffer_2 = Buffer(
...    b"$GPGGL,3751.65,S,14507.36,E*77\\r\\n"
...    b"$GPGLL,3723.2475,N,12158.3416,W,161229.489,A,A*41\\r\\n"
...)
>>> start = 0
>>> flyweight = message_factory(buffer_2[start+1 : start+6])
>>> p_1 = flyweight.from_buffer(buffer_2, start).get_fix()
>>> p_1
Point(latitude=-37.86083333333333, longtitude=145.12266666666667)
>>> print(p_1)
(37°51.6500S , 145°07.3600Е)
```

Мы нашли первое сообщение **`GPGLL`**, создали объект **`GPGLL`** и извлекли изменения из сообщения. Следующее сообщение начинается там, где заканчивается предыдущее. Это позволяет нам начать с новой позиции в буфере и исследовать другую часть последовательности байтов.

```python
>>> flyweight.end
30
>>> next_start = buffer_2.index(ord(b"$"), flyweight.end)
>>> next_start
32
>>> 
>>> p_2 = flyweight.from_buffer(buffer_2, next_start).get_fix()
>>> p_2
Point(latitude=37.387458333333335, longitude=-121.97236)
>>> print(p_2)
(37°23.2475N, 121°58.3416W)
```

Для создания нового объекта **`GPGLL`** мы использовали функцию **`message_factory()`** . Поскольку данные из сообщения не находятся в объекте, повторно используется предыдущий объект **`GPGLL`**. Можно убрать строку кода, содержащую **`flyweight =`**, и результаты будут такими же. При использовании метода **`from_buffer()`** мы находим новый набор символов **`,`** . А используя метод **`get_fix()`**, получаем значения из нового места в общей коллекции байтов.

Чтобы получить кэшируемый объект для использования **`message_factory()`** , создаем несколько коротких строк байтов. В данном случае новый объект **`Point`** будет содержать новые значения с плавающей запятой. Такой подход позволяет избежать размещения в памяти больших блоков байтов и заставить объекты обработки сообщений повторно использовать один и тот же экземпляр **`Buffer`**.

Как правило, обращение к **паттерну Легковес** упирается в наличие ссылок на исходные данные. Python избегает присутствия неявных копий объектов. Почти все создание объектов очевидно, используется имя класса или, возможно, синтаксис *comprehension*. Единственный случай, когда создание объекта неочевидно, - это получение фрагмента из последовательности, например, из буфера байтов: при применении **`bytes[start : end]`** создается копия байтов. Их слишком много, и IоТ-устройству не хватает доступной памяти. **Паттерн Легковес** позволяет избежать создания новых объектов, в частности нарезки строк и байтов для создания копий данных.

В нашем примере также присутствует слабая ссылка **`weakref`**. Для паттерна Легковес это не обязательно, но полезно для идентификации объектов, которые можно удалить из памяти. Хотя они часто используются вместе, на самом деле не похожи друг на друга.

Паттерн Легковес очень существенно сокращает потребление памяти. Но программные решения, оптимизирующие ЦП, память или дисковое пространство, обычно приводят к более сложному коду, чем их неоптимизированные аналоги. Поэтому при выборе между простотой сопровождения кода и оптимизацией важно найти сбалансированный подходящий вариант. Выбирая оптимизацию, старайтесь использовать такие паттерны, как Легковес, чтобы убедиться, что сложность, возникающая в результате оптимизации, ограничивается одним (хорошо документированным) разделом кода.

Прежде чем приступить к изучению паттерна Абстрактная фабрика, немного отвлечемся и рассмотрим еще один уникальный для Python метод оптимизации памяти. Это специальный атрибут **`__slots__`**.



#### Оптимизация памяти Паттерн Легковес с помощью атрибута **`__slots__`** Python
---

