---
date of creation: 2024-06-28T17:39:00
tags:
  - Python
  - OOP/Python
  - Patterns
  - Patterns/Python
  - Python/Patterns
  - Developing/Python
  - Python/OOP
Read status: false
aliases:
  - новые паттерны проектирования
---
---
# Новые паттерны проектирования
2024-06-28




В этой главе вы познакомитесь еще с несколькими паттернами проектирования. Мы вместе рассмотрим примеры их использования и реализацию на Python. Вы освоите следующие темы.

- **[[#Паттерн Адаптер|Паттерн Адаптер]]** ==(Adapter)==
- **[[#Паттерн Фасад|Паттерн Фасад]]** ==(Façade)==
- **[[#Паттерн Легковес|Ленивая инициализация и паттерн Легковес]]** ==(Flyweight)==
- **[[#Паттерн Абстрактная фабрика|Паттерн Абстрактная фабрика]]** ==(Abstract Factory)==
- **[[#Паттерн Компоновщик|Паттерн Компоновщик]]** ==(Composite)==
- **[[#Паттерн Шаблонный метод|Паттерн Шаблонный метод]]** ==(Template)==

Начнем свое изучение с паттерна Адаптер. По сути, он типичный переходник для разных интерфейсов или данных.




## Паттерн Адаптер
---

В отличие от большинства рассмотренных в предыдущей главе паттернов **паттерн Адаптер** предназначен для взаимодействия с уже существующим кодом. Мы не стали разрабатывать совершенно новый набор объектов, реализующих **паттерн Адаптер**. Адаптеры используются для обеспечения совместной работы двух объектов, даже если их интерфейсы несовместимы. Как и адаптеры дисплея, позволяющие подключать зарядный кабель Micro USB к телефону USB-C, адаптер находится между двумя разными интерфейсами, леrко переводя их между собой. ==Единственной целью адаптера является выполнение данного преобразования. Ведь адаптация может повлечь за собой множество задач, таких как преобразование арrументов в другой формат, изменение порядка аргументов, вызов метода с другим именем или предоставление аргументов по умолчанию.==

По структуре **паттерн Адаптер** похож на упрощенный вариант **[[Общие Паттерны Проектирования#Паттерн Декоратор|паттерна Декоратор]]**. Но декораторы обычно предоставляют тот же интерфейс, который они заменяют, тогда как адаптеры служат мостом между двумя разными интерфейсами, что представлено на UМL-диаграмме (рис. 12.1).

>![[Рис. 12.1. Паттерн Адаптер.jpg]]
>           **Рис. 12.1.** Паттерн Адаптер

В данном случае клиентский объект, экземпляр **`Client`**, чтобы сделать что-то полезное, должен работать совместно с другим классом. Для этого используется **`load_data()`** как конкретный пример метода, в котором требуется адаптер. Уже имеется класс **`Implementation`**, который делает все, что необходимо (и чтобы избежать дублирования, мы не будем его переписывать!). Однако существует проблема: класс требует сложной последовательности операций с использованием методов **`read_raw_data()`** , **`parse_raw_d ata()`** и  **`createuseful_object()`**. Класс Adapter реализует простой в использовании интерфейс **`load_data()`** , который скрывает сложность существующего интерфейса, предоставляемого классом **`Implementation`**.

Преимущество такой схемы заключается в том, что весь код, отображающий сопоставляемый ожидаемый и фактический интерфейсы, находится в одном месте - в классе Adapter. В качестве альтернативы можно было бы поместить код в клиента, дополняя его не относящимися к делу деталями реализации. В такой редакции кода при наличии нескольких типов клиентов пришлось бы в нескольких местах выполнять сложную обработку **`loaddata()`** всякий раз, когда какому-то из этих клиентов потребовался бы доступ к классу **`Implementation`**.

Хороший пример **паттерна Адаптер**(реализация на уровне объектов), на примере конвертера весов с русских на британских:

```python
import abc
from abc import ABCMeta
 

class IScale(metaclass=ABCMeta):
    @abc.abstractmethod
    def get_weight(self):
        pass
 

class RussianScales(IScale):
    def __init__(self, cw: float):
        self.__current_weight = cw  

    def get_weight(self) -> float:
        return self.__current_weight
   

class BritishScales:
    def __init__(self, cw: float):
        self.__current_weight = cw 

    def get_weight(self) -> float:
        return self.__current_weight
 

class AdapterForBritishScales(IScale):
    def __init__(self, british_scales: BritishScales):
        self.__british_scales = british_scales

    def get_weight(self) -> float:
        return self.__british_scales.get_weight() * .453  
        

if __name__ == "__main__":
    kg: float = 55.  # кг
    lb: float = 55.  # фунты  

    rScales = RussianScales(kg)
    bScales = AdapterForBritishScales(BritishScales(lb))
  
    print(rScales.get_weight())  # кг
    print(bScales.get_weight())  # кг
```
```output
55.0
24.915
```

### Пример реализации паттерна Адаптер
---

Представьте, что уже существует класс, который принимает временные метки строк в формате ННММSS и вычисляет полезные интервалы с плавающей запятой:

```python
class TimeSince:
    """Expects time as six digits, no punctuation."""

    def parse_time(self, time: str) -> tuple[float, float, float]:
        return (
            float(time[0:2]),
            float(time[2:4]),
            float(time[4:]),
        )

    def __init__(self, starting_time: str) -> None:
        self.hr, self.min, self.sec = self.parse_time(starting_time)
        self.start_seconds = ((self.hr * 60) + self.min) * 60 +                                      self.sec

    def interval(self, log_time: str) -> float:
        log_hr, log_min, log_sec = self.parse_time(log_time)
        log_seconds = ((log_hr * 60) + log_min) * 60 + log_sec
        return log_seconds - self.start_seconds

```

Этот класс выполняет преобразование строки во временной интервал и уже присутствует в приложении, имеет модульные тесты и прекрасно работает. Если вы забудете импортировать аннотации **`from __future__`**, при попытке использовать **`tuple[float, float, float]`** в качестве подсказки типа получите сообщение об ошибке. Не забудьте включить модуль аннотаций в качестве первой строки кода. Например, так:

```python
>>> ts = TimeSince('000123')  # logstarted at 00:01:23
>>> ts.interval('020304')
7301.0
>>> ts.interval('030405')
10962.0
```

Работать с таким неформатированным временем немного неудобно, но ряд устройств Internet of Тhings (IoT) предоставляют именно такие временные строки, отделенные от остальной части даты. Посмотрите, например, на сообщения формата NMEA 0183 от устройства GPS, там даты и время представляют собой неформатированные строки цифр.

У нас имеется старый лог-файл с одного из этих устройств, очевидно созданный несколько лет назад. Необходимо проанализировать этот лог-файл на наличие последовательности сообщений, которые появляются после каждого сообщения `ERROR`, и, кроме того, получить точное время относительно сообщения `ERROR` в качестве анализа основной причины проблемы.

Например:
```python
>>> data = [
...     ("000123", "INFO", "Gila Flats 1959-08-20"),
...     ("000142", "INFO", "test block 15"),
...     ("004201", "ERROR", "intrinsic field chamber door locked"),
...     ("004210.11", "INFO", "generator power active"),
...     ("004232.33", "WARNING", "extra mass detected")
... ]
```

Вычислить временной интервал между сообщением **`ERROR`** и **`WARNING`** сложно, но возможно. У многих программистов достаточно навыков, чтобы производить подобные вычисления. Но, может, лучше проанализировать лог-файл, содержащий относительное время, а не абсолютное? Ниже представлена схема форматирования лог-файла, которую необходимо использовать. Однако здесь вырисовывается проблема, которую мы отметили символами **`???`** :

```python
class LogProcessor:
    def __init__(self, log_entries: list[tuple[str, str, str]]) ->           None:
        self.log_entries = log_entries

    def report(self) -> None:
        first_time, first_sev, first_msg = self.log_entries[0]
        for log_time, severety, message in self.log_entries:
            if severety == "ERROR":
                first_time = log_time
            interval = ??? Need to compute an interval ???
            print(f"{interval:8.2f} | {severety:7s} {message}")
            
```

Класс **`LogProcessor`** кажется правильным. Он перебирает записи лог-файла, сбрасывая переменную **`first_time`** при каждом появлении строки **`ERROR`**. Это гарантирует, что лог-файл отображает позицию ошибки, избавляя нас от необходимости выполнять множество математических вычислений.

Но взгляните повнимательнее: возникает необходимость повторно использовать класс **`TimeSince`**. Он не просто вычисляет интервал между двумя значениями. Существует несколько вариантов реализации данного сценария.

- Для работы со строками времени можно было бы переписать класс **`TimeSince`**. Но тогда возникает риск нарушить код в нашем приложении. Иногда это называется радиусом разбрызгивания - сколько вещей в окружении намокнет, если бросить камень в бассейн? Принцип открытого/закрытого проектирования (один из принципов SOLID, дополнительную информацию можно получить на сайте https://subscription.packtpub.com/book/application_development/9781788835831/4) предполагает, что класс должен быть доступен для расширения, но недоступен для подобных модификаций. Если класс был загружен из `PyPI`, мы можем не изменять его внутреннюю структуру, так как тогда станет невозможно использовать последующие релизные версии. Необходим альтернативный вариант работы внутри другого класса.

- Мы могли бы использовать класс как есть и всякий раз при необходимости вычислить интервалы между сообщением **`ERROR`** и последующими строками лог-файла создавать новый объект **`TimeSince`**. Это выливается в создание большого количества объектов. Представьте, что имеется несколько приложений для анализа лог-файлов, каждое из которых рассматривает различные аспекты сообщений этих файлов. Внесение изменений означает необходимость вернуться и исправить все места, где были созданы объекты **`TimeSince`**. Если в классе **`LogProcessor`** слишком много деталей, связанных с работой класса **`TimeSince`**, нарушается принцип единой ответственности. А также вспомним еще один принцип - Не повторяйся (DRY), который применим и в этом случае.

- Вместо этого можно добавить адаптер, который связывает потребности класса **`LogProcessor`** с методами, доступными в классе **`TimeSince`**.

Решение с **паттерном Адаптер** подразумевает наличие класса с интерфейсом, необходимым для класса **`LogProcessor`**. Он также использует интерфейс, предлагаемый классом **`ТimeSince`**. То есть он представляет собой развитие обоих классов, оставляя их закрытыми для модификации, но доступными для расширения. Например, так, как в следующем фрагменте кода:

```python
from typing import Optional


class IntervalAdapter:
    def __init__(self) -> None:
        self.ts: Optional[TimeSince] = None

    def time_offset(self, start: str, now: str) -> float:
        if self.ts is None:
            self.ts = TimeSince(start)
        else:
            h_m_s = self.ts.parse_time(start)
            if h_m_s != (self.ts.hr, self.ts.min, self.ts.sec):
                self.ts = TimeSince(start)
        return self.ts.interval(now)
```

Этот адаптер создает объект **`ТimeSince`**, когда это необходимо. Если **`TimeSince`** отсутствует, адаптер должен его создать. Если объект **`TimeSince`** уже существует и использует уже установленное начальное время, то экземпляр **`TimeSince`** можно использовать повторно. Однако, как только класс **`LogProcessor`** сместил фокус на новое сообщение об ошибке, возникает необходимость создать новый экземпляр **`TimeSince`**.

Рассмотрим пример окончательного проекта класса **`LogProcessor`** с использованием класса **`IntervalAdapter`**:

```python
class LogProcessor:
    def __init__(self, log_entries: list[tuple[str, str, str]]) -> None:
        self.log_entries = log_entries
        self.time_convert = IntervalAdapter()

    def report(self) -> None:
        first_time, first_sev, first_msg = self.log_entries[0]
        for log_time, severity, message in self.log_entries:
            if severity == "ERROR":
                first_time = log_time
            interval = self.time_convert.time_offset(first_time,                                                         log_time)
            print(f"{interval:8.2f} | {severity:7s} {message}")
```

Здесь в процессе инициализации был создан экземпляр **`IntervalAdapter()`** . Затем этот объект применялся для вычисления каждой временной позиции, а существующий класс **`TimeSince`** повторно использовался без каких-либо модификаций исходного класса, причем класс **`LogProcessor`** не заботился о деталях работы экземпляра **`TimeSince`**.

Также в данном случае мы можем использовать наследование. Можно расширить экземпляр **`ТimeSince`**, чтобы добавить к нему необходимый метод. Альтернатива наследования - неплохая идея. Обратите внимание: похоже, это как раз та ситуация, когда нет единственного правильного ответа. В некоторых случаях имеет смысл обдумать реализацию с наследованием и сравнить ее с реализацией адаптера, проанализировав, какая из них проще.

Для добавления метода к существующему классу вместо наследования мы можем использовать метод *monkey patching*. Python позволяет добавлять новый метод, который предоставляет адаптированный интерфейс, необходимый для вызова кода. То есть внутри оператора **`class`** легко найти определение класса - но это будет не весь класс, используемый во время выполнения. И другие разработчики в случае необходимости будут вынуждены искать в коде место внедрения в класс новой функции. То есть вне модульного тестирования метод *monkey patching* не является хорошей идеей.

Как правило, в качестве адаптера можно использовать функцию. Хотя такой подход явно не соответствует классическому дизайну паттерна проектирования класса Адаптер, иногда этим несоответствием пренебрегают: класс с методом **`__call__()`** является вызываемым объектом, неотличимым от функции. Функция тоже может быть отличным адаптером. Python не требует, чтобы все было определено в классах.

Различие между **паттернами Адаптер и Декоратор** незначительное, но важное. **Паттерн Адаптер**, как правило, расширяет, модифицирует или комбинирует более одного метода из адаптируемых классов. Паттерн Декоратор обычно избегает значительных изменений, сохраняя интерфейс исходного метода, постепенно добавляя функции. Как уже указывалось в [[Общие Паттерны Проектирования]] , паттерн Декоратор следует рассматривать как особый вид адаптера.

Использование класса Адаптер аналогично использованию класса **Стратегия**. Идея состоит в том, что после внесения изменений может понадобиться другой адаптер. Принципиальное отличие заключается в том, что стратегии часто выбираются во время выполнения, а адаптеры выбираются во время разработки и изменяются очень редко.

Следующий паттерн, который мы рассмотрим, похож на Адаптер, так как он также заключает функциональность в новый контейнер. Разница состоит в сложности того, что именно обертывается. **Паттерн Фасад**, как правило, содержит значительно более сложные конструкции.





## Паттерн Фасад
---

**Паттерн Фасад** ==предназначен для предоставления простого интерфейса сложной системе компонентов.== Это структурный паттерн, который предоставляет простой интерфейс к сложной системе объектов, библиотеке или фреймворку. **Паттерн Фасад** дает возможность определить новый класс, который 'инкапсулирует типичное использование системы, тем самым позволяя избежать дизайна, раскрывающего слишком много деталей реализации, обычно не выраженных явно при взаимодействии объектов. Каждый раз, когда нужен доступ к общей или типичной функциональности, используется упрощенный интерфейс одного объекта. Если другой части проекта требуется доступ к более полной функциональности, код по-прежнему может напрямую взаимодействовать с компонентами и отдельными методами.

UML-диаграмма для **паттерна Фасад** зависит от подсистемы, изображенной в виде пакета **`Big System`**, но в облачном виде диаграмма выглядит так, как это показано на **рис. 12.2.**

>![[Рис. 12.2. Паттерн Фасад.jpg]]
> **Рис. 12.2**. Паттерн Фасад

Паттерн Фасад во многом похож на **[[#Паттерн Адаптер|паттерн Адаптер]]**. Основное отличие заключается в том, что паттерн Фасад абстрагирует более простой интерфейс от сложного, в то время как Адаптер только сопоставляет один существующий интерфейс с другим.

Хороший пример **паттерна Фасад**, на примере интернет-магазина:

```python
class ProviderCommunication:
    def receive(self):
        print("Получение продукции от производителя")

    def payment(self):
        print("Оплата поставщику с удержанием коммисии за продажу                  продукции")
 

class Site:
    def placement(self):
        print("Размещение на сайте")

    def delete(self):
        print("Удаление с сайта")
 

class Database:
    def insert(self):
        print("Запись в базу данных")

    def delete(self):
        print("Удаление из базы данных")
  

class MarketPlace:
    def __init__(self):
        self._provider_cummunication = ProviderCommunication()
        self._site = Site()
        self._database = Database() 

    def product_receive(self):
        self._provider_cummunication.receive()
        self._site.placement()
        self._database.insert() 

    def product_release(self):
        self._provider_cummunication.payment()
        self._site.delete()
        self._database.delete()
  

if __name__ == "__main__":
    market_place = MarketPlace()
    market_place.product_receive()
    
    print()

    market_place.product_release()
```
```powershell
Получение продукции от производителя
Размещение на сайте
Запись в базу данных 

Оплата поставщику с удержанием коммисии за продажу продукции
Удаление с сайта
Удаление из базы данных
```




### Пример реализации паттерна Фасад
---

Все изображения для этой книги были сделаны с помощью PlantUML (https://plantuml.com). Каждая диаграмма начинается с текстового файла и должна быть преобразована в формат PNG. Это двухэтапный процесс, и ниже в коде будет показано, как **паттерн Фасад** применяется для объединения двух процессов.

Первый этап - обход дерева каталогов с поиском всех файлов UML, то есть с расширением `.uml`. Анализируется и содержимое файла на предмет наличия в нем названия диаграмм.

```python
import re
from pathlib import Path
from typing import Iterator, Tuple


class FindUML:
    def __init__(self, base: Path) -> None:
        self.base = base
        self.start_pattern = re.compile(r"@startmul *(.*)")

    def uml_file_iter(self) -> Iterator[tuple[Path, Path]]:
        for source in self.base.glob("**/*.uml"):
            if any(n.startswith(".") for n in source.parts):
                continue
            body = source.read_text()
            for output_name in self.start_pattern.findall(body):
                if output_name:
                    target = source.parent / output_name
                else:
                    target = source.with_suffix(".png")
                yield (
                    source.relative_to(self.base),
                    target.relative_to(self.base)
                )
```

Для класса **`FindUML`** необходим базовый каталог. Метод **`uml_file_iter()`** проходит по всему дереву каталогов, используя метод **`Path.glob()`** . При поиске пропускаются все каталоги, имена которых начинаются с **`.`** , так как к ним часто обращаются в своей работе инструменты **`tox`**, **`mуру`** или **git**. Остальные файлы будут содержать cтpoки **`@startuml`**, а некоторые и строку с именами нескольких выходных файлов.

Большинство файлов UML не создают нескольких файлов. Регулярное выражение **`self.start_pattern`** определяет имя, если оно указано, а итератор выдает кортежи с двумя путями.

Имеется класс, который в качестве подпроцесса запускает прикладную программу PlantUML. Когда Python работает, все это является процессом операционной системы. Опираясь на модуль **`subprocess`**, можно запускать дочерние процессы, которые, в свою очередь, запускают другие бинарные приложения или сценарии оболочки. Например, так:

```python
import subprocess

class PlantUML:
    """
    Default setup is this:

    1.  Download Java Runtime (JRE) for your platform.
        https://www.java.com/en/download/manual.jsp 

    2.  Download the ``plantuml.jar`` and put into your conda                environment ``share`` directory.https://plantuml.com/download

    3.  Use ``conda install graphiz`` to create the ``dot``                  application in your conda environment.

    4.  If necessary, update this script with environment name and           locations
    """

    conda_env_name = "CaseStudy"
    base_env = Path.home() / "miniconda3" / "envs" / "conda_env_name"

    def __init__(
            self,
            graphviz: Path = Path("bin") / "dot",
            plantjar: Path = Path("share") / "plantuml.jar",
    ) -> None:
        self.graphviz = self.base_env / graphviz
        self.plantviz = self.base_env / plantjar  

    def process(self, source: Path) -> None:
        env = {
            "GRAPHVIZ_DOT": str(self.graphviz),
        }
        command = [
            "java", "-jar",
            str(self.plantjar), "-progress",
            str(source)
        ]
        subprocess.run(command, env=env, check=True)
        print()
```

При создании виртуальной среды **`CaseStudy`** работа класса PlantUML зависит от применения `conda`. При использовании других менеджеров виртуальной среды подкласс может предоставлять все необходимые пути модификации. В указанную виртуальную среду нужно установить пакет **`Graphviz`**. Тогда диаграмма будет представлена как файл изображения. Необходимо также скачать файл **`plantuml.jar`**. Поместим его в общий каталог внутри выбранной виртуальной среды. Значение командной переменной предполагает, что среда выполнения Java (JRE) корректно установлена и видна.

Функция **`subprocess.run()`** принимает аргументы командной строки и любые специальные переменные среды, которые необходимо установить. Функция запустит команду в данной среде и проверит полученный код возврата, чтобы убедиться, что программа работает правильно.

Также эти этапы можно использовать отдельно, чтобы найти все файлы UML и создать диаграммы. Поскольку интерфейс немного сложен для понимания, класс, работающий с **паттерном Фасад**, помогает создать полезное приложение командной строки.

```python
class GenerateImages:
    def __init__(self, base: Path) -> None:
        self.finder = FindUML(base)
        self.painter = PlantUML()

    def make_all_images(self) -> None:
        for source, target in self.finder.uml_file_iter():
            if (
                not target.exists()
                or source.stat().st_mtime > target.stat().st_mtime
            ):
                print(f"Processing {source} -> {target}")
                self.painter.process(source)
            else:
                print(f"Skipping {source} -> {target}")
```

Класс **`Generatelmages`** - это удобный фасад, сочетающий в себе функции классов **`FindUML`** и **`PlantUML`**. Он использует метод **`FindUML.uml_file_iter()`** для поиска исходных файлов и выходных файлов изображений. Класс **`GenerateImages`** проверяет время модификации этих файлов, чтобы избежать их обработки, если изображение новее исходного. ( Информацию, касающуюся **`stat().st_mtime`**, пока нельзя считать точной. Метод **`stat()`** класса **`Path`** предоставляет большое количество информации о состоянии файла, а время модификации - лишь часть информации о файле, которую мы можем найти.) Если файл `.uml` создан позже, значит, один из авторов изменил его и изображения необходимо пере-генерировать. Теперь код становится довольно простым:

```python
if __name__ == "__main__":
    g = GenerateImages(Path.cwd())
    g.make_all_images()
```

Хотя **паттерн Фасад** редко упоминается в сообществе Python, он является неотъемлемой частью экосистемы языка. Поскольку Python делает упор на удобочитаемость языка, и язык, и его библиотеки для сложных задач, как правило, предоставляют простые для понимания интерфейсы. Например, циклы **`for`**, списковые включения и генераторы - все это фасады более сложного **протокола [[Паттерн Итератор|Итератор]]**. Реализация **`defaultdict`** - это фасад, который не учитывает исключительные ситуации, когда ключа нет в словаре.

Сторонние запросы или библиотеки **`httpx`** являются мощным фасадом по сравнению с менее читабельными библиотеками **`urllib`** для обработки НТТР. Сам пакет **`urllib`** представляет собой фасад управления текстовым НТТР-протоколом с использованием базового пакета **`socket`**.

**Паттерн Фасад** помогает избежать сложностей. ==Но когда необходимо избежать дублирования данных, имеет смысл обратиться к следующему паттерну проектирования==. Он оптимизирует хранилище при работе с большими объемами данных. Это особенно полезно на очень маленьких компьютерах, типичных для приложений [[IoT (Internet of Things)|IоТ]].






## Паттерн Легковес
---

**Паттерн Легковес** - ==это паттерн оптимизации памяти==. Начинающие Руthоn-разработчики обычно игнорируют такую оптимизацию, предполагая, что об этом позаботится встроенная программа очистки памяти. Для старта в программировании это неплохо - рассчитывать на встроенное управление. Но в некоторых случаях, например при работе с очень большими приложениями по обработке и анализу данных, ограничение объема памяти может стать барьером, и необходимо принимать более активные меры по управлению ее расходованием. В очень маленьких устройствах [[IoT (Internet of Things)|IoT (Internet of Things)]] управление памятью тем более важно.

**Паттерн Легковес** ==гарантирует, что объекты, которые совместно используют состояние, могут претендовать на одну и ту же область памяти.== Обычно это начинают практиковать только после возникновения проблем с памятью. В некоторых случаях имеет смысл с самого начала разработать оптимальное ее распределение. ==Правда, имейте в виду, что преждевременная оптимизация является наиболее эффективным способом создания сложно поддерживаемой программы.==

В некоторых языках **паттерн Легковес** требует внимательного обращения со ссылками на объекты, предотвращения случайного копирования объектов и отслеживания прав собственности на объекты с тем, чтобы гарантировать, что объекты не будут преждевременно удалены. В Python все является объектом и все объекты работают через согласованные ссылки. Дизайн **паттерна Легковес** в Python, как правило, несколько проще, чем в других языках.

Рассмотрим, как это выглядит на UМL-диаграмме (**рис.12.3**).

Объект **`Flyweight`** не имеет собственного определенного состояния. Каждый раз при необходимости выполнить операцию над **`SpecificState`** это состояние передается во **`Flyweight`** вызывающим кодом в качестве значения аргумента. Фабрика, возвращающая экземпляр класса **`Flyweight`**, представляет собой отдельный объект. Цель этого объекта состоит в том, чтобы возвращать отдельные объекты **`Flyweight`**, возможно организованные по какому-либо ключу или индексу.

Иначе говоря, все работает подобно **паттерну Синглтон**, который мы уже обсуждали в [[Общие Паттерны Проектирования]]. Если **`Flyweight`** существует, то он возвращается. В противном случае создается новый. Во многих языках фабрика реализована не как отдельный объект, а как статический метод самого класса **`Flyweight`**.

>![[Рис. 12.3. Паттерн Легковес.jpg]]
>   **Рис. 12.3.** *Паттерн Легковес*

Это можно сравнить с тем, как [[Всемирная паутина|Всемирная паутина]] заменила компьютер, загруженный данными. Раньше приходилось собирать и индексировать документы и файлы, заполняя локальный компьютер копиями исходных данных, работать с физическими носителями, такими как дискеты и компакт-диски. Теперь же можно через веб-сайт получить ссылку на исходные данные, не создавая громоздкой и занимающей много места копии. Поскольку идет работа со ссылкой на исходные данные, их становится легко прочитать на мобильном устройстве. **Паттерн Легковес** для работы со ссылкой на данные - это важный механизм в общей системе доступа к информации.

В отличие от паттерна проектирования **Синглтон**, который должен возвращать только один экземпляр класса, паттерн Легковес может иметь несколько экземпляров классов **`Flyweight`**. Один из подходов состоит в том, чтобы хранить элементы в словаре и предоставлять значения объектам **`Flyweight`** на основе ключа словаря. Другим распространенным подходом в некоторых приложениях **[[IoT (Internet of Things)|IoT]]** является использование буфера элементов. На мощном компьютере выделение и освобождение объектов обходится относительно недорого. Но на небольшом IоТ-компьютере необходимо свести к минимуму создание объектов, а это подразумевает применение **паттерна Легковес**, в котором буфер используется совместно объектами.

Хороший пример **паттерна Легковес**, учет представителей разных компаний, приехавших на конференцию по IT-технологиям.

```python
from typing import List, Dict

  
class Shared:
    def __init__(self, company: str, position: str):
        self.__company = company
        self.__position = position
 
    @property
    def company(self):
        return self.__company

    @property
    def position(self):
        return self.__position 
  

class Unique:
    def __init__(self, name: str, passport: str):
        self.__name = name
        self.__passport = passport  

    @property
    def name(self):
        return self.__name
 
    @property
    def passport(self):
        return self.__passport
  

class Flyweight:
    def __init__(self, shared: Shared):
        self.__shared = shared

    def process(self, unique: Unique):
        print(
            f"Отображаем новые данные: общие -                             {self.__shared.company}_{self.__shared.position},и уникальные        {unique.name}_{unique.passport}"
        )  
    def get_data(self) -> str:
        return self.__shared.company + "_" + self.__shared.position


class FlyweightFactory:
    def get_key(self, shared: Shared):
        return f"{shared.company}_{shared.position}"

    def __init__(self, shareds: List[Shared]):
        self.__flyweights: Dict[str, Flyweight] = {}
        for shared in shareds:
            self.__flyweights[self.get_key(shared)] =                                              Flyweight(shared)

    def get_flyweight(self, shared: Shared):
        key: str = self.get_key(shared)
        if self.__flyweights.get(key) is None:
            print("Фабрика легковесов: общии объект по ключу "
             + key + " не найден. Создаем новый")
            self.__flyweights[key] = Flyweight(shared)
        else:
            print("Фабрика легковесов: Извлекаем данные из имеющихся                   записей по ключу " + key + ".")
        return self.__flyweights[key]
  
    def list_flyweight(self):
        count: int = len(self.__flyweights)
        print(f"\nФабрика легковесов: всего {count} записей:")
        for pair in self.__flyweights.values():
            print(pair.get_data())


def add_specialist_database(
        ff: FlyweightFactory, company: str, position: str, name: str, passport: str
):
    print()
    flyweight = ff.get_flyweight(Shared(company, position))
    flyweight.process(Unique(name, passport))
 

if __name__ == "__main__":
    shared_list: List[Shared] = \
    (Shared("Microsoft", "Управляющий"),
     Shared("Google", "Android-разработчик"),
     Shared("Google", "Web-разработчик"),
     Shared("Apple", "Swift-разработчик"))

    factory = FlyweightFactory(shared_list)
    factory.list_flyweight()
  
    add_specialist_database(
        factory,
        "Google",
        "Web-разработчик",
        "Jack",
        "Ieefana-288311"
    )
    
    add_specialist_database(
        factory,
        "Apple",
        "Управляющий",
        "Antonio",
        "DDCQ-9992336184"
    ) 

    factory.list_flyweight()
```
```output
  
Фабрика легковесов: всего 4 записей:
Microsoft_Управляющий
Google_Android-разработчик
Google_Web-разработчик
Apple_Swift-разработчик 

Фабрика легковесов: Извлекаем данные из имеющихся записей по ключу Google_Web-разработчик.Отображаем новые данные: общие - Google_Web-разработчик,и уникальные Jack_Ieefana-288311

Фабрика легковесов: общии объект по ключу Apple_Управляющий не найден. Создаем новый Отображаем новые данные: общие - Apple_Управляющий,и уникальные Antonio_DDCQ-9992336184 

Фабрика легковесов: всего 5 записей:
Microsoft_Управляющий
Google_Android-разработчик
Google_Web-разработчик
Apple_Swift-разработчик
Apple_Управляющий

```




### Пример реализации паттерна Легковес
---

Начнем с изучения некоторых конкретных классов для устройства [[IoT (Internet of Things)|IoT]], которое работает с сообщениями GPS. Не будем создавать множество отдельных объектов **`Message`** с повторяющимися значениями, взятыми из исходного буфера. Наоборот, необходимо, чтобы объекты **`Flyweight`** способствовали экономии памяти. При этом не забывайте о двух важных особенностях паттерна.

- Объекты **`Flyweight`** повторно используют байты в одном буфере. Это позволяет избежать дублирования данных на маленьком компьютере.
- Для различных типов сообщений классы **`Flyweight`** могут включать различающиеся типы обработки. Например, все сообщения **`GPGGA`**, **`GPGLL`** и **`GPRMC`** содержат информацию о широте и долготе. Несмотря на то что детали сообщений различаются в зависимости от их типа, не стоит создавать отдельные объекты Python для каждого из типов. Обработка каждого случая, когда единственным реальным ее отличием является расположение соответствующих байтов в буфере, требует значительных расходов.

Посмотрите, как описанные принципы выглядят на UМL-диаграмме (**рис. 12.4**).

Для создания экземпляров **`Flyweight`** различных подклассов **`Message`**, которые работают с объектом **`Buffer`**, содержащим байты, считанные из GPS, применяется **`MessageFactory`**. Каждый подкласс имеет доступ к общему объекту **`Buffer`** и создает объект **`Point`**. Однако подклассы имеют уникальные реализации, отражающие особую структуру каждого сообщения.

Имеется дополнительная сложность, уникальная для Python. При наличии нескольких ссылок на экземпляр объекта **`Buffer`** у разработчиков могут возникнуть проблемы. После работы с несколькими сообщениями в каждом из подклассов **`Message`** будут созданы локальные временные данные, включая ссылку на экземпляр **`Buffer`**.

>![[Рис. 12.4. Сообщение GPS на UМL-диаграмме.jpg]]
>    **Рис. 12.4.** Сообщение GPS на UМL-диаграмме

Для примера рассмотрим следующую диаграмму (**рис. 12.5**).

>![[Рис. 12.5. Ссылочная диаграмма.jpg]]
>    **Рис. 12.5.** Ссылочная диаграмма

Некоторое клиентское приложение, изображенное как объект **`Client`**, содержит ссылку на экземпляр **`Buffer`**. Объект **`Client`** считывает в буфер множество GРS-трафика. Кроме того, конкретный экземпляр **`GРGGА`** также содержит ссылку на объект **`Buffer`**, поскольку **`Offset = 0`**, в буфере содержится сообщение **`GPGGA`**. Если **`Offset = 68 и 98`**, там содержатся другие сообщения, которые также будут содержать ссылки на экземпляр **`Buffer`**.

Поскольку **`Buffer`** содержит ссылку на объект **`GPGGA Message`**, а **`Message`** также имеет обратную ссылку на **`Buffer`**, образуется циклическая пара ссылок. Когда клиент перестает использовать **`Buffer`**, счетчик ссылок уменьшается с четырех до трех.

В подобной ситуации нельзя легко удалить **`Buffer`** и его объекты **`Message`**.

Можно решить эту проблему, воспользовавшись модулем слабой ссылки Python. В отличие от обычных (сильных) ссылок при управлении памятью слабая ссылка не учитывается. Допустимо иметь большое количество слабых ссылок на объект, но как только будет удалена последняя обычная ссылка, объект может быть удален из памяти. Это позволяет клиенту начать работу с новым объектом **`Buffer`**, не беспокоясь о том, что прежний объект **`Buffer`** занимает память. Количество сильных ссылок уменьшается с одной до нуля, что позволяет удалить их. Точно так же каждый объект **`Message`** может иметь одну сильную ссылку из объекта **`Buffer`**, поэтому удаление объекта **`Buffer`** удалит и объект **`Message`**

Слабые ссылки - это часть основы среды выполнения Python. Следовательно, они подлежат оптимизации, которая проявляется в нескольких особых случаях. Одна из этих оптимизаций заключается в том, что мы не можем иметь слабую ссылку на объект **`bytes`**, так как расходы на это оказываются необоснованно большими.

В некоторых случаях (таких как рассматриваемый) необходимо создать **адаптер** для базового объекта **`bytes`**, чтобы преобразовать его в объект, имеющий слабые ссылки.

```python
from typing import Sequence, Iterator, overload, Union


class Buffer(Sequence[int]):
    def __init__(self, content: bytes) -> None:
        self.content = content 

    def __len__(self) -> int:
        return len(self.content) 

    def __iter__(self) -> Iterator[int]:
        return iter(self.content)

    @overload
    def __getitem__(self, index: int) -> int:
        ...

    @overload
    def __getitem__(self, index: slice) -> bytes:
        ...

    def __getitem__(self, index: Union[int, slice]) -> Union[int, bytes]:
        return self.content[index]
```

Это определение класса **`Buffer`** в действительности не содержит много нового кода. Мы предоставили три специальных метода, которые делегировали работу базовому объекту **`bytes`**. Абстрактный базовый тип **`Sequence`** предоставляет несколько методов, таких как **`index()`** и **`count()`**.

Три определения перегруженного метода **`__getitem__()`** - это то, как мы сообщаем `mуру` о важном различии между такими выражениями, как **`buffer[i]`** и **`buffer[start:end]`** . Первое выражение получает из буфера один элемент типа **`int`**, второе использует срез и возвращает объект **`bytes`**. Окончательное определение метода **`__getitem__()`** реализует две перегрузки, делегируя работу объекту self.**`contents`**.

Еще в [[Общие Паттерны Проектирования]] вы изучили использование дизайна на основе состояний для получения и вычисления контрольных сумм. Но сейчас для работы с большим объемом быстро поступающих сообщений GPS применим другой подход.

Поступим вот так:
```python
>>> raw = Buffer(b"$GPGLL,3751.65,S,14507.36,E*77")
```

Символ **`$`** обозначает начало сообщения. Символ **`*`** обозначает конец сообщения. Символы, следующие за звездочкой **`*`**, являются значением контрольной суммы. В этом примере мы проигнорируем два байта контрольной суммы, предполагая, что это правильно. Рассмотрим абстрактный класс **`Message`** с некоторыми общими методами, помогающими анализировать сообщения GPS:

```python
import abc
import weakref
from typing import Sequence, Iterator, overload, Union, Optional


class GPSError(Exception):
    ...  
  

class Message(abc.ABC):
    def __init__(self) -> None:
        self.buffer: weakref.ReferenceType[Buffer]
        self.offset: int
        self.end: Optional[int]
        self.commas: list[int]

    def from_buffer(self, buffer: Buffer, offset: int) -> "Message":
        self.buffer = weakref.ref(buffer)
        self.offset = offset
        self.commas = [offset]
        self.end = None
        for index in range(offset, offset + 82):
            if buffer[index] == ord(b","):
                self.commas.append(index)
            elif buffer[index] == ord(b"*"):
                self.commas.append(index)
                self.end = index + 3
                break
        if self.end is None:
            raise GPSError("Incomplete")
        return self

```

Метод **`__init__()`** ничего не делает. Мы предоставили список переменных экземпляра с их типами, но не установили их. Это способ предупредить `mуру` о том, какие переменные экземпляра будут установлены в другом месте класса.

В методе **`from_buffer()`** мы создаем слабую ссылку на экземпляр **`Buffer`**, при этом используя функцию **`weakref.ref()`**. Как отмечалось выше, указанная специальная ссылка не применяется для отслеживания того, сколько места использует объект **`Buffer`**, что позволяет удалять объекты **`Buffer`**, даже если объекты **`Message`** все еще имеют устаревшие ссылки на них.

Метод **`from_buffer()`** сканирует буфер на наличие символов, **`,`** упрощая определение того, где находится каждое поле. При использовании нескольких полей это может сэкономить некоторое время. Если необходимо только одно или два поля, могут опять появиться излишние расходы. В методе **`__getitem__()`** мы разыменовываем слабую ссылку, чтобы отследить объект **`Buffer`**. Обычно объект **`Buffer`** при обработке находится в памяти вместе с некоторыми объектами сообщений. Вычисление **`self.buffer()`** - вызов ссылки как функции - извлекает обычную ссылку, которая используется в теле метода. В конце метода **`__getitem__()`** переменная буфера больше не нужна, и временная ссылка исчезает.

Ниже приведен код клиентского приложения:

```python
while True:
	buffer = Buffer(gps_device.read(1024))
	// обработка сообщение в буфере
```

Переменная **`buffer`** имеет обычную ссылку на объект **`Buffer`**. В идеале это единственная ссылка. Каждый раз, когда выполнится этот оператор присваивания, прежний объект **`Buffer`** будет иметь нулевые ссылки и сможет быть удален из памяти. После оператора присваивания и до того, как будет выполнен метод **`from_buffer( )`** объекта **`Message`**, попытка использовать метод **`__getitem__()`** объекта **`Message`** вызовет исключение **`RuntimeError`**.

Произойдет серьезная и фатальная ошибка, если приложение будет пытаться использовать метод **`__getitem__()`** объекта **`Message`** без предварительного выполнения **`set_fields()`**. Мы сделали это очевидным, намеренно вызвав сбой приложения. После изучения [[Тестирование Объектно-Ориентированных Программ]] вы сможете использовать модульные тесты, чтобы убедиться, что методы применяются в правильном порядке. До тех пор мы должны быть уверены в правильности использования метода **`__getitem__()`**.

Рассмотрим оставшуюся часть абстрактного базового класса **`Message`**, демонстрирующую работу методов, необходимых для извлечения изменений из сообщения:

```python
    def get_fix(self) -> Point:
        return Point.from_bytes(
        self.latitude(), self.lat_n_s(),
        self.longitude(), self.lon_e_w()
        )

    @abc.abstractmethod
    def latitude(self) -> bytes:
        ...

    @abc.abstractmethod
    def lat_n_s(self) -> bytes:
        ...

    @abc.abstractmethod
    def longitude(self) -> bytes:
        ...

    @abc.abstractmethod
    def lon_e_w(self) -> bytes:
        ...
```

Метод **`get_fix()`** делегирует работу четырем отдельным методам, каждый из которых извлекает одно из множества полей сообщения GPS. Также предоставим подклассы, подобные следующим:

```python
class GPGLL(Message):
    def latitude(self) -> bytes:
        return self[1]

    def lat_n_s(self) -> bytes:
        return self[2]

    def longitude(self) -> bytes:
        return self[3]

    def lon_e_w(self) -> bytes:
        return self[4]
```

Этот класс использует метод **`get_field()`** , унаследованный от класса **`Message`**, с целью получения байтов для четырех определенных полей в общей последовательности байтов. Поскольку метод **`get_field()`** оперирует ссылкой на объект **`Buffer`**, нет необходимости дублировать всю последовательность байтов сообщения. Вместо этого возвратимся к объекту **`Buffer`**, чтобы получить данные, избегая загромождения памяти.

Мы пока не рассматривали объект **`Point`**. Оставим его изучение читателям в качестве упражнений. Напомним только, что объект должен преобразовывать строки байтов в полезные числа с плавающей запятой.

Итак, разберем создание подходящего объекта **`Flyweight`** на основе типа сообщения в буфере:

```python
def message_factory(header: bytes) -> Optional[Message]:
    # TODO: Add functools.lru_cache to save storage and time
    if header == b"GPGGA":
        return GPGGA()
    elif header == b"GPGLL":
        return GPGLL()
    elif header == b"GPRMC":
        return GPRMC()
    else:
        return None
```

Для анализа распознанного сообщения надо создать экземпляр одного из наших классов **`Flyweight`**. Мы оставили комментарий, где предлагаем выполнить другое упражнение: используйте **`functools.lru_cache`**, чтобы избежать создания объектов **`Message`**, которые уже доступны.

Проанализируем, как работает **`message_factory()`** :

```python
>>> buffer = Buffer(
...     b"$GPGLL,3751.65,S,14507.36,E*77"
... )
>>> flyweight = message_factory(buffer[1 : 6])
>>> flyweight.__class__.__name__
'GPGLL'
>>> flyweight.from_buffer(buffer, 0)
<gps_messages.GPGLL object at ...>

>>> flyweight.get_fix()
Point(latitude=-37.86083333333333, longitude=145.12266666666667)
>>> print(flyweight.get_fix())
(37°51.6500S, 145°07.3600E)
```

Мы заполнили объект **`Buffer`** несколькими байтами. Имя сообщения представляет собой срез байтов в позициях буфера 1-6. Операция среза создает в данном случае небольшой объект **`bytes`**. Функция **`message_factory()`** найдет одно из определений класса **`Flyweight`** - класс **`GPGLL`**. Затем обращаемся к методу **`from_buffer()`** , чтобы **`Flyweight`** мог сканировать **`Buffer`**, начиная с нулевой позиции, ожидая найти байты , **`,`** чтобы определить для различных полей начальную и конечную точки.

Когда выполняется метод **`get_fix()`** , класс **`GPGLL`** извлекает четыре поля, преобразует значения в полезные градусы и возвращает объект **`Point`**, содержащий два значения с плавающей запятой.

Теперь при необходимости сопоставить это с другими устройствами можно отобразить значение, имеющее градусы и минуты, отделенные друг от друга. Формат вывода `37°51, 6500 ю.ш.` гораздо нагляднее, чем `37, 860833333333333`.



#### Сообщения из буфера
---

Проанализируем содержимое буфера, хранящего последовательность сообщений. Для этого поместим два сообщения **`GPGLL`** в последовательность байтов. В конце строки добавим явные пробельные символы, которые некоторые GРS-устройства включают в поток данных.

```python
>>> buffer_2 = Buffer(
...    b"$GPGGL,3751.65,S,14507.36,E*77\\r\\n"
...    b"$GPGLL,3723.2475,N,12158.3416,W,161229.489,A,A*41\\r\\n"
...)
>>> start = 0
>>> flyweight = message_factory(buffer_2[start+1 : start+6])
>>> p_1 = flyweight.from_buffer(buffer_2, start).get_fix()
>>> p_1
Point(latitude=-37.86083333333333, longtitude=145.12266666666667)
>>> print(p_1)
(37°51.6500S , 145°07.3600Е)
```

Мы нашли первое сообщение **`GPGLL`**, создали объект **`GPGLL`** и извлекли изменения из сообщения. Следующее сообщение начинается там, где заканчивается предыдущее. Это позволяет нам начать с новой позиции в буфере и исследовать другую часть последовательности байтов.

```python
>>> flyweight.end
30
>>> next_start = buffer_2.index(ord(b"$"), flyweight.end)
>>> next_start
32
>>> 
>>> p_2 = flyweight.from_buffer(buffer_2, next_start).get_fix()
>>> p_2
Point(latitude=37.387458333333335, longitude=-121.97236)
>>> print(p_2)
(37°23.2475N, 121°58.3416W)
```

Для создания нового объекта **`GPGLL`** мы использовали функцию **`message_factory()`** . Поскольку данные из сообщения не находятся в объекте, повторно используется предыдущий объект **`GPGLL`**. Можно убрать строку кода, содержащую **`flyweight =`**, и результаты будут такими же. При использовании метода **`from_buffer()`** мы находим новый набор символов **`,`** . А используя метод **`get_fix()`**, получаем значения из нового места в общей коллекции байтов.

Чтобы получить кэшируемый объект для использования **`message_factory()`** , создаем несколько коротких строк байтов. В данном случае новый объект **`Point`** будет содержать новые значения с плавающей запятой. Такой подход позволяет избежать размещения в памяти больших блоков байтов и заставить объекты обработки сообщений повторно использовать один и тот же экземпляр **`Buffer`**.

Как правило, обращение к **паттерну Легковес** упирается в наличие ссылок на исходные данные. Python избегает присутствия неявных копий объектов. Почти все создание объектов очевидно, используется имя класса или, возможно, синтаксис *comprehension*. Единственный случай, когда создание объекта неочевидно, - это получение фрагмента из последовательности, например, из буфера байтов: при применении **`bytes[start : end]`** создается копия байтов. Их слишком много, и IоТ-устройству не хватает доступной памяти. **Паттерн Легковес** позволяет избежать создания новых объектов, в частности нарезки строк и байтов для создания копий данных.

В нашем примере также присутствует слабая ссылка **`weakref`**. Для паттерна Легковес это не обязательно, но полезно для идентификации объектов, которые можно удалить из памяти. Хотя они часто используются вместе, на самом деле не похожи друг на друга.

Паттерн Легковес очень существенно сокращает потребление памяти. Но программные решения, оптимизирующие ЦП, память или дисковое пространство, обычно приводят к более сложному коду, чем их неоптимизированные аналоги. Поэтому при выборе между простотой сопровождения кода и оптимизацией важно найти сбалансированный подходящий вариант. Выбирая оптимизацию, старайтесь использовать такие паттерны, как Легковес, чтобы убедиться, что сложность, возникающая в результате оптимизации, ограничивается одним (хорошо документированным) разделом кода.

Прежде чем приступить к изучению паттерна Абстрактная фабрика, немного отвлечемся и рассмотрим еще один уникальный для Python метод оптимизации памяти. Это специальный атрибут **`__slots__`**.



#### Оптимизация памяти Паттерн Легковес с помощью атрибута **`__slots__`** Python
---

Если в одной программе имеется большое количество объектов Python, еще одним способом оптимизации памяти является использование атрибута **`__slоts__`**. Специальный атрибут **`__slots__`** позволяет явно указать, какие атрибуты экземпляра ожидаются от экземпляров объекта. В отличие от паттерна Легковес, при котором хранилище намеренно разделяется, дизайн слотов создает объекты с их собственными личными данными, но не обращается к встроенному словарю Python. Вместо этого напрямую сопоставляется имя атрибута с последовательностью значений, что позволяет не заниматься созданием довольно большой хеш-таблицы, которая является частью каждого объекта **`dict`**.

Вернемся к предыдущему примеру и опустим описание объекта **`Point`**, созданного как часть метода **`get_fix()`** каждого подкласса **`Message`**. Например, так:

```python
class Point:
    __slots__ = ("latitude", "longitude")

    def __init__(self, latitude: float, longitude: float) -> None:
        self.latitude = latitude
        self.longitude = longitude

    def __repr__(self) -> str:
        return f"Point(latitude={self.latitude}, longitude={self.longitude})"
```

Каждый экземпляр **`Point`** имеет ровно два атрибута **`latitude`** и **`longitude`**. Meтoд **`__init__()`** устанавливает эти значения и предоставляет полезные подсказки типов для таких инструментов, как `mуру`.

В остальном же описанный класс такой же, как класс, не содержащий атрибута **`__slots__`**. Наиболее заметным различием между ними является то, что здесь нельзя добавлять атрибуты. Вот так:

```python
>>> p2 = Point(latitude=49.274, longitude=-123.185)
>>> p2.extra_attribute = 42
Traceback (most recent call last):
...
AttributeError: 'Point' object has no attribute 'extra_attribute'

```

Дополнительная работа по определению имен слотов полезна только при создании приложением огромного количества таких объектов. Если же, как здесь, приложение построено на одном или очень небольшом числе экземпляров класса, экономия памяти за счет добавления **`__slots__`** незначительна.

В некоторых случаях использование **`NamedTuple`** может быть столь же эффективным для экономии памяти, как и применение атрибута **`__slоts__`** (это было описано в [[Структуры данных Python]]).

Итак, к настоящему моменту вы увидели, как управлять сложностью, используя **паттерн Фасад**, научились управлять памятью с помощью **паттерна Легковес**. У них обоих незначительное (или совсем отсутствует) внутреннее состояние. Далее рассмотрим, как можно создавать различные типы объектов с помощью фабрики.





## Паттерн Абстрактная фабрика
---

**Паттерн Абстрактная** ==фабрика считается подходящим вариантом для использования в ПО при наличии нескольких реализаций системы, зависящих от особенностей конфигурации или платформы.== Вызывающий код запрашивает объект у **Абстрактной фабрики**, не зная точно, какой класс объекта будет возвращен. Возвращаемая базовая реализация может зависеть от множества факторов, таких как текущая локаль, операционная система или локальная конфигурация.

Типичные примеры использования **паттерна Абстрактная фабрика** - это коды для независимых от операционной системы наборов инструментов, серверных частей баз данных и программ форматирования или калькуляторов для конкретных стран. Независимый от операционной системы инструментарий GUI применяет паттерн Абстрактная фабрика, возвращающий набор виджетов WinForm в Windows, виджеты Сосоа в Маc, виджеты GTK в Gnome и виджеты QT в КDЕ. Django предоставляет паттерн **Абстрактная фабрика**, возвращающий набор объектно-реляционных классов для взаимодействия с конкретной базой данных (MySQL, PostgreSQL, SQLite и пр.) для текущего сайта в зависимости от настройки конфигурации. Благодаря ему, если приложение необходимо развернуть в нескольких местах, в каждом из них могут использоваться разные серверные части базы данных, нужно изменить только одну переменную конфигурации. В разных странах действуют разные системы расчета налогов, промежуточных и итоговых сумм по розничным товарам. Абстрактная фабрика возвращает конкретный объект расчета налога.

Существует две основные особенности **Абстрактной фабрики**.

- Необходимо иметь несколько вариантов реализации. Каждая реализация для создания объектов имеет класс фабрики. Одна Абстрактная фабрика определяет интерфейс для реализации фабрик.
- Существует ряд тесно связанных объектов, и отношения реализуются с помощью нескольких методов каждой фабрики.

Рассмотрим следующую UМL-диаграмму(**рис. 12.6**).

>![[Рис. 12.6. Паттерн Абстрактная фабрика.jpg]]
>   **Рис. 12.6.** Паттерн Абстрактная фабрика

В данном случае наблюдается важная симметрия. Клиенту необходимы экземпляры класса **`А`** и **`В`**. Для клиента это определения абстрактного класса. Класс **`Factory`** - это абстрактный базовый класс, требующий реализации. Каждый из пакетов реализации, **`implementation_1`** и **`implementation_2`**, предоставляет конкретные подклассы **`Factory`**, они будут создавать необходимые для клиента экземпляры **`А`** и **`В`**.

Хороший пример **паттерна Абстрактная Фабрика**, на примере двух фабрик по производству машин и двигателей, для этих же машин:

```python
from abc import ABCMeta, abstractmethod
  

class IEngine(metaclass=ABCMeta):
    @abstractmethod
    def release_engine(self):
        pass
 

class JapaneseEngine(IEngine):
    def release_engine(self):
        print("Японский двигатель")
  

class RussianEngine(IEngine):
    def release_engine(self):
        print("Российский двигатель")
 

class ICar(metaclass=ABCMeta):
    @abstractmethod
    def release_car(self, engine: IEngine):
        pass
  

class JapaneseCar(ICar):
    def release_car(self, engine: IEngine):
        print("Собрали японский автомобиль ", end="")
        engine.release_engine()
   

class RussianCar(ICar):
    def release_car(self, engine: IEngine):
        print("Собрали российский автомобиль ", end="")
        engine.release_engine()
 

class IFactory(metaclass=ABCMeta):
    @abstractmethod
    def create_engine(self) -> IEngine:
        pass

    @abstractmethod
    def create_car(self) -> ICar:
        pass
 

class JapaneseFactory(IFactory):
    def create_engine(self) -> IEngine:
        return JapaneseEngine()  

    def create_car(self) -> ICar:
        return JapaneseCar() 
  

class RussianFactory(IFactory):
    def create_engine(self) -> IEngine:
        return RussianEngine()  

    def create_car(self) -> ICar:
        return RussianCar()  
  

if __name__ == "__main__":
    j_factory = JapaneseFactory()
    j_engine = j_factory.create_engine()
    j_car = j_factory.create_car() 

    j_car.release_car(j_engine) 

    r_factory = RussianFactory()
    r_engine = r_factory.create_engine()
    r_car = r_factory.create_car()
  
    r_car.release_car(r_engine)
```




### Пример реализации паттерна Абстрактная фабрика
---

UМL-диаграмму классов для **паттерна Абстрактная фабрика** сложно понять без конкретного примера, поэтому сначала рассмотрим такой пример. Имеется две карточные игры, покер и криббедж. Не беспокойтесь, вам не нужно знать все правила. Отметьте для себя только то, что некоторые аспекты у них схожи, но детали различаются. Схема действий ниже, на **рис. 12.7**.

>![[Рис. 12.7. Паттерн Абстрактная фабрика на примере таких карточных игр ,как покер и криббедж.jpg]]
>**Рис. 12.7.** Паттерн Абстрактная фабрика на примере таких карточных игр ,как покер и криббедж

Для класса **`Game`** требуются объекты **`Card`** и **`Hand`** (среди прочих). На диаграмме видно, что абстрактные объекты **`Card`** содержатся в абстрактной коллекции **`Hand`**. Каждая реализация предоставляет некоторые уникальные функции. По большей части **`PokerCard`** соответствует общему определению **`Card`**. Однако класс **`PokerHand`** расширяет абстрактный базовый класс **`Hand`** всеми уникальными правилами для определения ранга руки. Игроки в покер знают, что существует очень большое количество вариантов игры в покер. Здесь определена абстрактная рука, содержащая пять карт, так как это общее правило большинства игр.

Реализация криббеджа вводит ряд типов подклассов **`CribbageCard`**, каждый из которых имеет дополнительный атрибут - очки (баллы). Все карты **`CribbageFace`** соответствуют 10 очкам, в то время как для других типов классов **`CribbageCard`** количество очков соответствует рангу. Класс **`CribbageHand`** расширяет абстрактный базовый класс **`Hand`** уникальными правилами для нахождения всех выигрышных комбинаций в раздаче. Паттерн **Абстрактная фабрика** используется для создания объектов **`Card`** и **`Hand`**.

Рассмотрим основные определения **`Hand`** и **`Card`**. Мы не создавали эти официальные абстрактные базовые классы. Python не требует этого, и дополнительная сложность в данном случае не кажется полезной.

```python
from enum import Enum, auto
from typing import List, NamedTuple
  

class Suit(str, Enum):
    Clubs = "\N{BLACK CLUB SUIT}"
    Diamonds = "\N{BLACK DIAMOND SUIT}"
    Hearts = "\N{BLACK HEART SUIT}"
    Spades = "\N{BLACK SPADE SUIT}"
 

class Card(NamedTuple):
    rank: int
    suit: Suit 

    def __str__(self) -> str:
        return f"{self.rank}{self.suit}"


class Trick(int, Enum):
    pass 
  

class Hand(List[Card]):
    def __init__(self, *cards: Card) -> None:
        super().__init__(cards)

    def scoring(self) -> List[Trick]:
        pass
```

Данный пример отражает сущность «карты» и «карточной руки». Но их необходимо расширить с помощью подклассов, относящихся к каждой игре соответственно. Также понадобится Абстрактная фабрика, которая создает «карты> и «руки>:

```python
class CardGameFactory(abc.ABC):
    @abc.abstractmethod
    def make_card(self, rank: int, suit: Suit) -> "Card":
        ...

    @abc.abstractmethod
    def make_hand(self, *cards: Card) -> "Hand":
        ...
```

Здесь фабрика выступает настоящим абстрактным базовым классом. Каждая отдельная игра должна предоставлять расширения для уникальных игровых функций **`Hand`** и **`Card`**. Кроме того, в игре будет реализован класс **`CardGameFactory`**, который создает ожидаемые классы.

Мы можем определить карты для криббеджа следующим образом:

```python
class CribbageCard(Card):
    @property
    def points(self) -> int:
        return self.rank


class CribbageAce(Card):
    @property
    def points(self) -> int:
        return 1


class CribbageFace(Card):
    @property
    def points(self) -> int:
        return 10
```

Все приведенные в коде расширения базового класса **`Card`** имеют дополнительное свойство очков. В криббедже одним из приемов является любая комбинация карт на 15 очков. Большинство карт имеют очки, равные рангу, но валет, дама и король соответствуют 10 очкам. Это означает, что расширение **`Напd`** имеет довольно сложный метод подсчета очков, который пока опустим.

```python
class CribbageHand(Hand):
    starter: Card

    def upcard(self, starter: Card) -> "Hand":
        self.starter = starter
        return self

    def scoring(self) -> list[Trick]:
        """15's. Pairs. Runs. Right Jack."""

        def trick_iter(cards: list[CribbageCard]) -> Iterator[Trick]:
            for subset in powerset(cards):
                if sum(c.points for c in subset) == 15:
                    yield CribbageTrick.Fifteen
            for c1, c2 in itertools.combinations(cards, 2):
                if c1.rank == c2.rank:
                    yield CribbageTrick.Pair

        def run_length(sorted_cards: list[CribbageCard]) -> int:
            card_iter = iter(sorted_cards)
            base = next(card_iter)
            for offset, card in enumerate(card_iter, start=1):
                if base.rank + offset != card.rank:
                    break
            return offset + 1

        hand_plus_starter = cast(List[CribbageCard], self + [self.starter])
        hand_plus_starter.sort()
        tricks = list(trick_iter(hand_plus_starter))
        if run_length(hand_plus_starter) == 5:
            tricks += [CribbageTrick.Run_5]
        elif (
            run_length(hand_plus_starter) == 4 or run_length(hand_plus_starter[1:]) == 4
        ):
            tricks += [CribbageTrick.Run_4]
        elif (
            run_length(hand_plus_starter) == 3
            or run_length(hand_plus_starter[1:]) == 3
            or run_length(hand_plus_starter[2:]) == 3
        ):
            tricks += [CribbageTrick.Run_3]
        right_jack = any(c.rank == 11 and c.suit == self.starter.suit for c in self)
        if right_jack:
            tricks += [CribbageTrick.Right_Jack]
        return tricks
```

Чтобы обеспечить некоторое единообразие между играми, в криббедже мы определили выигрышные комбинации, в покере - ранг руки как подкласс **`Trick`**. В криббедже имеется довольно много приемов с набором очков. В покере имеется только один прием, представляющий руку в целом. В реализации приемов Абстрактная фабрика вряд ли может быть полезна.

Вычисление различных выигрышных комбинаций в криббедже - довольно сложная задача. Среди прочего криббедж включает в себя просмотр всех возможных комбинаций карт, которые в сумме дают 15 очков. Эти детали никак не связаны с паттерном проектирования Абстрактная фабрика.

В покере тузы имеют более высокий ранг, чем король:

```python
class PokerCard(Card):
    def __str__(self) -> str:
        if self.rank == 14:
            return f"A{self.suit}"
        return f"{self.rank}{self.suit}"


class PokerHand(Hand):
	def scoring(self) -> list[Trick]:
		"""Return a single 'Trick'"""
		... details omitted ...
		return [rank]
```

Расстановка различных рук в покере тоже представляет собой довольно сложную задачу, но она выходит за рамки сферы влияния Абстрактной фабрики. Рассмотрим следующий пример:

```python
class PokerFactory(CardGameFactory):
    def make_card(self, rank: int, suit: Suit) -> "Card":
        if rank == 1:
            # Aces above kings
            rank = 14
        return PokerCard(rank, suit)

    def make_hand(self, *cards: Card) -> "Hand":
        return PokerHand(*cards)
```

Обратите внимание, как метод **`make_card()`** отражает роль тузов в покере. Тот факт, что туз превосходит короля по рангу, отражает распространенную слож1юсть в ряде карточных игр, значит, в программе необходимо реализовать все роли тузов в различных играх.

Вот как это работает, например, в криббедже:

```python
>>> factory = CribbageFactory()
>>> cards = [
...     factory.make_card(6, Suit.Clubs),
...     factory.make_card(7, Suit.Diamonds),
...     factory.make_card(8, Suit.Hearts),
...     factory.make_card(10, Suit.Spades),
... ]
>>> starter = factory.make_card(5, Suit.Spades)
>>> hand = factory.make_hand(*cards)
>>> score = sorted(hand.upcard(starter).scoring())
>>> [t.name for t in score]
['Fifteen', 'Fifteen', 'Run_5']
```

Здесь создан экземпляр класса **`CribbageFactory`**, конкретная реализация абстрактного класса **`CardGameFactory`**. Применим фабрику для создания некоторых карт и для создания набора карт. В криббедже переворачивается дополнительная карта, называемая стартовой. В этом случае рука состоит из четырех карт в последовательности, и стартовая соответствует этой последовательности. Можно проанализировать карты в руке и увидеть, что есть три выигрышные комбинации: два способа набрать 15 очков плюс ран из пяти карт.

Уже по приведенным описаниям можно составить представление о том, что нужно будет сделать, когда придется поддерживать большее количество игр. Введение новых правил означает создание новых подклассов **`Hand`** и **`Card`**, расширение определения класса **Абстрактной фабрики**. Конечно, наследование дает возможность повторного использования, на что и стоит опираться при создании нескольких игр с похожими правилами.



#### Паттерн Абстрактная фабрика в Python
---

На предыдущем примере можно познакомиться с тем, как работает утиная типизация в Python. Действительно ли так нужен абстрактный базовый класс **`CardGameFactory`**? Он предоставляет структуру, используемую для проверки типов, но в остальном не имеет никаких полезных функций. Отказавшись от этого, мы можем работать с **Абстрактной фабрикой** как с тремя параллельными модулями. Это видно на **рис. 12.8.**

Обе описанные игры реализуют класс **`CardGameFactory`**, определяющий уникальные особенности игры. Поскольку они находятся в отдельных модулях, для каждого класса используется одно и то же имя. Это позволяет создать приложение **`Cribbage`**, применяющее **`from cribbage import CardGameFactory`**. В данном случае можно сэкономить на расходах, связанных с общим абстрактным базовым классом, что позволит создавать расширения в виде отдельных модулей, разделяющих некоторые общие определения базового класса. Каждая альтернативная реализация обеспечивает общий интерфейс уровня модуля: она предоставляет стандартное имя класса, которое затем обрабатывает оставшиеся детали создания уникальных объектов.

>![[Рис. 12.8. Абстрактная фабрика без абстрактных базовых классов.jpg]]
>**Рис. 12.8.** Абстрактная фабрика без абстрактных базовых классов

В этом случае **Абстрактная фабрика** становится концепцией, а не фактическим абстрактным базовым классом. Необходимо для всех классов, которые претендуют на роль реализаций **`CardGameFactory`**, составить адекватную документацию в строках документации. Уточним намерения, определив протокол с помощью **`typing.Protocol`**. Например, так:

```python
class CardGameFactoryProtocol(Protocol):
	def make_card(self, rank: int, suit: Suit) -> "Card":
		...

	def make_hand(self, *cards: Card) -> "Hand":
		...
```

Приведенное определение позволяет mуру подтвердить, что класс **`Game`** может ссылаться либо на **`poker.CardGameFactory`**, либо на **`cribbage.CardGameFactory`**, поскольку оба реализуют один и тот же протокол. В отличие от определения абстрактного базового класса это не будет проверкой во время выполнения. Определение протокола используется mуру только для подтверждения того, что код способен пройти набор модульных тестов.

**Паттерн Абстрактная фабрика** помогает определять родственные объекты, например игральные карты и руки. Одна фабрика способна производить два отдельных класса объектов, тесно связанных друг с другом. В некоторых случаях отношения не являются простой коллекцией и элементом. Иногда в дополнение к элементам имеются подколлекции. Такие типы структур можно обрабатывать с помощью паттерна проектирования Компоновщик.





## Паттерн Компоновщик
---

==**Паттерн Компоновщик** позволяет создавать сложные древовидные структуры из простых компонентов, часто называемых **узлами**.== **Узел с дочерними элементами будет вести себя как контейнер**, *узел без потомков будет вести себя как один объект*. Составной объект - это объект-контейнер, содержимое которого может быть другим составным объектом.

Как правило, каждый узел в составном объекте должен быть либо конечным узлом (который не может содержать другие объекты), либо составным. Суть в том, что и составные, и конечные узлы могут иметь один и тот же интерфейс. Рассмотрим UМL-диаграмму на **рис. 12.9**, где это показано как метод **`some_action()`**.

>![[Рис. 12.9. Паттерн Компоновщик.jpg]]
>**Рис. 12.9.** Паттерн Компоновщик

Этот простой паттерн позволяет создавать сложные расположения элементов, каждый из которых соответствует интерфейсу объекта-компонента. Следующая диаграмма, на **рис. 12.10**, изображает конкретный пример такой сложной структуры.

>![[Рис. 12.10. Усложненный вариант паттерна Компоновщик.jpg]]
>**Рис. 12.10.** Усложненный вариант паттерна Компоновщик

**Паттерн Компоновщик** применяется в языковой обработке. Как естественные, так и искусственные языки (например, Python) обычно следуют правилам, которые являются иерархическими и хорошо согласуются с подобным паттерном проектирования. Языки разметки, например [[HTML]], [[XML]], [[RST]] и [[Markdown]], как правило, отражают некоторые общие составные концепции, а именно списки списков и заголовки с подзаголовками.

Язык программирования включает в себя рекурсивные древовидные структуры. В стандартной библиотеке Python содержится модуль **`ast`**, предоставляющий классы, которые определяют структуру кода Python. Этот модуль можно использовать для изучения кода Pythoп, не  прибегая к регулярным выражениям или другой сложной обработке текста.

Хороший пример паттерна Компоновщик, на примере меню программы:

```python
import abc

  
class Item(metaclass=abc.ABCMeta):
    def __init__(self, name: str):
        self._item_name: str = name
        self._owner_name: str = None 

    def set_owner(self, o: str):
        self._owner_name = o  

    @abc.abstractmethod
    def add(self, sub_item: "Item"):
        pass
  
    @abc.abstractmethod
    def remove(self, sub_time: "Item"):
        pass

    @abc.abstractmethod
    def display(self):
        pass
  

class ClickableItem(Item):
    def __init__(self, name: str):
        super().__init__(name)

    def add(self, sub_item: Item):
        raise Exception("Кликабельному элементу нельзя добавить                                   подэлемент")

    def remove(self, sub_item: Item):
        raise Exception("У кликабельного элемента не могут быть                                   подэлементы")

    def display(self):
        print(self._owner_name + self._item_name)


class DropDownItem(Item):
    def __init__(self, name: str):
        super().__init__(name)
        self.__children = []

    def add(self, sub_item: Item):
        sub_item.set_owner(self._item_name)
        self.__children.append(sub_item) 

    def remove(self, sub_item: Item):
        self.__children.remove(sub_item)  

    def display(self):
        for item in self.__children:
            if self._owner_name is not None:
                print(self._owner_name, end="")
            item.display()
 

if __name__ == "__main__":
    file: Item = DropDownItem("Файл->")
    create: Item = DropDownItem("Создать->")
    open_: Item = DropDownItem("Открыть->")
    exit_: Item = ClickableItem("Выход")

    file.add(create)
    file.add(open_)
    file.add(exit_)
  
    project: Item = ClickableItem("Проект...")
    repository: Item = ClickableItem("Репозитории...")

    create.add(project)
    create.add(repository)
 
    solution: Item = ClickableItem("Решение...")
    folder = ClickableItem("Папка...") 

    open_.add(solution)
    open_.add(folder)

    file.display()
    
    print()

    file.remove(create) 
    file.display()
```
```output
Файл->Создать->Проект...
Файл->Создать->Репозитории...
Файл->Открыть->Решение...
Файл->Открыть->Папка...
Файл->Выход  

Файл->Открыть->Решение...
Файл->Открыть->Папка...
Файл->Выход
```



#### Пример реализации паттерна Компоновщик
---

**Паттерн Компоновщик** ==необходимо применять к древовидным структурам, таким как, скажем, файлы и папки файловой системы.== Независимо от того, является ли узел в дереве обычным файлом данных или папкой, он по-прежнему подвергается таким операциям, как перемещение, копирование или удаление узла. Мы можем создать компонентный интерфейс, поддерживающий эти операции, а затем использовать составной объект для представления папок и конечные узлы - для представления файлов данных.

Конечно, для неявного предоставления интерфейса в Python мы снова можем воспользоваться *[[Утиная типизация|утиной типизацией]]*, для этого необходимо создать только два класса. Сначала определим эти интерфейсы в следующем коде:

```python
from typing import Optional
 

class Folder:
    def __init__(self, name: str, children: Optional[dict[str, "Node"]]        = None) -> None:
        self.name = name
        self.children = children or {}
        self.parent = Optional["Folder"] = None 

    def __repr__(self) -> str:
        return f"Folder({self.name!r}, {self.children!r})"  

    def add_child(self, node: "Node") -> "Node":
        node.parent = self
        return self.children.setdefault(node.name, node)

    def move(self, new_folder: "Folder") -> None:
        pass

    def copy(self, new_folder: "Folder") -> None:
        pass  

    def remove(self) -> None:
        pass
  

class File:
    def __init__(self, name: str) -> None:
        self.name = name
        self.parent: Optional[Folder] = None

    def __repr__(self) -> str:
        return f"File({self.name!r})"

    def move(self, new_path):
        pass
  
    def copy(self, new_path):
        pass

    def remove(self):
        pass
```

Для каждой папки, составного объекта, мы поддерживаем словарь дочерних элементов. Дочерние элементы могут быть смесью экземпляров **`Folder`** и **`File`**. Во многих случаях составных реализаций списка этого достаточно, но тогда для поиска дочерних элементов по имени будет полезен словарь.

Можно выделить несколько закономерностей.

- Перемещение папки приведет к переносу всех дочерних элементов. Перемещение файла будет точно таким же кодом, так как здесь не нужно учитывать дочерние элементы.
- Чтобы сделать копию, необходимо скопировать все дочерние элементы. Поскольку за пределами узлов **`File`** составного объекта данных нет, больше ничего делать не нужно.
- При выполнении удаления мы должны следовать паттерну [[Linux]], очищая дочерние элементы, прежде чем пытаться удалить родительские.

Такой дизайн позволяет создавать подклассы с различными реализациями операций. Каждая реализация подкласса выполняет внешние запросы или, возможно, запросы ОС на локальном компьютере.

Чтобы воспользоваться преимуществами подобных операций, извлечем общие методы в родительский класс. Реорганизуем его и создадим базовый класс **`Node`** со следующим кодом:

```python
class Node(abc.ABC):
    def __init__(
        self,
        name: str,
    ) -> None:
        self.name = name
        self.parent: Optional["Folder"] = None

    def move(self, new_place: "Folder") -> None:
        previous = self.parent
        new_place.add_child(self)
        if previous:
            del previous.children[self.name]

    @abc.abstractmethod
    def copy(self, new_folder: "Folder") -> None:
        ...

    @abc.abstractmethod
    def remove(self) -> None:
        ...
```

Абстрактный класс **`Node`** определяет, что каждый узел имеет строку со ссылкой на родителя. Сохранение родительской информации позволяет анализировать дерево выше, ближе к корневому узлу. То есть становится возможным перемещать и удалять файлы, внося изменения в родительскую коллекцию дочерних файлов.

В классе **`Node`** мы создали метод **`move()`**. Он перемещает в новое место объекты **`Folder`** или **`File`**. Далее следует удаление объекта из его предыдущего местоположения. Для метода **`move()`** целью должна быть существующая папка, иначе мы получим ошибку, поскольку экземпляр **`File`** не имеет метода **`add_child()`**. Как и во многих примерах из технической литературы, обработка ошибок, к сожалению, отсутствует. Это сделано для того, чтобы сосредоточить все внимание на рассматриваемых принципах. Обычной практикой является обработка исключения **`AttributeError`** путем создания нового исключения **`TypeError`**.

Теперь мы можем расширить этот класс, чтобы предоставить уникальные функции папки, содержащей дочерние элементы, и файла, который является конечным узлом дерева и не имеет дочерних элементов:

```python
class Folder(Node):
    def __init__(self, name: str, children: Optional[dict[str, "Node"]] = None) -> None:

        super().__init__(name)
        self.children = children or {}

    def __repr__(self) -> str:
        return f"Folder({self.name!r}, {self.children!r})"

    def add_child(self, node: "Node") -> "Node":
        node.parent = self
        return self.children.setdefault(node.name, node)

    def copy(self, new_folder: "Folder") -> None:
        target = cast(Folder, new_folder.add_child(Folder(self.name)))
        for c in self.children:
            self.children[c].copy(target)

    def remove(self) -> None:
        names = list(self.children)
        for c in names:
            self.children[c].remove()
        if self.parent:
            del self.parent.children[self.name]


class File(Node):
    def __repr__(self) -> str:
        return f"File({self.name!r})"

    def copy(self, new_folder: "Folder") -> None:
        new_folder.add_child(File(self.name))

    def remove(self) -> None:
        if self.parent:
            del self.parent.children[self.name]
```

При добавлении дочернего элемента в **`Folder`** происходит следующее. Во-первых, мы указываем ему, кто его новый родитель. Это гарантирует, что у каждого **`Node`** (кроме экземпляра **`Folder`**) будет родитель. Во-вторых, новый **`Node`** помещается в коллекцию дочерних элементов папки, если он еще не существует.

При копировании объектов **`Folder`** нам необходимо убедиться, что при этом копируются все его дочерние объекты. Ведь каждый дочерний элемент, в свою очередь, может быть еще одним объектом **`Folder`**, содержащим дочерние элементы. Такой рекурсивный обход элементов подразумевает делегирование операции **`сору()`** каждой подпапке внутри экземпляра **`Folder`**. С другой стороны, реализация объекта **`File`** гораздо проще.

Рекурсивный дизайн для удаления аналогичен рекурсивному копированию. Экземпляр **`Folder`** должен сначала удалить все дочерние элементы. Это включает удаление экземпляров подпапок. С другой стороны, объект **`File`** можно удалить напрямую.

Итак, пока все достаточно легко. Проанализируем, правильно ли работает описанная составная файловая иерархия, обратимся для этого к следующему фрагменту кода:

```python
>>> tree = Folder("Tree")
>>> tree.add_child(Folder("src"))
Folder('src', {})
>>> tree.children["src"].add_child(File("ex1.py"))
File('ex1.py')
>>> tree.add_child(Folder("src"))
Folder('src', {'ex1.py': File('ex1.py')})
>>> tree.children["src"].add_child(File("test1.py"))
File('test1.py')
>>> tree
Folder('Tree', {'src': Folder('src', {'ex1.py': File('ex1.py'), 'test1.py': File('test1.py')})})
```

Древовидная структура **`tree`** оказалась сложной для понимания. Рассмотрим вариант отображения, который поможет разобраться.

```python
>>> tree.tree(outer=True)
 +-- Tree
      +-- src
           +-- ex1.py
           +-- test1.py
```

Здесь не анализируется алгоритм создания этой вложенной визуализации. Дополнить определения классов не так уж сложно. Видно, что родительская папка **`Tree`** имеет подпапку **`src`** с двумя файлами внутри. Операцию файловой системы опишем следующим образом:

```python
>>> test1 = tree.children["src"].children["test1.py"]
>>> test1
File('test1.py')
>>> tree.add_child(Folder("tests"))
Folder('tests', {})
>>> test1.move(tree.children["tests"])
>>> tree
Folder('Tree', {'src': Folder('src', {'ex1.py': File('ex1.py')}), 'tests': Folder('tests', {'test1.py': File('test1.py')})})
```

Мы создали новую папку **`tests`** и переместили файл. Рассмотрим еще один вид получившихся составных объектов:

```python
>>> tree.tree(outer=True)
 +-- Tree
      +-- src
           +-- ex1.py
      +-- tests
           +-- test1.py
```

**Паттерн Компоновщик** ==чрезвычайно полезен при работе с множеством древовидных структур, включая иерархии виджетов== [[GUI]]==, иерархии файлов, наборы деревьев,== [[графы базы данных|Графы СУБД]] и [[HTML]] [[DOM]]. Иногда, при создании неглубоких деревьев, можно обойтись списком списков или словарем словарей, и тогда не нужно реализовывать пользовательские компоненты, конечные и составные классы. Действительно, документы [[JSON]], [[YAML]] и [[TOML]], как правило, следуют шаблону dict-of-dict. Для таких ситуаций часто применяются абстрактные базовые классы, но это не является обязательным. [[Утиная типизация]] Python упрощает добавление других объектов в составную иерархию, если они имеют правильный интерфейс.

Одним из важных аспектов **паттерна Компоновщик** является общий интерфейс для различных подтипов узла. В примере нам понадобилось создать два варианта реализации для классов **`Folder`** и **`File`**. В ряде случаев эти варианты операций очень схожи, и тогда может быть полезен **паттерн Шаблонный метод**.





## Паттерн Шаблонный метод
---

**Паттерн Шаблонный** метод (иногда называемый просто шаблонным методом) полезен для удаления повторяющегося кода. Он поддерживает принцип •*Не повторяйся*•, который уже обсуждался в [[КОГДА БЕЗ ООП НЕ ОБОЙТИСЬ]]. Паттерн также оказывается нужен в ситуациях, когда необходимо решить несколько разных задач, осуществляющих общие действия. Общие действия реализованы в базовом классе, а отдельные этапы переопределяются в подклассах для обеспечения поведения, затребованного пользователем. В некотором смысле это похоже на паттерн Стратегия, за исключением того, что аналогичные друг другу разделы алгоритмов совместно используются с помощью базового класса. Рассмотрим, как это выглядит на UМL-диаграмме (**рис. 12.11**).