---
date of creation: 2024-06-28T17:39:00
tags:
  - Python
  - OOP/Python
  - Patterns
  - Patterns/Python
  - Python/Patterns
  - Developing/Python
Read status: false
aliases:
  - новые паттерны проектирования
---
---
# Новые паттерны проектирования
2024-06-28




В этой главе вы познакомитесь еще с несколькими паттернами проектирования. Мы вместе рассмотрим примеры их использования и реализацию на Python. Вы освоите следующие темы.

- **[[#Паттерн Адаптер|Паттерн Адаптер]]** ==(Adapter)==
- **[[#Паттерн Фасад|Паттерн Фасад]]** ==(Façade)==
- **[[#Паттерн Легковес|Ленивая инициализация и паттерн Легковес]]** ==(Flyweight)==
- **Паттерн Абстрактная фабрика** ==(Abstract Factory)==
- **Паттерн Компоновщик** ==(Composite)==
- **Паттерн Шаблонный метод** ==(Template)==

Начнем свое изучение с паттерна Адаптер. По сути, он типичный переходник для разных интерфейсов или данных.




## Паттерн Адаптер
---

В отличие от большинства рассмотренных в предыдущей главе паттернов **паттерн Адаптер** предназначен для взаимодействия с уже существующим кодом. Мы не стали разрабатывать совершенно новый набор объектов, реализующих **паттерн Адаптер**. Адаптеры используются для обеспечения совместной работы двух объектов, даже если их интерфейсы несовместимы. Как и адаптеры дисплея, позволяющие подключать зарядный кабель Micro USB к телефону USB-C, адаптер находится между двумя разными интерфейсами, леrко переводя их между собой. ==Единственной целью адаптера является выполнение данного преобразования. Ведь адаптация может повлечь за собой множество задач, таких как преобразование арrументов в другой формат, изменение порядка аргументов, вызов метода с другим именем или предоставление аргументов по умолчанию.==

По структуре **паттерн Адаптер** похож на упрощенный вариант **[[Общие Паттерны Проектирования#Паттерн Декоратор|паттерна Декоратор]]**. Но декораторы обычно предоставляют тот же интерфейс, который они заменяют, тогда как адаптеры служат мостом между двумя разными интерфейсами, что представлено на UМL-диаграмме (рис. 12.1).

>![[Рис. 12.1. Паттерн Адаптер.jpg]]
>           **Рис. 12.1.** Паттерн Адаптер

В данном случае клиентский объект, экземпляр **`Client`**, чтобы сделать что-то полезное, должен работать совместно с другим классом. Для этого используется **`load_data()`** как конкретный пример метода, в котором требуется адаптер. Уже имеется класс **`Implementation`**, который делает все, что необходимо (и чтобы избежать дублирования, мы не будем его переписывать!). Однако существует проблема: класс требует сложной последовательности операций с использованием методов **`read_raw_data()`** , **`parse_raw_d ata()`** и  **`createuseful_object()`**. Класс Adapter реализует простой в использовании интерфейс **`load_data()`** , который скрывает сложность существующего интерфейса, предоставляемого классом **`Implementation`**.

Преимущество такой схемы заключается в том, что весь код, отображающий сопоставляемый ожидаемый и фактический интерфейсы, находится в одном месте - в классе Adapter. В качестве альтернативы можно было бы поместить код в клиента, дополняя его не относящимися к делу деталями реализации. В такой редакции кода при наличии нескольких типов клиентов пришлось бы в нескольких местах выполнять сложную обработку **`loaddata()`** всякий раз, когда какому-то из этих клиентов потребовался бы доступ к классу **`Implementation`**.

Хороший пример **паттерна Адаптер**(реализация на уровне объектов), на примере конвертера весов с русских на британских:

```python
import abc
from abc import ABCMeta
 

class IScale(metaclass=ABCMeta):
    @abc.abstractmethod
    def get_weight(self):
        pass
 

class RussianScales(IScale):
    def __init__(self, cw: float):
        self.__current_weight = cw  

    def get_weight(self) -> float:
        return self.__current_weight
   

class BritishScales:
    def __init__(self, cw: float):
        self.__current_weight = cw 

    def get_weight(self) -> float:
        return self.__current_weight
 

class AdapterForBritishScales(IScale):
    def __init__(self, british_scales: BritishScales):
        self.__british_scales = british_scales

    def get_weight(self) -> float:
        return self.__british_scales.get_weight() * .453  
        

if __name__ == "__main__":
    kg: float = 55.  # кг
    lb: float = 55.  # фунты  

    rScales = RussianScales(kg)
    bScales = AdapterForBritishScales(BritishScales(lb))
  
    print(rScales.get_weight())  # кг
    print(bScales.get_weight())  # кг
```


### Пример реализации паттерна Адаптер
---

Представьте, что уже существует класс, который принимает временные метки строк в формате ННММSS и вычисляет полезные интервалы с плавающей запятой:

```python
class TimeSince:
    """Expects time as six digits, no punctuation."""

    def parse_time(self, time: str) -> tuple[float, float, float]:
        return (
            float(time[0:2]),
            float(time[2:4]),
            float(time[4:]),
        )

    def __init__(self, starting_time: str) -> None:
        self.hr, self.min, self.sec = self.parse_time(starting_time)
        self.start_seconds = ((self.hr * 60) + self.min) * 60 +                                      self.sec

    def interval(self, log_time: str) -> float:
        log_hr, log_min, log_sec = self.parse_time(log_time)
        log_seconds = ((log_hr * 60) + log_min) * 60 + log_sec
        return log_seconds - self.start_seconds

```

Этот класс выполняет преобразование строки во временной интервал и уже присутствует в приложении, имеет модульные тесты и прекрасно работает. Если вы забудете импортировать аннотации **`from __future__`**, при попытке использовать **`tuple[float, float, float]`** в качестве подсказки типа получите сообщение об ошибке. Не забудьте включить модуль аннотаций в качестве первой строки кода. Например, так:

```python
>>> ts = TimeSince('000123')  # logstarted at 00:01:23
>>> ts.interval('020304')
7301.0
>>> ts.interval('030405')
10962.0
```

Работать с таким неформатированным временем немного неудобно, но ряд устройств Internet of Тhings (IoT) предоставляют именно такие временные строки, отделенные от остальной части даты. Посмотрите, например, на сообщения формата NMEA 0183 от устройства GPS, там даты и время представляют собой неформатированные строки цифр.

У нас имеется старый лог-файл с одного из этих устройств, очевидно созданный несколько лет назад. Необходимо проанализировать этот лог-файл на наличие последовательности сообщений, которые появляются после каждого сообщения `ERROR`, и, кроме того, получить точное время относительно сообщения `ERROR` в качестве анализа основной причины проблемы.

Например:
```python
>>> data = [
...     ("000123", "INFO", "Gila Flats 1959-08-20"),
...     ("000142", "INFO", "test block 15"),
...     ("004201", "ERROR", "intrinsic field chamber door locked"),
...     ("004210.11", "INFO", "generator power active"),
...     ("004232.33", "WARNING", "extra mass detected")
... ]
```

Вычислить временной интервал между сообщением **`ERROR`** и **`WARNING`** сложно, но возможно. У многих программистов достаточно навыков, чтобы производить подобные вычисления. Но, может, лучше проанализировать лог-файл, содержащий относительное время, а не абсолютное? Ниже представлена схема форматирования лог-файла, которую необходимо использовать. Однако здесь вырисовывается проблема, которую мы отметили символами **`???`** :

```python
class LogProcessor:
    def __init__(self, log_entries: list[tuple[str, str, str]]) ->           None:
        self.log_entries = log_entries

    def report(self) -> None:
        first_time, first_sev, first_msg = self.log_entries[0]
        for log_time, severety, message in self.log_entries:
            if severety == "ERROR":
                first_time = log_time
            interval = ??? Need to compute an interval ???
            print(f"{interval:8.2f} | {severety:7s} {message}")
            
```

Класс **`LogProcessor`** кажется правильным. Он перебирает записи лог-файла, сбрасывая переменную **`first_time`** при каждом появлении строки **`ERROR`**. Это гарантирует, что лог-файл отображает позицию ошибки, избавляя нас от необходимости выполнять множество математических вычислений.

Но взгляните повнимательнее: возникает необходимость повторно использовать класс **`TimeSince`**. Он не просто вычисляет интервал между двумя значениями. Существует несколько вариантов реализации данного сценария.

- Для работы со строками времени можно было бы переписать класс **`TimeSince`**. Но тогда возникает риск нарушить код в нашем приложении. Иногда это называется радиусом разбрызгивания - сколько вещей в окружении намокнет, если бросить камень в бассейн? Принцип открытого/закрытого проектирования (один из принципов SOLID, дополнительную информацию можно получить на сайте https://subscription.packtpub.com/book/application_development/9781788835831/4) предполагает, что класс должен быть доступен для расширения, но недоступен для подобных модификаций. Если класс был загружен из `PyPI`, мы можем не изменять его внутреннюю структуру, так как тогда станет невозможно использовать последующие релизные версии. Необходим альтернативный вариант работы внутри другого класса.

- Мы могли бы использовать класс как есть и всякий раз при необходимости вычислить интервалы между сообщением **`ERROR`** и последующими строками лог-файла создавать новый объект **`TimeSince`**. Это выливается в создание большого количества объектов. Представьте, что имеется несколько приложений для анализа лог-файлов, каждое из которых рассматривает различные аспекты сообщений этих файлов. Внесение изменений означает необходимость вернуться и исправить все места, где были созданы объекты **`TimeSince`**. Если в классе **`LogProcessor`** слишком много деталей, связанных с работой класса **`TimeSince`**, нарушается принцип единой ответственности. А также вспомним еще один принцип - Не повторяйся (DRY), который применим и в этом случае.

- Вместо этого можно добавить адаптер, который связывает потребности класса **`LogProcessor`** с методами, доступными в классе **`TimeSince`**.

Решение с **паттерном Адаптер** подразумевает наличие класса с интерфейсом, необходимым для класса **`LogProcessor`**. Он также использует интерфейс, предлагаемый классом **`ТimeSince`**. То есть он представляет собой развитие обоих классов, оставляя их закрытыми для модификации, но доступными для расширения. Например, так, как в следующем фрагменте кода:

```python
from typing import Optional


class IntervalAdapter:
    def __init__(self) -> None:
        self.ts: Optional[TimeSince] = None

    def time_offset(self, start: str, now: str) -> float:
        if self.ts is None:
            self.ts = TimeSince(start)
        else:
            h_m_s = self.ts.parse_time(start)
            if h_m_s != (self.ts.hr, self.ts.min, self.ts.sec):
                self.ts = TimeSince(start)
        return self.ts.interval(now)
```

Этот адаптер создает объект **`ТimeSince`**, когда это необходимо. Если **`TimeSince`** отсутствует, адаптер должен его создать. Если объект **`TimeSince`** уже существует и использует уже установленное начальное время, то экземпляр **`TimeSince`** можно использовать повторно. Однако, как только класс **`LogProcessor`** сместил фокус на новое сообщение об ошибке, возникает необходимость создать новый экземпляр **`TimeSince`**.

Рассмотрим пример окончательного проекта класса **`LogProcessor`** с использованием класса **`IntervalAdapter`**:

```python
class LogProcessor:
    def __init__(self, log_entries: list[tuple[str, str, str]]) -> None:
        self.log_entries = log_entries
        self.time_convert = IntervalAdapter()

    def report(self) -> None:
        first_time, first_sev, first_msg = self.log_entries[0]
        for log_time, severity, message in self.log_entries:
            if severity == "ERROR":
                first_time = log_time
            interval = self.time_convert.time_offset(first_time,                                                         log_time)
            print(f"{interval:8.2f} | {severity:7s} {message}")
```

Здесь в процессе инициализации был создан экземпляр **`IntervalAdapter()`** . Затем этот объект применялся для вычисления каждой временной позиции, а существующий класс **`TimeSince`** повторно использовался без каких-либо модификаций исходного класса, причем класс **`LogProcessor`** не заботился о деталях работы экземпляра **`TimeSince`**.

Также в данном случае мы можем использовать наследование. Можно расширить экземпляр **`ТimeSince`**, чтобы добавить к нему необходимый метод. Альтернатива наследования - неплохая идея. Обратите внимание: похоже, это как раз та ситуация, когда нет единственного правильного ответа. В некоторых случаях имеет смысл обдумать реализацию с наследованием и сравнить ее с реализацией адаптера, проанализировав, какая из них проще.

Для добавления метода к существующему классу вместо наследования мы можем использовать метод *monkey patching*. Python позволяет добавлять новый метод, который предоставляет адаптированный интерфейс, необходимый для вызова кода. То есть внутри оператора **`class`** легко найти определение класса - но это будет не весь класс, используемый во время выполнения. И другие разработчики в случае необходимости будут вынуждены искать в коде место внедрения в класс новой функции. То есть вне модульного тестирования метод *monkey patching* не является хорошей идеей.

Как правило, в качестве адаптера можно использовать функцию. Хотя такой подход явно не соответствует классическому дизайну паттерна проектирования класса Адаптер, иногда этим несоответствием пренебрегают: класс с методом **`__call__()`** является вызываемым объектом, неотличимым от функции. Функция тоже может быть отличным адаптером. Python не требует, чтобы все было определено в классах.

Различие между **паттернами Адаптер и Декоратор** незначительное, но важное. **Паттерн Адаптер**, как правило, расширяет, модифицирует или комбинирует более одного метода из адаптируемых классов. Паттерн Декоратор обычно избегает значительных изменений, сохраняя интерфейс исходного метода, постепенно добавляя функции. Как уже указывалось в [[Общие Паттерны Проектирования]] , паттерн Декоратор следует рассматривать как особый вид адаптера.

Использование класса Адаптер аналогично использованию класса **Стратегия**. Идея состоит в том, что после внесения изменений может понадобиться другой адаптер. Принципиальное отличие заключается в том, что стратегии часто выбираются во время выполнения, а адаптеры выбираются во время разработки и изменяются очень редко.

Следующий паттерн, который мы рассмотрим, похож на Адаптер, так как он также заключает функциональность в новый контейнер. Разница состоит в сложности того, что именно обертывается. **Паттерн Фасад**, как правило, содержит значительно более сложные конструкции.





## Паттерн Фасад
---

**Паттерн Фасад** предназначен для предоставления простого интерфейса сложной системе компонентов. Это структурный паттерн, который предоставляет простой интерфейс к сложной системе объектов, библиотеке или фреймворку. Паттерн Фасад дает возможность определить новый класс, который 'инкапсулирует типичное использование системы, тем самым позволяя избежать дизайна, раскрывающего слишком много деталей реализации, обычно не выраженных явно при взаимодействии объектов. Каждый раз, когда нужен доступ к общей или типичной функциональности, используется упрощенный интерфейс одного объекта. Если другой части проекта требуется доступ к более полной функциональности, код по-прежнему может напрямую взаимодействовать с компонентами и отдельными методами.

UML-диаграмма для **паттерна Фасад** зависит от подсистемы, изображенной в виде пакета **`Big System`**, но в облачном виде диаграмма выглядит так, как это показано на **рис. 12.2.**

>![[Рис. 12.2. Паттерн Фасад.jpg]]
> **Рис. 12.2**. Паттерн Фасад

Паттерн Фасад во многом похож на **[[#Паттерн Адаптер|паттерн Адаптер]]**. Основное отличие заключается в том, что паттерн Фасад абстрагирует более простой интерфейс от сложного, в то время как Адаптер только сопоставляет один существующий интерфейс с другим.

Хороший пример **паттерна Фасад**, на примере интернет-магазина:

```python
class ProviderCommunication:
    def receive(self):
        print("Получение продукции от производителя")

    def payment(self):
        print("Оплата поставщику с удержанием коммисии за продажу                  продукции")
 

class Site:
    def placement(self):
        print("Размещение на сайте")

    def delete(self):
        print("Удаление с сайта")
 

class Database:
    def insert(self):
        print("Запись в базу данных")

    def delete(self):
        print("Удаление из базы данных")
  

class MarketPlace:
    def __init__(self):
        self._provider_cummunication = ProviderCommunication()
        self._site = Site()
        self._database = Database() 

    def product_receive(self):
        self._provider_cummunication.receive()
        self._site.placement()
        self._database.insert() 

    def product_release(self):
        self._provider_cummunication.payment()
        self._site.delete()
        self._database.delete()
  

if __name__ == "__main__":
    market_place = MarketPlace()
    market_place.product_receive()
    
    print()

    market_place.product_release()
```
```powershell
Получение продукции от производителя
Размещение на сайте
Запись в базу данных 

Оплата поставщику с удержанием коммисии за продажу продукции
Удаление с сайта
Удаление из базы данных
```




### Пример реализации паттерна Фасад
---

Все изображения для этой книги были сделаны с помощью PlantUML (https://plantuml.com). Каждая диаграмма начинается с текстового файла и должна быть преобразована в формат PNG. Это двухэтапный процесс, и ниже в коде будет показано, как **паттерн Фасад** применяется для объединения двух процессов.

Первый этап - обход дерева каталогов с поиском всех файлов UML, то есть с расширением `.uml`. Анализируется и содержимое файла на предмет наличия в нем названия диаграмм.

```python
import re
from pathlib import Path
from typing import Iterator, Tuple


class FindUML:
    def __init__(self, base: Path) -> None:
        self.base = base
        self.start_pattern = re.compile(r"@startmul *(.*)")

    def uml_file_iter(self) -> Iterator[tuple[Path, Path]]:
        for source in self.base.glob("**/*.uml"):
            if any(n.startswith(".") for n in source.parts):
                continue
            body = source.read_text()
            for output_name in self.start_pattern.findall(body):
                if output_name:
                    target = source.parent / output_name
                else:
                    target = source.with_suffix(".png")
                yield (
                    source.relative_to(self.base),
                    target.relative_to(self.base)
                )
```

Для класса **`FindUML`** необходим базовый каталог. Метод **`uml_file_iter()`** проходит по всему дереву каталогов, используя метод **`Path.glob()`** . При поиске пропускаются все каталоги, имена которых начинаются с **`.`** , так как к ним часто обращаются в своей работе инструменты **`tox`**, **`mуру`** или **git**. Остальные файлы будут содержать cтpoки **`@startuml`**, а некоторые и строку с именами нескольких выходных файлов.

Большинство файлов UML не создают нескольких файлов. Регулярное выражение **`self.start_pattern`** определяет имя, если оно указано, а итератор выдает кортежи с двумя путями.

Имеется класс, который в качестве подпроцесса запускает прикладную программу PlantUML. Когда Python работает, все это является процессом операционной системы. Опираясь на модуль **`subprocess`**, можно запускать дочерние процессы, которые, в свою очередь, запускают другие бинарные приложения или сценарии оболочки. Например, так:

```python
import subprocess

class PlantUML:
    """
    Default setup is this:

    1.  Download Java Runtime (JRE) for your platform.
        https://www.java.com/en/download/manual.jsp 

    2.  Download the ``plantuml.jar`` and put into your conda                environment ``share`` directory.https://plantuml.com/download

    3.  Use ``conda install graphiz`` to create the ``dot``                  application in your conda environment.

    4.  If necessary, update this script with environment name and           locations
    """

    conda_env_name = "CaseStudy"
    base_env = Path.home() / "miniconda3" / "envs" / "conda_env_name"

    def __init__(
            self,
            graphviz: Path = Path("bin") / "dot",
            plantjar: Path = Path("share") / "plantuml.jar",
    ) -> None:
        self.graphviz = self.base_env / graphviz
        self.plantviz = self.base_env / plantjar  

    def process(self, source: Path) -> None:
        env = {
            "GRAPHVIZ_DOT": str(self.graphviz),
        }
        command = [
            "java", "-jar",
            str(self.plantjar), "-progress",
            str(source)
        ]
        subprocess.run(command, env=env, check=True)
        print()
```

При создании виртуальной среды **`CaseStudy`** работа класса PlantUML зависит от применения `conda`. При использовании других менеджеров виртуальной среды подкласс может предоставлять все необходимые пути модификации. В указанную виртуальную среду нужно установить пакет **`Graphviz`**. Тогда диаграмма будет представлена как файл изображения. Необходимо также скачать файл **`plantuml.jar`**. Поместим его в общий каталог внутри выбранной виртуальной среды. Значение командной переменной предполагает, что среда выполнения Java (JRE) корректно установлена и видна.

Функция **`subprocess.run()`** принимает аргументы командной строки и любые специальные переменные среды, которые необходимо установить. Функция запустит команду в данной среде и проверит полученный код возврата, чтобы убедиться, что программа работает правильно.

Также эти этапы можно использовать отдельно, чтобы найти все файлы UML и создать диаграммы. Поскольку интерфейс немного сложен для понимания, класс, работающий с **паттерном Фасад**, помогает создать полезное приложение командной строки.

```python
class GenerateImages:
    def __init__(self, base: Path) -> None:
        self.finder = FindUML(base)
        self.painter = PlantUML()

    def make_all_images(self) -> None:
        for source, target in self.finder.uml_file_iter():
            if (
                not target.exists()
                or source.stat().st_mtime > target.stat().st_mtime
            ):
                print(f"Processing {source} -> {target}")
                self.painter.process(source)
            else:
                print(f"Skipping {source} -> {target}")
```

Класс **`Generatelmages`** - это удобный фасад, сочетающий в себе функции классов **`FindUML`** и **`PlantUML`**. Он использует метод **`FindUML.uml_file_iter()`** для поиска исходных файлов и выходных файлов изображений. Класс **`GenerateImages`** проверяет время модификации этих файлов, чтобы избежать их обработки, если изображение новее исходного. ( Информацию, касающуюся **`stat().st_mtime`**, пока нельзя считать точной. Метод **`stat()`** класса **`Path`** предоставляет большое количество информации о состоянии файла, а время модификации - лишь часть информации о файле, которую мы можем найти.) Если файл `.uml` создан позже, значит, один из авторов изменил его и изображения необходимо пере-генерировать. Теперь код становится довольно простым:

```python
if __name__ == "__main__":
    g = GenerateImages(Path.cwd())
    g.make_all_images()
```

Хотя **паттерн Фасад** редко упоминается в сообществе Python, он является неотъемлемой частью экосистемы языка. Поскольку Python делает упор на удобочитаемость языка, и язык, и его библиотеки для сложных задач, как правило, предоставляют простые для понимания интерфейсы. Например, циклы **`for`**, списковые включения и генераторы - все это фасады более сложного **протокола [[Паттерн Итератор|Итератор]]**. Реализация **`defaultdict`** - это фасад, который не учитывает исключительные ситуации, когда ключа нет в словаре.

Сторонние запросы или библиотеки **`httpx`** являются мощным фасадом по сравнению с менее читабельными библиотеками **`urllib`** для обработки НТТР. Сам пакет **`urllib`** представляет собой фасад управления текстовым НТТР-протоколом с использованием базового пакета **`socket`**.

**Паттерн Фасад** помогает избежать сложностей. ==Но когда необходимо избежать дублирования данных, имеет смысл обратиться к следующему паттерну проектирования==. Он оптимизирует хранилище при работе с большими объемами данных. Это особенно полезно на очень маленьких компьютерах, типичных для приложений [[IoT (Internet of Things)|IоТ]].






## Паттерн Легковес
---

**Паттерн Легковес** - ==это паттерн оптимизации памяти==. Начинающие Руthоn-разработчики обычно игнорируют такую оптимизацию, предполагая, что об этом позаботится встроенная программа очистки памяти. Для старта в программировании это неплохо - рассчитывать на встроенное управление. Но в некоторых случаях, например при работе с очень большими приложениями по обработке и анализу данных, ограничение объема памяти может стать барьером, и необходимо принимать более активные меры по управлению ее расходованием. В очень маленьких устройствах [[IoT (Internet of Things)|IoT (Internet of Things)]] управление памятью тем более важно.

**Паттерн Легковес** гарантирует, что объекты, которые совместно используют состояние, могут претендовать на одну и ту же область памяти. Обычно это начинают практиковать только после возникновения проблем с памятью. В некоторых случаях имеет смысл с самого начала разработать оптимальное ее распределение. Правда, имейте в виду, что преждевременная оптимизация является наиболее эффективным способом создания сложно поддерживаемой программы.

В некоторых языках **паттерн Легковес** требует внимательного обращения со ссылками на объекты, предотвращения случайного копирования объектов и отслеживания прав собственности на объекты с тем, чтобы гарантировать, что объекты не будут преждевременно удалены. В Python все является объектом и все объекты работают через согласованные ссылки. Дизайн паттерна Легковес в Python, как правило, несколько проще, чем в других языках.

Рассмотрим, как это выглядит на UМL-диаграмме (**рис.12.3**).

Объект **`Flyweight`** не имеет собственного определенного состояния. Каждый раз при необходимости выполнить операцию над **`SpecificState`** это состояние передается во **`Flyweight`** вызывающим кодом в качестве значения аргумента. Фабрика, возвращающая экземпляр класса **`Flyweight`**, представляет собой отдельный объект. Цель этого объекта состоит в том, чтобы возвращать отдельные объекты **`Flyweight`**, возможно организованные по какому-либо ключу или индексу.

Иначе говоря, все работает подобно **паттерну Синглтон**, который мы уже обсуждали в [[Общие Паттерны Проектирования]]. Если **`Flyweight`** существует, то он возвращается. В противном случае создается новый. Во многих языках фабрика реализована не как отдельный объект, а как статический метод самого класса **`Flyweight`**.

>![[Рис. 12.3. Паттерн Легковес.jpg]]
>   **Рис. 12.3.** *Паттерн Легковес*

Это можно сравнить с тем, как [[Всемирная паутина|Всемирная паутина]] заменила компьютер, загруженный данными. Раньше приходилось собирать и индексировать документы и файлы, заполняя локальный компьютер копиями исходных данных, работать с физическими носителями, такими как дискеты и компакт-диски. Теперь же можно через веб-сайт получить ссылку на исходные данные, не создавая громоздкой и занимающей много места копии. Поскольку идет работа со ссылкой на исходные данные, их становится легко прочитать на мобильном устройстве. **Паттерн Легковес** для работы со ссылкой на данные - это важный механизм в общей системе доступа к информации.

В отличие от паттерна проектирования **Синглтон**, который должен возвращать только один экземпляр класса, паттерн Легковес может иметь несколько экземпляров классов **`Flyweight`**. Один из подходов состоит в том, чтобы хранить элементы в словаре и предоставлять значения объектам **`Flyweight`** на основе ключа словаря. Другим распространенным подходом в некоторых приложениях **[[IoT (Internet of Things)|IoT]]** является использование буфера элементов. На мощном компьютере выделение и освобождение объектов обходится относительно недорого. Но на небольшом IоТ-компьютере необходимо свести к минимуму создание объектов, а это подразумевает применение **паттерна Легковес**, в котором буфер используется совместно объектами.

Хороший пример **паттерна Легковес**, учет представителей разных компаний, приехавших на конференцию по IT-технологиям.

```python

```