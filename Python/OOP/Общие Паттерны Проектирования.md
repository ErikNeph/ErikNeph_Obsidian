---
date of creation: 2024-06-25T17:02:00
tags:
  - Patterns
  - Python/Patterns
  - OOP
  - OOP/Python
  - Developing/Python
  - IT/Python
  - IT
  - DesignPatterns
  - Python
Read status: false
aliases:
---
---
# Общие Паттерны Проектирования
2024-06-25


В предыдущей [[Паттерн Итератор|главе]] уже упоминалось о паттернах проектирования и вы даже изучили паттерн Итератор. Паттерн Итератор настолько полезный и распространенный, что он встроен в язык программирования Python. В этой главе рассмотрим другие распространенные паттерны и примеры их реализации в Python. Как и в случае с итерацией, нам предстоит проанализировать и традиционный классический подход к работе с паттернами, и альтернативный синтаксис, предоставляемый средствами Python.

Прочитав эту заметку, вы освоите следующее.

- Паттерн *[[#Паттерн Декоратор|Декоратор]]* (Decorator).
- Паттерн *[[#Паттерн Наблюдатель|Наблюдатель]]* (Observer).
- Паттерн *Стратегия* (Strategy).
- Паттерн *Команда* (Command).
- Паттерн *Состояние* (State).
- Паттерн *Синглтон* (Singleton).

Начнем свое изучение с паттерна *Декоратор*. ==Это структурный паттерн, цель которого - предоставление новых функциональных возможностей классам и объектам во время выполнения кода.==



## Паттерн Декоратор
---

**Паттерн Декоратор** ==позволяет добавлять объектам новое поведение, помещая их в объекты-оболочки.== Декоратор оборачивает объекты бесчисленное количество раз благодаря тому, что и обертки, и сами обернутые объекты имеют общий интерфейс. Любой объект, использующий объект-декоратор, будет взаимодействовать с ним точно так же, как если бы он не был декоратором (то есть интерфейс объекта-декоратора идентичен интерфейсу основного объекта).

Существует два способа реализации паттерна Декоратор:

- улучшение отклика компонента при отправке данных второму компоненту;
- поддержка нескольких дополнительных вариантов поведения.

Второй вариант обычно является подходящей альтернативой множественному наследованию. Мы можем создать основной объект, а затем декоратор, обертывающий это ядро. Поскольку объект-декоратор имеет тот же интерфейс, что и основной объект, можно даже обернуть и новый объект в другие декораторы. Рассмотрим, как это выглядит на UМL-диаграмме (**рис. 11.1**).

В данном случае **ядро** и все декораторы реализуют определенный **интерфейс**. Пунктирные линии означают <*реализацию*>. Декораторы поддерживают ссылку на основной экземпляр данного **интерфейса** через композицию. При вызове декоратор выполняет некоторую дополнительную обработку до или после вызова своего обернутого интерфейса. Обернутый объект может быть другим декоратором или основным функционалом. Хотя несколько декораторов могут обертывать друг друга, основную функциональность обеспечивает объект в конце цепочки всех декораторов.

Важно, чтобы каждый из объектов в цепочке обеспечивал реализацию общей функции. Цель состоит в том, чтобы предоставить набор шагов обработки ядра различными декораторами. Как правило, декораторы невелики по размеру, фактически это определение функции без какого-либо состояния.

![[Рис. 11.1. Паттерн Декоратор на UМL- диаграмме.jpg]]
>   **Рис. 11.1.** Паттерн Декоратор на UМL- диаграмме


### Пример реализации паттерна Декоратор
---

Рассмотрим пример из сетевого программирования. Скажем, необходимо создать небольшой сервер и клиент. Сервер предоставляет данные, клиент с ним взаимодействует. Сервер имитирует бросание костей. Клиент отправляет запрос и ожидает ответ, содержащий случайные числа.

В этом примере два процесса взаимодействуют через сокет ТСР - способ передачи байтов между компьютерными системами. Сокеты создаются сервером, прослушивающим соединения. При попытке клиента подключиться к сокету сервер должен принять новое соединение, после чего два процесса смогут передавать байты в обе стороны. Для данного примера это будет запрос от клиента к серверу и ответ от сервера к клиенту. Сокет ТСР является частью основы протокола НТТР, вокруг которого построена Всемирная паутина.

При клиент-серверном взаимодействии для передачи строки байтов через сокет будет использоваться метод **`socket.send()`** , а для получения байтов - метод **`socket.recv()`**.

Проанализируем этот пример, начиная с интерактивного сервера, который ожидает подключения от клиента, а затем отвечает на запрос. Назовем этот модуль **`socket_server.ру`**. Например:

```python
import contextlib
import socket


def main_1() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("localhost", 2401))
    server.listen(1)
    with contextlib.closing(server):
        while True:
            client, addr = server.accept()
            dice_response(client)
            client.close()
```

Сервер привязан к общедоступному сокету через произвольный порт с номером 2401. Именно здесь сервер прослушивает запросы на подключение. При попытке клиента подключиться к этому сокету создается дочерний сокет, чтобы клиент и сервер могли общаться, оставляя общедоступный сокет готовым для дополнительных подключений. Чтобы обеспечить большое количество одновременных сессий веб-сервер часто применяет несколько потоков. Мы не используем здесь потоки, и второй клиент должен ждать, пока сервер не закончит работу с первым клиентом. Это напоминает очередь в кофейню, где только один бариста готовит эспрессо.

Обратите внимание, что сокеты ТСР/IP имеют как адрес хоста, так и номер порта. Номер порта должен быть выше чем `1023`. Номера портов `1023` и ниже зарезервированы и требуют специальных привилегий ОС. В примере выбран порт `2401`, так как он не используется для других задач.

Функция **`dice_response()`** выполняет всю реальную работу описанного сервиса. Для ответа клиенту функция принимает параметр сокета. Считываются байты с клиентским запросом, создается ответ, который затем отправляется. Функция **`dice_response()`** для корректной обработки исключений выглядит следующим образом:

```python
def dice_response(client: socket.socket) -> None:
    request = client.recv(1024)
    try:
        response = dice.dice_roller(request)
    except (ValueError, KeyError) as ex:
        response = repr(ex).encode("utf-8")
    client.send(response)
```

В примере в обработчик исключений обернута другая функция, **`dice_roller()`** . Это распространенный прием для отделения обработки ошибок и других задач от реального выполнения кода броска костей и ответа клиенту:

```python
import random


def dice_roller(request: bytes) -> bytes:
    request_text = request.decode("utf-8")
    numbers = [random.randint(1, 6) for _ in range(6)]
    response = f"{request_text} = {numbers}"
    return response.encode("utf-8")
```

Это не слишком сложно. Данный пример более подробно рассмотрим в разделе, касающемся **паттерна Команда**, но уже здесь в качестве ответа предоставляется последовательность случайных чисел.

Обратите внимание, что фактически мы ничего не делаем с объектом **`request`**, пришедшим от клиента. В примерах мы будем считывать эти байты и игнорировать их. **`request`** является плейсхолдером для более сложного запроса, описывающего необходимое количество игральных костей и количество бросков.

**Паттерн проектирования Декоратор** иногда используется для добавления функций. Он обертывает основную функцию **`dice_response()`** , которой предоставляется объект **`socket`**, а его уже можно и читать, и записывать. Чтобы использовать паттерн проектирования, важно учитывать, как при добавлении функционала эта функция опирается на методы **`socket.send()`** и **`socket.recv()`** : необходимо сохранить определение интерфейса.

Чтобы протестировать сервер, напишем код простого клиента, который подключается к тому же порту и перед выходом выводит ответ:

```python
def main() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.connect(("localhost", 2401))
    count = input("How many rolls: ") or "1"
    pattern = input("Dice pattern nd6[dk+-]a: ") or "d6"
    command = f"Dice {count} {pattern}"
    server.send(command.encode("utf-8"))
    response = server.recv(1024)
    print(response.decode("utf-8"))
    server.close()


if __name__ == "__main__":
    main()
```

Клиент задает два вопроса и создает довольно сложную строку, **`command`**, содержащую подсчет и паттерн броска костей. На данный момент сервер еще не использует эту команду, и код представляет собой задачу для более сложной игры в кости.

Результат будет выглядеть так, как показано на **рис. 11.2.**

![[Рис. 11.2. Сервер и клиент.jpg]]
>   **Рис. 11.2.** Сервер и клиент

==На схеме слева изображен сервер==. Приложение запущено, и оно начало прослушивать порт `2401` для клиентов. Справа изображен клиент. Каждый раз, когда запускается клиент, он подключается к общедоступному сокету. Операция подключения создает дочерний сокет, который можно использовать для остальной части взаимодействия. Клиент отправляет команду, сервер отвечает на эту команду, и клиент вы водит ее.

Теперь, проанализировав код сервера, мы явно различаем два его раздела. Функция **`dice_response()`** считывает данные и отправляет их обратно клиенту через объект **`socket`**. Оставшийся сценарий отвечает за создание объекта **`socket`**. Создадим пару декораторов, настраивающих поведение сокета, не расширяя и не изменяя самого сокета.

Начнем с **`логирования`**. Объект выводит любые данные, получаемые с консоли сервера, прежде чем отправить их клиенту:

```python
class LogSocket:
    def __init__(self, socket: socket.socket) -> None:
        self.socket = socket

    def recv(self, count: int = 0) -> bytes:
        data = self.socket.recv(count)
        print(f"Receiving {data!r} from {self.socket.getpeername()[0]}")
        return data

    def send(self, data: bytes) -> None:
        print(f"Sending {data!r} to {self.socket.getpeername()[0]}")
        self.socket.send(data)

    def close(self) -> None:
        self.socket.close()
```

В коде класс декорирует объект **`socket`** и предоставляет обращающимся к нему клиентам интерфейсы **`send()`** , **`recv()`** и  **`close()`** . Подходящий декоратор мог бы правильно реализовать все аргументы для отправки (которые на самом деле принимают необязательный аргумент), но лучше не будем усложнять. Всякий раз, когда для экземпляра класса **`LogSocket`** вызывается функция **`send()`** , перед отправкой данных клиенту, использующему исходный сокет, на экран записывается вывод. Аналогично для **`recv()`** считываются и регистрируются полученные данные.

Для применения этого декоратора необходимо изменить только одну строку в исходном коде. Вместо того чтобы вызывать функцию **`dice_response()`** с исходным клиентским сокетом, вызовем ее с декорированным сокетом:

```python
from typing import cast


def main_2() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("localhost", 2401))
    server.listen(1)
    with contextlib.closing(server):
        while True:
            client, addr = server.accept()
            logging_socket = cast(socket.socket, LogSocket(client))
            dice_response(logging_socket)
            client.close()
```

Итак, мы декорировали основной сокет **`LogSocket`**. Сокет **`LogSocket`** будет выводить результат на консоль и вызывать метод, который он декорирует. Основная обработка в функции **`dice_response()`** не меняется, так как экземпляр **`LogSocket`** ведет себя как базовый объект **`socket`**.

Обратите внимание, что необходимо было использовать метод **`cast()`** , чтобы сообщить **`mуру`**, что экземпляр **`LogSocket`** предоставит интерфейс, аналогичный обычному объекту **`socket`**. Здесь надо проанализировать, почему нельзя просто расширить класс **`socket`** и переопределить метод **`send`**. Для фактической отправки после регистрации данных подкласс может вызвать методы **`super().send() и super().recv() `**. Декорирование имеет преимущество перед наследованием: декорирование можно повторно использовать в различных классах и в различных иерархиях классов. В данном конкретном примере объектов, подобных сокетам, не слишком много, поэтому возможности повторного использования ограниченны.

Декораторы могут быть связанными и декорировать уже декорированные элементы. Идея состоит в том, чтобы действовать через композицию. Переработаем декоратор логирования, чтобы сосредоточиться на запросе и ответе в виде байтов, а не на объекте **`socket`**. Следующий пример должен выглядеть аналогично предыдущему, но с некоторым изменением кода, касающимся размещения в одном методе **`__call__()`** :

```python
Address = Tuple[str, int]
  

class LogRoller:
    def __init__(self, dice: Callable[[bytes], bytes], remote_addr: Address) -> None:
        self.dice_roller = dice
        self.remote_addr = remote_addr

    def __call__(self, request: bytes) -> bytes:
        print(f"Receiving {request!r} from {self.remote_addr}")
        dice_roller = self.dice_roller
        response = dice_roller(request)
        print(f"Sending {response!r} to {self.remote_addr}")
        return response
```

Ниже представлен пример второго декоратора, который сжимает данные, применяя сжатие **`gzip`** для полученных байтов:

```python
import gzip
import io


class ZipRoller:
    def __init__(self, dice: Callable[[bytes], bytes]) -> None:
        self.dice_roller = dice  

    def __call__(self, request:bytes) -> bytes:
        dice_roller = self.dice_roller
        response = dice_roller(request)
        buffer = io.BytesIO()
        with gzip.GzipFile(fileobj=buffer, mode="w") as zip_file:
            zip_file.write(response)
        return buffer.getvalue()
```

Этот декоратор сжимает входящие данные перед их отправкой клиенту. Он декорирует базовый объект **`dice_roller`**, вычисляющий ответ на запрос.

Теперь, когда имеется два декоратора, напишем код, который накладывает один декоратор на другой:

```python
def dice_response(client: socket.socket) -> None:
    request = client.recv(1024)
    try:
        remote_addr = client.getpeername()
        roller_1 = ZipRoller(dice.dice_roller)
        roller_2 = LogRoller(roller_1, remote_addr=remote_addr)
        response = roller_2(request)
    except (ValueError, KeyError) as ex:
        response = repr(ex).encode("utf-8")
    client.send(response)
```

Цель состоит в том, чтобы разделить три аспекта этого приложения.

- Архивирование полученного документа.
- Ведение журнала или запись в лог-файл (логирование).
- Выполнение базовых вычислений.

Можно архивировать или логировать любое аналогичное приложение, которое работает с приемом и отправкой байтов. При необходимости, используя динамический выбор, можно выполнить операцию архивирования. У нас может быть отдельный файл конфигурации для включения или отключения функции **`GZip`**. Например:

```python
if config.zip_feature:
	roller_1 = ZipRoller(dice.dice_roller)
else:
	roller_1 = dice.dice_roller
```

Имеется динамический набор дополнительных функций. Попробуйте написать это, используя в том числе множественное наследование, и проанализируйте результат.



#### Полезный декоратор
---

Декораторы Python также допускают параметры. **`functools.lru_cache`** ==- один из самых полезных декораторов в стандартной библиотеке.== Идея кэширования состоит в том, чтобы сохранять вычисленные результаты функции, тем самым избегая их повторного вычисления. Вместо того чтобы сохранять все параметры и результаты, мы можем уменьшить размер кэша, **отбрасывая наименее использовавшиеся (LRU)** значения. Например, ниже представлена функция, требующая потенциально дорогостоящих вычислений:

```python
>>> from math import factorial
>>> def binom(n: int, k: int) -> int:
... 	return factorial(n) // (factorial(k) * factorial(n-k))

>>> f"6-card deals: {bionom(52, 6):,d}"
'6-card deals: 20,358,520'
```

Применим декоратор **`lru_cache`**, чтобы при известном ответе избежать выполнения этих вычислений. Например, так:

```python
>>> from math import factorial
>>> from functools import lru_cache
>>> @lru_cache(64)
... def bionom(n: int, k: int) -> int:
...     return factorial(n) // (factorial(k) * factorial(n-k))
```

Параметризованный декоратор **`@lru_cache(64)`**, применяемый для создания второй версии функции **`binom()`** , сохраняет самые последние 64 результата, чтобы избежать повторного вычисления значений, если они уже были вычислены один раз. Теперь в другом месте приложения никакие изменения больше не требуются. Иногда улучшение от этого небольшого нюанса может быть значительным. Конечно, можно точно настроить размер кэша на основе данных и количества выполняемых вычислений.

Использование подобных параметризованных декораторов похоже на топтание на одном месте. Сначала мы настраиваем декоратор с параметром, затем применяем этот настроенный декоратор к определению функции. Эти два отдельных шага аналогичны действиям, когда вызываемые объекты инициализируются с помощью мeтoдa **`__init__()`** и могут быть вызваны в качестве функции с помощью метода **`__call__()`**

Рассмотрим пример настраиваемого декоратора логирования **`NamedLogger`**:

```python
class NamedLogger:
    def __init__(self, logger_name: str) -> None:
        self.logger = logging.getLogger(logger_name)

    def __call__(self, function: Callable[..., Any]) -> Callable[..., Any]:
        @wraps(function)
        def wrapped_function(*args: Any, **kwargs: Any) -> Any:
            start = time.perf_counter()
            try:
                result = function(*args, **kwargs)
                μs = (time.perf_counter() - start) * 1_000_000
                self.logger.info(f"{function.__name__}, {μs:.1f}μs")
                return result
            except Exception as ex:
                μs = (time.perf_counter() - start) * 1_000_000
                self.logger.error(f"{ex}, {function.__name__}, {μs:.1f}μs")
                raise

        return wrapped_function
```

Метод **`__init__()`** гарантирует, что для создания декоратора мы можем написать код вроде **`NamedLogger("log4")`** . Этот декоратор позаботится о том, чтобы следующая функция использовала определенный регистратор.

Метод **`__саll__()`** следует уже известному паттерну. Определяем новую функцию **`wrap_function()`** , которая делает всю работу, и возвращаем новую функцию:

```python
@NamedLogger("log4")
def test4(median: float, sample: float) -> float:
    return abs(sample - median)
```

Здесь мы создали экземпляр класса **`NamedLogger`**. Затем применили этот экземпляр к определению функции **`test4()`**. При этом вызывался метод **`__саll__()`** , который создал новую функцию, декорированную версию функции **`test4()`**.

Существует еще несколько вариантов использования синтаксиса декоратора. Например, когда декоратор является методом класса, он также сохраняет информацию о декорированной функции, создавая реестр декорированных функций. Кроме того, классы также могут быть декорированы. В этом случае декоратор возвращает новый класс вместо новой функции.

Во всех более сложных случаях мы используем обычный объектно-ориентированный дизайн с более простым синтаксисом **`@dесоrаtоr`**.



## Паттерн Наблюдатель
---
