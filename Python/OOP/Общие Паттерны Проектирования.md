---
date of creation: 2024-06-25T17:02:00
tags:
  - Patterns
  - Python/Patterns
  - OOP
  - OOP/Python
  - Developing/Python
  - IT/Python
  - IT
  - DesignPatterns
  - Python
Read status: true
aliases:
---
---
# Общие Паттерны Проектирования
2024-06-25


В предыдущей [[Паттерн Итератор|главе]] уже упоминалось о паттернах проектирования и вы даже изучили паттерн Итератор. Паттерн Итератор настолько полезный и распространенный, что он встроен в язык программирования Python. В этой главе рассмотрим другие распространенные паттерны и примеры их реализации в Python. Как и в случае с итерацией, нам предстоит проанализировать и традиционный классический подход к работе с паттернами, и альтернативный синтаксис, предоставляемый средствами Python.

Прочитав эту заметку, вы освоите следующее.

- Паттерн *[[#Паттерн Декоратор|Декоратор]]* (Decorator).
- Паттерн *[[#Паттерн Наблюдатель|Наблюдатель]]* (Observer).
- Паттерн *[[#Паттерн Стратегия|Стратегия]]* (Strategy).
- Паттерн *[[#Паттерн Команда|Команда]]* (Command).
- Паттерн *[[#Паттерн Состояние|Состояние]]* (State).
- Паттерн *[[#Паттерн Синглтон|Синглтон]]* (Singleton).

Начнем свое изучение с паттерна *Декоратор*. ==Это структурный паттерн, цель которого - предоставление новых функциональных возможностей классам и объектам во время выполнения кода.==



## Паттерн Декоратор



---

**Паттерн Декоратор** ==позволяет добавлять объектам новое поведение, помещая их в объекты-оболочки.== Декоратор оборачивает объекты бесчисленное количество раз благодаря тому, что и обертки, и сами обернутые объекты имеют общий интерфейс. Любой объект, использующий объект-декоратор, будет взаимодействовать с ним точно так же, как если бы он не был декоратором (то есть интерфейс объекта-декоратора идентичен интерфейсу основного объекта).

Существует два способа реализации паттерна Декоратор:

- улучшение отклика компонента при отправке данных второму компоненту;
- поддержка нескольких дополнительных вариантов поведения.

Второй вариант обычно является подходящей альтернативой множественному наследованию. Мы можем создать основной объект, а затем декоратор, обертывающий это ядро. Поскольку объект-декоратор имеет тот же интерфейс, что и основной объект, можно даже обернуть и новый объект в другие декораторы. Рассмотрим, как это выглядит на UМL-диаграмме (**рис. 11.1**).

В данном случае **ядро** и все декораторы реализуют определенный **интерфейс**. Пунктирные линии означают <*реализацию*>. Декораторы поддерживают ссылку на основной экземпляр данного **интерфейса** через композицию. При вызове декоратор выполняет некоторую дополнительную обработку до или после вызова своего обернутого интерфейса. Обернутый объект может быть другим декоратором или основным функционалом. Хотя несколько декораторов могут обертывать друг друга, основную функциональность обеспечивает объект в конце цепочки всех декораторов.

Важно, чтобы каждый из объектов в цепочке обеспечивал реализацию общей функции. Цель состоит в том, чтобы предоставить набор шагов обработки ядра различными декораторами. Как правило, декораторы невелики по размеру, фактически это определение функции без какого-либо состояния.

![[Рис. 11.1. Паттерн Декоратор на UМL- диаграмме.jpg]]
>   **Рис. 11.1.** Паттерн Декоратор на UМL- диаграмме


### Пример реализации паттерна Декоратор
---

Рассмотрим пример из сетевого программирования. Скажем, необходимо создать небольшой сервер и клиент. Сервер предоставляет данные, клиент с ним взаимодействует. Сервер имитирует бросание костей. Клиент отправляет запрос и ожидает ответ, содержащий случайные числа.

В этом примере два процесса взаимодействуют через сокет ТСР - способ передачи байтов между компьютерными системами. Сокеты создаются сервером, прослушивающим соединения. При попытке клиента подключиться к сокету сервер должен принять новое соединение, после чего два процесса смогут передавать байты в обе стороны. Для данного примера это будет запрос от клиента к серверу и ответ от сервера к клиенту. Сокет ТСР является частью основы протокола НТТР, вокруг которого построена Всемирная паутина.

При клиент-серверном взаимодействии для передачи строки байтов через сокет будет использоваться метод **`socket.send()`** , а для получения байтов - метод **`socket.recv()`**.

Проанализируем этот пример, начиная с интерактивного сервера, который ожидает подключения от клиента, а затем отвечает на запрос. Назовем этот модуль **`socket_server.ру`**. Например:

```python
import contextlib
import socket


def main_1() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("localhost", 2401))
    server.listen(1)
    with contextlib.closing(server):
        while True:
            client, addr = server.accept()
            dice_response(client)
            client.close()
```

Сервер привязан к общедоступному сокету через произвольный порт с номером 2401. Именно здесь сервер прослушивает запросы на подключение. При попытке клиента подключиться к этому сокету создается дочерний сокет, чтобы клиент и сервер могли общаться, оставляя общедоступный сокет готовым для дополнительных подключений. Чтобы обеспечить большое количество одновременных сессий веб-сервер часто применяет несколько потоков. Мы не используем здесь потоки, и второй клиент должен ждать, пока сервер не закончит работу с первым клиентом. Это напоминает очередь в кофейню, где только один бариста готовит эспрессо.

Обратите внимание, что сокеты ТСР/IP имеют как адрес хоста, так и номер порта. Номер порта должен быть выше чем `1023`. Номера портов `1023` и ниже зарезервированы и требуют специальных привилегий ОС. В примере выбран порт `2401`, так как он не используется для других задач.

Функция **`dice_response()`** выполняет всю реальную работу описанного сервиса. Для ответа клиенту функция принимает параметр сокета. Считываются байты с клиентским запросом, создается ответ, который затем отправляется. Функция **`dice_response()`** для корректной обработки исключений выглядит следующим образом:

```python
def dice_response(client: socket.socket) -> None:
    request = client.recv(1024)
    try:
        response = dice.dice_roller(request)
    except (ValueError, KeyError) as ex:
        response = repr(ex).encode("utf-8")
    client.send(response)
```

В примере в обработчик исключений обернута другая функция, **`dice_roller()`** . Это распространенный прием для отделения обработки ошибок и других задач от реального выполнения кода броска костей и ответа клиенту:

```python
import random


def dice_roller(request: bytes) -> bytes:
    request_text = request.decode("utf-8")
    numbers = [random.randint(1, 6) for _ in range(6)]
    response = f"{request_text} = {numbers}"
    return response.encode("utf-8")
```

Это не слишком сложно. Данный пример более подробно рассмотрим в разделе, касающемся **паттерна Команда**, но уже здесь в качестве ответа предоставляется последовательность случайных чисел.

Обратите внимание, что фактически мы ничего не делаем с объектом **`request`**, пришедшим от клиента. В примерах мы будем считывать эти байты и игнорировать их. **`request`** является плейсхолдером для более сложного запроса, описывающего необходимое количество игральных костей и количество бросков.

**Паттерн проектирования Декоратор** иногда используется для добавления функций. Он обертывает основную функцию **`dice_response()`** , которой предоставляется объект **`socket`**, а его уже можно и читать, и записывать. Чтобы использовать паттерн проектирования, важно учитывать, как при добавлении функционала эта функция опирается на методы **`socket.send()`** и **`socket.recv()`** : необходимо сохранить определение интерфейса.

Чтобы протестировать сервер, напишем код простого клиента, который подключается к тому же порту и перед выходом выводит ответ:

```python
def main() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.connect(("localhost", 2401))
    count = input("How many rolls: ") or "1"
    pattern = input("Dice pattern nd6[dk+-]a: ") or "d6"
    command = f"Dice {count} {pattern}"
    server.send(command.encode("utf-8"))
    response = server.recv(1024)
    print(response.decode("utf-8"))
    server.close()


if __name__ == "__main__":
    main()
```

Клиент задает два вопроса и создает довольно сложную строку, **`command`**, содержащую подсчет и паттерн броска костей. На данный момент сервер еще не использует эту команду, и код представляет собой задачу для более сложной игры в кости.

Результат будет выглядеть так, как показано на **рис. 11.2.**

![[Рис. 11.2. Сервер и клиент.jpg]]
>   **Рис. 11.2.** Сервер и клиент

==На схеме слева изображен сервер==. Приложение запущено, и оно начало прослушивать порт `2401` для клиентов. Справа изображен клиент. Каждый раз, когда запускается клиент, он подключается к общедоступному сокету. Операция подключения создает дочерний сокет, который можно использовать для остальной части взаимодействия. Клиент отправляет команду, сервер отвечает на эту команду, и клиент вы водит ее.

Теперь, проанализировав код сервера, мы явно различаем два его раздела. Функция **`dice_response()`** считывает данные и отправляет их обратно клиенту через объект **`socket`**. Оставшийся сценарий отвечает за создание объекта **`socket`**. Создадим пару декораторов, настраивающих поведение сокета, не расширяя и не изменяя самого сокета.

Начнем с **`логирования`**. Объект выводит любые данные, получаемые с консоли сервера, прежде чем отправить их клиенту:

```python
class LogSocket:
    def __init__(self, socket: socket.socket) -> None:
        self.socket = socket

    def recv(self, count: int = 0) -> bytes:
        data = self.socket.recv(count)
        print(f"Receiving {data!r} from {self.socket.getpeername()[0]}")
        return data

    def send(self, data: bytes) -> None:
        print(f"Sending {data!r} to {self.socket.getpeername()[0]}")
        self.socket.send(data)

    def close(self) -> None:
        self.socket.close()
```

В коде класс декорирует объект **`socket`** и предоставляет обращающимся к нему клиентам интерфейсы **`send()`** , **`recv()`** и  **`close()`** . Подходящий декоратор мог бы правильно реализовать все аргументы для отправки (которые на самом деле принимают необязательный аргумент), но лучше не будем усложнять. Всякий раз, когда для экземпляра класса **`LogSocket`** вызывается функция **`send()`** , перед отправкой данных клиенту, использующему исходный сокет, на экран записывается вывод. Аналогично для **`recv()`** считываются и регистрируются полученные данные.

Для применения этого декоратора необходимо изменить только одну строку в исходном коде. Вместо того чтобы вызывать функцию **`dice_response()`** с исходным клиентским сокетом, вызовем ее с декорированным сокетом:

```python
from typing import cast


def main_2() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("localhost", 2401))
    server.listen(1)
    with contextlib.closing(server):
        while True:
            client, addr = server.accept()
            logging_socket = cast(socket.socket, LogSocket(client))
            dice_response(logging_socket)
            client.close()
```

Итак, мы декорировали основной сокет **`LogSocket`**. Сокет **`LogSocket`** будет выводить результат на консоль и вызывать метод, который он декорирует. Основная обработка в функции **`dice_response()`** не меняется, так как экземпляр **`LogSocket`** ведет себя как базовый объект **`socket`**.

Обратите внимание, что необходимо было использовать метод **`cast()`** , чтобы сообщить **`mуру`**, что экземпляр **`LogSocket`** предоставит интерфейс, аналогичный обычному объекту **`socket`**. Здесь надо проанализировать, почему нельзя просто расширить класс **`socket`** и переопределить метод **`send`**. Для фактической отправки после регистрации данных подкласс может вызвать методы **`super().send() и super().recv() `**. Декорирование имеет преимущество перед наследованием: декорирование можно повторно использовать в различных классах и в различных иерархиях классов. В данном конкретном примере объектов, подобных сокетам, не слишком много, поэтому возможности повторного использования ограниченны.

Декораторы могут быть связанными и декорировать уже декорированные элементы. Идея состоит в том, чтобы действовать через композицию. Переработаем декоратор логирования, чтобы сосредоточиться на запросе и ответе в виде байтов, а не на объекте **`socket`**. Следующий пример должен выглядеть аналогично предыдущему, но с некоторым изменением кода, касающимся размещения в одном методе **`__call__()`** :

```python
Address = Tuple[str, int]
  

class LogRoller:
    def __init__(self, dice: Callable[[bytes], bytes], remote_addr: Address) -> None:
        self.dice_roller = dice
        self.remote_addr = remote_addr

    def __call__(self, request: bytes) -> bytes:
        print(f"Receiving {request!r} from {self.remote_addr}")
        dice_roller = self.dice_roller
        response = dice_roller(request)
        print(f"Sending {response!r} to {self.remote_addr}")
        return response
```

Ниже представлен пример второго декоратора, который сжимает данные, применяя сжатие **`gzip`** для полученных байтов:

```python
import gzip
import io


class ZipRoller:
    def __init__(self, dice: Callable[[bytes], bytes]) -> None:
        self.dice_roller = dice  

    def __call__(self, request:bytes) -> bytes:
        dice_roller = self.dice_roller
        response = dice_roller(request)
        buffer = io.BytesIO()
        with gzip.GzipFile(fileobj=buffer, mode="w") as zip_file:
            zip_file.write(response)
        return buffer.getvalue()
```

Этот декоратор сжимает входящие данные перед их отправкой клиенту. Он декорирует базовый объект **`dice_roller`**, вычисляющий ответ на запрос.

Теперь, когда имеется два декоратора, напишем код, который накладывает один декоратор на другой:

```python
def dice_response(client: socket.socket) -> None:
    request = client.recv(1024)
    try:
        remote_addr = client.getpeername()
        roller_1 = ZipRoller(dice.dice_roller)
        roller_2 = LogRoller(roller_1, remote_addr=remote_addr)
        response = roller_2(request)
    except (ValueError, KeyError) as ex:
        response = repr(ex).encode("utf-8")
    client.send(response)
```

Цель состоит в том, чтобы разделить три аспекта этого приложения.

- Архивирование полученного документа.
- Ведение журнала или запись в лог-файл (логирование).
- Выполнение базовых вычислений.

Можно архивировать или логировать любое аналогичное приложение, которое работает с приемом и отправкой байтов. При необходимости, используя динамический выбор, можно выполнить операцию архивирования. У нас может быть отдельный файл конфигурации для включения или отключения функции **`GZip`**. Например:

```python
if config.zip_feature:
	roller_1 = ZipRoller(dice.dice_roller)
else:
	roller_1 = dice.dice_roller
```

Имеется динамический набор дополнительных функций. Попробуйте написать это, используя в том числе множественное наследование, и проанализируйте результат.



#### Полезный декоратор
---

Декораторы Python также допускают параметры. **`functools.lru_cache`** ==- один из самых полезных декораторов в стандартной библиотеке.== Идея кэширования состоит в том, чтобы сохранять вычисленные результаты функции, тем самым избегая их повторного вычисления. Вместо того чтобы сохранять все параметры и результаты, мы можем уменьшить размер кэша, **отбрасывая наименее использовавшиеся (LRU)** значения. Например, ниже представлена функция, требующая потенциально дорогостоящих вычислений:

```python
>>> from math import factorial
>>> def binom(n: int, k: int) -> int:
... 	return factorial(n) // (factorial(k) * factorial(n-k))

>>> f"6-card deals: {bionom(52, 6):,d}"
'6-card deals: 20,358,520'
```

Применим декоратор **`lru_cache`**, чтобы при известном ответе избежать выполнения этих вычислений. Например, так:

```python
>>> from math import factorial
>>> from functools import lru_cache
>>> @lru_cache(64)
... def bionom(n: int, k: int) -> int:
...     return factorial(n) // (factorial(k) * factorial(n-k))
```

Параметризованный декоратор **`@lru_cache(64)`**, применяемый для создания второй версии функции **`binom()`** , сохраняет самые последние 64 результата, чтобы избежать повторного вычисления значений, если они уже были вычислены один раз. Теперь в другом месте приложения никакие изменения больше не требуются. Иногда улучшение от этого небольшого нюанса может быть значительным. Конечно, можно точно настроить размер кэша на основе данных и количества выполняемых вычислений.

Использование подобных параметризованных декораторов похоже на топтание на одном месте. Сначала мы настраиваем декоратор с параметром, затем применяем этот настроенный декоратор к определению функции. Эти два отдельных шага аналогичны действиям, когда вызываемые объекты инициализируются с помощью мeтoдa **`__init__()`** и могут быть вызваны в качестве функции с помощью метода **`__call__()`**

Рассмотрим пример настраиваемого декоратора логирования **`NamedLogger`**:

```python
class NamedLogger:
    def __init__(self, logger_name: str) -> None:
        self.logger = logging.getLogger(logger_name)

    def __call__(self, function: Callable[..., Any]) -> Callable[..., Any]:
        @wraps(function)
        def wrapped_function(*args: Any, **kwargs: Any) -> Any:
            start = time.perf_counter()
            try:
                result = function(*args, **kwargs)
                μs = (time.perf_counter() - start) * 1_000_000
                self.logger.info(f"{function.__name__}, {μs:.1f}μs")
                return result
            except Exception as ex:
                μs = (time.perf_counter() - start) * 1_000_000
                self.logger.error(f"{ex}, {function.__name__}, {μs:.1f}μs")
                raise

        return wrapped_function
```

Метод **`__init__()`** гарантирует, что для создания декоратора мы можем написать код вроде **`NamedLogger("log4")`** . Этот декоратор позаботится о том, чтобы следующая функция использовала определенный регистратор.

Метод **`__саll__()`** следует уже известному паттерну. Определяем новую функцию **`wrap_function()`** , которая делает всю работу, и возвращаем новую функцию:

```python
@NamedLogger("log4")
def test4(median: float, sample: float) -> float:
    return abs(sample - median)
```

Здесь мы создали экземпляр класса **`NamedLogger`**. Затем применили этот экземпляр к определению функции **`test4()`**. При этом вызывался метод **`__саll__()`** , который создал новую функцию, декорированную версию функции **`test4()`**.

Существует еще несколько вариантов использования синтаксиса декоратора. Например, когда декоратор является методом класса, он также сохраняет информацию о декорированной функции, создавая реестр декорированных функций. Кроме того, классы также могут быть декорированы. В этом случае декоратор возвращает новый класс вместо новой функции.

Во всех более сложных случаях мы используем обычный объектно-ориентированный дизайн с более простым синтаксисом **`@dесоrаtоr`**.



## Паттерн Наблюдатель
---

**Паттерн Наблюдатель** полезен для мониторинга состояния и ситуаций обработки событий. ==Это поведенческий паттерн==, который позволяет объектам уведомлять другие объекты об изменениях в их состоянии. ==Основной наблюдаемый объект должен реализовать интерфейс, который делает его== *наблюдаемым*.

Всякий раз, когда значение в основном объекте изменяется, он сообщает всем объектам-наблюдателям, что изменение произошло, вызывая метод, объявляющий об изменении состояния. Паттерн Наблюдатель широко используется в графических интерфейсах, чтобы убедиться, что любое изменение состояния в базовой модели отражается в представлениях модели. Обычно используются подробные и сводные представления. Изменение сведений должно также обновлять виджеты и любые отображаемые перечни. Иногда существенное изменение режима приводит к изменению ряда элементов. Например, после щелчка на значке «замок> статус отображаемых элементов изменяется на статус «заблокирован>. Это может быть реализовано в виде нескольких наблюдателей, прикрепленных к наблюдаемому виджету отображения.

В Python наблюдатель может быть уведомлен с помощью метода **`_call_()`** , благодаря чему каждый наблюдатель ведет себя как функция или другой вызываемый объект. Каждый наблюдатель при изменении основного объекта может отвечать за разные задачи. Основной объект не знает и не заботится о том, что это за задачи, а наблюдатели обычно не знают и не заботятся о том, что делают другие наблюдатели.

Это обеспечивает огромную гибкость, отделяя реакцию на изменение состояния от самого изменения.

Рассмотрим, как это выглядит на UМL-диаграмме (**`рис.11.3`**).

![[Рис. 11.З. Паттерн Наблюдатель на UМL-диаграмме.jpg]]
>   **Рис. 11.З.** Паттерн Наблюдатель на UМL-диаграмме

Здесь объект **`Core`** содержит список объектов-наблюдателей. Чтобы быть наблюдаемым, класс **`Core`** должен придерживаться общего понимания наблюдаемости. В частности, он должен предоставить список наблюдателей и способ присоединения новых наблюдателей.

Подклассы **`Observer`** включают метод **`__call__()`**. К нему обращается наблюдаемый для уведомления каждого наблюдателя об изменении состояния. Как и в случае с *паттерном Декоратор*, нет необходимости формализовать отношения с формально определенными абстрактными суперклассами. В большинстве случаев мы можем полагаться на правила утиной типизации. Пока наблюдатели имеют правильный интерфейс, их можно использовать в определенной роли. Если у них нет надлежащего интерфейса, **`mуру`** выявит конфликт, а модульный тест определит проблему.

Хороший пример паттерна наблюдатель, *система обновления цен на товар*

```python
import abc
from typing import List


class IObserver(metaclass=abc.ABCMeta):
	@abc.abstractmethod
	def update(self, p: int):
		pass


class IObservable(metaclass=abc.ABCMeta):
	@abc.abstractmethod
	def add_observer(self, o: IObserver):
		pass

	@abc.abstractmethod
	def remove_observer(self, o: IObserver):
		pass

	@abc.abstractmethod
	def notify(self):
		pass


class Product(IObservable):
	def __init__(self, price: int):
		self.__price = price
		self.__observers: List[IObserver] = []

	def change_price(self, price: int):
		self.__price = price
		self.notify()

	def add_observer(self, o: IObserver):
		self.__observers.append(o)

	def remove_observer(self, o: IObserver):
		self.__observers.remove(o)

	def notify(self):
		for o in self.__observers:
			o.update(self.__price)


class Wholesale(IObserver):
	def __init__(self, obj: IObservable):
		self.__product = obj
		obj.add_observer(self)

	def update(self, p: int):
		if p < 300:
			print(f"Оптовик закупил по цене {p}")
			self.__product.remove_observer(self)


class Buyer(IObserver):
	def __init__(self, obj: IObservable):
		self.__product = obj
		obj.add_observer(self)

	def update(self, p: int):
		if p < 350:
			print(f"Покупатель закупил по цене {p}")
			self.__product.remove_observer(self)


if __name__ == "__main__":
	product = Product(400)
	wholesale = Wholesale(product)
	buyer = Buyer(product)
	product.change_price(330)
	product.change_price(250)

```



### Пример реализации паттерна Наблюдатель
---

Вне графического интерфейса паттерн Наблюдатель полезен для сохранения промежуточных состояний объектов. ==Использование объектов-наблюдателей может быть удобно в системах, где требуется тщательный аудит изменений.== *Паттерн также хорошо себя зарекомендовал в случае ненадежной системы.*

В сложных облачных приложениях могут возникать проблемы из-за ненадежных соединений. Паттерн Наблюдатель мы можем использовать для записи изменений состояния, упрощая восстановление и перезапуск.

В примере ниже для хранения набора важных значений определим основной объект, а затем попросим одного или нескольких наблюдателей создать сериализованные копии этого объекта. Эти копии могут храниться, например, в базе данных, на удаленном хаете или в локальном файле. Поскольку наблюдателей может быть несколько, для использования разных кэшей данных настроить дизайн оказывается несложно. В нашем примере игры в кости под названием Zonk, или Zilch, или Ten Thousand игрок бросает шесть костей, набирает очки за тройки и, возможно, бросает снова, что приводит к последовательности бросков костей. В действительности правила более замысловатые, но мы не станем усложнять.

Рассмотрим следующий пример:

```python
from typing import Protocol


class Observer(Protocol):
    def __call__(self) -> None:
        ...


class Observable:
    def __init__(self) -> None:
        self._observers: list[Observer] = []  

    def attach(self, observer: Observer) -> None:
        self._observers.append(observer)

    def detach(self, observer: Observer) -> None:
        self._observers.remove(observer)

    def _notify_observers(self) -> None:
        for observer in self._observers:
            observer()
```

Класс **`Observer`** - это протокол, абстрактный суперкласс для наблюдателей. Мы не формализовали его как абстрактный класс **`аbc.АВС`**. Мы не полагаемся на ошибку времени выполнения, предлагаемую модулем **`аbс`**. При определении протокола мы рассчитываем на инструмент **`mуру`** для подтверждения того, что все наблюдатели действительно реализуют требуемый метод.

Класс **`Observable`** определяет переменную экземпляра **`_observers`** и три метода, которые являются исключительно частью определения этого протокола. Наблюдаемый объект может добавить наблюдателя, удалить его и, что наиболее важно, уведомить всех наблюдателей об изменении состояния. Единственное, что должен сделать базовый класс, чтобы он был особенным или отличался от других, - при изменении состояния вызвать метод **`_notify_observers()`**.

Класс **`Observable`** определяет переменную экземпляра **`_observers`** и три метода, которые являются исключительно частью определения этого протокола. ==Наблюдаемый объект может добавить наблюдателя, удалить его и, что наиболее важно, уведомить всех наблюдателей об изменении состояния==. Единственное, что должен сделать базовый класс, чтобы он был особенным или отличался от других, - при изменении состояния вызвать метод **`_notify_observers()`**.

Соответствующее уведомление является важной частью дизайна наблюдаемого объекта.

Рассмотрим интересующую нас часть игры Zonk в следующем примере:

```python
from typing import List


Hand = List[int]


class ZonkHandHistory(Observable):
    def __init__(self, player: str, dice_set: Dice) -> None:
        super().__init__()
        self.player = player
        self.dice_set = dice_set
        self.rolls: list[Hand]

    def start(self) -> Hand:
        self.dice_set.roll()
        self.rolls = [self.dice_set.dice]
        self._notify_observers()  # Изменение состояния
        return self.dice_set.dice()

    def roll(self) -> Hand:
        self.dice_set.roll()
        self.rolls.append(self.dice_set.dice)
        self._notify_observers()  # Изменения состояния
        return self.dice_set.dice

```

При важных изменениях состояния этот класс вызывает **`self._not ify_observers()`**, тем самым уведомляя все экземпляры наблюдателя. Наблюдатели могут кэшировать копии бросков, отправлять данные по сети, обновлять виджеты в графическом интерфейсе и многое другое. Метод **`_notify_observers()`**, унаследованный от **`Observable`**, перебирает всех зарегистрированных наблюдателей и сообщает каждому, что состояние бросков изменилось.

Теперь реализуем простой объект-наблюдатель, выводящий некоторое состояние на консоль:

```python
class SaveZonkHand(Observer):
    def __init__(self, hand: ZonkHandHistory) -> None:
        self.hand = hand
        self.count = 0

    def __call__(self) -> None:
        self.count += 1
        message = {
            "player": self.hand.player,
            "sequence": self.count,
            "hands": json.dumps(self.hand.rolls),
            "time": time.time(),
        }
        print(f"SaveZonkHand {message}")

```

Здесь нет ничего особенно сложного. Наблюдаемый объект настраивается в инициализаторе, и, когда вызывается наблюдатель, мы *что-то* делаем, например, как в коде выше, выводим строку. Обратите внимание, что суперкласс **`Observer`** в данном случае фактически не нужен. Контекст, в котором используется этот класс, достаточен для **`mуру`**, чтобы подтвердить, что рассматриваемый класс соответствует требуемому протоколу **`Observer`**. Хотя нам не нужно указывать, что это **`Observer`**, это может помочь проанализировать, что данный класс реализует протокол **`Observer`**.

В интерактивной консоли протестируем наблюдатель **`SaveZonkHand`**:
```python
>>> d = Dice.from_text("6d6")
>>> player = ZonkHandHistory("Bo", d)
>>>
>>> save_history = SaveZonkHand(player)
>>> player.attach(save_history)
>>> r1 = player.start()
SaveZonkHand {'player': 'Bo', 'sequence': 1, 'hands': '[[3, 4, 4, 4, 4, 6]]', 'time': 1719390993.790934}
>>> r1
[3, 4, 4, 4, 4, 6]
>>> r2 = player.roll()
SaveZonkHand {'player': 'Bo', 'sequence': 2, 'hands': '[[3, 4, 4, 4, 4, 6], [1, 1, 2, 5, 5, 6]]', 'time': 1719391051.5066156}
```

После присоединения наблюдателя к объекту **`Inventory`** всякий раз, когда изменяется одно из двух наблюдаемых свойств, вызывается наблюдатель и его действие. Обратите внимание, что наблюдатель отслеживает порядковый номер и включает временную метку. Метки не входят в определение игры и отделены от основной ее обработки, поскольку являются частью класса наблюдателя **`SaveZonkHand`**.

Мы можем добавить несколько наблюдателей различных классов. Например, добавим второй наблюдатель, у которого есть ограниченная работа по проверке трех пар, и объявим об этом:

```python
class ThreePairZonkHand:
    """Observer of ZonkHandHistory"""
    def __init__(self, hand: ZonkHandHistory) -> None:
        self.hand = hand
        self.zonked = False  

    def __call__(self) -> None:
        last_roll = self.hand.rolls[-1]
        distinct_values = set(last_roll)
        self.zonked = len(distinct_values) == 3 and all(
            last_roll.count(v) == 2 for v in distinct_values
        )
        if self.zonked:
            print("3 Pair Zonk!")

```

В данном примере мы не определяем **`Observer`** в качестве суперкласса. Мы доверились инструменту **`mуру`**, который заметит, как используется этот класс и какие протоколы тот должен реализовывать.

Добавление нового наблюдателя **`ThreePairZonkHand`** означает, что при изменении состояния броска может быть два набора выходных данных, по одному для каждого Наблюдателя. Основная идея здесь заключается в том, что мы можем легко добавлять совершенно разные типы наблюдателей, чтобы выполнять разные действия, в данном случае копировать данные, а также в особых случаях проверять их.

**Паттерн Observer** ==отделяет код, за которым наблюдают, от кода, выполняющего наблюдение.== Если бы мы не использовали этот паттерн, нам пришлось бы поместить код в класс **`ZonkHandHistory`** для обработки различных случаев: записи на консоль, обновления базы данных или файла, проверки особых случаев и пр. Весь код для каждой из этих задач смешался бы с определением базового класса. Поддерживать его было бы сложно, а добавление новых функций мониторинга на более позднем этапе было бы очень болезненным.




## Паттерн Стратегия
---

**Паттерн Стратегия** - обычная демонстрация абстракции в ООП. ==Это поведенческий паттерн, объединяющий набор алгоритмов в отдельные классы и делающий их взаимозаменяемыми.== Другие объекты содержат ссылку на объект стратегии и делегируют ему работу.

Как правило, разные алгоритмы имеют разные решения. Один может быть быстрее другого, но использовать намного больше памяти, тогда как третий может быть наиболее подходящим, только когда присутствует несколько ЦП или предоставляется распределенная система.

Рассмотрим, как это выглядит на UМL-диаграмме (**рис. 11.4**).

![[Рис. 11.4 Паттерн Стратегия на UМL-диаграмме.jpg]]
>   Рис. 11.4 Паттерн Стратегия на UМL-диаграмме

Код ядра, подключающийся к абстракции **Стратегия**, просто должен знать, что он имеет дело с каким-то классом, соответствующим интерфейсу **Стратегии**, для данного конкретного действия. Каждая из реализаций должна выполнять одну и ту же задачу, но по-разному. Интерфейсы реализации должны быть идентичными, и часто полезно использовать абстрактный базовый класс, чтобы убедиться, что реализации совпадают.

>[!tip]
>Идея стратегии подключаемых модулей также является аспектом **паттерна Наблюдатель**. Действительно , объект стратегии - важный компонент многих паттернов, рассматриваемых в этой главе. Общая идея состоит в том, чтобы использовать отдельный объект для изоляции условной или заменяемой обработки и делегирования работы отдельному объекту. Это работает для наблюдаемых декорированных объектов и, как мы увидим в дальнейшем, для команд и состояний.



### Пример реализации паттерна Стратегия
---

Одним из распространенных примеров паттерна Стратегия являются процедуры сортировки. Существует множество алгоритмов для сортировки объектов. Быстрая сортировка, сортировка слиянием и сортировка с использованием кучи - все это алгоритмы с различными реализациями, каждый из которых полезен, в зависимости от размера и типа входных данных, степени их неупорядоченности и требований системы.

Если у нас есть клиентский код, которому необходимо отсортировать коллекцию, можем передать его объекту с помощью метода **`sort()`**. Этот объект может быть объектом **`QuickSorter`** или **`MergeSorter`**, но в любом случае результат будет одинаковым: отсортированный список. Стратегия, используемая для сортировки, абстрагирована от вызывающего кода, что делает её модульной и заменяемой.

Конечно, в Python мы обычно просто вызываем функцию **`sorted()`** или метод **`list.sort()`** и надеемся, что сортировка будет выполнена достаточно быстро, так что детали алгоритма **TimSort** не имеют значения. Более подробно о том, насколько быстро работает **TimSort**, можно прочитать на сайте https://bugs.python.org/file4451/timsort.txt. Хотя сортировка считается полезным приемом, это не самый практичный пример, поэтому сейчас рассмотрим другой.

В качестве более простого примера паттерна проектирования Стратегия рассмотрим менеджер обоев Рабочего стола . Когда изображение служит фоном Рабочего стола , его можно подогнать под размер экрана различными способами. Например, если предположить, что изображение меньше экрана, его можно расположить на экране в виде мозаики, центрировать или масштабировать по размеру экрана. Можно использовать и другие, более сложные стратегии, такие как масштабирование до максимальной высоты или ширины, комбинирование со сплошным, полупрозрачным или градиентным цветом фона и пр. Мы, возможно, и добавим все эти стратегии позже, но начнем с нескольких основных.

Вам необходимо будет установить модуль **`pillow`**. Если для управления виртуальными средами вы используете **conda**, выполните команду `conda install pillow` для установки реализации PIL проекта Pillow. Если вы не используете **conda**, введите команду `python -m pip install pillow`.

Объекты Стратегии должны принимать два входных параметра: отображаемое изображение и кортеж ширины и высоты экрана. Каждый из них возвращает новое изображение с размером, соответствующим размеру экрана, при этом изображение подгоняется в соответствии с заданной стратегией.

Рассмотрим следующий пример:

```python
import abc
from pathlib import Path
from PIL import Image  #:ignore[import]
from typing import Tuple

Size = Tuple[int, int]
 

class FillAlgorithm(abc.ABC):
    @abc.abstractmethod
    def make_background(self, img_file: Image, desktop_size: Size) ->          Image:
        pass
```

Действительно ли нужна эта абстракция? Пожалуй, рассматриваемую ситуацию можно оценить как что-то между слишком простой, чтобы требовать абстракции, и достаточно сложной, чтобы хотеть помочь суперклассу. Сигнатура функции довольно сложная, со специальной подсказкой типа для описания размера кортежа. По этой причине абстракция здесь поможет проверить каждую реализацию, чтобы убедиться, что все типы совпадают.

Обратите внимание, что необходимо включить специальный комментарий **`#:ignore[import]`** , чтобы убедиться, что **`mуру`** не запутается из-за отсутствия аннотаций в модулях PIL.

Рассмотрим нашу первую конкретную стратегию. Это полный алгоритм, который отображает изображения в виде мозаики:

```python
class TiledStrategy(FillAlgorithm):
    def make_background(self, img_file: Path, desktop_size: Size) -> Image:
        in_img = Image.open(img_file)
        out_img = Image.new("RGB", desktop_size)
        num_titles = [
            o // i + 1 for o, i in zip(out_img.size, in_img.size)
        ]
        for x in range(num_titles[0]):
            for y in range(num_titles[1]):
                out_img.paste(in_img, (
                    in_img.size[0] * x,
                    in_img.size[1] * y,
                    in_img.size[0] * (x + 1),
                    in_img.size[1] * (y + 1),
                ))
        return out_img
```

Это работает путем деления высоты и ширины результирующего изображения на высоту и ширину входного изображения. Последовательность **`num_tiles`** - способ выполнения одних и тех же вычислений для ширины и высоты. Здесь мы задействовали два кортежа, вычисляемые с помощью представления списка, чтобы быть уверенными, что ширина и высота обрабатываются одинаково.

Ниже приведен алгоритм, который центрирует изображение без его повторного масштабирования:

```python
class CentredStrategy(FillAlgorithm):
    """Алгоритм, который центрирует изображение без его повторного                               масштабирования"""

    def make_background(self, img_file: Path, desktop_size: Size) -> Image:
        in_img = Image.open(img_file)
        out_img = Image.new("RGB", desktop_size)
        left = (out_img.size[0] - in_img.size[0]) // 2
        top = (out_img.size[1] - in_img.size[1]) // 2
        out_img.paste(
            in_img,
            (left, top, left + in_img.size[0], top + in_img.size[0]),
        )
        return out_img

```

Наконец, при ведем алгоритм , который масштабирует изображение, чтобы заполнить весь экран:

```python
class ScaledStrategy(FillAlgorithm):
"""Алгоритм, который масштабирует изображение, чтобы заполнить весьэкран"""
    def make_background(self, img_file: Path, desktop_size: Size) -> Image:
        in_img = Image.open(img_file)
        out_img = in_img.resize(desktop_size)
        return out_img

```

Здесь присутствуют три подкласса стратегии, каждый из которых использует **`PIL.Image`** для выполнения своей задачи. Все реализации стратегии имеют метод **`make_background()`**, принимающий одинаковый набор параметров. После выбора соответствующий объект Стратегии может быть вызван для создания версии изображения Рабочего стола правильного размера. Класс **`TiledStrategy`** вычисляет количество фрагментов входного изображения, которое вмещается по ширине и высоте экрана, и многократно копирует изображение в каждое место фрагмента без изменения масштаба, поэтому оно может не заполнить все пространство. Класс **`CenteredStrategy`** определяет количество пространства, которое необходимо оставить по четырем краям изображения для его центрирования. Класс **`ScaledStrategy`** приводит изображение к выходному размеру без сохранения исходного соотношения сторон.

Ниже в коде представлен общий объект, который изменяет размер, используя один из классов Стратегии. Переменная экземпляра алгоритма заполняется при создании экземпляра **`Resizer`**:

```python
class Resizer:
    def __init__(self, algorithm: FillAlgorithm) -> None:
        self.algorithm = algorithm  

    def resize(self, image_file: Path, size: Size) -> Image:
        result = self.algorithm.make_background(image_file, size)
        return result

```

А в следующем коде представлена основная функция, которая создает экземпляр класса **`Resizer`** и применяет один из доступных классов Стратегии:

```python
def main() -> None:
    image_file = Path.cwd() / "Yog-sototh.jpg"
    tiled_desktop = Resizer(TiledStrategy())
    tiled_image = tiled_desktop.resize(image_file, (1920, 1080))
    tiled_image.show()
```

Важно то, что привязка экземпляра Стратегии происходит в процессе работы: решение в любой момент может быть принято (и отменено), поскольку любой из доступных объектов стратегии может быть в любое время подключен к объекту **`Resizer`**.

Проанализируйте сами, как было бы реализовано переключение между этими вариантами без **паттерна Стратегия**. Необходимо было бы поместить весь код в один большой метод и использовать не очень подходящий в данном случае оператор **`if`**. Каждый раз при необходимости добавить новую стратегию пришлось бы делать метод еще более непонятным.



#### Стратегия в Python
---

Предыдущая каноническая реализация **паттерна Стратегия** хотя и очень распространена в большинстве объектно-ориентированных библиотек, но для Python неидеальна. Это связано с некоторыми издержками, которые в действительности не нужны.

Каждый из описанных классов стратегий определяет объекты, которые н ничего не делают, кроме предоставления одного метода. Но ведь так же легко вызвать саму функцию **`__call__`** и сделать объект вызываемым напрямую. Поскольку с объектом не связаны никакие другие данные, нам необходимо создать набор функции верхнего уровня и вместо этого передать в качестве наших стратегий.

Вместо абстрактного класса мы можем обобщить эти стратегии с подсказкой типа:

```python
FillAlgorithm = Callble[[Image, Size], Image]
```

После такого действия в определениях классов мы можем удалить вес ссылки на **`FillAlgorithm`**. Класс **`CenteredStrategy(FillAlgorithm)`** : изменится на класс **`CenteredStrategy`**:

Существует четкое правило, отделяющее определения классов примесей от объектов стратегии подключаемых модулей. Как мы уже изучали в [[Абстрактные классы и перегрузка операторов]], определения классов примесей создаются в исходном коде и во время выполнения не могут быть легко изменены.

Однако подключаемый объект **Стратегия** заполняется во время выполнения, что позволяет произвести позднее связывание стратегии. Код между ними, как правило, очень похож, и полезно иметь для каждого класса конкретные строки документации, чтобы объяснить, как различные классы сочетаются друг с другом.





## Паттерн Команда
---

В соответствии с обязанностями классы подразделяются на *пассивные*, которые содержат объекты и поддерживают внутреннее состояние, но мало что инициируют, и *активные*, которые обращаются к другим объектам, чтобы предпринимать и выполнять, определенные действия.

Это не очень четкое разделение, но оно помогает отличить относительно *пассивный Наблюдатель*, от более *активного паттерна проектирования Команда*. **Наблюдатель** уведомляет о том что, что-то изменилось. **Паттерн Команда**, со своей стороны, будет проявлять активность, изменяя состояние других объектов.

**Паттерн Команда** обычно включает иерархию классов, каждый из которых что-то делает. Класс **`Core`**, например, создает команду (или последовательность команд) для выполнения действий.

Это своего рода метапрограммирование: создание объектов **`Command`**, которые содержат набор операторов, позволяющих проектировать «язык» объектов **`Command`** более высокого уровня.

Рассмотрим, как это выглядит на UМL-диаграмме (**рис. 11.5**).

![[Рис. 11 .5. Паттерн Команда на UМL-диаграмме.jpg]]
>   **Рис. 11.5.** Паттерн Команда на UМL-диаграмме

Хороший пример паттерна Команда, на примере пульта управление конвейерной установкой:

```python
import abc
from typing import List, Deque
 

class ICommand(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def positive(self):
        ...  

    @abc.abstractmethod
    def negative(self):
        ...
 

class Conveyor:
    def on(self):
        print("Конвеер запущен.")

    def off(self):
        print("Конвеер остановлен.")

    def speed_increase(self):
        print("Увеличена скорость конвеера.") 

    def speed_decrease(self):
        print("Снижена скорость конвеера.")
  

class ConveyorWorkCommand(ICommand):
    def __init__(self, conveyor: Conveyor):
        self.conveyor: Conveyor = conveyor

    def positive(self):
        self.conveyor.on()  

    def negative(self):
        self.conveyor.off() 
  

class ConveyorAdjustCommand(ICommand):
    def __init__(self, conveyor: Conveyor):
        self.conveyor: Conveyor = conveyor

    def positive(self):
        self.conveyor.speed_increase()

    def negative(self):
        self.conveyor.speed_decrease()
  

class Multipult:
    def __init__(self):
        self.__commands: List[ICommand] = [None, None]
        self.__history: Deque[ICommand] = [] 

    def set_command(self, button: int, command: ICommand):
        self.__commands[button] = command 

    def press_on(self, button: int):
        self.__commands[button].positive()
        self.__history.append(self.__commands[button])

    def press_cancel(self):
        if len(self.__history) != 0:
            self.__history.pop().negative()
  

if __name__ == "__main__":
    conveyor = Conveyor()

    multipult = Multipult()
    multipult.set_command(0, ConveyorWorkCommand(conveyor))
    multipult.set_command(1, ConveyorAdjustCommand(conveyor))

    multipult.press_on(0)
    multipult.press_on(1)
    multipult.press_cancel()
    multipult.press_cancel()
```
```output
Конвеер запущен.
Увеличена скорость конвеера.
Снижена скорость конвеера.
Конвеер остановлен.
```




### Пример реализации паттерна Команда
---

В качестве примера рассмотрим бросок игральной кости, который был исключен из примера **паттерна Декоратор**. В предыдущем примере мы использовали функцию **`dice_roller()`** , которая вычисляла последовательность случайных чисел:

```python
def dice_roller(request: bytes) -> bytes:
	request_text = request.decode("utf-8")
	numbers = [random.randint(1, 6) for _ in range(6)]
	response = f"{request_text} = {numbers}"
	return response.encode("utf-8")
```

Не самый подходящий пример. Мы бы предпочли что-то более сложное. Например, пусть необходимо иметь возможность записывать такие строки, как **`3d6`**, означающие три шестигранных кубика, **`3d6+2`**, то есть три шестигранных кубика плюс бонус в виде еще двух. Или даже что-то еще более замысловатое, например **`4d6d1`**, означающее «бросьте четыре шестигранных кубика и бросьте один из кубиков с наименьшим значением». Чтобы осуществить такое, понадобится объединить элементы и написать **`4d6d1+2`**, а также объединить отбрасывание наименьшего и добавление двух к результату.

Опции d1 и +2 можно рассматривать как серию команд. Существует четыре распространенных варианта: «отбросить», «сохранить», «добавить» и «вычесть».

Конечно, их может быть намного больше, чтобы отразить большое разнообразие игровых механик и желаемых статистических распределений, но мы рассмотрим именно четыре команды, которые влияют на набор костей.

Разберем следующий пример:

```python
dice_pattern = re.compile(r"(?P<n>\d *)d(?P<d>\d+)(?P<a>[dk+-]\d+)*")
```

Это регулярное выражение кажется немного сложным и пугающим. Некоторые специалисты считают полезными синтаксические диаграммы, приведенные на сайте https://www.debuggex.com. Взгляните, как это выглядит на UМL-диаграмме (**рис. 11.6**).

![[Рис. 11.6. Регулярное выражение, имитирующее броски кубиков.jpg]]
>   **Рис. 11.6.** Регулярное выражение, имитирующее броски кубиков

Данный паттерн состоит из четырех частей.

1. Первая группа **`(?P<n>\d*)`** включает в себя набор цифр для количества игральных костей, сохраняя его как группу **`n`**. Это не обязательно, но позволяет нам писать **`d6`** вместо **`1d6`**.
2. Символ **`d`**, который должен присутствовать, но не включен.
3. Следующая группа **`(?P<d>\d+)`** фиксирует цифры количества граней на каждом кубике, сохраняя их как группу d. Можем попытаться ограничить это до (4|6|10|12|20|100) , чтобы определить приемлемый список правильных многогранных игральных костей (и двух обычных неправильных многогранников). Мы не предоставили этот краткий список. Вместо него примем любую последовательность цифр.
4. Окончательная группа **`(?Р<а>[dk+-]\d+)*`** определяет повторяющийся ряд корректировок. У каждой имеется префикс и последовательность цифр, например d1 или kЗ, или +1, или -2. Зафиксируем всю последовательность корректировок как группу А и выделим части по отдельности. Каждая из этих частей станет командой в соответствии с паттерном **проектирования Команда**.

Примем, что каждая часть броска костей - отдельная команда. Одна команда определяет бросок костей, а затем с помощью последующих команд корректируются значения костей. Скажем, Зd6+2 означает бросок трех кубиков (например, 4], 4], 3]) и добавление 2, чтобы получить в сумме 13. В целом класс выглядит следующим образом:

```python
class Dice:
    def __init__(self, n: int, d: int, *adj: Adjustment) -> None:
        self.adjustments = [cast(Adjustment, Roll(n, d))] + list(adj)
        self.dice: list[int]
        self.modifier: int

    def roll(self) -> int:
        for a in self.adjustments:
            a.apply(self)
        return sum(self.dice) + self.modifier
```

При необходимости нового броска костей объект Dice применяет для создания нового броска отдельные объекты **`Adjustment`**. В методе **`__init__()`** показан один из видов объектов **`Adjustment`**: объект **`Roll`**. Сначала это добавляется в последовательность корректировок. Потом любые дополнительные корректировки обрабатываются по порядку. Каждая корректировка - другой вид команды.

Ниже приведены виды команд настройки, изменяющие состояние объекта **`Dice`**:

```python
class Adjustment(abc.ABC):
    def __init__(self, amount: int) -> None:
        self.amount = amount

    @abc.abstractmethod
    def apply(self, dice: "Dice") -> None:
        ...


class Roll(Adjustment):
    def __init__(self, n: int, d: int) -> None:
        self.n = n
        self.d = d

    def apply(self, dice: "Dice") -> None:
        dice.dice = sorted(random.randint(1, self.d) for _ in                                  range(self.n))
        dice.modifier = 0

class Drop(Adjustment):
    def apply(self, dice: "Dice") -> None:
        dice.dice = dice.dice[self.amount:]


class Keep(Adjustment):
    def apply(self, dice: "Dice") -> None:
        dice.dice = dice.dice[: self.amount]


class Plus(Adjustment):
    def apply(self, dice: "Dice") -> None:
        dice.modifier += self.amount


class Minus(Adjustment):
    def apply(self, dice: "Dice") -> None:
        dice.modifier -= self.amount

```





## Паттерн Состояние
---

**Паттерн Состояние** структурно подобен **паттерну Стратегия**, но его назначение очень отличается от назначения **Стратегии**. Целью шаблона Состояние является представление систем переходов состояний: систем, в которых поведение объекта ограничено состоянием, в котором он находится, и возможны только узко определенные переходы в другие состояния.

Для этого необходим контекстный менеджер или класс, предоставляющий интерфейс для переключения состояний. Внутри этот класс содержит указатель на текущее состояние. Каждый объект знает, в каких других состояниях ему разрешено находиться, и будет переходить в эти состояния в зависимости от совершаемых над ним действий.

Рассмотрим, как это выглядит на UМL-диаграмме (**рис. 11.7**).

**Паттерн Состояние** разбивает проблему на два типа классов: класс **`Core`** и несколько классов **`State`**. Класс **`Core`** поддерживает текущее состояние и перенаправляет действия объекту текущего состояния. Объекты **`State`** обычно скрыты от любых других объектов, вызывающих объект **`Core`**. Они действуют как черный ящик, который выполняет внутреннее управление состоянием.

![[Рис. 11.7. Паттерн Состояние на UМL-диаграмме.jpg]]
>   Рис. 11.7. Паттерн Состояние на UМL-диаграмме

Хороший пример паттерна Состояние, в виде светофора:
```python
import abc


class State(metaclass=abc.ABCMeta):
    def __init__(self):
        self._traffic_light: "TrafficLight" = None

    @abc.abstractmethod
    def next_state(self):
        pass

    @abc.abstractmethod
    def previous_state(self):
        pass


class TrafficLight:
    def __init__(self, st: State):
        self.set_state(st)

    def set_state(self, st: State):
        self.__state = st
        self.__state._traffic_light = self

    def next_state(self):
        self.__state.next_state()

    def previous_state(self):
        self.__state.previous_state()


class GreenState(State):
    def next_state(self):
        print("Из зеленного в желтый.")
        self._traffic_light.set_state(YellowState())

    def previous_state(self):
        print("Зеленый цвет.")


class YellowState(State):
    def next_state(self):
        print("Из желтого в красный.")
        self._traffic_light.set_state(RedState())

    def previous_state(self):
        print("Из желтого в зеленый.")
        self._traffic_light.set_state(GreenState())


class RedState(State):
    def next_state(self):
        print("Красный цвет.")

    def previous_state(self):
        print("Из красного в желтый.")
        self._traffic_light.set_state(YellowState())


if __name__ == "__main__":
    traffic_light = TrafficLight(YellowState())

    traffic_light.next_state()
    traffic_light.next_state()

    traffic_light.previous_state()
    traffic_light.previous_state()
    traffic_light.previous_state()
```
```output
Из желтого в красный.
Красный цвет.
Из красного в желтый.
Из желтого в зеленый.
Зеленый цвет.
```




### Пример реализации паттерна Состояние
---

Одним из наиболее подходящих примеров обработки, зависящей от состояния, является синтаксический анализ текста. При написании регулярного выражения мы детализируем ряд альтернативных изменений состояния, используемых для сопоставления шаблона с образцом текста. На более высоком уровне синтаксический анализ текста языка программирования или языка разметки также является работой с необходимостью тщательного сохранения состояния.

Языки разметки, такие как XML, HTML, УAML, TOML или даже reStructuredText и Markdown, учитывают правила отслеживания состояния для определения того, что разрешено, а что - нет.

Рассмотрим относительно простую ситуацию, возникающую при решении проблем Internet of Things ([[IoT (Internet of Things)|IoT]]) . Поток данных от GРS-приемника представляет собой интересное явление. Операторы синтаксического анализа этого языка являются примером шаблона проектирования Состояние. Самим языком является общепринятый стандарт представления навигационных данных в текстовом формате (ASCII)NMEA0183.

Выходной сигнал GРS-антенны - поток байтов, образующих последовательность «предложений». Каждое предложение начинается с символа **`$`**, состоит из печатных символов в кодировке ASCII и заканчивается символом возврата каретки и символом новой строки. Выходные данные устройства GPS включают в себя несколько различных типов предложений, в том числе следующие:

- GPRMC - рекомендуемый минимум навигационных данных;
- GPGGA - данные о последнем определении местоположения;
- GPGLL - широта и долгота;
- GPGSV - количество видимых спутников;
- GPGSA - активные спутники.

На самом деле сообщений гораздо больше, они исходят из антенного устройства с высокой скоростью. Все сообщения имеют общий формат, что облегчает их проверку и фильтрацию, поэтому мы можем использовать только подходящие и игнорировать те, которые не предоставляют полезной информации для нашего конкретного приложения.

Стандартное сообщение выглядит следующим образом:

```shell
$GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41
```

Это предложение имеет следующую структуру.
![[таблица gps cимволов.jpg]]

Почти все сообщения от GPS, как уже сказано выше, имеют одинаковую структуру. Исключительные сообщения будут начинаться с символа **`!`**, и наш код будет их игнорировать.

При создании устройств IoT необходимо учитывать два усложняющих фактора.

- Все в мире не очень надежно, а это означает, что наше программное обеспечение должно быть готово к поврежденным или неполным сообщениям.
- Устройства крошечные, и некоторые распространенные методы Python, которые работают на большом портативном компьютере общего назначения, не будут корректно работать на крошечном чипе Circuit Playground Express с объемом памяти всего 32 Кбайт.

Что нам необходимо делать, так это прочитать и проверить сообщение по мере поступления байтов. Проверка при приеме данных экономит время (и память). Для этих сообщений GPS существует определенная верхняя граница длины 82 байта, поэтому в качестве площадки для обработки байтов сообщения будем использовать структуры Python **`bytearray`**.

Процесс чтения сообщения имеет несколько различных состояний. На следующей диаграмме перехода состояния (**`рис. 11.8`**) показаны доступные изменения состояния.

![[Рис. 11.8. Переходы состояний для разбора предложений NMEA.jpg]]
>  **Рис. 11.8.** Переходы состояний для разбора предложений NMEA

Мы начинаем в состоянии ожидания следующего символа **`$`**. Предположим, что устройства IoT имеют проблемы с питанием и с проводами. Конечно, некоторые специалисты умеют хорошо паять, поэтому ненадежность может их так не беспокоить, как нас.

Как только получим символ **`$`**, перейдем в состояние чтения пятисимвольного заголовка. Если в какой-то момент получим еще один символ **`$`**, это будет означать, что какие-то байты были утеряны и нужно начинать сначала. Когда будем иметь в наличии все пять символов имени сообщения, можем перейти к чтению тела сообщения, которое должно содержать до *73 дополнительных байтов*. Получение символа **`*`** означает, что мы находимся в конце тела сообщения. Обнаружение в потоке символа **`$`** означает, что что-то не так и мы должны выполнить перезапуск.

Последние два байта (после символа **`*`**) представляют собой шестнадцатеричное значение, которое должно равняться вычисленной контрольной сумме предыдущего сообщения (заголовка и тела). Если контрольная сумма верна, сообщение может быть использовано приложением. В конце сообщения будет один или несколько <пробельных> символов - обычно это символы возврата каретки и новой строки.

Каждое из этих состояний мы можем представить как расширение следующего класса:

```python
class NMEA_State:
    def __init__(self, message: "Message") -> None:
        self.message = message

    def feed_byte(self, input: int) -> "NMEA_State":
        return self

    def valid(self) -> bool:
        return False

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.message})"

```

Для работы с объектом **`Message`** мы определили каждое состояние. Некий объект чтения будет передавать байт в текущее состояние, оно будет что-то делать с байтом (обычно сохранять его) и возвращать следующее состояние. Точное поведение зависит от полученного байта. Например, большинство состояний при получении символа **`$`** сбрасывают буфер сообщений до пустого, и переходят в состояние **`Header`**. Большинство состояний для функции **`valid()`** возвращают **`False`**. Одно состояние будет проверять полное сообщение и, возможно, если контрольная сумма верна, для функции **`valid()`** возвращать **`True`**.

Объект **`Message`** является оболочкой двух структур **`bytearray`**, в которых накапливается содержимое сообщения:

```python
class Message:
    def __init__(self) -> None:
        self.body = bytearray(80)
        self.checksum_source = bytearray(2)
        self.body_len = 0
        self.checksum_len = 0
        self.checksum_computed = 0

    def reset(self) -> None:
        self.body_len = 0
        self.checksum_len = 0
        self.checksum_computed = 0

    def body_append(self, input: int) -> int:
        self.body[self.body_len] = input
        self.body_len += 1
        self.checksum_computed ^= input
        return self.body_len

    def checksum_append(self, input: int) -> int:
        self.checksum_source[self.checksum_len] = input
        self.checksum_len += 1
        return self.checksum_len

    @property
    def valid(self) -> bool:
        return (
            self.checksum_len == 2
            and int(self.checksum_source, 16) == self.checksum_computed
        )
```

Определение класса **`Message`** инкапсулирует многое из того, что важно в каждом предложении, поступающем от GРS-устройства. Для накопления байтов в теле сообщения и накопления контрольной суммы этих байтов определен метод **`body_append()`**.

Для вычисления контрольной суммы используется оператор **`^=`** настоящий оператор Python, побитовое **исключающее** **ИЛИ**. **Исключающее ИЛИ** означает •одно или другое, но не оба•. Например: **`bin(ord(b'а')^ord(b'z'))`**. Биты в **`b'z'`** равны **`0b1100001`**. Биты в **`b'z'`** равны **`0b111010`**. Применяя к битам •одно или другое, но не оба•, **исключающее ИЛИ**, получим **`0b0011011`**.

Рассмотрим пример считывателя, который создает действительные объекты **`Message`**, претерпевая ряд изменений состояния по мере получения байтов:

```python
class Reader:
    def __init__(self) -> None:
        self.buffer = Message()
        self.state: NMEA_State = Waiting(self.buffer)

    def read(self, source: Iterable[bytes]) -> Iterator[Message]:
        for byte in source:
            self.state = self.state.feed_byte(cast(int, byte))
            if self.buffer.valid:
                yield self.buffer
                self.buffer = Message()
                self.state = Waiting(self.buffer)

```

Начальное состояние является экземпляром класса **`Waiting`**, подкласса **`NMEA_State`**. Метод **`read()`** использует один байт из ввода, а затем для обработки передает его текущему объекту **`NMEA_State`**. Объект состояния может сохранить байт или отбросить его, может перейти в другое состояние или вернуть текущее.

Если метод состояния **`valid()`** имеет значение **`True`**, сообщение завершено и мы можем передать его для дальнейшей обработки нашим приложением.

Обратите внимание, что мы повторно используем массивы байтов объекта **`Message`** до тех пор, пока он не будет полным и действительным. Такая политика позволяет избежать выделения и освобождения большого количества объектов, игнорируя при этом неполные сообщения на зашумленной линии. Это нетипично для программ Python на больших компьютерах.

В некоторых приложениях нам не нужно сохранять исходное сообщение, необходимо сохранить только значения нескольких полей, что еще больше сокращает объем используемой памяти.

Для повторного использования буфера в объекте **`Message`** необходимо убедиться, что он не является частью какого-либо конкретного объекта **`State`**. Мы сделали текущий объект **`Message`** частью общего Reader, а в качестве значения аргумента каждому состоянию предоставили рабочий объект **`Message`**.

Теперь, когда контекст ясен, рассмотрим пример классов для реализации различных состояний неполного сообщения. Начнем с состояния ожидания начала сообщения, с символа **`$`**. При обнаружении символа **`$`** синтаксический анализатор переходит в новое состояние, **`Header`**:

```python
class Waiting(NMEA_State):
    def feed_byte(self, input: int) -> NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        return self
```

Находясь в состоянии **`Header`**, мы обнаруживаем символ **`$`** и ждем пять символов, идентифицирующих передатчик сообщений (GP) и тип предложения (например, GLL).

Мы будем накапливать байты, пока не получим пять, а затем перейдем в состояние **`Body`**:

```python
class Header(NMEA_State):
    def __init__(self, message: "Message") -> None:
        self.message = message
        self.message.reset()

    def feed_byte(self, input: int) -> NMEA_State:
        if input == ord(b"$"):
            # Reset any accumulated bytes
            return Header(self.message)
        size = self.message.body_append(input)
        if size == 5:
            return Body(self.message)
        return self

```

Состояние **`Body`** - это состояние, в котором накапливается большая часть сообщения. Для некоторых приложений мы можем применить дополнительную обработку и при получении необходимого типа сообщения вернуться к ожиданию заголовков. При работе с устройствами, производящими большое количество данных, это может немного сократить время обработки.

Когда приходит символ **`*`**, тело готово, и следующие два байта должны быть частью контрольной суммы. Это означает переход в состояние **`Checksum`**:

```python
class Body(NMEA_State):
    def feed_byte(self, input: int) -> NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        if input == ord(b"*"):
            return Checksum(self.message)
        self.message.body_append(input)
        return self

```

Состояние **`Checksum`** похоже на накопление байтов в состоянии **`Header`**: мы ожидаем определенное количество входных байтов. После вычисления контрольной суммы за большинством сообщений следуют символы ASCII **`\r`** и **`\n`**. Если мы получаем любой из них, то переходим в состояние End, где можем игнорировать лишние символы:

```python
class Checksum(NMEA_State):
    def feed_byte(self, input: int) -> NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        if input in {ord(b"\n"), ord(b"\r")}:
            # Incomplete checksum... Will be invalid.
            return End(self.message)
        size = self.message.checksum_append(input)
        if size == 2:
            return End(self.message)
        return self

```

Состояние **`End`** имеет дополнительную функцию: оно по умолчанию переопределяет метод **`valid()`**.

Для всех остальных состояний метод **`valid()`** имеет значение **`False`**. При получении полного сообщения определение класса этого состояния изменяет правило валидности: теперь, чтобы сравнить вычисленную контрольную сумму с окончательными байтами контрольной суммы и понять, валидно ли сообщение, мы зависим от класса **`Message`**:

```python
class End(NMEA_State):
    def feed_byte(self, input: int) -> NMEA_State:
        if input == ord(b"$"):
            return Header(self.message)
        elif input not in {ord(b"\n"), ord(b"\r")}:
            return Waiting(self.message)
        return self

    def valid(self) -> bool:
        return self.message.valid

```

Возможность изменения поведения в зависимости от состояния является одной из веских причин использовать паттерн проектирования  **Состояние**. Вместо того чтобы использовать сложный набор условий **`if`**, чтобы определить, имеется ли у нас полное сообщение, имеются ли в нем все необходимые фрагменты и знаки препинания, мы преобразовали сложность в ряд отдельных состояний и правил перехода из состояния в состояние. Проверка валидности включается только тогда, когда мы получили символ **`$`**, пять символов, тело, символ **`*`**, еще два символа и убедились, что контрольная сумма верна.

Рассмотрим следующий тестовый пример:

```python
>>> message = b"""
... $GPGGA,161229.487,3723.2475,N,12158.3416,W,1,07,1.0,9.0,M,,,0000*18
... $GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41
... """
>>> rdr = Reader()
>>> result = list(rdr.read(message))
[Message(bytearray(b'GPGGA,161229.487,3723.2475,N,12158.3416,W,1,07,1.0,9.0,M,,,,0000'), bytearray(b'18'), computed=18), Message(bytearray(b'GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A'), bytearray(b'41'), computed=41)]
>>> result[0].message()
b'$GPGGA,161229.487,3723.2475,N,12158.3416,W,1,07,1.0,9.0,M,,,,0000*18'
>>> result[1].message()
b'$GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41'
>>> result[0].fields()
[b'GPGGA', b'161229.487', b'3723.2475', b'N', b'12158.3416', b'W', b'1', b'07', b'1.0', b'9.0', b'M', b'', b'', b'', b'0000']
>>> result[1].fields()
[b'GPGLL', b'3723.2475', b'N', b'12158.3416', b'W', b'161229.487', b'A', b'A']
```

Мы скопировали два примера сообщений из справочного руководства SiRF NMEA в редакции 1.3, чтобы убедиться, что наш анализ был правильным. Дополнительную информацию об устройствах GPS IoT вы можете найти на сайте https://www.sparkfun.com/products/ 13750, примеры и информацию - на сайте http://aprs.gids.nl/nmea/.



#### Паттерны Состояние и Стратегия
---

Паттерны Состояние и Стратегия очень похожи. Действительно, UМL-диаграммы для них идентичны. Реализация также идентична. Мы могли бы даже записать наши состояния в виде функций первого класса, вместо того чтобы оборачивать их в объекты, как было предложено в разделе, касающемся паттерна Стратегия.

Эти два шаблона похожи, так как они делегируют работу другим объектам. Так сложная задача разбивается на несколько тесно связанных, но более простых.

**Паттерн Стратегия** используется для выбора алгоритма во время выполнения. Как правило, для конкретного варианта использования выбирается только один из этих алгоритмов. Идея состоит в том, чтобы предоставить выбор реализации во время выполнения, как можно позже в процессе проектирования. Определения классов стратегии редко знают о других реализациях. Каждая Стратегия обычно независимая.

**Паттерн Состояние**, с другой стороны, предназначен для динамического переключения между различными состояниями по мере развития какого-либо процесса. В приведенном примере состояние менялось по мере получения байтов и удовлетворения изменяющегося набора условий валидности.

Определения состояния обычно заданы как группа с возможностью переключения между различными объектами состояния. В некоторой степени состояние **`End`**, используемое для анализа сообщения NMEA, имеет как отличительные черты **паттерна Состояние**, так и черты **паттерна Стратегия**. Поскольку реализация метода **`valid`()** отличается от других состояний, это отражает другую стратегию определения валидности предложения.





## Паттерн Синглтон
---

**Паттерн Синглтон** выступает предметом споров. Многие считают, что он является антипаттерном, паттерном, которого следует избегать и никак не продвигать его. В Python, если используется паттерн Синглтон, он почти наверняка будет делать что-то не так, вероятно потому, что исходит из более строгого языка программирования.

Так зачем вообще его изучать? Синглтон хорошо работает в неклассических объектно-ориентированных языках и является важной частью традиционного ООП. Более того, идея Синглтона полезна, даже если мы реализуем эту концепцию в Python совершенно по-другому.

Основная цель паттерна Синглтон состоит в том, чтобы ограничить возможность создания объектов данного класса одним экземпляром. Паттерн обеспечивает глобальность до одного экземпляра и глобальный доступ к созданному объекту. ==Класс в вашей программе будет иметь только один экземпляр, доступный всем клиентам.== Как правило, этот объект представляет собой своего рода класс менеджера, подобный тем, которые мы обсуждали в [[КОГДА БЕЗ ООП НЕ ОБОЙТИСЬ|главе 5]]. На такие объекты-менеджеры необходимо ссылаться из множества других объектов. Передача ссылок на объект-менеджер методам и конструкторам, которые в них нуждаются, может усложнить чтение кода.

Вместо этого, когда используется Синглтон, отдельные объекты у класса запрашивают один экземпляр объекта-менеджера. Рассмотрим, как это выглядит на UМL-диаграмме (**рис. 11.9**).

![[Рис. 11.9. Паттерн Синглтона UМL-диаграмме.jpg]]
>**Рис. 11.9.** Паттерн Синглтона UМL-диаграмме

В большинстве сред программирования паттерн Синглтон реализуется путем создания закрытого конструктора (чтобы никто не мог создавать его дополнительные экземпляры), а затем для извлечения единственного экземпляра предоставляется статический метод. Этот метод при первом вызове создает новый экземпляр и затем возвращает его для всех последующих вызовов.

Хороший пример **паттерна Синглтон**, для подключения к базе данных:
```python
class DatabaseHelper:
    __database_connection = None
    __data: str = ""  

    def __new__(cls):
        if cls.__database_connection is None:
            cls.__database_connection: DatabaseHelper = object.__new__(cls)
            print("Подключение к базе данных.")
        return cls.__database_connection

    def select_data(self) -> str:
        return self.__data

    def insert_data(self, new_data:str):
        self.__data = new_data
  

if __name__ == "__main__":
    connection1 = DatabaseHelper()
    connection1.insert_data("12345")
  
    connection2 = DatabaseHelper()
    print(connection2.select_data())
```
```output
Подключение к базе данных.
12345
```




### Пример реализации паттерна Синглтон
---

Python не имеет приватных конструкторов, но для этой цели можно использовать метод класса **`__nеw__()`**, тем самым гарантируя, что будет создан только один экземпляр:

```python
>>> class OneOnly:
...     _singleton = None
...     def __new__(cls, *args, **kwargs):
...             if not cls._singleton:
...                     cls._singleton = super().__new__(cls, *args,                                                                **kwargs)
...             return cls._singleton
```

При вызове метода **`__new__()`** обычно создается новый экземпляр запрошенного класса. Когда мы его переопределяем, сначала проверяем, был ли создан наш единственный экземпляр. Если нет, создаем его с помощью вызова метода **`super`**. Таким образом, всякий раз при вызове конструктора **`OneOnly`** мы всегда получаем один и тот же экземпляр:

```python
>>> o1 = OneOnly()
>>> o2 = OneOnly()
>>> o1 == o2
True
>>> id(o1) == id(o2)
True
>>> o1
<__main__.OneOnly object at 0x00000164CF6AA490>
>>> o2
<__main__.OneOnly object at 0x00000164CF6AA490>
```

Два объекта равны и расположены по одному и тому же адресу. Таким образом, они являются одним и тем же объектом. Данная конкретная реализация не очень понятна, так как не очевидно, что специальный метод используется для создания одноэлементного объекта.

Фактически в этом нет необходимости. Python предоставляет два встроенных паттерна Синглтон, которые мы можем использовать. Вместо того чтобы изобретать что-то сложно читаемое, стоит воспользоваться такими двумя вариантами.

- Модуль Python является одноэлементным. Метод **`import`** создает модуль. Все последующие попытки импортировать модуль возвращают единственный экземпляр модуля. В случае, когда требуется файл конфигурации или кэш для всего приложения, делайте это частью отдельного модуля. Библиотечные модули, такие как **`logging`**, **`random`** и даже **`re`**, имеют одноэлементные кэши на уровне модуля. Далее мы рассмотрим использование переменных уровня модуля.
- Определение класса Python также может быть использовано в качестве единственного элемента. В данном пространстве имен класс может быть создан только один раз. Проанализируйте возможность использования класса с атрибутами уровня класса в качестве одноэлементного объекта. Это означает определение методов с помощью дeкopaтopa **`@staticmethod`**, так как никогда не будет создан экземпляр и нет переменной **`self`**.

Чтобы вместо сложного **паттерна Синглтон** использовать переменные уровня модуля, мы создаем экземпляр класса после его определения. А вот чтобы использовать одноэлементные объекты для каждого из состояний, мы можем улучшить нашу реализацию **паттерна Состояние**. Вместо создания нового объекта каждый раз, когда меняются состояния, создадим коллекцию переменных уровня модуля, которые всегда доступны.

Внесем небольшое, но очень важное изменение в дизайн. В приведенных выше примерах каждое состояние имеет ссылку на накапливаемый объект **`Message`**. В данном случае необходимо предоставить объект **`Message`** как часть создания нового объекта **`NMEA_State`**. Здесь использован такой код, как **`return Body(self.message)`** , чтобы при работе с тем же экземпляром **`Message`** переключиться в новое состояние **`Body`**.

Если же не создавать (и пересоздавать) объекты состояния, то необходимо предоставить сообщение в качестве аргумента для соответствующих методов.

Например:

```python
class NMEA_State:
	def enter(self, message: "Message") -> "NMEA_State":
		return self

	def feed_byte(self, message: "Message", input: int) -> "NMEA_State":
		return self

	def valid(self, message: "Message") -> bool:
		return False

	def __repr__(self) -> str:
		return f"{self.__class__.__name__}()"
```

Этот вариант класса **`NMEA_State`** не имеет переменных экземпляра. Все методы работают со значениями аргументов, переданными клиентом:

```python
class Waiting(NMEA_State):
	def feed_byte(self, message: "Message", input: int) -> "NMEA_State":
		return self
		if input == ord(b"$"):
			return HEADER
		return self


class Header(NMEA_State):
	def enter(self, message: "Message") -> "NMEA_State":
		message.reset()
		return self

	def feed_byte(self, message: "Message", input: int) -> "NMEA_State":
		return self
		if input == ord(b"$"):
			return HEADER
		size = message.body_append(input)
		if size == 5:
			return BODY
		return self


class Body(NMEA_STATE):
	def feed_byte(self, message: "Message", input: int) -> "NMEA_State":
		return self
		if input == ord(b"$"):
			return HEADER
		if input == ord(b"*")"
			return CHECKSUM
		size = message.body_append(input)
		return self


class Checksum(NMEA_State):
	def feed_byte(self, message: "Message", input: int) -> "NMEA_State":
		return self
		if input == ord(b"$"):
			return HEADER
		if input in {ord(b"\n"), ord(b"\r")}:
			# Неполная контрольная сумма...Будет невалидной.
			return END
		size = message.checksum_append(input)
		if size == 2:
			return END
		return self


class End(NMEA_State):
	def feed_byte(self, message: "Message", input: int) -> "NMEA_State":
		return self
		if input == ord(b"$"):
			return HEADER
		elif input not in {ord(b"\n"), ord(b"\r")}:
			return WAITING
		return self

	def valid(self, message: "Message") -> bool:
		return message.valid


WAITING = Waiting()
HEADER = Header()
BODY = Body()
CHECKSUM = Checksum()
END = End()
```

Для изменения состояния внутри каждого из этих классов в процессе синтаксического анализа можно обращаться к этим пяти глобальным переменным. Возможность ссылаться на глобальную переменную, определенную после класса, поначалу кажется немного сложной. Но она отлично работает, так как имена переменных Python не преобразуются в объекты до начала выполнения. При создании каждого класса имя типа **`CHECKSUM`** представляет собой не более чем набор символов. Но при оценке метода **`Body.feedbyte()`** уже необходимо вернуть значение **`CHECKSUM`**,тогда имя будет разрешено для экземпляра **Синглтон** класса **`Checksum()`**.

Обратите внимание на реорганизацию класса **`Header`**. В версии, где каждое состояние имеет **`__init__()`**, при входе в состояние **`Header`** мы можем явно оценить **`Message.reset()`**. Поскольку в этом проекте мы не создаем новые объекты состояния, нужен способ обработки особого случая входа в новое состояние и однократного выполнения метода **`enter()`** только для инициализации или настройки. Это требование приводит к небольшому изменению в классе **`Reader`**:

```python
class Reader:
	def __init__(self) -> None:
		self.buffer = Message()
		self.state: NMEA_State = WAITING

	def read(self, source: Iterable[bytes]) -> Iterator[Message]:
		for byte in source:
			new_state = self.state.feed_byte(
			self.buffer, cast(int,byte))
			if self.buffer.valid:
				yield self.buffer
				self.buffer = Message()
				new_state = WAITING
			if new_state != self.state():
				new_state.enter(self.buffer)
				self.state = new_state
```

Здесь мы не просто заменяем значение переменной экземпляра **`self.state`** результатом вычисления **`self.state.feed_byte()`**, напротив, мы сравниваем предыдущее значение **`self.state`** со следующим значением **`new_state`**, чтобы увидеть, произошло ли изменение состояния.

Если было изменение, то для нового состояния необходимо вычислить **`enter()`**, чтобы позволить изменению состояния выполнить любую требуемую однократную инициализацию.

В данном примере память не расходуется впустую на создание большого количества новых экземпляров каждого объекта состояния, которые позже должны быть удалены. Вместо этого для каждой части входящего потока данных мы повторно используем один объект состояния. Даже если одновременно запущено несколько анализаторов, необходимо использовать только эти объекты состояния. Данные сообщения с отслеживанием состояния хранятся отдельно от правил обработки состояния в каждом объекте состояния.

>[!tip]
>Мы объединили два паттерна, каждый из которых предназначен для разных целей. Паттерн Состояние описывает завершение обработки. Паттерн Синглтон описывает управление экземплярами объектов. Очень часто проекты программного обеспечения включают множество перекрывающихся и дополнительных паттернов.





## Ключевые моменты
---

Мир разработки программного обеспечения полон замечательных идей. Действительно хорошие идеи повторяются и формируют повторяющиеся модели, паттерны. Знание и использование этих паттернов проектирования ПО может уберечь разработчика от сложной и затратной работы при попытке заново изобрести что-то, что уже было разработано. В этой главе вы изучили несколько наиболее распространенных паттернов.

- **Паттерн Декоратор** используется в языке Python для добавления возможностей к функциям или классам. Функции-декораторы определяются и затем применяются напрямую или через синтаксис **`@`** к другой функции.
- **Паттерн Наблюдатель** упрощает написание приложений с графическим интерфейсом. Его также можно использовать в приложениях без графического пользовательского интерфейса для формализации отношений между объектами, которые изменяют состояние, и объектами, которые отображают, обобщают или иным образом используют информацию о состоянии.
- **Паттерн Стратегия** занимает центральное место во многих объектах ООП. Мы можем разложить большие проблемы на контейнеры с данными и объектами стратегии, которые помогают в обработке данных. Объект Стратегия является своего рода плагином для другого объекта. Это дает возможность адаптировать, расширять и улучшать обработку, не нарушая при внесении изменений весь код.
- **Паттерн Команда** - удобный способ суммировать набор изменений, примененных к другим объектам. Это действительно полезно в контексте веб-служб, когда внешние команды поступают от веб-клиентов.
- **Паттерн Состояние** - способ определения обработки, при которой происходит изменение состояния и изменение поведения. Можно внедрить обработку уникальных или особых случаев в объекты, зависящие от состояния, используя затем паттерн Стратегия для подключения поведения, зависящего от состояния.
- **Паттерн Синглтон** используется в редких случаях, когда необходимо убедиться, что существует один и только один объект определенного типа. Например, обычно приложение ограничивается одним подключением к центральной базе данных.

Перечисленные паттерны проектирования помогают организовывать сложные наборы объектов. Знание ряда паттернов позволяет разработчикам визуализировать набор взаимодействующих классов и распределить их обязанности, разобраться с проблемами в дизайне: представив и изучив одну и ту же информацию по паттернам проектирования, они могут затем ссылаться на паттерны по имени и пропускать длинные описания.





## Резюме
---

В главе подробно обсуждались самые распространенные паттерны проектирования с примерами, UМL-диаграммами. Затрагивались различия между Python и объектно-ориентированными языками со статической типизацией. **Паттерн Декоратор**, как правило, реализуется с использованием более общего синтаксиса декоратора Python. **Паттерн Наблюдатель** - полезный способ отделить события от действий, предпринятых для этих событий. **Паттерн Стратегия** позволяет выбирать разные алгоритмы для выполнения одной и той же задачи. **Паттерн Команда** помогает создавать активные классы, которые имеют общий интерфейс, но выполняют разные действия. **Паттерн Состояние** подобен **паттерну Стратегия**, но используется для представления систем, которые могут могут перемещаться между различными состояниями с помощью четко определенных действий. **Паттерн Синглтон**, распространенный в некоторых статически типизированных языках, в Python почти всегда является антипаттерном.

В [[Новые Паттерны Проектирования]] мы завершим обсуждение паттернов проектирования.


---