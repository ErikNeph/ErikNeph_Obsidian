---
date of creation: 2024-06-25T17:02:00
tags:
  - Patterns
  - Python/Patterns
  - OOP
  - OOP/Python
  - Developing/Python
  - IT/Python
  - IT
  - DesignPatterns
  - Python
Read status: false
aliases:
---
---
# Общие Паттерны Проектирования
2024-06-25


В предыдущей [[Паттерн Итератор|главе]] уже упоминалось о паттернах проектирования и вы даже изучили паттерн Итератор. Паттерн Итератор настолько полезный и распространенный, что он встроен в язык программирования Python. В этой главе рассмотрим другие распространенные паттерны и примеры их реализации в Python. Как и в случае с итерацией, нам предстоит проанализировать и традиционный классический подход к работе с паттернами, и альтернативный синтаксис, предоставляемый средствами Python.

Прочитав эту заметку, вы освоите следующее.

- Паттерн *[[#Паттерн Декоратор|Декоратор]]* (Decorator).
- Паттерн *[[#Паттерн Наблюдатель|Наблюдатель]]* (Observer).
- Паттерн *Стратегия* (Strategy).
- Паттерн *Команда* (Command).
- Паттерн *Состояние* (State).
- Паттерн *Синглтон* (Singleton).

Начнем свое изучение с паттерна *Декоратор*. ==Это структурный паттерн, цель которого - предоставление новых функциональных возможностей классам и объектам во время выполнения кода.==



## Паттерн Декоратор
---

**Паттерн Декоратор** ==позволяет добавлять объектам новое поведение, помещая их в объекты-оболочки.== Декоратор оборачивает объекты бесчисленное количество раз благодаря тому, что и обертки, и сами обернутые объекты имеют общий интерфейс. Любой объект, использующий объект-декоратор, будет взаимодействовать с ним точно так же, как если бы он не был декоратором (то есть интерфейс объекта-декоратора идентичен интерфейсу основного объекта).

Существует два способа реализации паттерна Декоратор:

- улучшение отклика компонента при отправке данных второму компоненту;
- поддержка нескольких дополнительных вариантов поведения.

Второй вариант обычно является подходящей альтернативой множественному наследованию. Мы можем создать основной объект, а затем декоратор, обертывающий это ядро. Поскольку объект-декоратор имеет тот же интерфейс, что и основной объект, можно даже обернуть и новый объект в другие декораторы. Рассмотрим, как это выглядит на UМL-диаграмме (**рис. 11.1**).

В данном случае **ядро** и все декораторы реализуют определенный **интерфейс**. Пунктирные линии означают <*реализацию*>. Декораторы поддерживают ссылку на основной экземпляр данного **интерфейса** через композицию. При вызове декоратор выполняет некоторую дополнительную обработку до или после вызова своего обернутого интерфейса. Обернутый объект может быть другим декоратором или основным функционалом. Хотя несколько декораторов могут обертывать друг друга, основную функциональность обеспечивает объект в конце цепочки всех декораторов.

Важно, чтобы каждый из объектов в цепочке обеспечивал реализацию общей функции. Цель состоит в том, чтобы предоставить набор шагов обработки ядра различными декораторами. Как правило, декораторы невелики по размеру, фактически это определение функции без какого-либо состояния.

![[Рис. 11.1. Паттерн Декоратор на UМL- диаграмме.jpg]]
>   **Рис. 11.1.** Паттерн Декоратор на UМL- диаграмме


### Пример реализации паттерна Декоратор
---

Рассмотрим пример из сетевого программирования. Скажем, необходимо создать небольшой сервер и клиент. Сервер предоставляет данные, клиент с ним взаимодействует. Сервер имитирует бросание костей. Клиент отправляет запрос и ожидает ответ, содержащий случайные числа.

В этом примере два процесса взаимодействуют через сокет ТСР - способ передачи байтов между компьютерными системами. Сокеты создаются сервером, прослушивающим соединения. При попытке клиента подключиться к сокету сервер должен принять новое соединение, после чего два процесса смогут передавать байты в обе стороны. Для данного примера это будет запрос от клиента к серверу и ответ от сервера к клиенту. Сокет ТСР является частью основы протокола НТТР, вокруг которого построена Всемирная паутина.

При клиент-серверном взаимодействии для передачи строки байтов через сокет будет использоваться метод **`socket.send()`** , а для получения байтов - метод **`socket.recv()`**.

Проанализируем этот пример, начиная с интерактивного сервера, который ожидает подключения от клиента, а затем отвечает на запрос. Назовем этот модуль **`socket_server.ру`**. Например:

```python
import contextlib
import socket


def main_1() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("localhost", 2401))
    server.listen(1)
    with contextlib.closing(server):
        while True:
            client, addr = server.accept()
            dice_response(client)
            client.close()
```

Сервер привязан к общедоступному сокету через произвольный порт с номером 2401. Именно здесь сервер прослушивает запросы на подключение. При попытке клиента подключиться к этому сокету создается дочерний сокет, чтобы клиент и сервер могли общаться, оставляя общедоступный сокет готовым для дополнительных подключений. Чтобы обеспечить большое количество одновременных сессий веб-сервер часто применяет несколько потоков. Мы не используем здесь потоки, и второй клиент должен ждать, пока сервер не закончит работу с первым клиентом. Это напоминает очередь в кофейню, где только один бариста готовит эспрессо.

Обратите внимание, что сокеты ТСР/IP имеют как адрес хоста, так и номер порта. Номер порта должен быть выше чем `1023`. Номера портов `1023` и ниже зарезервированы и требуют специальных привилегий ОС. В примере выбран порт `2401`, так как он не используется для других задач.

Функция **`dice_response()`** выполняет всю реальную работу описанного сервиса. Для ответа клиенту функция принимает параметр сокета. Считываются байты с клиентским запросом, создается ответ, который затем отправляется. Функция **`dice_response()`** для корректной обработки исключений выглядит следующим образом:

```python
def dice_response(client: socket.socket) -> None:
    request = client.recv(1024)
    try:
        response = dice.dice_roller(request)
    except (ValueError, KeyError) as ex:
        response = repr(ex).encode("utf-8")
    client.send(response)
```

В примере в обработчик исключений обернута другая функция, **`dice_roller()`** . Это распространенный прием для отделения обработки ошибок и других задач от реального выполнения кода броска костей и ответа клиенту:

```python
import random


def dice_roller(request: bytes) -> bytes:
    request_text = request.decode("utf-8")
    numbers = [random.randint(1, 6) for _ in range(6)]
    response = f"{request_text} = {numbers}"
    return response.encode("utf-8")
```

Это не слишком сложно. Данный пример более подробно рассмотрим в разделе, касающемся **паттерна Команда**, но уже здесь в качестве ответа предоставляется последовательность случайных чисел.

Обратите внимание, что фактически мы ничего не делаем с объектом **`request`**, пришедшим от клиента. В примерах мы будем считывать эти байты и игнорировать их. **`request`** является плейсхолдером для более сложного запроса, описывающего необходимое количество игральных костей и количество бросков.

**Паттерн проектирования Декоратор** иногда используется для добавления функций. Он обертывает основную функцию **`dice_response()`** , которой предоставляется объект **`socket`**, а его уже можно и читать, и записывать. Чтобы использовать паттерн проектирования, важно учитывать, как при добавлении функционала эта функция опирается на методы **`socket.send()`** и **`socket.recv()`** : необходимо сохранить определение интерфейса.

Чтобы протестировать сервер, напишем код простого клиента, который подключается к тому же порту и перед выходом выводит ответ:

```python
def main() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.connect(("localhost", 2401))
    count = input("How many rolls: ") or "1"
    pattern = input("Dice pattern nd6[dk+-]a: ") or "d6"
    command = f"Dice {count} {pattern}"
    server.send(command.encode("utf-8"))
    response = server.recv(1024)
    print(response.decode("utf-8"))
    server.close()


if __name__ == "__main__":
    main()
```

Клиент задает два вопроса и создает довольно сложную строку, **`command`**, содержащую подсчет и паттерн броска костей. На данный момент сервер еще не использует эту команду, и код представляет собой задачу для более сложной игры в кости.

Результат будет выглядеть так, как показано на **рис. 11.2.**

![[Рис. 11.2. Сервер и клиент.jpg]]
>   **Рис. 11.2.** Сервер и клиент

==На схеме слева изображен сервер==. Приложение запущено, и оно начало прослушивать порт `2401` для клиентов. Справа изображен клиент. Каждый раз, когда запускается клиент, он подключается к общедоступному сокету. Операция подключения создает дочерний сокет, который можно использовать для остальной части взаимодействия. Клиент отправляет команду, сервер отвечает на эту команду, и клиент вы водит ее.

Теперь, проанализировав код сервера, мы явно различаем два его раздела. Функция **`dice_response()`** считывает данные и отправляет их обратно клиенту через объект **`socket`**. Оставшийся сценарий отвечает за создание объекта **`socket`**. Создадим пару декораторов, настраивающих поведение сокета, не расширяя и не изменяя самого сокета.

Начнем с **`логирования`**. Объект выводит любые данные, получаемые с консоли сервера, прежде чем отправить их клиенту:

```python
class LogSocket:
    def __init__(self, socket: socket.socket) -> None:
        self.socket = socket

    def recv(self, count: int = 0) -> bytes:
        data = self.socket.recv(count)
        print(f"Receiving {data!r} from {self.socket.getpeername()[0]}")
        return data

    def send(self, data: bytes) -> None:
        print(f"Sending {data!r} to {self.socket.getpeername()[0]}")
        self.socket.send(data)

    def close(self) -> None:
        self.socket.close()
```

В коде класс декорирует объект **`socket`** и предоставляет обращающимся к нему клиентам интерфейсы **`send()`** , **`recv()`** и  **`close()`** . Подходящий декоратор мог бы правильно реализовать все аргументы для отправки (которые на самом деле принимают необязательный аргумент), но лучше не будем усложнять. Всякий раз, когда для экземпляра класса **`LogSocket`** вызывается функция **`send()`** , перед отправкой данных клиенту, использующему исходный сокет, на экран записывается вывод. Аналогично для **`recv()`** считываются и регистрируются полученные данные.

Для применения этого декоратора необходимо изменить только одну строку в исходном коде. Вместо того чтобы вызывать функцию **`dice_response()`** с исходным клиентским сокетом, вызовем ее с декорированным сокетом:

```python
from typing import cast


def main_2() -> None:
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("localhost", 2401))
    server.listen(1)
    with contextlib.closing(server):
        while True:
            client, addr = server.accept()
            logging_socket = cast(socket.socket, LogSocket(client))
            dice_response(logging_socket)
            client.close()
```

Итак, мы декорировали основной сокет **`LogSocket`**. Сокет **`LogSocket`** будет выводить результат на консоль и вызывать метод, который он декорирует. Основная обработка в функции **`dice_response()`** не меняется, так как экземпляр **`LogSocket`** ведет себя как базовый объект **`socket`**.

Обратите внимание, что необходимо было использовать метод **`cast()`** , чтобы сообщить **`mуру`**, что экземпляр **`LogSocket`** предоставит интерфейс, аналогичный обычному объекту **`socket`**. Здесь надо проанализировать, почему нельзя просто расширить класс **`socket`** и переопределить метод **`send`**. Для фактической отправки после регистрации данных подкласс может вызвать методы **`super().send() и super().recv() `**. Декорирование имеет преимущество перед наследованием: декорирование можно повторно использовать в различных классах и в различных иерархиях классов. В данном конкретном примере объектов, подобных сокетам, не слишком много, поэтому возможности повторного использования ограниченны.

Декораторы могут быть связанными и декорировать уже декорированные элементы. Идея состоит в том, чтобы действовать через композицию. Переработаем декоратор логирования, чтобы сосредоточиться на запросе и ответе в виде байтов, а не на объекте **`socket`**. Следующий пример должен выглядеть аналогично предыдущему, но с некоторым изменением кода, касающимся размещения в одном методе **`__call__()`** :

```python
Address = Tuple[str, int]
  

class LogRoller:
    def __init__(self, dice: Callable[[bytes], bytes], remote_addr: Address) -> None:
        self.dice_roller = dice
        self.remote_addr = remote_addr

    def __call__(self, request: bytes) -> bytes:
        print(f"Receiving {request!r} from {self.remote_addr}")
        dice_roller = self.dice_roller
        response = dice_roller(request)
        print(f"Sending {response!r} to {self.remote_addr}")
        return response
```

Ниже представлен пример второго декоратора, который сжимает данные, применяя сжатие **`gzip`** для полученных байтов:

```python
import gzip
import io


class ZipRoller:
    def __init__(self, dice: Callable[[bytes], bytes]) -> None:
        self.dice_roller = dice  

    def __call__(self, request:bytes) -> bytes:
        dice_roller = self.dice_roller
        response = dice_roller(request)
        buffer = io.BytesIO()
        with gzip.GzipFile(fileobj=buffer, mode="w") as zip_file:
            zip_file.write(response)
        return buffer.getvalue()
```

Этот декоратор сжимает входящие данные перед их отправкой клиенту. Он декорирует базовый объект **`dice_roller`**, вычисляющий ответ на запрос.

Теперь, когда имеется два декоратора, напишем код, который накладывает один декоратор на другой:

```python
def dice_response(client: socket.socket) -> None:
    request = client.recv(1024)
    try:
        remote_addr = client.getpeername()
        roller_1 = ZipRoller(dice.dice_roller)
        roller_2 = LogRoller(roller_1, remote_addr=remote_addr)
        response = roller_2(request)
    except (ValueError, KeyError) as ex:
        response = repr(ex).encode("utf-8")
    client.send(response)
```

Цель состоит в том, чтобы разделить три аспекта этого приложения.

- Архивирование полученного документа.
- Ведение журнала или запись в лог-файл (логирование).
- Выполнение базовых вычислений.

Можно архивировать или логировать любое аналогичное приложение, которое работает с приемом и отправкой байтов. При необходимости, используя динамический выбор, можно выполнить операцию архивирования. У нас может быть отдельный файл конфигурации для включения или отключения функции **`GZip`**. Например:

```python
if config.zip_feature:
	roller_1 = ZipRoller(dice.dice_roller)
else:
	roller_1 = dice.dice_roller
```

Имеется динамический набор дополнительных функций. Попробуйте написать это, используя в том числе множественное наследование, и проанализируйте результат.



#### Полезный декоратор
---

Декораторы Python также допускают параметры. **`functools.lru_cache`** ==- один из самых полезных декораторов в стандартной библиотеке.== Идея кэширования состоит в том, чтобы сохранять вычисленные результаты функции, тем самым избегая их повторного вычисления. Вместо того чтобы сохранять все параметры и результаты, мы можем уменьшить размер кэша, **отбрасывая наименее использовавшиеся (LRU)** значения. Например, ниже представлена функция, требующая потенциально дорогостоящих вычислений:

```python
>>> from math import factorial
>>> def binom(n: int, k: int) -> int:
... 	return factorial(n) // (factorial(k) * factorial(n-k))

>>> f"6-card deals: {bionom(52, 6):,d}"
'6-card deals: 20,358,520'
```

Применим декоратор **`lru_cache`**, чтобы при известном ответе избежать выполнения этих вычислений. Например, так:

```python
>>> from math import factorial
>>> from functools import lru_cache
>>> @lru_cache(64)
... def bionom(n: int, k: int) -> int:
...     return factorial(n) // (factorial(k) * factorial(n-k))
```

Параметризованный декоратор **`@lru_cache(64)`**, применяемый для создания второй версии функции **`binom()`** , сохраняет самые последние 64 результата, чтобы избежать повторного вычисления значений, если они уже были вычислены один раз. Теперь в другом месте приложения никакие изменения больше не требуются. Иногда улучшение от этого небольшого нюанса может быть значительным. Конечно, можно точно настроить размер кэша на основе данных и количества выполняемых вычислений.

Использование подобных параметризованных декораторов похоже на топтание на одном месте. Сначала мы настраиваем декоратор с параметром, затем применяем этот настроенный декоратор к определению функции. Эти два отдельных шага аналогичны действиям, когда вызываемые объекты инициализируются с помощью мeтoдa **`__init__()`** и могут быть вызваны в качестве функции с помощью метода **`__call__()`**

Рассмотрим пример настраиваемого декоратора логирования **`NamedLogger`**:

```python
class NamedLogger:
    def __init__(self, logger_name: str) -> None:
        self.logger = logging.getLogger(logger_name)

    def __call__(self, function: Callable[..., Any]) -> Callable[..., Any]:
        @wraps(function)
        def wrapped_function(*args: Any, **kwargs: Any) -> Any:
            start = time.perf_counter()
            try:
                result = function(*args, **kwargs)
                μs = (time.perf_counter() - start) * 1_000_000
                self.logger.info(f"{function.__name__}, {μs:.1f}μs")
                return result
            except Exception as ex:
                μs = (time.perf_counter() - start) * 1_000_000
                self.logger.error(f"{ex}, {function.__name__}, {μs:.1f}μs")
                raise

        return wrapped_function
```

Метод **`__init__()`** гарантирует, что для создания декоратора мы можем написать код вроде **`NamedLogger("log4")`** . Этот декоратор позаботится о том, чтобы следующая функция использовала определенный регистратор.

Метод **`__саll__()`** следует уже известному паттерну. Определяем новую функцию **`wrap_function()`** , которая делает всю работу, и возвращаем новую функцию:

```python
@NamedLogger("log4")
def test4(median: float, sample: float) -> float:
    return abs(sample - median)
```

Здесь мы создали экземпляр класса **`NamedLogger`**. Затем применили этот экземпляр к определению функции **`test4()`**. При этом вызывался метод **`__саll__()`** , который создал новую функцию, декорированную версию функции **`test4()`**.

Существует еще несколько вариантов использования синтаксиса декоратора. Например, когда декоратор является методом класса, он также сохраняет информацию о декорированной функции, создавая реестр декорированных функций. Кроме того, классы также могут быть декорированы. В этом случае декоратор возвращает новый класс вместо новой функции.

Во всех более сложных случаях мы используем обычный объектно-ориентированный дизайн с более простым синтаксисом **`@dесоrаtоr`**.



## Паттерн Наблюдатель
---

**Паттерн Наблюдатель** полезен для мониторинга состояния и ситуаций обработки событий. ==Это поведенческий паттерн==, который позволяет объектам уведомлять другие объекты об изменениях в их состоянии. Основной наблюдаемый объект должен реализовать интерфейс, который делает его *наблюдаемым*.

Всякий раз, когда значение в основном объекте изменяется, он сообщает всем объектам-наблюдателям, что изменение произошло, вызывая метод, объявляющий об изменении состояния. Паттерн Наблюдатель широко используется в графических интерфейсах, чтобы убедиться, что любое изменение состояния в базовой модели отражается в представлениях модели. Обычно используются подробные и сводные представления. Изменение сведений должно также обновлять виджеты и любые отображаемые перечни. Иногда существенное изменение режима приводит к изменению ряда элементов. Например, после щелчка на значке «замок> статус отображаемых элементов изменяется на статус «заблокирован>. Это может быть реализовано в виде нескольких наблюдателей, прикрепленных к наблюдаемому виджету отображения.

В Python наблюдатель может быть уведомлен с помощью метода **`_call_()`** , благодаря чему каждый наблюдатель ведет себя как функция или другой вызываемый объект. Каждый наблюдатель при изменении основного объекта может отвечать за разные задачи. Основной объект не знает и не заботится о том, что это за задачи, а наблюдатели обычно не знают и не заботятся о том, что делают другие наблюдатели.

Это обеспечивает огромную гибкость, отделяя реакцию на изменение состояния от самого изменения.

Рассмотрим, как это выглядит на UМL-диаграмме (**`рис.11.3`**).

![[Рис. 11.З. Паттерн Наблюдатель на UМL-диаграмме.jpg]]
>   **Рис. 11.З.** Паттерн Наблюдатель на UМL-диаграмме

Здесь объект **`Core`** содержит список объектов-наблюдателей. Чтобы быть наблюдаемым, класс **`Core`** должен придерживаться общего понимания наблюдаемости. В частности, он должен предоставить список наблюдателей и способ присоединения новых наблюдателей.

Подклассы **`Observer`** включают метод **`__call__()`**. К нему обращается наблюдаемый для уведомления каждого наблюдателя об изменении состояния. Как и в случае с *паттерном Декоратор*, нет необходимости формализовать отношения с формально определенными абстрактными суперклассами. В большинстве случаев мы можем полагаться на правила утиной типизации. Пока наблюдатели имеют правильный интерфейс, их можно использовать в определенной роли. Если у них нет надлежащего интерфейса, **`mуру`** выявит конфликт, а модульный тест определит проблему.

Хороший пример паттерна наблюдатель, *система обновления цен на товар*

```python
import abc
from typing import List


class IObserver(metaclass=abc.ABCMeta):
	@abc.abstractmethod
	def update(self, p: int):
		pass


class IObservable(metaclass=abc.ABCMeta):
	@abc.abstractmethod
	def add_observer(self, o: IObserver):
		pass

	@abc.abstractmethod
	def remove_observer(self, o: IObserver):
		pass

	@abc.abstractmethod
	def notify(self):
		pass


class Product(IObservable):
	def __init__(self, price: int):
		self.__price = price
		self.__observers: List[IObserver] = []

	def change_price(self, price: int):
		self.__price = price
		self.notify()

	def add_observer(self, o: IObserver):
		self.__observers.append(o)

	def remove_observer(self, o: IObserver):
		self.__observers.remove(o)

	def notify(self):
		for o in self.__observers:
			o.update(self.__price)


class Wholesale(IObserver):
	def __init__(self, obj: IObservable):
		self.__product = obj
		obj.add_observer(self)

	def update(self, p: int):
		if p < 300:
			print(f"Оптовик закупил по цене {p}")
			self.__product.remove_observer(self)


class Buyer(IObserver):
	def __init__(self, obj: IObservable):
		self.__product = obj
		obj.add_observer(self)

	def update(self, p: int):
		if p < 350:
			print(f"Покупатель закупил по цене {p}")
			self.__product.remove_observer(self)


if __name__ == "__main__":
	product = Product(400)
	wholesale = Wholesale(product)
	buyer = Buyer(product)
	product.change_price(330)
	product.change_price(250)

```



### Пример реализации паттерна Наблюдатель
---

Вне графического интерфейса паттерн Наблюдатель полезен для сохранения промежуточных состояний объектов. ==Использование объектов-наблюдателей может быть удобно в системах, где требуется тщательный аудит изменений.== *Паттерн также хорошо себя зарекомендовал в случае ненадежной системы.*

В сложных облачных приложениях могут возникать проблемы из-за ненадежных соединений. Паттерн Наблюдатель мы можем использовать для записи изменений состояния, упрощая восстановление и перезапуск.

В примере ниже для хранения набора важных значений определим основной объект, а затем попросим одного или нескольких наблюдателей создать сериализованные копии этого объекта. Эти копии могут храниться, например, в базе данных, на удаленном хаете или в локальном файле. Поскольку наблюдателей может быть несколько, для использования разных кэшей данных настроить дизайн оказывается несложно. В нашем примере игры в кости под названием Zonk, или Zilch, или Ten Thousand игрок бросает шесть костей, набирает очки за тройки и, возможно, бросает снова, что приводит к последовательности бросков костей. В действительности правила более замысловатые, но мы не станем усложнять.

Рассмотрим следующий пример:

```python
from typing import Protocol


class Observer(Protocol):
    def __call__(self) -> None:
        ...


class Observable:
    def __init__(self) -> None:
        self._observers: list[Observer] = []  

    def attach(self, observer: Observer) -> None:
        self._observers.append(observer)

    def detach(self, observer: Observer) -> None:
        self._observers.remove(observer)

    def _notify_observers(self) -> None:
        for observer in self._observers:
            observer()
```

Класс **`Observer`** - это протокол, абстрактный суперкласс для наблюдателей. Мы не формализовали его как абстрактный класс **`аbc.АВС`**. Мы не полагаемся на ошибку времени выполнения, предлагаемую модулем **`аbс`**. При определении протокола мы рассчитываем на инструмент **`mуру`** для подтверждения того, что все наблюдатели действительно реализуют требуемый метод.

Класс **`Observable`** определяет переменную экземпляра **`_observers`** и три метода, которые являются исключительно частью определения этого протокола. Наблюдаемый объект может добавить наблюдателя, удалить его и, что наиболее важно, уведомить всех наблюдателей об изменении состояния. Единственное, что должен сделать базовый класс, чтобы он был особенным или отличался от других, - при изменении состояния вызвать метод **`_notify_observers()`**.

Класс **`Observable`** определяет переменную экземпляра **`_observers`** и три метода, которые являются исключительно частью определения этого протокола. ==Наблюдаемый объект может добавить наблюдателя, удалить его и, что наиболее важно, уведомить всех наблюдателей об изменении состояния==. Единственное, что должен сделать базовый класс, чтобы он был особенным или отличался от других, - при изменении состояния вызвать метод **`_notify_observers()`**.

Соответствующее уведомление является важной частью дизайна наблюдаемого объекта.

Рассмотрим интересующую нас часть игры Zonk в следующем примере:

```python
from typing import List


Hand = List[int]


class ZonkHandHistory(Observable):
    def __init__(self, player: str, dice_set: Dice) -> None:
        super().__init__()
        self.player = player
        self.dice_set = dice_set
        self.rolls: list[Hand]

    def start(self) -> Hand:
        self.dice_set.roll()
        self.rolls = [self.dice_set.dice]
        self._notify_observers()  # Изменение состояния
        return self.dice_set.dice()

    def roll(self) -> Hand:
        self.dice_set.roll()
        self.rolls.append(self.dice_set.dice)
        self._notify_observers()  # Изменения состояния
        return self.dice_set.dice

```

При важных изменениях состояния этот класс вызывает **`self._not ify_observers()`**, тем самым уведомляя все экземпляры наблюдателя. Наблюдатели могут кэшировать копии бросков, отправлять данные по сети, обновлять виджеты в графическом интерфейсе и многое другое. Метод **`_notify_observers()`**, унаследованный от **`Observable`**, перебирает всех зарегистрированных наблюдателей и сообщает каждому, что состояние бросков изменилось.

Теперь реализуем простой объект-наблюдатель, выводящий некоторое состояние на консоль:

```python
class SaveZonkHand(Observer):
    def __init__(self, hand: ZonkHandHistory) -> None:
        self.hand = hand
        self.count = 0

    def __call__(self) -> None:
        self.count += 1
        message = {
            "player": self.hand.player,
            "sequence": self.count,
            "hands": json.dumps(self.hand.rolls),
            "time": time.time(),
        }
        print(f"SaveZonkHand {message}")

```

Здесь нет ничего особенно сложного. Наблюдаемый объект настраивается в инициализаторе, и, когда вызывается наблюдатель, мы *что-то* делаем, например, как в коде выше, выводим строку. Обратите внимание, что суперкласс **`Observer`** в данном случае фактически не нужен. Контекст, в котором используется этот класс, достаточен для **`mуру`**, чтобы подтвердить, что рассматриваемый класс соответствует требуемому протоколу **`Observer`**. Хотя нам не нужно указывать, что это **`Observer`**, это может помочь проанализировать, что данный класс реализует протокол **`Observer`**.

В интерактивной консоли протестируем наблюдатель **`SaveZonkHand`**:
```python
>>> d = Dice.from_text("6d6")
>>> player = ZonkHandHistory("Bo", d)
>>>
>>> save_history = SaveZonkHand(player)
>>> player.attach(save_history)
>>> r1 = player.start()
SaveZonkHand {'player': 'Bo', 'sequence': 1, 'hands': '[[3, 4, 4, 4, 4, 6]]', 'time': 1719390993.790934}
>>> r1
[3, 4, 4, 4, 4, 6]
>>> r2 = player.roll()
SaveZonkHand {'player': 'Bo', 'sequence': 2, 'hands': '[[3, 4, 4, 4, 4, 6], [1, 1, 2, 5, 5, 6]]', 'time': 1719391051.5066156}
```

После присоединения наблюдателя к объекту **`Inventory`** всякий раз, когда изменяется одно из двух наблюдаемых свойств, вызывается наблюдатель и его действие. Обратите внимание, что наблюдатель отслеживает порядковый номер и включает временную метку. Метки не входят в определение игры и отделены от основной ее обработки, поскольку являются частью класса наблюдателя **`SaveZonkHand`**.

Мы можем добавить несколько наблюдателей различных классов. Например, добавим второй наблюдатель, у которого есть ограниченная работа по проверке трех пар, и объявим об этом:

```python
class ThreePairZonkHand:
    """Observer of ZonkHandHistory"""
    def __init__(self, hand: ZonkHandHistory) -> None:
        self.hand = hand
        self.zonked = False  

    def __call__(self) -> None:
        last_roll = self.hand.rolls[-1]
        distinct_values = set(last_roll)
        self.zonked = len(distinct_values) == 3 and all(
            last_roll.count(v) == 2 for v in distinct_values
        )
        if self.zonked:
            print("3 Pair Zonk!")

```

В данном примере мы не определяем **`Observer`** в качестве суперкласса. Мы доверились инструменту **`mуру`**, который заметит, как используется этот класс и какие протоколы тот должен реализовывать.

Добавление нового наблюдателя **`ThreePairZonkHand`** означает, что при изменении состояния броска может быть два набора выходных данных, по одному для каждого Наблюдателя. Основная идея здесь заключается в том, что мы можем легко добавлять совершенно разные типы наблюдателей, чтобы выполнять разные действия, в данном случае копировать данные, а также в особых случаях проверять их.

Паттерн Observer отделяет кол, за которым наблюдают, от кода, выполняющего наблюдение. Если бы мы не использовали этот паттерн, нам пришлось бы поместить код в класс **`ZonkHandHistory`** для обработки различных случаев: записи на консоль, обновления базы данных или файла, проверки особых случаев и пр. Весь код для каждой из этих задач смешался бы с определением базового класса. Поддерживать его было бы сложно, а добавление новых функций мониторинга на более позднем этапе было бы очень болезненным.



## Паттерн Стратегия
---
