# Атрибуты и поведение

Еще раз о базовой терминологии ООП. ==Объекты - экземпляры класса==, которые связаны между собой. Экземпляр класса - некоторый объект с определенными данными и поведением; апельсин на столе, перед нами, считается экземпляром общего класса апельсинов. Так же читайте если забыли, что такое [[Объекты и классы]].

Апельсин имеет состояние: например, он спелый или неспелый; мы судим о со­ стоянии объекта по его атрибутам. Также апельсин имеет некоторое поведение. Сам по себе он неподвижен, а вот его состояние может изменяться. Давайте разберем подробнее два термина - «состояние» и «поведение».

## Данные - показатель состояния объекта

Обратимся к данным. Данные обозначают индивидуальные особенности объ­екта, его состояние, а класс - общие особенности, признаки, свойственные всем объектам класса. При этом каждый конкретный объект имеет свои значения данных для каждого признака. Например, три апельсина на столе (вы же еще не съели их, правда?) могут иметь разный вес. **Класс Апельсин** имеет атрибут Вес для представления этих данных. Все экземпляры класса Апельсин имеют атрибут Вес, но его значение для каждого апельсина индивидуально. Значе­ние атрибутов, кстати, не обязательно уникально, два апельсина могут иметь одинаковый вес.

![[Диаграмма классов c атрибутами и их типом.jpg]]


## Поведение - это действия

Выяснив, как данные определяют состояние объекта, разберем последний неиз­вестный термин - «поведение». ==Поведение== - это действия, которые происходят с объектом. Поведение, которое определяется классом объекта, называется **ме­тодами** этого класса. На программном уровне методы сравнимы с функциями в структурном программировании, но, в отличие от последних, методы имеют доступ к атрибутам, в частности к переменным с данными, которые связаны с объектом. Так же как функции, методы принимают **параметры** и возвращают **значение**.

Параметры метода предоставляются ему как коллекция (набор) объектов, которые необходимо **передать** в метод. ==Арrументы== - фактически переданные экземпляры объекта во время вызова метода. При этом передаваемые пере­менные связаны с переменными **параметров** в теле метода. Метод использует их независимо от того, для какого типа задач и достижения какой цели он ока­зывается вызван. Обычно результат выполнения метода - возвращаемые зна­чения. Но возможна и другая ситуация: его действие направлено на изменение внутреннего состояния объекта.

Класс Корзина содержит метод продать. Когда корзина продана, наша система инвентаризации обновляет данные по объектам, которые еще не указаны нами, для расчета дохода. В другом случае корзина с апельсинами может еще до про­ даже оказаться испорченной, потому нужно добавить метод выбросить. Добавим эти методы на диаграмме (рис. 1.5).

![[Диаграмма классов c атрибутами и методами.jpg]]


## Сокрытие информации и создание общедоступного интерфейса

Ключевая задача моделирования объекта в объектно-ориентированном про­ектировании - определить, какой будет внешний **интерфейс** данного объекта. *Интерфейс* - коллекция, набор атрибутов и методов, доступных для взаимо­действия с другими объектами. Особо стоит подчеркнуть, что свободный доступ извне к внутренней работе объекта не нужен, а в некоторых языках и запрещен.

Возьмем пример реального мира - телевизор. Пульт управления - наш ин­терфейс. Каждая кнопка пульта управления представляет метод, который мы вызываем, чтобы повлиять на объект <телевизор>. Когда нажимаем кнопку, вы­зываем объект и обращаемся к методам, нам неинтересно, как именно телевизор получит сигнал - через кабель, спутник или Интернет. Нас не интересует, как идет электрический сигнал, когда мы увеличиваем громкость, неважно даже, будет ли звук передан в динамики или в наушники. Разбирая телевизор, чтобы что-либо починить внутри, например разделить выход на наушники и динамики, мы лишаемся гарантии.

Сокрытие внутренней реализации объекта называют **сокрытием информации**. Также об этом можно сказать, что информация **инкапсулирована**, хотя это более широкий термин. Инкапсулирование данных не обязательно означает сокрытие. Буквально <инкапсуляция> означает <помещение в капсулу> или <упаковку> атрибутов. Внешний корпус ТВ заключает в себя (инкапсулирует) состояние и поведение телевизора. Мы имеем доступ к внешнему экрану, динамикам и пуль­ту управления. Но у нас нет доступа к связке усилителей или приемников ТВ.

Различие между инкапсуляцией и сокрытием информации не слишком важ­но в большинстве случаев, особенно на стадии проектирования. Во многих практических руководствах эти термины используют как взаимозаменяемые. Разработчикам Python не нужно скрывать информацию, создавая полностью приватные и недоступные переменные (мы обсудим это в главе 2), так что мы будем использовать термин «инкапсуляция> в широком смысле.

==[[Абстракция]]== - еще один термин ООП, связанный с инкапсуляцией и сокрытием информации. Абстракция означает работу с частью информации соответству­ющей задачи. Так происходит разделение общедоступного интерфейса и вну­тренних механизмов. Водитель может повернуть руль, ускориться, затормозить. Для него не имеет значения, как работают двигатель, сцепление и тормоз. Зато это важно для механика, который решает свои задачи на другом уровне абстрак­ции - настраивает двигатель или прокачивает тормоза. На рис. 1.6 изображены эти два уровня абстракции.

![[Уровни абстракции автомобиля.jpg]]

Теперь мы познакомились с основными терминами изучаемого подхода. Обобщим коротко то, что касается использования профессионального сленга: ==[[абстракция]] - процесс инкапсуляции информации на разных уровнях публичного интерфейса.== Каждый частный элемент может быть скрыт. На UМL-диаграмме используется знак - вместо +, чтобы показать, что этот элемент не является частью внешнего интерфейса.

Исходя из данных определений, сформулируем вывод: следует обеспечить, чтобы разрабатываемая модель была понятна другим объектам, ведь она должна с ними взаимодействовать. Для этого разработчику необходимо обращать пристальное
внимание на детали.


## Композиция

К этому моменту вы уже научились проектировать структуру своего ПО как систему взаимодействующих объектов с определенным представлением на соот­ветствующем уровне абстракции. Но пока еще неизвестно, как задавать уровни абстракции. И в этом, надо сказать, существуют разные подходы. Паттерны про­ектирования мы обсудим ниже, в главах 10- 12. Пока достаточно отметить, что большинство паттернов проектирования основаны на двух базовых принципах ООП: **композиции и наследовании.** Композиция проще, начнем с нее.

==[[Композиция]]== - процесс группировки объектов для создания нового объекта. Когда объект включен в другой, можно говорить о композиции. Мы уже стал­кивались с этим понятием, когда говорили об автомобиле. Он состоит из дви­гателя, сцепления, фар, ветрового стекла и всех остальных частей. Двигатель, в свою очередь, содержит клапаны, коленчатый вал и поршень. В этом примере композиция, то есть составные части с внутренней вложенностью, определяет уровень абстракции. Объект **Автомобиль** имеет один уровень абстракции для водителя, другой уровень абстракции - тот, с которым работает механик. И конечно, можно выделить новые уровни абстракции на тот случай, когда ме­ханику понадобится более глубокое понимание принципов работы внутренних систем для ремонта машины.

==[[Агрегация]]== подобна композиции. Различие лишь в том, что объекты агрегации могут существовать независимо друг от друга. Например, невозможно, чтобы клетка одной шахматной доски была связана с другой клеткой. Доска состоит из клеток. Но фигуры к ней прямого отношения не имеют и не связаны с ней. Фигуры могут принадлежать этой доске или другой, они, можно так сказать, временно агрегированы с доской в один набор шахмат.

Другой способ различать агрегацию и композицию - по сроку их жизни.
- Если объект составной, то внутренние объекты (части) создаются и удаляются только вместе - это композиция.
- Если объект связанный, то его подобъекты создаются и удаляются независимо друг от друга - это агрегация.

*Запомните, что композиция и агрегация - это одно и то же, просто агрегация более общая форма композиции. Каждое отношение композиции есть отношение* *агрегации, но не наоборот.*

![[Диаграмма классов для набора шахмат.jpg]]



## Наследование

Итак, существует три вида отношений между объектами: ассоциация, компо­зиция и агрегирование.

==[[Наследование]]== - самое известное понятие ООП, используемое и к месту, и не к месту. Наследование всем понятно, каждый может вспомнить семейное генеа­логическое дерево. Дасти Филлипс - один из авторов книги. Фамилия его деда была Филлипс, его отец унаследовал эту фамилию. Точно так же унаследовал ее Дасти. В ООП наследуются атрибуты и методы от других классов, как человек наследует физические черты или особенности характера от других.

Например, в нашем комплекте шахмат - 32 фигуры, но только шесть различных типов фигур (пешки, ладьи, слоны, кони, король и ферзь) со своим особым, отли­чающимся от других способом движения. Все эти классы имеют такие свойства, как цвет, принадлежность к шахматному комплекту и способ движения. Шесть типов фигур наследуют свойства общего класса **Фигура**.

На рис. 1.10 белая стрелка указывает, что отдельные классы наследуют свойства от класса **Фигура**. Все дочерние классы автоматически имеют атрибуты **набор_ шахмат и цвет.** Все фигуры выглядят по-разному (внешний вид отображается на экране доски) и могут ходить по шахматной доске только определенным способом движения.

Понятно, что все дочерние классы класса Фигура должны иметь метод движе­ние; иначе, когда мы попробуем передвинуть фигуру, выйдет ошибка. Также мы можем создать новую версию шахмат с новой фигурой (создадим фигуру Волшебник!). Наш текущий проект позволяет спроектировать фигуру без метода движение. И вновь мы потерпели бы неудачу, если бы захотели передвинуть подобную фигуру.

![[Наследование в шахматных фигурах.jpg]]

==Полиморфизм== - крутой принцип, но в мире программирования Python ис­пользуется редко. **Python обращается с дочерним классом точно так же, как с родительским**. Доска на Python реализует абсолютно любой объект с методом движение, будь то Слон, Автомобиль или Утка. Когда движение вызывается, Слон двигается диагонально, Автомобиль едет, а Утка плавает или летает в за­висимости от настроения.

Полиморфизм на Python реализован как утиная типизация: *если что-то выгля­дит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка*.


## [[Множественное наследование]]

Наследование в семье происходит от обоих родителей. Когда матери говорят, что у ее сына папины глаза, она отвечает: «да, но у него мой нос».

==Множественное наследование== - одна из особенностей объектно-ориентирован­ного проектирования, позволяющая наследовать функциональность от многих родительских классов. На практике реализация такого наследования - дело не из легких, а в некоторых языках категорически запрещена (например, вjava). Но множественное наследование используют в тех случаях, когда необходимо создать объект с двумя типами поведения. Скажем, нужно создать объект, который сканирует изображение и посылает его факсом. Такой объект можно получить путем наследования свойств от двух других объектов - **сканера и факса**.

Все будет в порядке, пока дочерний класс наследует поведение от двух родителей, имеющих разные интерфейсы. Но становится гораздо сложнее и запутаннее, если он наследует от двух родителей, интерфейсы которых совпадают. Со ска­нером и факсом нет никаких проблем, они выполняют разные задачи. Разберем другую ситуацию.

Допустим, есть мотоцикл и лодка, которые оба наследуют поведение от метода движение. Но что делать, если нужно создать машину-амфибию? Как резуль­тирующий класс будет знать, какое движение наследовать от метода движение? На уровне проектирования потребуется поломать голову. (И для одного из авторов, живущего на корабле, ответ на этот вопрос составляет почти жизненный интерес.)

В Python есть **порядок разрешения методов** (method resolution order, ==MRO==), который помогает понять, какие альтернативные методы нужно использовать. Хотя порядок разрешения методов и прост сам по себе, но все-таки избежать совпадения или пересечения интерфейсов еще проще. Множественное насле­дование с техниками вроде «миксинов» (mix-in - «смешивания») оказывается полезным в случае объединения разных функций, но можно обойтись без него, если сразу проектировать составной объект.

==[[Наследование]]== - мощное средство для многократного использования кода. Этот замечательный инструмент демонстрирует преимущество ООП над более ранними парадигмами. Поэтому очень часто ООП-программисты хватаются за него в первую очередь. Однако, как говорят, молотком не превратишь шурупы в гвозди. Наследование следует применять, когда в задаче между объектами есть явное близкое отношение. Иначе структура кода становится грязной. Если такое случается, не стоит сразу утверждать, что этот проект плох, но нужно за­ думаться - почему он именно такой? Может, уместнее было бы использовать иные отношения или иной паттерн проектирования?