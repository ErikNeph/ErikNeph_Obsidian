---
date of creation: 2024-06-28T17:39:00
tags:
  - Python
  - OOP/Python
  - Patterns
  - Patterns/Python
  - Python/Patterns
  - Developing/Python
Read status: false
aliases:
  - новые паттерны проектирования
---
---
# Новые паттерны проектирования
2024-06-28




В этой главе вы познакомитесь еще с несколькими паттернами проектирования. Мы вместе рассмотрим примеры их использования и реализацию на Python. Вы освоите следующие темы.

- **[[#Паттерн Адаптер|Паттерн Адаптер]]** ==(Adapter)==
- **Паттерн Фасад** ==(Façade)==
- **Ленивая инициализация и паттерн Легковес** ==(Flyweight)==
- **Паттерн Абстрактная фабрика** ==(Abstract Factory)==
- **Паттерн Компоновщик** ==(Composite)==
- **Паттерн Шаблонный метод** ==(Template)==

Начнем свое изучение с паттерна Адаптер. По сути, он типичный переходник для разных интерфейсов или данных.




## Паттерн Адаптер
---

В отличие от большинства рассмотренных в предыдущей главе паттернов **паттерн Адаптер** предназначен для взаимодействия с уже существующим кодом. Мы не стали разрабатывать совершенно новый набор объектов, реализующих **паттерн Адаптер**. Адаптеры используются для обеспечения совместной работы двух объектов, даже если их интерфейсы несовместимы. Как и адаптеры дисплея, позволяющие подключать зарядный кабель Micro USB к телефону USB-C, адаптер находится между двумя разными интерфейсами, леrко переводя их между собой. ==Единственной целью адаптера является выполнение данного преобразования. Ведь адаптация может повлечь за собой множество задач, таких как преобразование арrументов в другой формат, изменение порядка аргументов, вызов метода с другим именем или предоставление аргументов по умолчанию.==

По структуре **паттерн Адаптер** похож на упрощенный вариант **[[Общие Паттерны Проектирования#Паттерн Декоратор|паттерна Декоратор]]**. Но декораторы обычно предоставляют тот же интерфейс, который они заменяют, тогда как адаптеры служат мостом между двумя разными интерфейсами, что представлено на UМL-диаграмме (рис. 12.1).

>![[Рис. 12.1. Паттерн Адаптер.jpg]]
>           **Рис. 12.1.** Паттерн Адаптер

В данном случае клиентский объект, экземпляр **`Client`**, чтобы сделать что-то полезное, должен работать совместно с другим классом. Для этого используется **`load_data()`** как конкретный пример метода, в котором требуется адаптер. Уже имеется класс **`Implementation`**, который делает все, что необходимо (и чтобы избежать дублирования, мы не будем его переписывать!). Однако существует проблема: класс требует сложной последовательности операций с использованием методов **`read_raw_data()`** , **`parse_raw_d ata()`** и  **`createuseful_object()`**. Класс Adapter реализует простой в использовании интерфейс **`load_data()`** , который скрывает сложность существующего интерфейса, предоставляемого классом **`Implementation`**.

Преимущество такой схемы заключается в том, что весь код, отображающий сопоставляемый ожидаемый и фактический интерфейсы, находится в одном месте - в классе Adapter. В качестве альтернативы можно было бы поместить код в клиента, дополняя его не относящимися к делу деталями реализации. В такой редакции кода при наличии нескольких типов клиентов пришлось бы в нескольких местах выполнять сложную обработку **`loaddata()`** всякий раз, когда какому-то из этих клиентов потребовался бы доступ к классу **`Implementation`**.



### Пример реализации паттерна Адаптер
---

Представьте, что уже существует класс, который принимает временные метки строк в формате ННММSS и вычисляет полезные интервалы с плавающей запятой:

```python
class TimeSince:
    """Expects time as six digits, no punctuation."""

    def parse_time(self, time: str) -> tuple[float, float, float]:
        return (
            float(time[0:2]),
            float(time[2:4]),
            float(time[4:]),
        )

    def __init__(self, starting_time: str) -> None:
        self.hr, self.min, self.sec = self.parse_time(starting_time)
        self.start_seconds = ((self.hr * 60) + self.min) * 60 +                                      self.sec

    def interval(self, log_time: str) -> float:
        log_hr, log_min, log_sec = self.parse_time(log_time)
        log_seconds = ((log_hr * 60) + log_min) * 60 + log_sec
        return log_seconds - self.start_seconds

```

Этот класс выполняет преобразование строки во временной интервал и уже присутствует в приложении, имеет модульные тесты и прекрасно работает. Если вы забудете импортировать аннотации **`from __future__`**, при попытке использовать **`tuple[float, float, float]`** в качестве подсказки типа получите сообщение об ошибке. Не забудьте включить модуль аннотаций в качестве первой строки кода. Например, так:

```python
>>> ts = TimeSince('000123')  # logstarted at 00:01:23
>>> ts.interval('020304')
7301.0
>>> ts.interval('030405')
10962.0
```

Работать с таким неформатированным временем немного неудобно, но ряд устройств Internet of Тhings (IoT) предоставляют именно такие временные строки, отделенные от остальной части даты. Посмотрите, например, на сообщения формата NMEA 0183 от устройства GPS, там даты и время представляют собой неформатированные строки цифр.

У нас имеется старый лог-файл с одного из этих устройств, очевидно созданный несколько лет назад. Необходимо проанализировать этот лог-файл на наличие последовательности сообщений, которые появляются после каждого сообщения `ERROR`, и, кроме того, получить точное время относительно сообщения `ERROR` в качестве анализа основной причины проблемы.

Например:
```python
>>> data = [
...     ("000123", "INFO", "Gila Flats 1959-08-20"),
...     ("000142", "INFO", "test block 15"),
...     ("004201", "ERROR", "intrinsic field chamber door locked"),
...     ("004210.11", "INFO", "generator power active"),
...     ("004232.33", "WARNING", "extra mass detected")
... ]
```

Вычислить временной интервал между сообщением **`ERROR`** и **`WARNING`** сложно, но возможно. У многих программистов достаточно навыков, чтобы производить подобные вычисления. Но, может, лучше проанализировать лог-файл, содержащий относительное время, а не абсолютное? Ниже представлена схема форматирования лог-файла, которую необходимо использовать. Однако здесь вырисовывается проблема, которую мы отметили символами **`???`** :