---
date of creation: 2024-06-28T17:39:00
tags:
  - Python
  - OOP/Python
  - Patterns
  - Patterns/Python
  - Python/Patterns
  - Developing/Python
Read status: false
aliases:
  - новые паттерны проектирования
---
---
# Новые паттерны проектирования
2024-06-28




В этой главе вы познакомитесь еще с несколькими паттернами проектирования. Мы вместе рассмотрим примеры их использования и реализацию на Python. Вы освоите следующие темы.

- **[[#Паттерн Адаптер|Паттерн Адаптер]]** ==(Adapter)==
- **[[#Паттерн Фасад|Паттерн Фасад]]** ==(Façade)==
- **Ленивая инициализация и паттерн Легковес** ==(Flyweight)==
- **Паттерн Абстрактная фабрика** ==(Abstract Factory)==
- **Паттерн Компоновщик** ==(Composite)==
- **Паттерн Шаблонный метод** ==(Template)==

Начнем свое изучение с паттерна Адаптер. По сути, он типичный переходник для разных интерфейсов или данных.




## Паттерн Адаптер
---

В отличие от большинства рассмотренных в предыдущей главе паттернов **паттерн Адаптер** предназначен для взаимодействия с уже существующим кодом. Мы не стали разрабатывать совершенно новый набор объектов, реализующих **паттерн Адаптер**. Адаптеры используются для обеспечения совместной работы двух объектов, даже если их интерфейсы несовместимы. Как и адаптеры дисплея, позволяющие подключать зарядный кабель Micro USB к телефону USB-C, адаптер находится между двумя разными интерфейсами, леrко переводя их между собой. ==Единственной целью адаптера является выполнение данного преобразования. Ведь адаптация может повлечь за собой множество задач, таких как преобразование арrументов в другой формат, изменение порядка аргументов, вызов метода с другим именем или предоставление аргументов по умолчанию.==

По структуре **паттерн Адаптер** похож на упрощенный вариант **[[Общие Паттерны Проектирования#Паттерн Декоратор|паттерна Декоратор]]**. Но декораторы обычно предоставляют тот же интерфейс, который они заменяют, тогда как адаптеры служат мостом между двумя разными интерфейсами, что представлено на UМL-диаграмме (рис. 12.1).

>![[Рис. 12.1. Паттерн Адаптер.jpg]]
>           **Рис. 12.1.** Паттерн Адаптер

В данном случае клиентский объект, экземпляр **`Client`**, чтобы сделать что-то полезное, должен работать совместно с другим классом. Для этого используется **`load_data()`** как конкретный пример метода, в котором требуется адаптер. Уже имеется класс **`Implementation`**, который делает все, что необходимо (и чтобы избежать дублирования, мы не будем его переписывать!). Однако существует проблема: класс требует сложной последовательности операций с использованием методов **`read_raw_data()`** , **`parse_raw_d ata()`** и  **`createuseful_object()`**. Класс Adapter реализует простой в использовании интерфейс **`load_data()`** , который скрывает сложность существующего интерфейса, предоставляемого классом **`Implementation`**.

Преимущество такой схемы заключается в том, что весь код, отображающий сопоставляемый ожидаемый и фактический интерфейсы, находится в одном месте - в классе Adapter. В качестве альтернативы можно было бы поместить код в клиента, дополняя его не относящимися к делу деталями реализации. В такой редакции кода при наличии нескольких типов клиентов пришлось бы в нескольких местах выполнять сложную обработку **`loaddata()`** всякий раз, когда какому-то из этих клиентов потребовался бы доступ к классу **`Implementation`**.



### Пример реализации паттерна Адаптер
---

Представьте, что уже существует класс, который принимает временные метки строк в формате ННММSS и вычисляет полезные интервалы с плавающей запятой:

```python
class TimeSince:
    """Expects time as six digits, no punctuation."""

    def parse_time(self, time: str) -> tuple[float, float, float]:
        return (
            float(time[0:2]),
            float(time[2:4]),
            float(time[4:]),
        )

    def __init__(self, starting_time: str) -> None:
        self.hr, self.min, self.sec = self.parse_time(starting_time)
        self.start_seconds = ((self.hr * 60) + self.min) * 60 +                                      self.sec

    def interval(self, log_time: str) -> float:
        log_hr, log_min, log_sec = self.parse_time(log_time)
        log_seconds = ((log_hr * 60) + log_min) * 60 + log_sec
        return log_seconds - self.start_seconds

```

Этот класс выполняет преобразование строки во временной интервал и уже присутствует в приложении, имеет модульные тесты и прекрасно работает. Если вы забудете импортировать аннотации **`from __future__`**, при попытке использовать **`tuple[float, float, float]`** в качестве подсказки типа получите сообщение об ошибке. Не забудьте включить модуль аннотаций в качестве первой строки кода. Например, так:

```python
>>> ts = TimeSince('000123')  # logstarted at 00:01:23
>>> ts.interval('020304')
7301.0
>>> ts.interval('030405')
10962.0
```

Работать с таким неформатированным временем немного неудобно, но ряд устройств Internet of Тhings (IoT) предоставляют именно такие временные строки, отделенные от остальной части даты. Посмотрите, например, на сообщения формата NMEA 0183 от устройства GPS, там даты и время представляют собой неформатированные строки цифр.

У нас имеется старый лог-файл с одного из этих устройств, очевидно созданный несколько лет назад. Необходимо проанализировать этот лог-файл на наличие последовательности сообщений, которые появляются после каждого сообщения `ERROR`, и, кроме того, получить точное время относительно сообщения `ERROR` в качестве анализа основной причины проблемы.

Например:
```python
>>> data = [
...     ("000123", "INFO", "Gila Flats 1959-08-20"),
...     ("000142", "INFO", "test block 15"),
...     ("004201", "ERROR", "intrinsic field chamber door locked"),
...     ("004210.11", "INFO", "generator power active"),
...     ("004232.33", "WARNING", "extra mass detected")
... ]
```

Вычислить временной интервал между сообщением **`ERROR`** и **`WARNING`** сложно, но возможно. У многих программистов достаточно навыков, чтобы производить подобные вычисления. Но, может, лучше проанализировать лог-файл, содержащий относительное время, а не абсолютное? Ниже представлена схема форматирования лог-файла, которую необходимо использовать. Однако здесь вырисовывается проблема, которую мы отметили символами **`???`** :

```python
class LogProcessor:
    def __init__(self, log_entries: list[tuple[str, str, str]]) ->           None:
        self.log_entries = log_entries

    def report(self) -> None:
        first_time, first_sev, first_msg = self.log_entries[0]
        for log_time, severety, message in self.log_entries:
            if severety == "ERROR":
                first_time = log_time
            interval = ??? Need to compute an interval ???
            print(f"{interval:8.2f} | {severety:7s} {message}")
            
```

Класс **`LogProcessor`** кажется правильным. Он перебирает записи лог-файла, сбрасывая переменную **`first_time`** при каждом появлении строки **`ERROR`**. Это гарантирует, что лог-файл отображает позицию ошибки, избавляя нас от необходимости выполнять множество математических вычислений.

Но взгляните повнимательнее: возникает необходимость повторно использовать класс **`TimeSince`**. Он не просто вычисляет интервал между двумя значениями. Существует несколько вариантов реализации данного сценария.

- Для работы со строками времени можно было бы переписать класс **`TimeSince`**. Но тогда возникает риск нарушить код в нашем приложении. Иногда это называется радиусом разбрызгивания - сколько вещей в окружении намокнет, если бросить камень в бассейн? Принцип открытого/закрытого проектирования (один из принципов SOLID, дополнительную информацию можно получить на сайте https://subscription.packtpub.com/book/application_development/9781788835831/4) предполагает, что класс должен быть доступен для расширения, но недоступен для подобных модификаций. Если класс был загружен из `PyPI`, мы можем не изменять его внутреннюю структуру, так как тогда станет невозможно использовать последующие релизные версии. Необходим альтернативный вариант работы внутри другого класса.

- Мы могли бы использовать класс как есть и всякий раз при необходимости вычислить интервалы между сообщением **`ERROR`** и последующими строками лог-файла создавать новый объект **`TimeSince`**. Это выливается в создание большого количества объектов. Представьте, что имеется несколько приложений для анализа лог-файлов, каждое из которых рассматривает различные аспекты сообщений этих файлов. Внесение изменений означает необходимость вернуться и исправить все места, где были созданы объекты **`TimeSince`**. Если в классе **`LogProcessor`** слишком много деталей, связанных с работой класса **`TimeSince`**, нарушается принцип единой ответственности. А также вспомним еще один принцип - Не повторяйся (DRY), который применим и в этом случае.

- Вместо этого можно добавить адаптер, который связывает потребности класса **`LogProcessor`** с методами, доступными в классе **`TimeSince`**.

Решение с **паттерном Адаптер** подразумевает наличие класса с интерфейсом, необходимым для класса **`LogProcessor`**. Он также использует интерфейс, предлагаемый классом **`ТimeSince`**. То есть он представляет собой развитие обоих классов, оставляя их закрытыми для модификации, но доступными для расширения. Например, так, как в следующем фрагменте кода:

```python
from typing import Optional


class IntervalAdapter:
    def __init__(self) -> None:
        self.ts: Optional[TimeSince] = None

    def time_offset(self, start: str, now: str) -> float:
        if self.ts is None:
            self.ts = TimeSince(start)
        else:
            h_m_s = self.ts.parse_time(start)
            if h_m_s != (self.ts.hr, self.ts.min, self.ts.sec):
                self.ts = TimeSince(start)
        return self.ts.interval(now)
```

Этот адаптер создает объект **`ТimeSince`**, когда это необходимо. Если **`TimeSince`** отсутствует, адаптер должен его создать. Если объект **`TimeSince`** уже существует и использует уже установленное начальное время, то экземпляр **`TimeSince`** можно использовать повторно. Однако, как только класс **`LogProcessor`** сместил фокус на новое сообщение об ошибке, возникает необходимость создать новый экземпляр **`TimeSince`**.

Рассмотрим пример окончательного проекта класса **`LogProcessor`** с использованием класса **`IntervalAdapter`**:

```python
class LogProcessor:
    def __init__(self, log_entries: list[tuple[str, str, str]]) -> None:
        self.log_entries = log_entries
        self.time_convert = IntervalAdapter()

    def report(self) -> None:
        first_time, first_sev, first_msg = self.log_entries[0]
        for log_time, severity, message in self.log_entries:
            if severity == "ERROR":
                first_time = log_time
            interval = self.time_convert.time_offset(first_time,                                                         log_time)
            print(f"{interval:8.2f} | {severity:7s} {message}")
```

Здесь в процессе инициализации был создан экземпляр **`IntervalAdapter()`** . Затем этот объект применялся для вычисления каждой временной позиции, а существующий класс **`TimeSince`** повторно использовался без каких-либо модификаций исходного класса, причем класс **`LogProcessor`** не заботился о деталях работы экземпляра **`TimeSince`**.

Также в данном случае мы можем использовать наследование. Можно расширить экземпляр **`ТimeSince`**, чтобы добавить к нему необходимый метод. Альтернатива наследования - неплохая идея. Обратите внимание: похоже, это как раз та ситуация, когда нет единственного правильного ответа. В некоторых случаях имеет смысл обдумать реализацию с наследованием и сравнить ее с реализацией адаптера, проанализировав, какая из них проще.

Для добавления метода к существующему классу вместо наследования мы можем использовать метод *monkey patching*. Python позволяет добавлять новый метод, который предоставляет адаптированный интерфейс, необходимый для вызова кода. То есть внутри оператора **`class`** легко найти определение класса - но это будет не весь класс, используемый во время выполнения. И другие разработчики в случае необходимости будут вынуждены искать в коде место внедрения в класс новой функции. То есть вне модульного тестирования метод *monkey patching* не является хорошей идеей.

Как правило, в качестве адаптера можно использовать функцию. Хотя такой подход явно не соответствует классическому дизайну паттерна проектирования класса Адаптер, иногда этим несоответствием пренебрегают: класс с методом **`__call__()`** является вызываемым объектом, неотличимым от функции. Функция тоже может быть отличным адаптером. Python не требует, чтобы все было определено в классах.

Различие между **паттернами Адаптер и Декоратор** незначительное, но важное. **Паттерн Адаптер**, как правило, расширяет, модифицирует или комбинирует более одного метода из адаптируемых классов. Паттерн Декоратор обычно избегает значительных изменений, сохраняя интерфейс исходного метода, постепенно добавляя функции. Как уже указывалось в [[Общие Паттерны Проектирования]] , паттерн Декоратор следует рассматривать как особый вид адаптера.

Использование класса Адаптер аналогично использованию класса **Стратегия**. Идея состоит в том, что после внесения изменений может понадобиться другой адаптер. Принципиальное отличие заключается в том, что стратегии часто выбираются во время выполнения, а адаптеры выбираются во время разработки и изменяются очень редко.

Следующий паттерн, который мы рассмотрим, похож на Адаптер, так как он также заключает функциональность в новый контейнер. Разница состоит в сложности того, что именно обертывается. **Паттерн Фасад**, как правило, содержит значительно более сложные конструкции.





## Паттерн Фасад
---

