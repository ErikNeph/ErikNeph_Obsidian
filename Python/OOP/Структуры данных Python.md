Мы затронем следующие темы.

**• Обычные и именованные кортежи.**
**• [[Классы данных]].**
**• Словари.**
**• Списки и множества.**
**• Очереди трех типов.**

Начнем с рассмотрения нескольких основополагающих конструкций, а именно - с класса `object`(объект).


## Пустые объекты

Рассмотрим базовую, встроенную в Python структуру, уже много раз использованную нами в неявном виде, которую (как оказалось) мы расширяли в каждом создаваемом нами классе: `object`.
Технически можно создать экземпляр класса object без подкласса:

`>>> o = object()`
`>>> o.x = 5`
  `Traceback (most recent call last)`
  `File '<stdin>', line 1, in <module>`
  `AttributeError: 'object' objects has no attribute 'x'`

К сожалению, созданному объекту невозможно задать атрибуты. Причина отнюдь не зловещее желание разработчиков Python заставить нас писать собственные классы. Это сделано для экономии памяти. Когда объекту доступны произвольные атрибуты, Python выделяет конкретный объем системной памяти для отслеживания атрибутов всех объектов и для хранения имени и значения каждого атрибута. Даже если у объекта нет существующих атрибутов, память уже выделена на тот случай, если атрибуты все же понадобятся. Учитывая десятки, сотни или даже тысячи объектов (а каждый класс является расширением класса `object`) в типичной программе на Python, этот небольшой объем выделенной памяти быстро увеличился бы до огромных масштабов при использовании произвольных атрибутов во всех классах. Поэтому Python по умолчанию запрещает использование произвольных атрибутов в классе `object` и в нескольких других встроенных структурах.

Однако создание пустого класса объекта довольно тривиально; мы уже рассматривали это в одном из недавних примеров:

`>>> class MyObject:`
    `pass`

о сути, код class `MyObject` равноценен коду class `MyObject(object)`. И, как уже было показано, в таких классах возможно задать атрибуты следующим образом:

`>>> m = MyObject()`
`>>> m.x = 'hello'`
`>>> m.x`
`hello`

Если бы мы хотели сгруппировать неизвестное количество атрибутов вместе, мы могли бы хранить их в пустом объекте наподобие этого. Проблема такого подхода заключается в отсутствии очевидной схемы, с помощью которой можно было бы разобраться, какие атрибуты должны присутствовать и какие типы значений они будут иметь.

Основное внимание этой книги сфокусировано на том, как работать с классами и объектами с учетом того, что только они должны определять и данные, и поведение.

Поэтому необходимо с самого начала работы с данными определяться, действительно это данные в чистом виде или замаскированный объект. Затем оставшаяся часть проекта прорабатывается согласно исходной концепции.


## Обычные и именованные кортежи

Кортежи - это объекты, которые могут последовательно хранить определенное количество других объектов. Они *неизменяемы* - в процессе выполнения программы в кортеж нельзя добавить, из него удалить или в нем заменить объекты. Может показаться, что это довольно существенное ограничение, однако обычно бывает так: если программисту становится необходимо изменять кортеж, · значит, он должен сделать вывод о том, что выбрал неверный тип данных для своих операций (скажем, для его целей лучше подошел бы список). Основное преимущество неизменяемости кортежа в том, что кортеж из неизменяемых объектов (таких как строки, числа и другие кортежи) имеет хеш-значение, позволяющее использовать эти объекты как ключи в словарях и как элементы множества. ( Кортеж, содержащий изменяемую структуру, например список, множество или словарь, не имеет хеш-значения. Более подробно мы рассмотрим это в следующем разделе.)

Экземпляры встроенного в Python универсального класса `tuple` используются для хранения данных; для кортежа как встроенной в Python структуры нельзя определить поведение. Если же нужно управлять кортежем, то необходимо передать кортеж в качестве аргумента функции, которая произведет необходимые действия. Данная тема описана в главе 8.

**Распаковка** - очень полезная функция в Python. Кортеж группирует связанные значения, чтобы упростить их хранение и передачу; в тот момент, когда нужно получить доступ к определенным элементам кортежа, их можно извлечь в отдельные переменные. Разумеется, иногда нужен доступ только к одной из переменных в кортеже. Тот же синтаксис, что и для других типов последовательностей (например, списков и строк), можно использовать, чтобы получить доступ к отдельному значению:


## Кортежи, именованные с применением `typing. NamedTupLe`

Итак, что же делать, когда необходимо сгруппировать значения вместе, но известно, что в перспективе часто потребуется обращаться к ним по отдельности? В действительности существует несколько сценариев такой работы.

- Можно использовать пустой экземпляр объекта, как обсуждалось ранее. Присвоить этому объекту произвольные атрибуты. Однако, если четко не определить, что разрешено и какие типы ожидаются, в дальнейшем разобраться в этом будет трудно. И мы получим много ошибок `mypy`.
- Можно использовать словарь. Это сработает, и допустимый список ключей для словаря будет формализован с помощью подсказки` typing. TypedDict`. Мы коснемся этой темы в учебном примере главы 9.
- Можно использовать `@dаtасlаss` - это тема следующего раздела этой главы.
- Можно также закрепить имена за позициями кортежа. Заодно определить методы для таких именованных кортежей, что сделает их очень полезными.

==Именованные кортежи== - это кортежи с отношением - отличный способ создания неизменяемой совокупности значений данных. Определяя именованный кортеж, мы тем самым создаем подкласс `typing.NamedTuple`, основанный на списке имен и типов данных. Нет необходимости писать мeтoд `_init_()`: он будет создан автоматически. В качестве примера:

`from typing import NamedTuple`
`>>> class Stock(NamedTuple):`
`...     symbol: str`
`...     current: float`
`...     high: float`
`...     low: float`

Этот новый класс будет иметь ряд методов, включая `__init__()` , `__repr__()` , `__hash__()` и `__eq__()` .
Ниже приведен пример, как можно создать кортеж этого класса. Выглядит почти как создание обычного кортежа:

`>>> Stock('AAPL', 123.52, 137.98, 56.11)`

Используем ключевые слова для большей ясности:

`>>> s2 = Stock('AAPL', 123.52, high=137.98, low=56.11)`

Важно учитывать, что имена, предоставленные на уровне класса, на самом деле не создаются в качестве атрибутов класса. Имена на уровне класса используются для создания метода `__init__()` ; каждый экземпляр класса будет иметь ожидаемые имена для позиций в кортеже. Здесь происходит умелое преобразование на уровне метакласса из того, что мы написали, в несколько более сложное определение результирующего класса с именованными позиционными элементами.

Полученный экземпляр подкласса `NamedTuple` - `Stock` - в дальнейшем можно будет упаковать, распаковать, индексировать, получить с него срез и обработать как обычный кортеж, но также реально получить доступ к отдельным атрибутам по имени, как если бы это был объект:

`>>>s2.high`
`137.98`
`>>>s2[2]`
`137.98`
`>>>symbol, current, high, low = s`
`Traceback (most recent call last):`
  `File "<stdin>", line 1, in <module>`
`NameError: name 's' is not defined. Did you mean: 's2'?`
`>>> symbol, current, high, low = s2`
`>>> current`
`123.52`

Именованные кортежи идеально подходят во многих случаях. Как и строки, кортежи и именованные кортежи неизменяемы, так что нельзя изменить атрибут после того, как он был определен. К примеру, текущая стоимость акций компании из предыдущих примеров упала с того момента, как это обсуждение началось, но новое значение мы задать не можем.

**Наличие нехешируемого объекта списка означает, что кортеж также будет целиком нехешируемым**

Можно создавать методы для вычисления значений, производных от атрибутов именованного кортежа. К примеру, мы можем переопределить наш кортеж `Stock`, чтобы включить в него метод (или декоратор `@рrореrtу`) для расчета среднего значения:

`>>> class Stock(NamedTuple):`
`...     symbol: str`
`...     current: float`
`...     high: float`
`...     low: float`
`...     @property`
`...     def middle(self) -> float:`
`...             return (self.high + self.low) / 2`

Итак, нельзя изменить состояние, но можно вычислить значения, полученные на основе текущего состояния. Это позволяет связывать вычисления непосредственно с кортежем, содержащим исходные данные. Вот объект, созданный на базе приведенного определения класса `Stock`:

`>>> s = Stock('AAPL', 123.52, 137.98, 53.15)`
`>>> s.middle`
`95.565`

Метод `middle()` теперь является частью определения класса. Что еще лучше, инструмент `mуру` поможет остановиться и удостовериться, что все подсказки для типов должным образом отвечают установленным требованиям во всем приложении.

Итог: состояние именованного кортежа фиксируется во время его создания. Если же необходимо иметь возможность изменять хранимые данные, то класс данных (`dataclass`) может быть тем, что можно предложить взамен неподходящим именованным кортежам. Приступим к рассмотрению классов данных.


## Классы данных

Начиная с Python 3.7 классы данных позволяют при определении обычных объектов указывать их атрибуты с использованием чистого синтаксиса кода. Внешне эти классы очень похожи на именованные кортежи. Такой довольно приятный подход облегчает понимание их работы.

Вот версия нашего примера `Stock` в качестве класса данных:

`from dataclasses import dataclass`
`>>> @dataclass`
`... class Stock:`
`...     symbol: str`
`...     current: float`
`...     high: float`
`...     low: float`

С оператором `@dataclass` применим в качестве декоратора класса. Мы уже сталкивались с декораторами в главе 6. А более подробно они будут рассмотрены в главе 11. Такой синтаксис определения класса не то чтобы значительно лаконичнее обычного класса с методом `__init__()` , однако он предоставляет доступ к нескольким дополнительным возможностям модуля `dataclass`.

Важно понимать, что хоть имена и предусматриваются на уровне класса, но, по сути, никакие атрибуты на уровне класса не создаются. Имена уровня класса используются для создания нескольких методов, включая метод `__init__()`; каждый экземпляр класса будет только ожидать наличия данных атрибутов. Декоратор преобразует все то, что мы написали, в более сложное определение класса с ожидаемыми атрибутами и параметрами для метода `__init__()`.

Поскольку объекты типа `dataclass` могут быть изменяемыми объектами, фиксирующими свое состояние, доступен ряд дополнительных возможностей. Начнем с основ. Вот пример создания экземпляра класса данных `Stock`:

`>>> s = Stock('AAPL', 133.23, 165.22, 51.11)`

Сразу после создания объект `Stock` может быть использован как обычный класс. Доступ к его атрибутам возможен, а значит, можно и обновить их следующим образом:

`>>> s`
`Stock(symbol='AAPL', current=133.23, high=165.22, low=51.11)`
`>>> s.current`
`133.23`
`>>> s.current = 122.25`
`>>> s`
`Stock(symbol='AAPL', current=122.25, high=165.22, low=51.11)`

Как и в случае с другими объектами, можно добавлять новые атрибуты, помимо тех, что формально были объявлены как часть класса данных. Это не всегда лучшее решение, однако оно имеет право на существование, поскольку такой класс является обычным изменяемым объектом:

`>>> s.unexpected_attribute = 'allowed'`
`>>> s.unexpected_attribute`
`'allowed'`

Добавление атрибутов недоступно для замороженных классов данных, о которых мы поговорим чуть позже в этом разделе. На первый взгляд кажется, что классы данных не дают особо много преимуществ по сравнению с определением обычного класса с соответствующим конструктором. Вот пример обычного класса, похожего на класс данных:

`>>> class StockOrdinary:`
`...     def __init__(self, name: str, current: float, high: float, low: float) -> None:`
`...             self.name = name`
`...             self.current = current`
`...             self.high = high`
`...             self.low = low`
`...`
`>>> s_ord = StockOrdinary('AAPL', 133.33, 171.11, 60.44)`

Одно из очевидных преимуществ класса данных заключается в том, что имена атрибутов необходимо указывать только один раз, избегая повторения этого действия в параметрах и теле мeтoдa `__init__()` . Но подождите, это еще не все! Строковое представление класса данных намного более информативно, чем то, которое получается от неявного суперкласса, `object`. По умолчанию классы данных также включают в себя проверку на равенство. Ее можно отключить для случаев, когда это не имеет смысла. В следующем примере сравниваются экземпляры созданного вручную класса:

`>>> s_ord`
`<__main__.StockOrdinary object at 0x00000210681D3A90>`
`>>> s_ord_2 = StockOrdinary('AAPL',133.33, 171.11, 60.44)`
`>>> s_ord == s_ord_2`
`False`

Классы, определения которых дополнены @dataclass, обладают множеством других полезных возможностей. К примеру, для атрибутов класса данных возможно указать значение по умолчанию. Предположим, что в настоящее время рынок закрыт и вы не знаете, какие значения акций будут в этот день:

`>>> @dataclass`
`... class StockDefaults:`
`...     name: str`
`...     current: float = 0.0`
`...     high: float = 0.0`
`...     low: float = 0.0`

В ы можете создать этот класс, указав только название акции; оставшиеся атрибуты примут значения по умолчанию. Но если есть необходимость, вы все еще можете указать значения, как показано ниже:

`>>> StockDefaults('GOOG')`
`StockDefaults(name='GOOG', current=0.0, high=0.0, low=0.0)`
`>>> StockDefaults('GOOG', 1883.44, 1845.20, 1013.43)`
`StockDefaults(name='GOOG', current=1883.44, high=1845.2, low=1013.43)`

Ранее было показано, что классы данных п о умолчанию поддерживают проверку на равенство. Если все атрибуты соответственно равны, то и сами объекты типа `dataclass` целиком считаются равными. По умолчанию классы данных не поддерживают другие типы сравнений, таких как <меньше> или <больше>, и они не могут быть отсортированы. Однако при желании легко можно добавить методы сравнения, как показано ниже:

`>>> @dataclass(order=True)`
`... class StockOrdered:`
`...     name: str`
`...     current: float = 0.0`
`...     high: float = 0.0`
`...     low: float = 0.0`
`...`

Здесь можно спросить: <Это все, что нужно задавать?> Ответ: да. Указание параметра декоратора order= True приводит к созданию всех специальных методов сравнения. Такое изменение позволяет сортировать и сравнивать экземпляры данного класса. Работает это следующим образом:

`>>> stock_ordered1 = StockOrdered('GOOG', 1817.11, 1834.22, 1022.22)`
`>>> stock_ordered2 = StockOrdered('GOOG')`
`>>> stock_ordered3 = StockOrdered('GOOG', 1723.20, high=1747.88,` `low=1702.98)`
`>>> stock_ordered1 < stock_ordered2`
`False`
`>>> stock_ordered1 > stock_ordered2`
`True`
`>>> from pprint import pprint`
`>>> pprint(sorted([stock_ordered1, stock_ordered2, stock_ordered3]))`
`[StockOrdered(name='GOOG', current=0.0, high=0.0, low=0.0),`
` StockOrdered(name='GOOG', current=1723.2, high=1747.88, low=1702.98),`
` StockOrdered(name='GOOG', current=1817.11, high=1834.22, low=1022.22)]`

Когда декоратор класса данных получит аргумент `order=True`, он по умолчанию будет сравнивать значения, полученные от каждого из атрибутов, в том порядке, в котором они были определены. Так что в данном случае первым делом он сравнивает значения атрибута name у двух объектов. Если они совпадают, то он сравнивает значения атрибута `current`. Если и они одинаковы, то он переходит к атрибуту `high` и даже может захватить атрибут `low`, если все остальное будет равным. Здесь правила следуют из определения кортежа: порядок определения будет являться порядком сравнения.

Мы рассмотрели два способа создания уникальных классов с особыми значениями атрибутов - именованные кортежи и классы данных. Зачастую для решения задачи легче взять класс данных и добавить специализированные методы. Это сэкономит немного времени на программировании, поскольку некоторые базовые вещи, такие как инициализация, сравнение и строковые представления, будут элегантно обрабатываться за нас.


## Словари

**Словари** - это невероятно полезные контейнеры, позволяющие напрямую связать одни объекты с другими. Словари чрезвычайно эффективны для быстрого поиска значений по заданному объекту-ключу, который связан с объектом значением. Секрет их скорости состоит в использовании хеш-ключа для поиска значения. У каждого неизменяемого объекта в Python есть числовой хеш-код; для сопоставления числового хеша напрямую со значением используется относительно простая таблица. При использовании этого трюка нет необходимости в переборе целой коллекции для поиска значения: ключ преобразуется в хеш, который (почти) моментально обнаруживает связанное значение.

Словари могут быть созданы или с применением конструктора `dict()`, или через сокращенный синтаксис `{}` . На практике почти всегда используется последний формат. Можно предварительно заполнить словарь, разделив ключ и значение двоеточием, а пары <ключ - значение> - запятой.

**Встроенные изменяемые объекты** - включая списки, словари и множества не могут быть использованы в качестве ключей словаря. Такие изменяемые коллекции не предоставляют хеш-значения. Однако разработчики могут создать свой собственный класс объектов, которые одновременно могут быть изменяемыми и будут иметь хеш-значение. Подобное действие не является безопасной практикой, потому что изменение состояния объекта может затруднить поиск ключа в словаре.


## Списки

Список является стандартной структурой Python, интегрированной в ряд функций языка. Такие функции не нужно импортировать, и довольно редко возникает необходимость в использовании особых методов для доступа к их возможностям. Можно обратиться ко всем элементам списка без явного запроса объекта-итератора и даже создать список (как словарь) при помощи очень простого синтаксиса. Кроме того, понимание работы списковых включений (list-comprehensions) и выражений-генераторов превращает их в настоящий швейцарский армейский нож вычислительной функциональности.

В Python списки обычно используются, когда существует необходимость хранить несколько экземпляров объектов одного типа: списки строк или списки чисел. Подсказка типа `list[T]` часто служит для того, чтобы указать тип объекта - т, хранящегося в списке. Например, `list[int]` или `list[str]` .

Списки изменяемы, поэтому элементы можно добавлять, заменять и удалять из списка. Это может пригодиться для отражения состояния некоторых более сложных объектов.

Как и словари, списки тоже являются объектами. У них есть методы, которые могут быть вызваны. Вот некоторые из них:

• `append(element)` добавляет элемент в конец списка;
• `insert(index, element)` помещает элемент на определенную позицию;
• `count(element)` сообщает, сколько раз элемент появляется в списке;
• `index()` возвращает индекс элемента в списке, вызывая исключение, если он не может найти этот элемент;
• `find()` делает то же самое, но возвращает - 1 вместо исключения для отсутствующих элементов;
• `reverse()` делает именно то, о чем говорит - разворачивает список в обратном порядке;
• `sort()` обладает довольно сложным объектно-ориентированным поведением,
которое мы сейчас рассмотрим.


## Сортировка списков

Без каких-либо параметров метод списка `sort()` будет работать так, как это и ожидается. Для существующего объекта `list[str]` метод `sort()` расположит его элементы в алфавитном порядке. Указанная операция чувствительна к регистру, поэтому все заглавные буквы будут идти перед строчными; например, z идет перед а. Если это список чисел, они будут отсортированы в числовом порядке. Если предоставлен список кортежей, он будет сортироваться путем рассмотрения элементов в кортеже по порядку. Если в списке смесь разных элементов, сортировка вызовет исключение `TypeError`.

Пусть необходимо поместить в список объекты определенных нами классов и иметь возможность их сортировать. Придется проделать немного больше работы. Чтобы сделать экземпляры класса сравнимыми, внутри него нужно определить специальный метод `__lt__()` _, чье название означает less than («меньше чем»). В итоге метод сортировки будет обращаться к методу сравнения этого класса для каждого объекта, чтобы определить его место в списке. Указанный метод должен возвращать True, если класс каким-то образом меньше переданного параметра, и False в противном случае.


## Множества

Списки - это чрезвычайно универсальные инструменты, которые подходят для многих приложений с контейнерными объектами. Однако они бесполезны в случае, когда нам нужно быть уверенными в том, что объекты в списке являются уникальными. Например, библиотека песен может содержать множество песен одного и того же исполнителя. Бывает необходимо отсортировать библиотеку и создать список всех исполнителей, например, в случае, когда приходится проверять список на предмет того, не добавляли ли мы уже этого исполнителя, прежде чем добавлять его снова.

Именно в подобных случаях пригодятся множества. Множества пришли из математики, где они представляют собой неупорядоченную группу уникальных предметов. Можно попытаться добавить элемент в множество пятьдесят раз, но после первого добавления состояние элемента перестанет изменяться и останется таким: <является членом множества>

В Python множества могут содержать любые хешируемые объекты, а не только строки или числа. Хешируемые объекты реализуют метод `__hаsh__()` ; это те же объекты, которые используются в качестве ключей в словарях. Очевидно, что изменяемые списки, множества и словари не работают. Как и математические множества, множества Python могут хранить только одну копию каждого объекта.

Элементы можно добавлять во множество по отдельности с помощью метода `add()` или обновлять массово с помощью метода `update()` .

Множества по своей природе не упорядочены из-за хеш-структуры данных, используемой для эффективного доступа к их членам. Из-за отсутствия упорядоченности в множествах нельзя искать элементы по индексу. Основная цель множества - разделить мир на две группы: вещи, которые входят в множество, и вещи, которые в него не входят. Легко проверить, находится ли элемент в множестве, или перебрать все элементы множества, но если мы хотим отсортировать или упорядочить их, множество лучше преобразовать в список.

Основной особенностью множества является уникальность. Множества часто используются для дупликации данных, для создания комбинаций, включая объединения и разность между коллекциями. Большинство методов у типа set действуют на другие множества, позволяя эффективно объединять или сравнивать элементы двух или более множеств.


## Три типа очередей

На вопрос «Что лучше?> ответ будет стандартным: « Все зависит от того, что вам нужно сделать>.

• В случае одно поточных приложений идеально подходит `collections.deque`,
разработанный специально для этой цели.
• В многопоточных приложениях `queue`.`Queue` необходима для обеспечения целостности структуры данных, которая может быть прочитана и изменена несколькими параллельными потоками.

Хотя разработчики довольно часто для самых разных целей обращаются к встроенным структурам, например к стандартному классу `list`, иногда это может оказаться далеко не идеальным вариантом. Две другие реализации имеют несомненные преимущества перед встроенным списком. Стандартная библиотека Python и более широкая экосистема внешних пакетов, доступных через Python Package Index (PYPI), могут сделать ситуацию значительно более эффективной по сравнению со стандартными структурами. Важно иметь в виду конкретное улучшение, прежде чем начинать поиски «идеального> пакета. В нашем примере разница в производительности между deque и `list` невелика. Время является доминирующим фактором при работе ОС для сбора исходных данных. Для большой файловой системы, возможно охватывающей несколько хостов, разница между `deque` и `list` станет более ощутимой.


## Выводы

К настоящему моменту мы рассмотрели в общей сложности четыре способа решения задач объектно-ориентированного проектирования и их реализации.

• В предыдущих главах мы занимались созданием объектов с нуля, написав все определения методов самостоятельно. Был сделан упор на наследование между классами в иерархии классов Sample.
• В этой главе с помощью `@dataclass` мы рассмотрели определение класса, имеющего внутреннее состояние. Этот вариант поддерживает наследование между классами в иерархии классов `Sample`.
• Мы также видели определение класса, не имеющего внутреннего состояния (или неизменяемого) и использующего `@dataclass(frozen=True)` . Выбор его для использования в разработке, как правило, препятствует некоторым аспектам наследования и склоняет к композиции.
• Наконец, мы рассмотрели определения без внутреннего состояния (или неизменяемые), реализованные с помощью `NamedTuple`. Проектируются они с использованием композиции.


## Ключевые моменты

В этой главе мы рассмотрели множество встроенных структур данных Python. Python позволяет выполнять значительную часть объектно-ориентированного программирования без излишних затрат на многочисленные, потенциально занутанные определения классов. Мы можем полагаться на ряд встроенных классов там, где они подходят для использования в проекте.

Из данной главы вы узнали следующее.

• Кортежи и именованные кортежи позволяют эффективно использовать простую коллекцию атрибутов. Можно расширить определение `NamedTuple`, чтобы добавить методы, когда это необходимо.
• Классы данных предоставляют сложные коллекции атрибутов, разнообразные
методы, упрощающие код.
• Словари являются важной структурой, широко используемой в Python. Существует множество задач, где можно задействовать ключи, связанные со значениями. Синтаксис обращения к встроенному классу словаря делает его простым в использовании.
• Списки и множества также являются превосходными составляющими языка
Python; их можно использовать в приложениях.
• Мы также рассмотрели три типа очередей. Это более специализированные структуры с более целенаправленными шаблонами доступа, чем у стандартного объекта `list`. Концепция узкой специализации и сужения возможностей может улучшить производительность, что также позволяет широко применять данный способ.
