
Нам часто приходится различать конкретные классы, имеющие полный набор атрибутов и методов, и *абстрактные классы*, в которых не реализованы один или несколько методов. Например, можно сказать, что парусное судно и само­ лет имеют общие абстрактные свойства, будучи транспортными средствами, но фактически способы их движения различны.

К определению подобных вещей в Python существует два подхода.

-  **[[Утиная типизация]]:** когда два определения класса имеют одни и те же атрибу­ты и методы, экземпляры двух классов имеют один и тот же протокол и могут использоваться взаимозаменяемо. Мы часто говорим: « Если я вижу птицу, которая ходит как утка, плавает как утка и крякает как утка, я называю эту птицу уткой» .
-  **[[Наследование]]:** когда два определения класса имеют общие аспекты, подкласс также может иметь общие черты суперкласса. Деталь реализации двух классов могут различаться, но при использовании общих функций, определенных суперклассом, классы должны быть взаимозаменяемыми.

Отметим терминологическую проблему, возникающую при работе с поняти­ями «базовый класс и «суперкласс» Конечно, это синонимы, что и приводит к некоторой путанице. Также можно назвать их параллельными метафорами. Иногда будем использовать метафору «базовый класс - это основа», когда дру­гой класс строится на нем посредством наследования. В других случаях будем использовать метафору «конкретный класс расширяет суперкласс», имея в виду, что суперкласс превосходит конкретный класс. На диаграмме классов UML он обычно представлен над конкретным классом, и его необходимо определить
в первую очередь. Например, как показано на рис. 6.1

![[Абстрактный базовый класс.jpg]]

Базовый класс `BaseClass` в качестве родительского класса имеет специальный класс `abc.АВС` . Здесь классу предоставляются некоторые специальные функции метакласса, и конкретный класс заменяет абстракцию. На данной диаграмме абстрактный класс мы отметили буквой «А» в круге. Это дополнение необязательно, поэтому в других диаграммах такое обозначение не используется. Абстрактный класс иногда также выделяют курсивом.

На диаграмме приведен абстрактный метод `a_method( )`, не имеющий опреде­ленного содержимого. Это содержимое должен предоставить подкласс. Чтобы определить метод как абстрактный, имя метода выделим наклонным шрифтом. Два конкретных подкласса предоставляют данный отсутствующий метод.

Вы изучите следующее.

-  Создание абстрактного базового класса.
-  АBC и подсказки типов.
-  Модуль `collections .abc`.
-  Создание собственного абстрактного базового класса.
-  Развеивание мифов: заглянем <за кулисы> АБС.
-  Перегрузку операторов.
-  Расширение встроенных функций.
-  Метаклассы.


## Создание абстрактного базового класса

Класс `аbс.АВС` представляет собой метакласc - то есть класс, используемый для построения конкретных определений классов. type - простейший метакласс Python. При попытке создания экземпляра метакласс не проверяет абстрактные методы по умолчанию.
Класс `аbс.АВС` содержит расширение метакласса type, чтобы предотвратить создание неопределенных экземпляров классов.

Чтобы убедиться, что модуль имеет доступ к необходимым абстрактным базовым классам для приложения, можно использовать импорт. Одно из преимуществ утиной типизации - возможность избежать сложного импорта и при этом создать полезный класс, который может действовать полиморфно с одноранговыми классами. Это преимущество часто бывает важнее способ­ности определения класса `аbс.ABC` две поддерживать проверку типов через туру и выполнять проверку правильности определения подкласса во время выпол­нения. Класс `аbс.АВС` предоставляет более полезные сообщения об ошибках, когда что-то идет не так.

Модуль collections - один из рабочих вариантов использования ABC, который определяет встроенные универсальные коллекции, применяя сложный набор базовых классов и миксинов (примесей).


## Абстрактные базовые классы и подсказки типов

Большинство универсальных классов Python, например `list, dict и set`, могут использоваться как подсказки типов, и эти подсказки могут быть параметризованные для сужения предметной области. Между `list [Any]` и `list[int]` прин­ципиально большая разница. Значение `["а", 42, 3.14]` допустимо для первой подсказки типа, но недопустимо для второй. Данная концепция параметризаций универсального типа с целью сделать его более конкретным обычно применяется к абстрактным классам.

Универсальные классы и абстрактные базовые классы не одно и то же. Эти два понятия пересекаются, но они абсолютно разные.

-  Универсальные классы имеют неявную связь с Any, которую необходимо сократить с помощью параметров типа, таких как `list[int]` . Класс `list` яв­ляется конкретным, и когда необходимо будет его расширить, мы добавим имя класса, чтобы заменить тип Any. Интерпретатор Python не использует универсальные подсказки классов. Они проверяются только инструментами статического анализа, такими как `**mypy**`.
-  Абстрактные классы вместо одного или нескольких методов содержат плейс­холдеры, или заполнители. Методы-заполнители требуют проектного решения, обеспечивающего конкретную реализацию Эти классы полностью не определе­ны. При их расширении необходимо будет предоставить конкретную реализацию метода, что затем проверяется mуру. Но это не все. Если мы не предоставим отсутствующих методов, при попытке создать экземпляр абстрактного класса интерпретатор вызовет исключение времени выполнения.

Другое понятие, связанное с абстрактными классами, - **протокол**. Это суть того, как работает утиная типизация: когда два класса имеют один и тот же набор методов, они оба придерживаются общего **протокола**. Для всех классов с похо­жими методами существует общий протокол, что может быть формализовано с помощью подсказки типа.

Рассмотрим объекты, которые можно хешировать. Неизменяемые классы реализуют метод `__hash__()` , включая строки, целые числа и кортежи. Как правило, изменяемые классы не реализуют метод `__hash__()` . К ним также относятся такие классы, как `list, dict и set`. Здесь единственный метод протокол Hashable. При попытке вставить подсказку типа `dict[list[int],list[str])` mуру определит, что `list[int]` нельзя использовать в качестве ключа. Он не может быть ключом, так как данный тип `list[int]` не реализует протокол Hashable. Во время выполнения попытка создать элемент словаря с изменяемым ключом будет неудачной, так как список не реализует требуе­мый метод.

Суть создания `ABC` определяется в модуле `abc` Позже вы узнаете, как это работа­ет. А пока необходимо попрактиковаться в использовании абстрактных классов, а это означает использование определений в модуле `collections`.


## Модуль collections.abc

Использование абстрактных базовых классов показано в модуле `collections.аbс`. Он предоставляет определения абстрактных базовых классов для встроенных коллекций Python. Например, классы `list, set и dict` (и некоторые другие) могут быть созданы из определений отдельных компонентов.

Определения можно использовать для создания собственных уникальных структур данных таким образом, чтобы они пересекались со встроенными структурами. Мы также можем их использовать для создания подсказок типа определенного свойства в структуре данных, освобождая разработчика от не­обходимости подробно описывать альтернативные реализации, которые также могут быть допустимыми.

Определения в `collections.аbс` не включают `list, set или dict`. Вместо этого модуль предоставляет такие определения, как `MutableSequence`, `MutableMapping` и `MutableSet`, которые фактически являются абстрактными базовыми класса­ ми, и для них используемые классы `list, dict или set` являются конкретными реализациями.

Общий подход к использованию абстрактных классов следующий. 
1. Найти класс, который делает большую часть того, что вам необходимо.
2. Идентифицировать методы в определениях `collections.abc`, помеченные как *абстрактные*. Обычно документация дает много информации, но придется также проанализировать и другие источники.
3. Создать подкласс абстрактного класса, добавив недостающие методы. 
4. Хотя в данном случае может помочь контрольный список методов, существует множество других полезных инструментов. Создание модульного теста (с тестированием мы ознакомимся в главе 13) означает, что необходимо создать экземпляр нового класса. Если вы не определили все абстрактные методы, будет вызвано исключение. Использование инструмента туру также позволит обнаружить абстрактные методы, которые не определены должным образом в конкретном подклассе.


## Создание собственного абстрактного класса

Создавать собственные абстрактные классы мы можем двумя способами: с помощью утиной типизации или определения общих абстракций. При использовании утиной типизации мы можем формализовать связанные типы, создав подсказку типа с определением протокола для перечисления общих методов или с Union[] для перечисления общих типов.

Существует большое количество влияющих факторов, которые определяют выбор того или иного подхода. Утиная типизация обеспечивает наибольшую гибкость, и при этом можно не использовать `mуру`. Абстрактное определение базового класса может быть одновременно многословным и запутанным.

Основную роль в этом играет выбор способа создания классов: объекты создаются вызовом класса по его имени. В этом суть ООП. Но что же такое класс?

1. *Класс* - это еще один объект с двумя ограниченными задачами: он имеет специальные методы, используемые для создания экземпляров класса и управления ими, а также действует как контейнер, содержащий определения методов для объектов класса. Мы создаем класс с помощью оператора class. Теперь возникает вопрос, как оператор class строит объект class. 
2. Класс **type** - это внутренний объект, из которого создаются классы наших приложений. Когда мы вводим код класса, за его создание фактически отвечают методы класса type. После того как type создал наш класс приложения, класс затем создает объекты приложения, которые занимаются решением нашей проблемы.

Объект type называется **метаклассом** - классом, используемым для создания классов. Это означает, что каждый объект класса является экземпляром type. В большинстве случаев нам вполне подходит, когда оператор class обрабатывается классом type, чтобы код нашего приложения мог выполняться. Однако есть одно место, где мы можем изменить работу type.


## Метаклассы

Как м ы уже знаем, создание нового класса включает в себя работу, выполняемую классом `type`. Задача класса `type` состоит в создании пустого объекта класса, чтобы затем различные определения и операторы присваивания атрибутов построили окончательный, пригодный для использования класс, необходимый для разрабатываемого приложения.

![[как type создает Myclass.jpg]]

Оператор `class` используется для поиска соответствующего метакласса. Если не указана опция `metaclass=`, то используется класс `type`.
Класс `type` подготовит новый пустой словарь, называемый пространством имен, а затем различные операторы класса заполнят этот контейнер атрибутами и определениями методов. Наконец класс создан; появляется возможность вносить изменения.