
Прежде чем изучать паттерны проектирования более высокого уровня, ознакомимся с одним из самых распространенных объектов Python: строкой. Кроме того, рассмотрим поиск в строках-шаблонах и сериализацию для хранения или передачи данных.

Поскольку сохранение происходит через файловую систему, на уровне байтов, через операции записи и чтения ОС, это подразумевает два преобразования: данные, которые мы сохранили, должны быть декодированы в полезный набор объектов в памяти; объекты из памяти должны быть закодированы в текстовый или байтовый формат для хранения, передачи по сети или вызова на удаленном сервере.


## Строки

Строки - это базовый примитив в Python. Мы использовали их почти в каждом примере. Строки представляют неизменяемую последовательность символов. Возможно, вы даже задумывались, что понятие �символ» несколько двусмысленное. Могут ли строки Python представлять последовательности символов с диакритическим знаком, символом подчеркивания? А китайские иероглифы? А как насчет греческого, кириллического или фарси?

В Python3 это возможно. Строки Python представлены в Unicode в соответствии со стандартом определения символов, который может представлять практически любой символ любого языка в мире (а также некоторые искусственные языки и случайные символы). Все происходит легко и незаметно для пользователя. Итак, представим строки Python 3 как неизменяемую последовательность символов Unicode. В предыдущих примерах вы уже ознакомились с некоторыми способами использования строк. Предлагаем вспомнить их и кратко описать!

Очень важно не придерживаться устаревших методов кодирования. Кодировка ASCII, например, была ограничена одним байтом на символ. В Unicode имеется несколько способов кодирования символа в байты. Самая популярная, UTF-8, имеет тенденцию к устаревшей кодировке ASCII для некоторых знаков препинания и букв. Это примерно один байт на символ. Но если вам нужен один из тысяч других символов Unicode, может понадобиться несколько байтов.

В таком случае необходимо учитывать следующее правило: мы кодируем наши символы для создания байтов; мы декодируем байты, чтобы восстановить символы.

![[Строки и байты.jpg]]

Из-за канонического отображения значений байтов могут возникнуть проблемы в понимании кода. Python отобразит значение байта как `b'Flamb\xc3\xa9'`. В значении байтов буквы являются условным обозначением для чисел и используют старую схему кодирования ASCII.
Мы понимаем это, так как символ Unicodeе , закодированный в UTF-8, занимает два байта, и ни для одного из этих байтов не существует условного соответствующего обозначения ASCII.


### Строковые операции

Как вам уже известно, строки в Python можно создавать, заключая последовательность символов в одинарные или двойные кавычки. Многолинейные строки можно создать, используя три символа кавычек, а созданные строки можно объединить, поместив их рядом. Рассмотрим следующие примеры:

`>>> a = "hello"`
`>>> b = "world"`
`>>> c = """a multiple`
`... line string"""`
`>>> d = """More`
`... multiple"""`
`>>> e = ("Three " "String " "Together"`
`... )`

Последняя строка автоматически составляется интерпретатором в одну строку. Также можно объединять строки с помощью оператора + (например, `"hello " + "world")`. Строки не обязательно должны быть жестко запрограммированы. Строковые данные могут поступать из различных внешних источников, таких как текстовые файлы и вводимые пользователем данные, или могут передаваться по сети.

Некоторые логические методы служат для определения, соответствуют ли символы в строке определенному шаблону. Большинство из них, например `isalpha()`, `isupper()`, `islower()`, `startwith()` и `endwith()`, имеют достаточно простые для понимания интерпретации. Метод `isspace()` также довольно очевиден, но помните, что в нем учитываются все символы пробелов (включая табуляцию и перевод на новую строку), а не только пробел как таковой.

Метод `istitle()` возвращает значение True, если каждое слово в строке начинается с заглавной буквы и в ней имеется хотя бы один символ в верхнем регистре.

Остальные методы возвращают преобразованную строку. Методы `upper()`, `lower()`, `capitalize()` и `title()` создают новые строки буквенными символами в соответствии с заданными правилами формата. Метод `translate()` возвращает копию строки, в которой каждый символ был сопоставлен и преобразован в соответствии с таблицей преобразования символов.

Обратите внимание, что для всех этих методов входная строка остается неизменной. Создается новый экземпляр `str`. При необходимости совершать манипуляции с результирующей строкой следует присвоить ее новой переменной, например, так: `new_value = value.capitalize()`. После выполнения преобразований старое значение больше не будет использоваться, поэтому общая идея состоит в том, чтобы присвоить значение той же переменной, что и для `value = value.title()`.

Некоторые строковые методы могут работать со списками. Метод `split()` разбивает строку на части с помощью специального разделителя и возвращает фрагменты строки в виде списка. Чтобы ограничить количество результирующих строк, в качестве второго параметра можно передать число. Метод `rsplit()` ведет себя так же, как и метод `split()`, если не ограничивать количество строк, но когда ограничение указано, метод разбивает строку справа. Методы `partition()` и `rpartition()` разбивают строку при первом или последнем вхождении строки аргумента и возвращают кортеж, содержащий фрагмент строки перед разделителем, строку аргумента и фрагмент после разделителя.

Метод `join()` возвращает строку, объединяющую все элементы итерации, разделенные заданным разделителем. Метод `replace()` возвращает копию строки, в которой все вхождения подстроки заменены второй подстрокой. Посмотрим на эти методы в действии:

`>>> s = "hello world, how are you"`
`>>> s2 = s.split(" ")`
`>>> s2`
`['hello', 'world,', 'how', 'are', 'you']`
`>>> "#".join(s2)`
`'hello#world,#how#are#you'`
`>>> s.replace(" ", "**")`
`'hello**world,**how**are**you'`
`>>> s.partition(" ")`
`('hello', ' ', 'world, how are you')`


### Форматирование строк

Python 3 поддерживает мощные механизмы форматирования строк и шаблонов, которые позволяют создавать строки, состоящие из текста шаблона и различных представлений объектов, как правило, из переменных и выражений. Некоторые механизмы форматирования мы уже использовали в предыдущих примерах.

В форматирующей строке (также называемой **f-строкой**) перед открывающей кавычкой имеется префикс `f`, например `f"hello world"` . Если такая строка содержит специальные символы {и}, то выражения, включая переменные из окружающей области, вычисляются, а затем интерполируются в строку. Например:

`>>> name = "Dusty"`
`>>> activity = "reviewing"`
`>>> message = f"Hello {name}, you are currently {activity}."`
`>>> print(message)`

Если запустить эти операторы на выполнение, они заменят фигурные скобки переменными следующим образом:

`Hello Dusty, you are currently reviewing.`


### Использование фигурных скобок

В строках, как правило, используются символы фигурных скобок. Однако рекомендуется избегать их применения в ситуациях, когда необходимо, чтобы они отображались сами по себе, а не были заменены. Этого можно добиться, удвоив скобки. Например, использовать Python для форматирования базовой Jаvа-программы можно так:

`>>> classname = "MyClass"`
`>>> python_code = "print('hello world')"`
`>>> template = f"""`
`... public class {classname} {{`
`...     public static void main(String[] args) {{`
`...         System.out.println("{python_code}");`
`...     }}`
`... }}`
`... """`

Там, где имеется последовательность {{и}}, то есть фигурные скобки заключают в себе определение класса и метода jаvа, f-строка заменит их одиночными фигурными скобками, а не каким-либо аргументом в окружающих методах:

`>>> print(template)`

`public class MyClass {`
`    public static void main(String[] args) {`
`        System.out.println("print('hello world')");`
`    }`
`}`

Имя класса и содержимое вывода были заменены двумя параметрами, а двойные фигурные скобки заменены одинарными, в результате чего получили валидный файл Java. Речь идет о самой простой программе на Python для печати самой простой программы Java, которая может распечатать самую простую программу Python.


#### f-строки могут содержать код Python

Разработчики не ограничены интерполяцией значений простых строковых переменных в шаблон f-строки. Любые примитивы, такие как целые числа или числа с плавающей запятой, могут быть отформатированы. Также можно использовать сложные объекты, включая списки, кортежи, словари и произвольные объекты, и обращаться к индексам и переменным или вызывать функции для этих объектов из форматирующей строки.

Например, если электронное письмо сгруппировало адреса электронной почты **From** и **То** в кортеж и по какой-то причине поместило тему и сообщение в словарь (возможно, это входные данные, необходимые для существующей функции `send_mail`, которую мы намерены использовать), отформатировать его можно следующим образом:

`>>> emails = ("steve@example.com", "dusty@example.com")`
`>>> message = {`
`...     "subject": "Next Chapter",`
`...     "message": "Here's the next chapter to review!"`
`... }`
`>>> formatted = f"""`
`... From" <{emails[0]}>`
`... To: """`
`>>> formatted = f"""`
`... From: <{emails[0]}>`
`... To: <{emails[1]}>`
`... Subject: {message['subject']}`
`...`
`... {message['message']}`
`... """`

Переменные внутри фигурных скобок в строке шаблона выглядят немного странно. Проанализируем, какую именно роль они выполняют. Два адреса электрон ной почты могут быть найдены с помощью выражения `emails[x]` , где х равно 0 или 1. Это обычная операция индексации кортежа, поэтому `emails[0]` относится к первому элементу кортежа emails. Точно так же выражение `message['subject']` получает элемент из словаря.

Приведенный прием работает особенно хорошо, когда имеется более сложный объект для отображения. Мы можем извлекать атрибуты и свойства объекта и даже вызывать методы внутри f-строки. Еще раз изменим данные нашего электронного письма, на этот раз в класс:

`>>> class Notification:`
`...     def __init__(`
`...         self,`
`...         from_addr: str,`
`...         to_addr: str,`
`...         subject: str,`
`...         message: str`
`...     ) -> None:`
`...         self.from_addr = from_addr`
`...         self.to_addr = to_addr`
`...         self.subject = subject`
`...         self._message = message`
`...     def message(self):`
`...         return self._message`
`...`

Рассмотрим экземпляр класса `Notification`:

`>>> email = Notification(`
`...     "dusty@example.com",`
`...     "steve@example.com",`
`...     "Commentes on the Chapter",`
`...     "Can we emphasize Python 3.9 type hints?",`
`... )`

Данный экземпляр электронной почты легко использовать для заполнения f-строки следующим образом:

`>>> email = Notification(`
`...     "dusty@example.com",`
`...     "steve@example.com",`
`...     "Commentes on the Chapter",`
`...     "Can we emphasize Python 3.9 type hints?",`
`... )`
`>>> formatted = f"""`
`... From: <{email.from_addr}>`
`... To: <{email.to_addr}>`
`... Subject: {email.subject}`
`...`
`... {email.message()}`
`... """`

Практически любой код Python, который, по вашему мнению, должен возвращать строку (или значение, которое можно преобразовать в строку с помощью функции `str()`), может быть выполнен внутри f-строки. В качестве примера того, насколько мощным может быть код, попробуйте в параметре форматирующей строки использовать список или тернарный оператор:

`>>> f"{[2*a+1 for a in range(5)]}"`
`'[1, 3, 5, 7, 9]'`
`>>> for n in range(1, 5):`
`...     print(f"{'fizz' if n % 3 == 0 else n}")`
`...`
`1`
`2`
`fizz`
`4`

В некоторых случаях к значению необходимо добавить метку, что очень полезно для отладки. К выражению можно добавить суффикс =, как показано ниже:

`>>> a = 5`
`>>> b = 7`
`>>> f"{a=}, {b=}, {31*a//42*b + b=}"`
`'a=5, b=7, 31*a//42*b + b=28'`

Метод создает метку и значение, что может тоже оказаться очень полезно. Доступны и более сложные варианты форматирования.

Хотя описанные возможности форматирования подходят для многих вещей, они недостаточно мощны для крупномасштабных проектов, таких как создание веб-страниц. Существует несколько сторонних библиотек шаблонов, к которым вы можете обратиться при необходимости сделать больше, чем просто базовое форматирование нескольких строк.


## Строки Unicode

В начале раздела строки были описаны как неизменяемые наборы символов Unicode. На самом деле Unicode очень усложняет ситуацию, так как не является форматом хранения. Если вы получите строку байтов из файла или сокета, она не будет в формате Unicode. Фактически строка будет последовательностью байтов встроенного типа. Сами байты - это неизменяемые последовательности. Байты являются основным форматом хранения в вычислениях. Байты представляют собой 8 бит, обычно описываемых ==как целое число от 0 до 255== или шестнадцатеричный эквивалент от `0х00` до `0xFF` . Байты не представляют ничего конкретного. Последовательность байтов может хранить символы закодированной строки или пиксели изображения, представлять целое число или часть значения с плавающей запятой.

При выводе на печать объекта bytes Pythoп использует достаточно компактное каноническое отображение. Любые отдельные значения байтов, которые сопоставляются с символами ASCII, отображаются как символы, в то время как не символьные байты ASCII выводятся на печать как еsсаре-последовательности, либо одно символьные еsсаре-последовательности (например, `\n`), либо шестнадцатеричные коды (такие как `\x1b`). Может показаться странным, что байт, представленный как целое число, может отображаться в символ ASCII. Но старый код ASCII определял латинские буквы для множества различных значений байтов. В ASCII символ а представлен тем же байтом, что и целое число `97`, которое представляет собой шестнадцатеричное число `0х61`. Все это интерпретация двоичного шаблона `0b1100001`.

`>>> list(map(hex, b'abc'))`
`['0x61', '0x62', '0x63']`
`>>> list(map(bin, b'abc'))`
`['0b1100001', '0b1100010', '0b1100011']`

Ниже показано, как могут выглядеть канонические байты отображения, когда они содержат сочетание значений, представленных символами ASCII, и значений, не содержащих простых символов:

`>>> bytes([137, 80, 71, 13, 10, 26, 10])`
`b'\x89PG\r\n\x1a\n'`

В первом байте использовалась шестнадцатеричная еsсаре-последовательность `\х89`. Следующие три байта содержат символы ASCII `Р`, `N` и `G`. Затем два байта имеют одно символьные еsсаре-символы `\r` и `\n`. Седьмой байт также имеет шестнадцатеричный еsсаре-символ `\x1a`, так как нет другой кодировки. Последний байт - это еще один еsсаре-символ, \n. Восемь байт расширены до 17 печатных символов, не считая префикса `b'` и закрывающей кавычки `(')`.


## Ключевые моменты

- Способы кодирования строк в байты и декодирования байтов в строки. Хотя некоторые устаревшие кодировки символов (например, ASCII) обрабатывают байты и символы одинаково, это подчас приводит к путанице. Текст Python может быть любым символом Unicode, а байты Python - числами в диапазоне от О до 255.
- Форматирование строк позволяет подготовить строковые объекты, которые имеют части шаблона и динамические части. В Python это работает для многих ситуаций. Одна из них - создание удобочитаемого вывода для пользователей. Но можно также для этой цели использовать f-строки и строковый метод `format()` везде, где создается сложная строка из фрагментов.
- Регулярные выражения применяются для разложения сложных строк. По сути, регулярное выражение является противоположностью средства форматирования строк. Регулярные выражения пытаются отделить символы, которые мы сопоставляем, от метасимволов, которые обеспечивают дополнительные правила сопоставления, например повторение или альтернативный выбор.