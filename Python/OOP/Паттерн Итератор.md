---
date of creation: 2024-06-25T08:11:00
tags:
  - Python
  - OOP/Python
  - OOP
  - Developing
  - Developing/Python
  - IT/Python
  - IT
  - Patterns
  - Python/Patterns
  - DesignPatterns
Read status: false
aliases:
  - Паттерн-Итератор
  - Паттерн-итератор
---
---
# Паттерн Итератор
2024-06-25


Прочитав эту заметку, вы освоите следующие темы.

- Какие существуют паттерны проектирования.
- Протокол Итератор - один из самых мощных паттернов проектирования.
- Список, множество (набор) и словарь.
- Функции-генераторы и их создание с помощью паттернов.


## Протокол **`Iterator`**
---

Абстрактный базовый класс **`Iterator`** в модуле **`collections.аbс`** определяет протокол `Iterator` в Python. На это определение также ссылается модуль **`typing`** для предоставления подходящих подсказок типа. Абстракция для `Iterable` показана на **рис. 10.1.**

![[Рис. 10.1 . Абстракция для lterable.jpg]]
>**Рис. 10.1.** Абстракция для `Iterable`

В основе любого определения класса **`Collection`** должен быть интерфейс **`Iterable`**, что означает возможность реализовать метод **`__iter__()`** , создающий объект **`Iterator`**.

Рассмотрим следующий очень подробный пример такой реализации. В нем показаны итерация и два протокола. Позже в этой главе мы разберем несколько еще более понятных примеров получения подобного результата:

```python
>>> class CapitalIterable(Iterable[str]):
...     def __init__(self, string: str) -> None:
...             self.string = string
...     def __iter__(self) -> Iterator[str]:
...             return CapitalIterator(self.string)
...
>>> class CapitalIterator(Iterator[str]):
...     def __init__(self, string: str) -> None:
...             self.words = [w.capitalize() for w in string.split()]
...             self.index = 0
...     def __next__(self) -> str:
...             if self.index == len(self.words):
...                     raise StopIteration()
...             word = self.words[self.index]
...             self.index += 1
...             return word
...
```

В примере определяется класс **`CapitalIterable`**, задачей которого является циклический перебор каждого слова в строке и вывод их с заглавной первой буквы. Чтобы определить намерение, мы формализовали это, используя в качестве суперкласса подсказку типа **`Iterable[str]`**. Большая часть работы данного итерируемого класса делегирована реализации класса **`CapitalIterator`**. Один из способов взаимодействия с итератором выглядит следующим образом:

```python
>>> iterable = CapitalIterable('the quick brown fox jumps over the lazy dog')
>>> iterator = iter(iterable)
>>> while True:
...     try:
...             print(next(iterator))
...     except StopIteration:
...             break
...
The
Quick
Brown
Fox
Jumps
Over
The
Lazy
Dog
```

Для создания итератора из итерируемого объекта Python имеет более простой синтаксис:
```python
>>> for i in iterable:
...     print(i)
...
The
Quick
Brown
Fox
Jumps
Over
The
Lazy
Dog
```



## Представления
---

**Представления** - это простой, но мощный синтаксис, который позволяет преобразовать или отфильтровать итерируемый объект, ограничиваясь всего одной строкой кода. Результирующий объект может быть совершенно обычным списком, множеством (набором) или словарем либо выражением-генератором, которое можно эффективно использовать, сохраняя в памяти только один элемент за раз.


### Представления списков
---

Проанализируем одну из упомянутых распространенных операций, а именно преобразование списка элементов в список связанных элементов. В частности, предположим, что мы только что прочитали список строк из файла и теперь необходимо преобразовать его в список целых чисел. Известно, что каждый элемент в списке является целым числом, и с этими числами необходимо выполнить некоторые действия (например, вычислить среднее значение). Рассмотрим следующий пример:
```python
>>> input_strings = ['1', '5', '28', '131', '3']
>>> output_integers = []
>>> for num in input_strings:
...     output_integers.append(int(num))
...
>>> output_integers
[1, 5, 28, 131, 3]
```

==Всего три строки кода, и все получилось.== Если вы еще не привыкли использовать представления списков, то даже и не подумаете, что данный код выглядит _некрасиво_! Теперь проанализируйте тот же код, используя представление списка:
```python
>>> output_integers = [int(num) for num in input_strings]
```

Количество строк сокращено до одной, и, что важно для производительности, мы отказались от вызова метода **`append`** для каждого элемента в списке. В целом довольно легко понять, как это работает.

Преобразование списка элементов в связанный список не единственная операция с использованием представления списков. Можно также исключить определенные значения, добавив оператор **`if`** внутри представления списка. Программисты называют это **фильтром**. Например:
```python
>>> output_integers = [int(num) for num in input_strings if len(num) < 3]
>>> output_integers
[1, 5, 28, 3]
```

Существенным отличием этого примера от предыдущего будет применение кода **`if len(num) < 3`**. Этот дополнительный код исключает любые строки, содержащие более двух символов. Оператор `if` применяется к каждому элементу **перед** финальной функцией `int()` , поэтому в данном случае проверяется длина строки. Поскольку все входные строки являются целыми числами, они исключают любое число больше 99.

==Повсеместное распространение шаблона «Итерация - фильтр - сопоставление - сбор» лежит в основе идеи представления списков.==


### Представления множеств и словарей
---

Представления не ограничиваются списками. Для создания множеств и словарей тоже можно использовать аналогичный синтаксис с фигурными скобками. Один из способов создать множество - обернуть представление списка в конструктор **`set()`** , который затем преобразует его в множество. Но зачем расходовать дополнительную память на создание промежуточного списка, который будет удален, когда есть способ создать множество напрямую?

Рассмотрим пример, в котором именованный кортеж используется для модели «автор/название/жанр», а затем извлекается множество всех авторов, которые пишут свои произведения в определенном жанре:

```python
>>> from typing import NamedTuple
>>> class Book(NamedTuple):
...     author: str
...     title: str
...     genre: str
...
>>> books = [
...     Book("Pratchett", "Nightwatch", "fantasy"),
...     Book("Pratchett", "Thief of Time", "fantasy"),
...     Book("Le Guin", "The Dispossessed", "scifi"),
...     Book("Le Guin", "A Wizard Of Eathsea", "scifi"),
...     Book("Jemisin", "The Broken Earth", "fantasy"),
...     Book("Turner", "The Thief", "fantasy"),
...     Book("Phillips", "Preston Diamond", "western"),
...     Book("Phillips", "Twice Upon A Time", "scifi"),
...     Book("Lovecraft", "Call of Ctulhu", "horror")
... ]
```

Здесь мы определили небольшую библиотеку экземпляров класса **`Book`**. Можно создать множество из каждого объекта, используя представление множества. Оно очень похоже на представление списка, но в данном случае используются фигурные скобки (**`{}`**) вместо квадратных (**`[]`**):
```python
>>> fantasy_authors = {b.author for b in books if b.genre == "fantasy"}
```

Представление множества, по сравнению с настройкой демонстрационных данных, выглядит значительно короче! Конечно, если бы мы использовали представление списка, автор `Теrrу Pratchett` был бы указан дважды. Как бы то ни было, дубликаты удаляются, и в итоге получаем следующее:
```python
>>> fantasy_authors
{'Pratchett', 'Turner', 'Jemisin'}
```

Обратите внимание, что множества не имеют определенного порядка, поэтому результат, полученный на вашем компьютере, может отличаться от полученного нами. В целях тестирования, чтобы установить порядок, разработчики иногда определяют переменную среды **`PYTHONHASHSEED`**, что делает уязвимой систему безопасности, поэтому переменная применима только для тестирования.

По-прежнему используя фигурные скобки, можно добавить двоеточие, чтобы создать пары **`key:value`**(`ключ:значение`), необходимые для создания представления словаря. Например, иногда бывает нужно быстро найти автора или жанр в словаре, если известно название произведения. Представление словаря легко использовать для сопоставления заголовков с объектами **`books`**:
```python
fantasy_title = {b.title: b for b in books if b.genre == "fantasy"}
```

Теперь у нас имеется словарь, и мы можем искать книги по названию, с применением обычного синтаксиса: **`fantasy_titles[' Nightwatch']`** . Мы создали высокопроизводительный индекс из менее производительной последовательности.

==Подводя итог, скажем, что представления - это не продвинутый Python и не функции ООП. Это более краткий синтаксис для создания списка, множества или словаря из существующего итерируемого источника данных.==



### Функции-генераторы
---

**Функции-генераторы** ==содержат в себе основные черты выражения-генератора.== Синтаксис функции-генератора выглядит еще менее объектно-ориентированным, чем все, что мы уже изучили, но на самом деле это сокращенная запись для создания своего рода объекта-итератора. Это помогает нам построить обработку в соответствии со стандартным шаблоном сопоставления фильтров итераторов.


```python
import csv
import re
from pathlib import Path
from typing import Match, cast, Iterator, Iterable


def warnings_filter(source: Iterable[str]) -> Iterator[tuple[str, ...]]:
    pattern = re.compile(r"(\w\w\w \d\d, \d\d\d\d \d\d:\d\d:\d\d) (\w+)                            (.*)")
    for line in source:
        if "WARN" in line:
            yield tuple(cast(Match[str], pattern.match(line)).groups())


def extract_and_parse_3(full_log_path: Path, warning_log_path: Path) -> None:
    with warning_log_path.open("w", newline="") as target:
        writer = csv.writer(target, delimiter="\t")
        with full_log_path.open() as infile:
            filter = warnings_filter(infile)
            for line_groups in filter:
                writer.writerow(line_groups)
```

Оператор **`yield`** функции **`warning_filters()`** является ключом к генераторам. Когда Python в функции обнаруживает оператор **`yield`**, он берет эту функцию и оборачивает ее в объект, следующий за протоколом **`Iterator`**, мало чем отличающимся от класса, определенного в предыдущем примере. Можно предположить, что оператор **`yield`** - это оператор **`return`**, который также возвращает строку. Однако, в отличие от реакции на **`return`**, функция только приостанавливается (переводится в состояние ожидания). При повторном вызове (посредством **`next()`** ) функция начинает выполняться с того места, на котором остановилась (со строки после оператора **`yield`**), а не с начала. В этом примере после оператора **`yield`** нет строки, поэтому выполняется переход к следующей итерации оператора for. Поскольку оператор **`yield`** находится внутри оператора **`if`**, он выдает только те строки, которые содержат **`WARNING`**.

Хотя это выглядит как функция, перебирающая строки, в действительности она создает объект специального типа, объект-генератор:
```python
>>> print(warnings_filter([]))
<generator object warnings_filter at 0xb644c5bc>
```

Все, что делает функция, - создает и возвращает объект-генератор. В примере выше был предоставлен пустой список и создан генератор. Объект-генератор имеет методы **`__itеr__( )`** и **`__next__()`** , точно такие же, как в предыдущем примере (использование встроенной функции **`dir()`** продемонстрирует, что еще является частью генератора). Всякий раз, когда вызывается метод **`__next__()`** , генератор запускает функцию до тех пор, пока не обнаружит оператор **`yield`**. Затем выполнение кода приостанавливается, сохраняется текущее состояние и возвращается значение из **`yield`**. При следующем вызове метода **`__next__()`** код продолжает работу с того места, где был остановлен.

На **рис. 10.2** представлена связь описанных паттернов. Выражение-генератор имеет все элементы операторов, слегка сжатые и в другом порядке.

![[Рис. 10.2. Функция - генератор и выражение-генератор.jpg]]
>**Рис. 10.2.** Функция - генератор и выражение-генератор

==Таким образом, представление - это генератор, заключенный для создания конкретного объекта в квадратные (**`[]`**) или фигурные скобки (**`{}`**)==. В некоторых случаях имеет смысл использовать методы **`list()`** , **`set()`** или **`dict()`** в качестве обертки. Это полезно при изучении возможности замены универсальной коллекции нашей собственной настраиваемой коллекцией. Изменение **`list()`** на **`MySpecialContainer()`** кажется более очевидным.

==Преимуществом выражения-генератора считается то, что оно короткое и появляется именно там, где необходимо. Функция-генератор имеет имя и параметры, то есть ее можно использовать повторно.== Что еще более важно, функция-генератор может иметь несколько операторов и более сложную логику обработки в случае необходимости использования операторов. Одной из распространенных причин использовать функцию-генератор является добавление обработки исключений.