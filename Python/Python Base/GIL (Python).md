---
title: GIL (Python)
date of creation: 2025-04-22T08:37:00
tags:
  - Python
  - Python/Base
  - Concurrency
  - Developing/Python
  - IT/Developing
  - IT
read status: false
completion status: false
aliases:
  - global interpreter lock
  - GIL
  - GIL (Global Interpreter Lock)
---
# GIL (Python)
---

**Глобальная блокировка интерпретатора (global interpreter lock – GIL)** тема, вызывающая споры в сообществе Python. ==Говоря кратко, GIL не дает Python-процессу исполнять более одной команды байт-кода в каждый момент времени.== Это означает, что, даже если имеется несколько потоков на многоядерной машине, интерпретатор сможет в каждый момент исполнять только один поток, содержащий написанный на Python код. В мире, где процессоры имеют несколько ядер, это создает серьезную проблему для разработчиков на Python, желающих воспользоваться многопоточностью для повышения производительности приложений.

>[!Примечение]
>Многопроцессные приложения могут конкурентно выполнять несколько команд байт-кода, потому что у каждого Python-процесса своя собственная GIL.

Так для чего же нужна GIL? Ответ кроется в том, как [[CPython]] управляет памятью. В CPython память управляется в основном с помощью подсчета ссылок. То есть для каждого объекта Python, например целого числа, словаря или списка, подсчитывается, сколько объектов в данный момент используют его. Когда объект перестает быть нужным кому-то, счетчик ссылок на него уменьшается, а когда кто-то новый обращается к нему, счетчик ссылок увеличивается. Если счетчик ссылок обратился в нуль, значит, на объект никто не ссылается, поэтому его можно удалить из памяти.

>[!Что такое CPython?]
>**CPython** – это эталонная реализация Python, т. е. стандартная реализация языка, которая используется как эталон правильного поведения. Существуют и другие реализации, например [[Jython]], работающая под управлением виртуальной машины [[Java]], или [[IronPython]], предназначенная для [[.NET]] Framework.

Конфликт потоков возникает из-за того, что интерпретатор CPython не является *потокобезопасным*. Это означает, что если два или более потоков модифицируют разделяемую переменную, то ее конечное состояние может оказаться неожиданным, поскольку зависит от порядка доступа к переменной со стороны потоков. Эта ситуация называется состоянием гонки. Состояния гонки могут возникать, когда два потока одновременно обращаются к одному объекту Python.

