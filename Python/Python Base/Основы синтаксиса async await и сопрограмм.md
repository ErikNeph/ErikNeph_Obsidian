---
title: Основы синтаксиса async await и сопрограмм
date of creation: 2025-04-23T11:10:00
tags:
  - Python
  - Developing/Python
  - Concurrency
  - Python/Concurrency
read status: true
completion status: true
aliases:
  - async await в python
  - async await
  - операторы async и await
---
# Основы синтаксиса `async` `await` и сопрограмм
---

Мы узнаем о *сопрограммах* и применении синтаксиса `async` `await` для их определения и выполнения. Мы также научимся выполнять сопрограммы конкурентно с помощью задач и посмотрим, какой можно достичь экономии времени, для чего создадим повторно используемый таймер. Наконец, рассмотрим типичные ошибки при работе с [[asyncio]] и научимся находить их в режиме отладки.


## Знакомство с сопрограммами
---

**Сопрограмму** можно рассматривать как обычную функцию Python, наделенную сверхспособностью: приостанавливаться, встретив операцию, для выполнения которой нужно заметное время. По завершении такой длительной операции сопрограмму можно «пробудить», после чего она продолжит выполнение. Пока приостановленная сопрограмма ждет завершения операции, мы можем выполнять другой код. Такое выполнение другого кода во время ожидания и обеспечивает конкурентность внутри приложения. Можно также одновременно выполнять несколько длительных операций, что еще больше повышает производительность приложения.
Для создания и приостановки сопрограммы нам придется использовать ключевые слова Python `async` и `await`. Слово `async` определяет сопрограмму, а слово await приостанавливает ее на время выполнения длительной операции.


### Создание сопрограмм с помощью ключевого слова `async`
---

Создать сопрограмму так же просто, как обычную функцию Python, только вместо ключевого слова `def` нужно использовать `async def`. Ключевое слово `async` говорит, что это сопрограмма, а не обычная функция.

Использование ключевого слова `async`:
```python
async def my_coroutine() -> None
    print('Hello world!')
```

Здесь сопрограмма всего лишь печатает сообщение «Hello world!». Отметим, что она не выполняет никаких длительных операций, просто печатает и возвращает управление. Это значит, что после передачи циклу событий эта сопрограмма будет выполнена немедленно, поскольку никакого блокирующего ввода-вывода нет и ничто не вынуждает ее приостановиться.

Несмотря на простоту синтаксиса, мы создали нечто, весьма отличное от обычной функции Python. Для иллюстрации напишем функцию, которая прибавляет единицу к целому числу, и сопрограмму, делающую то же самое, и сравним результаты. Также мы воспользуемся вспомогательной функцией `type`, чтобы узнать типы значений, возвращаемых сопрограммой и обычной функцией.

*Сравнение сопрограмм с обычными функциями:*
```python
async def coroutine_add_one(number: int) -> int:
    return number + 1


def add_one(number: int) -> int:
    return number + 1


function_result = add_one(1)
coroutine_result = coroutine_add_one(1)

print(f'Результат функции равен {function_result}, а его тип равен
{type(function_result)}')
print(f'Результат сопрограммы равен {coroutine_result}, а его тип равен
{type(coroutine_result)}')
```
Этот код печатает следующие строки:
```shell
Результат функции равен 2, а его тип равен <class 'int'>
Результат сопрограммы равен <coroutine object coroutine_add_one at 0x1071d6040>, а его тип равен <class 'coroutine'>
```

Обратите внимание, что обычная функция `add_one` исполняется и возвращает управление сразу, а результат вполне ожидаемый – целое число. Однако код сопрограммы `coroutine_add_one` вообще не выполняется, а получаем мы *объект сопрограммы.*

Это важный момент – **сопрограммы не выполняются, если их вызвать напрямую.** Вместо этого возвращается объект сопрограммы, который будет выполнен позже. **Чтобы выполнить сопрограмму, мы должны явно передать ее циклу событий.** И как же создать цикл событий и выполнить в нем нашу сопрограмму?

В версиях Python, предшествующих 3.7, цикл событий нужно было создавать вручную, если его еще не было. **Но затем в `asyncio` было добавлено несколько функций, абстрагирующих управление циклом событий. Одна из них – вспомогательная функция `asyncio.run`, которую можно использовать для запуска нашей сопрограммы.**

*Выполнение сопрограммы:*
```python
import asyncio


async def coroutine_add_one(number: int) -> int:
    return number + 1


result = asyncio.run(coroutine_add_one(1))

print(result)
```
При выполнении этого кода печатается «2», как и следовало ожидать. Мы подали сопрограмму циклу событий и выполнили ее!

В этом случае `asyncio.run` делает несколько важных вещей. Во-первых, она создает новое событие. Потом она выполняет код переданной нами сопрограммы до конца и возвращает результат. Эта функция также подчищает все то, что могло остаться после завершения сопрограммы. И в конце она останавливает и закрывает цикл событий.

**Но, возможно, самое главное в `asyncio.run` – то, что она задумана как главная точка входа в созданное нами приложение asyncio.** Она выполняет только одну сопрограмму, и эта сопрограмма должна позаботиться обо всех остальных аспектах приложения. Далее мы будем использовать эту функцию почти во всех наших приложениях. *Сопрограмма, которую выполняет `asyncio.run`, должна создать и запустить все прочие сопрограммы, это позволит нам обратить себе на пользу конкурентную природу `asyncio`.*


### Приостановка выполнения с помощью ключевого слова *await*
---

Пример, который мы видели в листинге, не имело смысла оформлять в виде сопрограммы, потому что в нем выполняется только неблокирующий Python-код. **Истинное достоинство `asyncio` – возможность приостановить выполнение и дать циклу событий возможность выполнить другие задачи, пока длительная операция делает свое дело.** Для приостановки выполнения служит ключевое слово await, за ним обычно следует обращение к сопрограмме (точнее, к объекту, *допускающему ожидание*, который необязательно является сопрограммой; мы вернемся к этому вопросу ниже в этой главе).

Использование ключевого слова `await` приводит к выполнению следующей за ним сопрограммы, а не просто к возврату объекту сопрограммы, как при прямом вызове. Кроме того, выражение `await` приостанавливает объемлющую сопрограмму до того момента, как сопрограмма, которую мы ждем, завершится и вернет результат. А после этого мы получим доступ к возвращенному результату, а объемлющая сопрограмма пробудится и обработает результат.

Ключевое слово `await` следует поместить перед вызовом сопрограммы. Продолжая предыдущую программу, мы можем написать код, который вызывает функцию `add_one` из асинхронной функции main и получает результат.

*Использование `await` для ожидания результата сопрограммы:*
```python
import asyncio


async def add_one(number: int) -> int:
    return number + 1


async def main() -> None:
    one_plus_one = await add_one(1)  # Приостановиться и ждать результата                                                              # add_one(1)
    two_plus_one = await add_one(2)  # Приостановиться и ждать результата                                                              # add_one(2)
    print(one_plus_one)
    print(two_plus_one)


asyncio.run(main())
```

Мы приостанавливаем выполнение дважды. Сначала ждем завершения `add_one(1)`. После получения результата выполнение функции `main` возобновляется, и мы присваиваем значение, возвращенное `add_one(1)`, переменной `one_plus_one`, в данном случае она станет равна `2`. Затем то же самое мы проделываем с `add_one(2)`, после чего печатаем результаты. Поток выполнения изображен на рис. 2.1. В блоках показано, что происходит в одной или нескольких строках кода.

![[как работает оператор await на диаграмме.jpg]]

**Этот код работает так же, как обычный последовательный код**. *По существу, мы имитируем обычный стек вызовов.* А теперь рассмотрим простой пример, показывающий, как во время ожидания выполнить другой код, для чего введем в рассмотрение фиктивную операцию засыпания [[Моделирование длительных операции с помощью sleep]].