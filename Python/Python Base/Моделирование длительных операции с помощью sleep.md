---
title: Моделирование длительных операции с помощью sleep
date of creation: 2025-04-23T12:38:00
tags:
  - Python
  - Developing
  - Concurrency
  - Python/Concurrency
  - Developing/Python
read status: true
completion status: true
aliases:
  - asyncio.sleep
  - asyncio.create_task
  - .cancel()
  - asyncio.shield()
---
# Моделирование длительных операции с помощью sleep
---

В предыдущих примерах не было медленных операций, мы просто изучили базовый синтаксис *сопрограмм*. Чтобы в полной мере прочувствовать все преимущества и показать, как обрабатывать несколько событий одновременно, нам нужны какие-то длительные операции. Но, вместо того чтобы сразу отправлять недетерминированные веб-запросы или запросы к базе данных, мы смоделируем длительную операцию, указав, сколько времени ждать завершения. **Для этого воспользуемся функцией `asyncio.sleep`.**

Функция `asyncio.sleep` заставляет сопрограмму «заснуть» на заданное число секунд, т. е. приостанавливает ее на заданное время. Это позволяет смоделировать, что происходит при обращении к базе данных или веб-ресурсу.

**`asyncio.sleep `сама является сопрограммой**, поэтому вызывать ее следует с помощью `await`. Вызвав ее напрямую, мы получим просто объект сопрограммы. Раз `asyncio.sleep` – сопрограмма, то, пока мы ее ждем, может выполняться другой код.

В листинге ниже показан простой пример – программа засыпает на 1 с, а затем печатает сообщение «Hello World!».

*Первое применение sleep:*
```python
import asyncio


async def hello_world_message() -> str:
    await asyncio.sleep(1)  # Приостановить hello_world_message на 1 с
    return "Hello, World!"


async def main() -> None:
    message = await hello_world_message()  # Приостановить main до                                                    завершения hello_world_message
    print(message)


asyncio.run(main())
```
Эта программа ждет 1 с, а затем печатает сообщение «Hello World!». Поскольку `hello_world_message` – сопрограмма, а мы приостановили ее на 1 с, у нас появилась одна секунда, в течение которой мог бы конкурентно работать другой код.

В последующих примерах мы часто будем использовать `sleep`, поэтому потратим немного времени на создание повторно используемой сопрограммы, которая спит заданное время, а затем печатает полезную информацию. Назовем ее `delay`. Код приведен ниже.

*Повторно используемая сопрограмма `delay`:*
```python
import asyncio


async def delay(delay_seconds: int) -> int:
    print(f"засыпаю на {delay_seconds} с")
    await asyncio.sleep(delay_seconds)
    print(f"сон в течение {delay_seconds} с закончился")
    return delay_seconds

```

Сопрограмма `delay` принимает целое число – продолжительность сна в секундах – и возвращает это же число вызывающей стороне по завершении сна. Мы также печатаем сообщения, когда сон начался и закончился. Это позволит увидеть, как конкурентно работает другой код, пока наша сопрограмма приостановлена.
Чтобы было проще обращаться к этой функции, создадим модуль, который будем при необходимости импортировать. В этот модуль мы будем добавлять и другие написанные нами повторно используемые функции. Назовем его util и поместим нашу функцию `delay` в файл `delay_functions.py`. Также добавим файл `__init__.py`, содержащий следующую строку, чтобы было удобнее импортировать таймер:

`from util.delay_functions import delay`

Начиная с этого момента, мы будем применять предложение `from util import delay` всякий раз, как нужно использовать функцию `delay`. Теперь, когда у нас есть повторно используемая сопрограмма задержки, объединим ее с написанной ранее сопрограммой `add_one` и попробуем заставить простое сложение работать конкурентно, пока `hello_world_message` приостановлена.

*Выполнение двух сопрограмм:*
```python
import asyncio
from utils.delay_functions import delay


async def add_one(number: int) -> int:
    return number + 1


async def hello_world() -> str:
    await delay(1)
    return "Hello, World!"


async def main() -> None:
    message = await hello_world()  # Приостановить main до                                                     возврата hello_world_message
    one_plus_one = await add_one(1)  # Приостановиться и ждать                                                   результата add_one(1)
    print(add_one)
    print(message)


asyncio.run(main())
```

При выполнении этого кода проходит 1 с, прежде чем будут напечатаны результаты обеих функций. Мы же хотели, чтобы значение `add_one(1)` было напечатано немедленно, пока `hello_world_message()` работает конкурентно. И что же не так с этим кодом? Дело в том, что await приостанавливает текущую сопрограмму и код внутри нее не выполняется, пока выражение ``await`` не вернет значение. Поскольку `hello_world_message` вернет значение только через секунду, сопрограмма `main` на эту секунду и приостанавливается. В данном случае код ведет себя как последовательный. Это поведение показано на рис. 2.2.

И `main`, и `hello_world` приостановлены в ожидании завершения `delay(1)`. А когда это случится, `main` возобновляется и может выполнить `add_one`.

Нам хотелось бы уйти от этой последовательной модели и выполнять `add_one` конкурентно с `hello_world`. Для этого введем в рассмотрение концепцию *[[#Конкурентное выполнение с помощью задач|задачи]]*.

![[поток выполнения кода со sleep диаграмма.jpg]]


## Конкурентное выполнение с помощью задач
---

Ранее мы видели, что непосредственный вызов сопрограммы не передает ее циклу событий для выполнения. Вместо этого мы получаем объект сопрограммы, который нужно затем использовать совместно с ключевым словом `await` или передать функции `asyncio.run`, чтобы получить возвращенное значение. Располагая только этими инструментами, мы можем написать асинхронный код, но не можем выполнить его конкурентно. А чтобы это сделать, нужны **задачи**.
**Задача** – ==это обертка вокруг сопрограммы, которая планирует выполнение последней в цикле событий как можно раньше.== И планирование, и выполнение происходят в неблокирующем режиме, т. е., создав задачу, мы можем сразу приступить к выполнению другого кода, пока эта задача работает в фоне. **Сравните с ключевым словом `await`, которое блокирует выполнение, т. е. мы приостанавливаем всю сопрограмму на время, пока выражение await не вернет управление.**
Способность создавать задачи и планировать их для немедленного выполнения в цикле событий означает, что несколько задач может работать приблизительно в одно и то же время. Пока одна задача выполняет длительную операцию, другие могут работать конкурентно. Для иллюстрации создадим две задачи и попробуем выполнить их одновременно.


### Основы создания задач
---

Для создания задачи служит функция **`asyncio.create_task`**. Ей передается подлежащая выполнению сопрограмма, а в ответ она немедленно возвращает объект задачи. Этот объект можно включить в выражение await, которое извлечет возвращенное значение по завершении задачи.

*Создание задачи:*
```python
import asyncio
from utils.delay_functions import delay


async def main():
    sleep_for_three = asyncio.create_task(delay(3))
    print(type(sleep_for_three))
    result = await sleep_for_three
    print(result)


asyncio.run(main())
```

Здесь мы создали задачу, которой для выполнения нужно 3 с. Кроме того, мы печатаем тип задачи, в данном случае `<class '_asyncio. Task'>`, чтобы показать, что это не сопрограмма.
Следует также отметить, что предложение печати выполняется сразу после запуска задачи. Если бы мы просто использовали `await` для сопрограммы `delay`, то увидели бы сообщение только через 3 с. Напечатав сообщение, мы применяем `await` к задаче `sleep_for_three`. Это приостанавливает сопрограмму `main` до получения результата от задачи.
Важно отметить, что обычно в каком-то месте приложения нужно использовать `await` для задачи. В листинге 2.8 если бы мы не включили `await`, то задача была бы запланирована, но почти сразу остановлена, после чего интерпретатор «прибрал» бы за ней, когда `asyncio.run` завершит цикл событий. Использование `await` применительно к задачам влияет также на обработку исключений. Познакомившись с тем, как создавать задачи и конкурентно запускать другой код, посмотрим, как можно одновременно выполнять несколько длительных операций.


### Конкурентное выполнение нескольких задач
---

Коль скоро задачи создаются мгновенно и планируются для выполнения как можно раньше, мы получаем возможность конкурентно выполнять несколько длительных задач. Для этого нужно последовательно запустить несколько задач в одной долго работающей сопрограмме.

*Конкурентное выполнение нескольких задач:*
```python
import asyncio
from utils.delay_functions import delay


async def main():
    sleep_for_three = asyncio.create_task(delay(3))
    sleep_again = asyncio.create_task(delay(3))
    sleep_once_more = asyncio.create_task(delay(3))
    
    await sleep_for_three
    await sleep_again
    await sleep_once_more


asyncio.run(main())

```
Здесь мы запустили три задачи, каждой из которых для завершения нужно 3 с. Каждое обращение к `create_task` возвращает управление немедленно, поэтому до предложения `await sleep_for_three` мы доходим сразу же. Ранее мы отмечали, что выполнение задач планируется «как можно раньше». На практике это означает, что в точке, где встречается первое после создания задачи предложение `await`, все ожидающие задачи начинают выполняться, так как `await` запускает очередную итерацию цикла событий.

Поскольку первым мы встречаем предложение `await sleep_for_three`, все три задачи начинают выполняться и засыпают одновременно. Значит, программа в листинге 2.9 завершится примерно через 3 с. Эта конкурентность показана на рис. 2.3 – обратите внимание, что все три задачи исполняют свои сопрограммы `sleep` в одно и то же время. Заметим, что на рис. 2.3 код в задачах, помеченных **RUN delay(3)** (в данном случае некоторые предложения `print`), не работает конкурентно с другими задачами; конкурентно задачи только спят. Если бы мы выполняли операции задержки последовательно, то программа работала бы дольше 9 с. А конкурентность позволила уменьшить время работы в три раза!

![[поток выполнения программы диаграмма.jpg]]

>[!ПРИМЕЧАНИЕ]
> Это превосходство растет по мере увеличения числа задач; если бы мы запустили 10 таких задач, то программа работала бы те же 3 с, что дало бы 10-кратное ускорение.

*Выполнение кода, пока другие операции работают в фоне:*
```python
import asyncio
from utils.delay_functions import delay


async def hello_every_second():
    for i in range(2):
        await asyncio.sleep(1)
        print("пока я жду, исполняется другой код!")


async def main():
    first_delay = asyncio.create_task(delay(3))
    second_delay = asyncio.create_task(delay(3))
    await hello_every_second()
    await first_delay
    await second_delay

asyncio.run(main())

```
Здесь мы создаем две задачи, работающие по 3 с. Пока эти задачи ждут, приложение простаивает, что дает нам возможность занять его другим кодом. В этом примере выполняется сопрограмма `hello_every_second`, которая дважды печатает сообщение с интервалом в одну секунду. Пока две задачи что-то делают, мы видим, как печатаются сообщения:

```shell
засыпаю на 3 с
засыпаю на 3 с
пока я жду, исполняется другой код!
пока я жду, исполняется другой код!
сон в течение 3 с закончился
сон в течение 3 с закончился
```

Поток выполнения показан на рис. 2.4. Сначала мы запускаем две задачи, которые спят в течение 3 с; пока эти задачи простаивают, мы видим, как каждую секунду печатается сообщение `«пока я жду, исполняется другой код!»`. Это означает, что даже во время выполнения длительных операций наше приложение может выполнять другие задачи.
Потенциальная проблема заключается в том, что задача может работать неопределенно долго. Быть может, нам захочется остановить задачу, если она никак не кончается сама. Такая возможность поддерживается и называется *[[#Снятие задач|снятием]]*.

![[поток выполнения программы диаграмма 2.jpg]]


## Снятие задач и задание тайм-аутов
---

Сетевые подключения ненадежны. Установленное пользователем подключение может быть разорвано из-за медленной сети, или [[Веб-сервер|вебсервер]] может «упасть» и оставить существующие запросы в подвешенном состоянии. **Поэтому, отправляя запросы, мы должны внимательно следить за ними, чтобы не ждать слишком долго. Иначе приложение может зависнуть, ожидая результата, который никогда не придет.** Наш пользователь останется недоволен – маловероятно, что он захочет вечно ждать ответа на свой запрос. *Кроме того, иногда имеет смысл предоставить пользователю выбор, если задача работает слишком долго.* Пользователь может согласиться с тем, что его запрос требует много времени, или остановить задачу, запущенную по ошибке.
В рассмотренных выше примерах если бы задачи работали вечно, то мы бы застряли в предложении `await` без всякой обратной связи. И остановить бы программу не смогли, даже если бы захотели. **В библиотеке `asyncio` предусмотрены обе ситуации – мы можем снять задачу или задать тайм-аут.**


### Снятие задач
---

**Снять задачу просто.** У каждого объекта задачи есть метод `cancel`, который можно вызвать, если требуется остановить задачу. В результате снятия задача возбудит исключение `CancelledError`, когда мы ждем ее с помощью `await`. Это исключения можно обработать, как того требует ситуация.

Для иллюстрации предположим, что мы запустили задачу, которая не должна работать дольше 5 с. Если за это время задача не завершилась, то мы хотим ее снять, сообщив пользователю, что задача работает слишком долго и будет остановлена. Мы также хотим каждую секунду печатать сообщение о состоянии, чтобы держать пользователя в курсе, а не оставлять в неведении на протяжении нескольких секунд.

*Снятие задачи:*
```python
import asyncio
from asyncio import CancelledError
from utils.delay_functions import delay


async def main():
    long_task = asyncio.create_task(delay(10))
    seconds_elapsed = 0
    
    while not long_task.done():
        print("Загрузка не закончилась,следующая проверка через секунду.")
        await asyncio.sleep(1)
        seconds_elapsed += 1
        if seconds_elapsed == 5:
            long_task.cancel()
    
    try:
        await long_task
    except CancelledError:
        print("Наша задача была снята")


asyncio.run(main())

```

Здесь мы создаем задачу, работающую 10 с. Затем в цикле `while` проверяем состояние задачи. **Метод задачи `done` возвращает `True`, если задача завершилась, и `False` в противном случае.** Каждую секунду мы проверяем, завершилась ли задача, и запоминаем, сколько секунд уже прошло. Если задача работает дольше 5 с, то мы ее снимаем. Далее задача запускается в предложении `await` `long_task` и, если возникло исключение `CancelledError`, печатается сообщение «Наша задача была снята».

**Важно отметить, что исключение `CancelledError` может быть возбуждено только внутри предложения `await`.** То есть, если вызвать метод `cancel`, когда задача исполняет Python-код, этот код будет продолжать работать, пока не встретится следующее предложение `await` (если встретится), и только тогда будет возбуждено исключение `CancelledError`. **Вызов `cancel` не прерывает задачу, делающую свое дело; он снимает ее, только если она уже находится в точке ожидания или когда дойдет до следующей такой точки.**


### Задание тайм-аута и снятие с помощью `wait_for`
---

Проверять состояние каждую секунду или с другим интервалом, как в предыдущем примере,– не самый простой способ реализации таймаута. В идеале хотелось бы иметь вспомогательную функцию, которая позволяла бы задать тайм-аут и снять задачу по его истечении.

В `asyncio` есть такая возможность в виде функции `asyncio.wait_for`. Она принимает объект сопрограммы или задачи и тайм-аут в секундах и возвращает сопрограмму, к которой можно применить await. Если задача не завершилась в отведенное время, то возбуждается исключение `TimeoutError` и задача автоматически снимается.

Для иллюстрации работы `wait_for` мы рассмотрим случай, когда задаче требуется две секунды, но мы даем ей только одну. Мы перехватываем исключение `TimeoutError` и смотрим, была ли задача снята.

*Задание тайм-аута для задачи с помощью `wait_for`:*
```python
import asyncio
from utils.delay_functions import delay


async def main():
    delay_task = asyncio.create_task(delay(2))
    try:
        result = await asyncio.wait_for(delay_task, timeout=1)
        print(result)
    except asyncio.exceptions.TimeoutError:
        print("Тайм-аут!")
        print(f"Задача была снята? {delay_task.cancelled()}")


asyncio.run(main())
```

Эта программа завершается примерно через 1 с. По истечении 1 с предложение `wait_for` возбуждает исключение `TimeoutError`, которое мы обрабатываем, а именно смотрим, была ли снята задача `delay`, и печатаем следующие сообщения:

```shell
засыпаю на 2 с 
Тайм-аут!
Задача была снята? True
```

Автоматическое снятие задачи, работающей дольше, чем ожидается, обычно является разумной практикой. В противном случае сопрограмма могла бы ждать неопределенно долго, занимая ресурсы, которые никогда не будут освобождены. Но в некоторых случаях желательно дать сопрограмме поработать. Например, по прошествии некоторого времени мы можем проинформировать пользователя о том, что работа занимает дольше, чем ожидалось, но не снимать ее, когда тайм-аут истечет.
Для этого обернем нашу задачу функцией `asyncio.shield`. Эта функция предотвращает снятие сопрограммы, снабжая ее «щитом», позволяющим игнорировать запросы на снятие.

*Защита задачи от снятия:*
```python
import asyncio
from utils.delay_functions import delay


async def main():
    task = asyncio.create_task(delay(10))
    try:
        result = await asyncio.wait_for(asyncio.shield(task), 5)
        print(result)
    except asyncio.exceptions.TimeoutError:
        print("Задача заняла более 5 с, скоро она закончится!")
        result = await task
        print(result)


asyncio.run(main())

```

Здесь мы сначала создаем задачу, обертывающую сопрограмму. В этом состоит отличие от нашего первого примера снятия, потому что нам необходим доступ к задаче в блоке `except`. Если бы мы передали сопрограмму, то `wait_for` обернула бы ее задачей, но сослаться на эту задачу мы бы не смогли, потому что она внутренняя.
Затем внутри блока `try` мы вызываем `wait_for`, обернув предварительно задачу функцией `shield`, чтобы она не была снята. В блоке обработки исключения мы печатаем полезное сообщение пользователю, в котором говорим, что задача еще работает, после чего ждем ее завершения с помощью `await`. Это позволит задаче доработать до конца, а пользователь увидит следующие сообщения:

```shell
засыпаю на 10 с
Задача заняла более 5 с, скоро она закончится!
сон в течение 10 с закончился
<function delay at 0x10e8cf820> завершилась за 10 с
```

**Снятие и защита от снятия – довольно хитрые вещи, у которых есть несколько достойных внимания сценариев применения.**
