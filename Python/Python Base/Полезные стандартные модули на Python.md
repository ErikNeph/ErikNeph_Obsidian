---
title: Полезные стандартные модули на Python
date of creation: 2025-01-14T10:53:00
tags:
  - Python
  - IT/Python
  - Developing
  - Useful
  - IT/Useful
read status: false
completion status: 
aliases:
  - Полезные модули стандартной библиотеки на Python
---
---
# Полезные стандартные модули на Python


## Модуль asyncio :LiStars:
---

Модуль **asyncio** предоставляет альтернативу потокам реализации параллелизма. Во внутреннем устройстве она основана на цикле событий, использующем опрос каналов ввода/вывода. Но высокоуровневая модель программирования очень похожа на многопоточное решение благодаря использованию специальных асинхронных функций.

```python
import asyncio

async def reader1(sock):
    loop = asyncio.get_event_loop() 
    while (data := await loop.sock_recv(sock, 8192)):
        print('reader1 got:', data)


async def reader2(sock):
    loop = asyncio.get_event_loop()
    while (data := await loop.sock_recv(sock, 8192)):
        print('reader2 got:', data)


async def main(sock1, sock2):
    loop = asyncio.get_event_loop()
    t1 = loop.create_task(reader1(sock1))
    t2 =loop.create_task(reader2(sock2))


# Ожидание завершения задач
await t1
await t2

...
# Запуск
asyncio.run(main(sock1, sock2))
```

Модуль **asyncio** поддерживает параллельные операции ввода/вывода с применением опроса каналов ввода/вывода и цикла событий. Он предназначен для использования в коде, работающем с сетями и распределенными системами.

Большинство приложений, использующих **asyncio**, будут работать не на уровне сокетов, а на более высоком. Но в таких приложениях вы все равно будете использовать специальные асинхронные функции и как-то взаимодействовать с циклом событий.

## Модуль binascii
---

**binascii** содержит функции для преобразования двоичных данных в текстовые представления — в частности, в шестнадцатеричную запись и base64:

```powershell
>>> binascii.b2a_hex(b'hello')
b'68656c6c6f'
>>> binascii.a2b_hex(_)
b'hello'
>>> binascii.b2a_base64(b'hello')
b'aGVsbG8=\n'
>>> binascii.a2b_base64(_)
b'hello'
>>>
```

Сходная функциональность предоставляется модулем **base64** и методами **`hex()`** и **`fromhex()`** типа **`bytes`**.


## Модуль cgi (Удален начиная с версии Python 3.13)
---

Допустим, вы хотите разместить на своем сайте простую форму, например для подписки на ежедневный бюллетень «Коты и их виды». Конечно, можно установить новейший веб-фреймворк и потратить неделю-другую на его освоение. А можно написать простой сценарий CGI — решение в духе «старой школы». Модуль **cgi** предназначен именно для этого.


## Модуль configparser
---

Формат файлов INI часто используется для кодирования конфигурационных данных в удобной для человека форме:

```
# config.ini
; Комментарий
[section1]
name1 = value1
name2 = value2
[section2]
; Альтернативный синтаксис 
name1: value1
name2: value2
```

**configparser** используется для чтения файлов .ini и извлечения данных
из них:

```python
import configparser

# Создание парсера и чтение файла
cfg = configparser.ConfigParser()
cfg.read('config.ini')

# Извлечение значений
a = cfg.get('section1', 'name1')
b = cfg.get('section2', 'name2')
...
```

Доступна и более расширенная функциональность, включающая интерполяцию строк, возможность слияния нескольких файлов .ini, определения значений по умолчанию и т. д. За примерами обращайтесь к дополнительным источникам.


## Модуль csv :LiStars:
---

**csv** предназначен для чтения/записи CSV-файлов (значений, разделенных запятыми). Формат CSV генерируется такими программами, как Microsoft Excel, или экспортируется из баз данных. Для использования этого модуля откройте файл и наложите на него дополнительный уровень кодирования/ декодирования CSV.

**csv** не делает с данными CSV почти ничего, кроме их чтения или записи. Главное преимущество этого модуля в том, что он умеет правильно кодировать/ декодировать данные и обрабатывает многие граничные случаи, включая данные в кавычках, специальные символы и другие подробности.


## Модуль errno
---

При каждой ошибке системного уровня Python сообщает о ней исключением-субклассом **`OSError`**. Некоторые распространенные виды системных ошибок представляются отдельными субклассами **`OSError`**: **`PermissionError`** или **`FileNotFoundError`**.

На практике могут встречаться сотни других ошибок. Для них любое исключение **`OSError`** содержит числовой атрибут **errno**, который может проверяться программой. Модуль **errno** дает символические константы, соответствующие этим кодам ошибок. Они часто используются при написании специализированных обработчиков исключений.


## Модуль fcntl
---

**fcntl** применяется для выполнения низкоуровневых управляющих операций ввода/вывода в UNIX с использованием системных функций **`fcntl()`** и **`ioctl()`**. Также он полезен при блокировке файлов — эта задача иногда возникает в контексте параллелизма и распределенных систем.


## Модуль hashlib
---

hashlib предоставляет функции для вычисления криптографических хешкодов —MD5 и SHA-1.


## Пакет http
---

В **http** содержится большой объем кода, относящегося к низкоуровневой реализации интернет-протокола HTTP. Он может использоваться для реализации как серверов, так и клиентов. Но большая часть пакета считается устаревшей и слишком низкоуровневой для повседневной работы. Серьезный программист, работающий с HTTP, скорее воспользуется такими сторонними библиотеками, как requests, httpx, Django, flask и т. д.

Одна из полезных скрытых возможностей пакета **http** — запуск автономного веб-сервера. Введите в каталоге с набором файлов следующую команду:

```bash
python -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

Теперь Python будет предоставлять файлы вашему браузеру, если тот подключится к правильному порту. Для управления веб-сайтом эта возможность не подойдет, но она пригодится для тестирования и отладки программ, использующих веб-технологии. Например, автор использовал ее для локального тестирования программ, содержащих комбинацию HTML, JavaScript и WebAssembly.


## Модуль io
---

**io** в основном содержит определения классов для реализации объектов файлов, возвращаемых функцией **`open()`**. Прямые обращения к таким классам встречаются редко. Но модуль содержит и пару классов, которые могут пригодиться для «имитации» файла в форме строк и байтов.

Это может быть удобно для тестирования и других применений, где нужно предоставить файл, но данные на самом деле были получены иначе.

**`StringIO()`** дает интерфейс «в стиле файла» для строк. Класс **`BytesIO()`** служит похожей цели, но используется для эмуляции двоичного ввода/вывода с байтами.


## Модуль json :LiStars:
---

json может использоваться для кодирования и декодирования данных в формат JSON, обычно используемый в API микросервисов и веб-приложений. Для преобразования данных определены две основные функции: **`dumps()`** и **`loads()`**. **`dumps()`** получает словарь Python и кодирует его в JSON-строку в «Юникоде»: