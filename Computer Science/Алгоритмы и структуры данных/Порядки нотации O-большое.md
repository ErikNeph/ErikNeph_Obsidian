---
title: Порядки нотации O-большое
date of creation: 2025-02-11T23:17:00
tags:
  - ComputerScience
  - Algorithms
  - ComputerScience/Algorithms
  - O-Big
  - О-большое
  - IT
  - Developing/Algorithms
read status: true
completion status: true
aliases:
  - О-большое порядки нотации
---
# Порядки нотации O-большое
---

Нотация **«О-большое»** обычно определяет несколько *порядков сложности*. Ниже эти порядки перечислены по возрастанию (сначала указаны *низкие порядки*, при которых код с ростом объема данных замедляется в наименьшей степени, а в конце — *высокие порядки* с наибольшим замедлением).

1.  $O(1)$, постоянное время (самый низкий порядок).
2.  O($log n$), логарифмическое время.
3.  O($n$), линейное время.
4.  O($n log n$), время N-Log-N.
5.  O($n^2$ ), полиномиальное время.
6.  O($2^n$ ), экспоненциальное время.
7.  O($n!$), факториальное время (наивысший порядок).

Обратите внимание на форму записи порядка «О-большое»: буква O в верхнем регистре, за ней следует пара круглых скобок с описанием порядка. Буква n в скобках представляет размер входных данных, с которыми работает код.

Чтобы использовать нотацию «О-большое», не обязательно понимать точный математический смысл таких терминов, как «логарифмическое» или «полиномиальное». Все порядки я более подробно опишу в следующем разделе, а пока ограничусь простым обозначением.

- O(1) и O(log n) — *быстрые алгоритмы.*
- O(n) и O(n log n) — *неплохие алгоритмы.*
- O(n 2 ), O(2 n ) и O(n!) — *медленные алгоритмы.*

Конечно, можно найти и контрпримеры, но в общем случае эту классификацию можно считать хорошей. Здесь перечислены не все порядки нотации «О-большое», а только самые распространенные. Рассмотрим примеры задач для каждого из них.


## $O(1)$, постоянное время
---

Если вы проверяете, пуста ли книжная полка, это операция с постоянным временем. Неважно, сколько книг на полке; вы с первого взгляда определите, есть ли на ней книги. Их количество может изменяться, но время выполнения останется постоянным, потому что, если вы видите на полке хотя бы одну книгу, дальше можно не проверять. Значение n не влияет на скорость выполнения задачи, поэтому n не входит в обозначение $O(1)$. Также постоянное время иногда записывается в виде $O(c)$.


## $O(log n)$, логарифмическое время
---

Логарифм является операцией, обратной по отношению к возведению в степень; результат 2 4 , или 2 × 2 × 2 × 2, равен 16, тогда как логарифм log 2 (16) (читается «логарифм 16 по основанию 2») равен 4. В программировании часто предполагается, что логарифм вычисляется по основанию 2, поэтому мы используем $O(log n)$ вместо $O(log 2 n)$.

Поиск на полке книги, если они упорядочены по алфавиту, является операцией с логарифмическим временем. Сначала вы проверяете книгу в середине полки. Если это та книга, которую вы искали, поиск завершен. В противном случае можно определить, находится ли искомая книга до или после книги в середине. При этом количество книг, среди которых вы ищете нужную, фактически сокращается вдвое. Этот процесс можно повторить и проверить книгу в середине той половины, где она может находиться. Этот алгоритм называется **[[Алгоритм бинарного поиска|алгоритмом бинарного поиска]]**;

Количество разбиений набора из n книг надвое равно $log 2 n$. На полке с 16 книгами для нахождения нужного издания потребуется не более 4 итераций. Так как каждая сокращает количество книг вдвое, удвоение количества книг добавит в поиск всего один дополнительный шаг. Даже если на упорядоченной полке стоят 4,2 миллиарда книг, для нахождения нужного экземпляра потребуется всего 32 итерации.

Алгоритмы $log n$ обычно включают принцип «разделяй и властвуй», который выбирает половину входных данных размера n, потом половину от этой половины и т. д. Операции $log n$ хорошо масштабируются: рабочая нагрузка n возрастает вдвое, тогда как время выполнения увеличивается всего на один шаг.


## $O(n)$, линейное время
---

Чтение всех книг на полке является операцией с линейным временем. Если книги приблизительно одинакового объема, то при удвоении количества книг на полке для чтения понадобится приблизительно вдвое больше времени. Время выполнения растет пропорционально количеству книг n.


## $O(n log n)$, время N-Log-N
---

Сортировка набора книг в алфавитном порядке является операцией со временем n-log-n. Этот порядок является произведением O(n) и O(log n). Можно рассматривать задачу $O(n log n)$ как задачу $O(log n)$, которую необходимо выполнить n раз. Я попробую неформально объяснить почему.

Начните со стопки книг, которую необходимо расставить по алфавиту, и пустой книжной полки. Выполните последовательность действий алгоритма бинарного поиска, описанную в подразделе «$O(log n)$, логарифмическое время», чтобы определить место одной книги на полке. Как вы уже знаете, эта операция имеет порядок $O(log n)$. Если есть n книг и упорядочение каждой книги требует $log n$ итераций, упорядочение всего набора книг займет $n × log n$, или $n log n$ итераций. При удвоении количества книг количество шагов увеличится чуть более чем вдвое, так что алгоритмы $n log n$ неплохо масштабируются.

Как выясняется, все эффективные обобщенные алгоритмы сортировки имеют порядок $O(n log n)$: сортировка слиянием, быстрая сортировка, пирамидальная сортировка и Timsort ([[Алгоритм Timsort|алгоритм Timsort]], изобретенный [[Тим Петерс|Тимом Петерсом]] (Tim Peters), используется методом Python **`sort()`**).


## $O(n^2 ),$ полиномиальное время
---

Проверка наличия одинаковых книг на неупорядоченной книжной полке является операцией с полиномиальным временем. Если на полке 100 книг, можно начать с первой и сравнить ее с 99 остальными книгами, чтобы узнать, найдется ли такая же. Затем вы берете вторую книгу и сравниваете ее с 99 остальными. Поиск дубликата одного издания выполняется на 99 шагов (округлим до 100, то есть n в нашем примере). Это необходимо сделать 100 раз, по одному для каждого экземпляра. Таким образом, количество шагов для выявления всех дубликатов составит приблизительно $n × n$, или $n 2$ . (Приближение n 2 верно даже в том случае, если действовать умнее и не повторять уже выполненные сравнения.)

Время выполнения возрастает в квадратичной зависимости от количества книг. Проверка 100 книг на наличие дубликатов выполняется за 100 × 100, или 10 000 шагов. Но при удвоении числа книг потребуется 200 × 200, или 40 000 итераций: объем работы увеличивается в четыре раза.

По собственному опыту программирования я обнаружил, что анализ нотации «О-большое» чаще всего используется для того, чтобы избежать случайного применения алгоритма $O(n 2 )$ там, где действует алгоритм $O(n log n)$ или $O(n)$. Порядок $O(n 2 )$ обычно становится переломной точкой для существенного замедления алгоритмов. Когда вы осознаете, что ваш код выполняется со временем $O(n 2 )$ и выше, стоит сделать паузу. Возможно, есть другой алгоритм, который позволит решить проблему быстрее. В таких ситуациях вам безусловно пригодится учебный курс структур данных и алгоритмов — университетский или онлайновый.

Время $O(n 2 )$ также называют *квадратичным*. Кроме того, известны алгоритмы с временем $O(n 3 )$, или *кубическим временем,* которое медленнее $O(n 2 )$; алгоритмы с временем $O(n 4 )$, или *биквадратным временем*, которое медленнее $O(n 3 )$, и другие варианты полиномиальной сложности.


## $O(2^n )$, экспоненциальное время
---

Фотографирование всех возможных комбинаций книг на полке — операция с экспоненциальным временем. Логика такова: каждая книга на полке может либо присутствовать на фотографии, либо отсутствовать. На рис. 13.1 изображены все возможные комбинации для n = 1, 2 или 3. Для n=1 возможны всего две фотографии: с книгой и без нее. Если n=2, количество фотографий увеличивается до четырех: обе книги на полке, обе книги не на полке, только первая книга на полке или только вторая книга на полке. При добавлении третьей книги объем необходимой работы снова удваивается: необходимо обработать каждое подмножество двух книг, которое включает третью книгу (четыре фотографии), и каждое подмножество двух книг, которое не включает третью книгу (еще четыре фотографии — итого 2 3 , или 8 фотографий.)

Каждая новая книга удваивает объем работы. Для n книг количество фотографий (то есть объем работы, которую необходимо выполнить) составляет $2 n$.

Время выполнения экспоненциальных задач растет очень быстро. Для 6 книг потребуется 2 6 , или 32 фотографии, но для 32 книг количество фотографий достигает 2 32 , то есть более 4,2 миллиарда фотографий. Алгоритмы $O(2 n )$, $O(3 n )$, $O(4 n )$ и т. д. имеют экспоненциальную сложность.


## $O(n!)$, факториальное время
---

Фотографирование книг на полке во всех возможных последовательностях — операция с факториальным временем. Все возможные варианты упорядочения n книг называются перестановками. Всего существуют n! (n факториал) перестановок. Факториал числа равен произведению всех положительных целых чисел вплоть до этого числа. Например, факториал 3 равен 3 × 2 × 1, то есть 6. На рис. 13.2 представлены все возможные перестановки трех книг.

Чтобы получить этот результат самостоятельно, подумайте, как бы вы сгенерировали все перестановки n книг. Первую книгу можно выбрать n возможными способами; вторую книгу — n – 1 разными способами (все книги, кроме выбранной в первую позицию); для третьей книги остаются n – 2 возможных варианта, и т. д. Для 6 книг вычисление 6! дает 6 × 5 × 4 × 3 × 2 × 1, или 720 фотографий. При добавлении всего одной книги потребуется 7!, или 5040 фотографий. Даже для небольших значений n часто оказывается, что алгоритмы с факториальным временем невозможно завершить за разумное время. Если вы возьмете 20 книг, будете переставлять их и фотографировать каждую секунду, для перебора всех возможных перестановок потребуется время, превышающее срок существования Вселенной.

Среди задач со временем O(n!) хорошо известна задача о коммивояжере. Коммивояжер должен посетить n городов; он хочет вычислить суммарное расстояние для всех n! возможных вариантов их посещения. По результатам вычислений он рассчитывает определить вариант с кратчайшим расстоянием. При большом количестве городов завершить перебор за разумное время не удастся. К счастью, оптимизированные алгоритмы способны найти короткий (но не обязательно кратчайший!) маршрут намного быстрее O(n!).


# Моментальный анализ сложности О-большое
---

Когда вы освоитесь с выполнением анализа «О-большое», вам не придется выполнять каждый из шагов. Через какое-то время вы сможете просто взглянуть на какие-то характерные особенности кода, чтобы быстро определить его порядок сложности.

Если обозначить переменной n размер данных, с которыми работает код, можно воспользоваться рядом общих правил.

- Если код не обращается ни к каким данным, это $O(1)$.
- Если код последовательно перебирает данные, это $O(1)$.
- Если код содержит два вложенных цикла, каждый из которых перебирает данные, это $O(n^2 )$.
- Вызовы функций включаются в подсчеты не как один шаг, а как общее количество шагов кода внутри функции.
- Если код содержит операцию «разделяй и властвуй», которая многократно делит данные надвое, это $O(log^n)$.
- Если код содержит операцию «разделяй и властвуй», которая выполняется по одному разу для каждого элемента данных, это $O(n log n)$.
- Если код перебирает все возможные комбинации значений в данных с размером n, это $O(2^n )$ или другой экспоненциальный порядок.
- Если код перебирает все возможные перестановки (то есть варианты упорядочения) значений данных, это $O(n!)$.
- Если код включает сортировку данных, это как минимум $O(n log n)$.

Эти правила станут хорошей отправной точкой для анализа, но они не заменят реального анализа «О-большое». Помните, что порядок не является окончательным критерием того, является ли код медленным, быстрым или эффективным. Рассмотрим следующую функцию **`waitAnHour()`**:

```python
import time


def waitAnHour():
	time.sleep(3600)
```

Формально функция **`waitAnHour()`** является функцией с постоянным временем **`O(1)`**. Считается, что код с постоянным временем работает быстро, но на ее выполнение требуется целый час! Означает ли это, что код неэффективен? Нет. Трудно представить себе реализацию **`waitAnHour()`**, которая бы выполнялась быстрее одного часа.

Анализ «О-большое» не заменит профилирования вашего кода. Его цель — дать представление о том, как поведет себя ваш код при возрастающем объеме входных данных.

