---
title: Префиксное дерево
date of creation: 2025-08-02T19:38:00
tags:
  - DataStructure
  - Tree
  - IT
  - Terminology
  - IT/Terminology
  - Developing
  - Backend
  - Web
read status: true
completion status: true
aliases:
---
# Префиксное дерево
---

**Префиксное дерево** — это иерархическая структура данных, которая подходит для компактного хранения строк. Ее английское название, trie, происходит от слова retrieval («извлечение, поиск»); это говорит о том, что она предназначена для операций извлечения строк. Основные свойства префиксного дерева:

- префиксное дерево является иерархической структурой данных;
- корень представляет пустую строку;
- каждый узел хранит символы и имеет 26 дочерних узлов, по одному для каждой буквы английского алфавита. Для экономии места мы не показываем пустые ветви;
- каждый узел дерева представляет отдельное слово или префиксную строку.

==Префиксное дерево — ключевой компонент системы автозаполнения.==

*Здесь показано префиксное дерево с поисковыми запросами tree, try, true, toy, wish и win. Полные поисковые запросы имеют утолщенные края.*
![[Диаграмма префиксного дерева.jpg]]

*Простое префиксное дерево хранит в своих узлах символы. Для поддержки сортировки узлы должны содержать информацию о частоте. Допустим, у нас есть следующая частотная таблица.*
![[Частотная таблица.jpg]]

*После добавления в узлы информации о частоте префиксное дерево будет выглядеть так:*
![[Диаграмма префексного дерева 2.jpg]]

Как работает автозаполнение при использовании префиксного дерева? Прежде чем углубляться в алгоритм, определимся с обозначениями:

- **p** — длина префикса;
- **n** — общее количество узлов в префиксном дереве;
- **c** — количество потомков у заданного узла.

Ниже перечислены этапы получения k самых популярных поисковых запросов.

1. Найти префикс. Временная сложность: O(p).
2. Пройтись по дереву, начиная с префиксного узла, чтобы получить все подходящие узлы-потомки. Потомок подходит, если он может сформировать нужную строку запроса. Временная сложность: O(c).
3. Отсортировать узлы-потомки и получить первые k. Временная сложность: O(clogc).

![[Диаграмма префексного дерева 3.jpg]]

Есть два варианта оптимизации:

1) ограничить максимальную длину префикса;
2) кэшировать самые популярные поисковые запросы в каждом узле.


### Ограничение максимальной длины префикса
---
Пользователи редко вводят длинные поисковые запросы. Поэтому можно легко предположить, что p — это небольшое целое число (скажем, 50). Если ограничить длину префикса, временную сложность его поиска можно сократить с O (p) до O (*небольшая константа*), например O (1).


### Кэширование самых популярных поисковых запросов в каждом узле
---
Чтобы не выполнять обход всего дерева, мы сохраняем k наиболее часто используемых запросов в каждом узле. Пользователю будет достаточно 5–10 вариантов автозаполнения, поэтому k будет относительно небольшим числом. В нашем конкретном случае кэшируются только пять верхних поисковых запросов.

Кэшируя популярные запросы в каждом узле, мы существенно снижаем временную сложность извлечения вариантов автозаполнения. Но этот подход требует много места для хранения популярных запросов в каждом узле. Короткое время ответа крайне важно и вполне оправдывает выделение дополнительного места.

Давайте проанализируем временную сложность алгоритма после применения этих двух оптимизаций:

1. Поиск префиксного узла. Временная сложность: O(1).
2. Возвращение k верхних результатов. Поскольку популярные запросы кэшируются, временная сложность этого этапа составляет O(1).

**Временная сложность каждого шага сведена к O(1), поэтому получение k самых популярных запросов с помощью этого алгоритма занимает всего O(1).**
