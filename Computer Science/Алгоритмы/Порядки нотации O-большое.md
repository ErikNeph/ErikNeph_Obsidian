---
title: Порядки нотации O-большое
date of creation: 2025-02-11T23:17:00
tags:
  - ComputerScience
  - Algorithms
  - ComputerScience/Algorithms
  - O-Big
  - О-большое
read status: true
completion status: true
aliases:
  - О-большое порядки нотации
---
---
# Порядки нотации O-большое

Нотация **«О-большое»** обычно определяет несколько *порядков сложности*. Ниже эти порядки перечислены по возрастанию (сначала указаны *низкие порядки*, при которых код с ростом объема данных замедляется в наименьшей степени, а в конце — *высокие порядки* с наибольшим замедлением).

1.  $O(1)$, постоянное время (самый низкий порядок).
2.  O($log n$), логарифмическое время.
3.  O($n$), линейное время.
4.  O($n log n$), время N-Log-N.
5.  O($n^2$ ), полиномиальное время.
6.  O($2^n$ ), экспоненциальное время.
7.  O($n!$), факториальное время (наивысший порядок).

Обратите внимание на форму записи порядка «О-большое»: буква O в верхнем регистре, за ней следует пара круглых скобок с описанием порядка. Буква n в скобках представляет размер входных данных, с которыми работает код.

Чтобы использовать нотацию «О-большое», не обязательно понимать точный математический смысл таких терминов, как «логарифмическое» или «полиномиальное». Все порядки я более подробно опишу в следующем разделе, а пока ограничусь простым обозначением.

- O(1) и O(log n) — *быстрые алгоритмы.*
- O(n) и O(n log n) — *неплохие алгоритмы.*
- O(n 2 ), O(2 n ) и O(n!) — *медленные алгоритмы.*

Конечно, можно найти и контрпримеры, но в общем случае эту классификацию можно считать хорошей. Здесь перечислены не все порядки нотации «О-большое», а только самые распространенные. Рассмотрим примеры задач для каждого из них.


## $O(1)$, постоянное время
---

Если вы проверяете, пуста ли книжная полка, это операция с постоянным временем. Неважно, сколько книг на полке; вы с первого взгляда определите, есть ли на ней книги. Их количество может изменяться, но время выполнения останется постоянным, потому что, если вы видите на полке хотя бы одну книгу, дальше можно не проверять. Значение n не влияет на скорость выполнения задачи, поэтому n не входит в обозначение $O(1)$. Также постоянное время иногда записывается в виде $O(c)$.


## $O(log n)$, логарифмическое время
---

Логарифм является операцией, обратной по отношению к возведению в степень; результат 2 4 , или 2 × 2 × 2 × 2, равен 16, тогда как логарифм log 2 (16) (читается «логарифм 16 по основанию 2») равен 4. В программировании часто предполагается, что логарифм вычисляется по основанию 2, поэтому мы используем $O(log n)$ вместо $O(log 2 n)$.

Поиск на полке книги, если они упорядочены по алфавиту, является операцией с логарифмическим временем. Сначала вы проверяете книгу в середине полки. Если это та книга, которую вы искали, поиск завершен. В противном случае можно

определить, находится ли искомая книга до или после книги в середине. При этом количество книг, среди которых вы ищете нужную, фактически сокращается вдвое. Этот процесс можно повторить и проверить книгу в середине той половины, где она может находиться. Этот алгоритм называется **[[Алгоритм бинарного поиска|алгоритмом бинарного поиска]]**;