---
date: 2024-05-29T12:43:00
tags:
  - PHP
  - Developing
  - WebDeveloping
  - Web
  - Programming
  - ProgrammingLanguage
  - if
  - switch
  - operators
  - else
  - Backend
  - elseif
---
**Предыдущие главы**:
- [[Кратко о PHP]]
- [[Введение в PHP]]

# Выражения и управление процессом выполнения программы в PHP
---
## Выражения
---
Начнем с базовой части любого языка программирования — *выражения*.

Выражение представляет собой сочетание значений, переменных, операторов и функций, в результате вычисления которого выдается новое значение. Оно знакомо всем, кто когда-либо имел дело с обыкновенной школьной алгеброй. Рассмотрим пример:

$$
y = 3(abs|2x| + 4)
$$

что в PHP приобретает следующий вид:

`$y = 3 * (abs(2*$x) + 4);`

Возвращаемое значение (в математическом выражении y или в PHP `$y`) может быть числом, строкой или булевым (логическим) значением (названным так в честь Джорджа Буля [[Джордж Буль]], английского математика и философа XIX века). Первые два типа значений вам уже должны быть знакомы, поэтому я объясню, что такое третий тип.

---
## Истина или ложь ?
---
Элементарное булево значение может быть либо истинным — TRUE, либо ложным — `FALSE`. Например, выражение 20 > 9 (20 больше 9) является истинным (`TRUE`), а выражение 5 == 6 (5 равно 6) — ложным (FALSE). (Булевы, или логические, операции могут быть объединены путем использования таких операторов, как И, ИЛИ и исключающее ИЛИ, то есть `AND`, `OR` и `XOR`, которые будут рассмотрены в этой главе.)

>[!info]
>Обратите внимание, что для имен `TRUE` и `FALSE` я использую буквы верхнего регистра. Это обусловлено тем, что в PHP они являются предопределенными константами. При желании можно также применять и их версии, составленные из букв нижнего регистра, поскольку они также являются предопределенными константами. Кстати, версия, в которой задействуются буквы нижнего регистра, более надежна, потому что PHP не допускает ее переопределения, а версия, использующая буквы верхнего регистра, может быть переопределена, и это нужно иметь в виду при импортировании чужого кода.


Если, как показано в примере 4.1, потребовать вывод на экран предопределенных констант, PHP их не выведет. В каждой строке код примера выводит букву с двоеточием и предопределенную константу. PHP самовольно сопоставляет со значением `TRUE` числовое значение 1, поэтому при выполнении кода примера после a: выводится 1. И еще загадочнее выглядит то, что попытка вывести сразу за b: значение `FALSE` приводит к тому, что на экране вместо этого значения вообще ничего не появляется. Константа `FALSE` в PHP определяется как еще одна ничем не обозначенная предопределенная константа `NULL`.

**Пример 4.1.** Вывод на экран значений TRUE и FALSE
```php
<?php  // test2.php
  echo "a: [" . TRUE . "]<br>";
  echo "b: [" . FALSE . "]<br>";
?>
```

Здесь при помощи тегов `<br>` создаются переводы на новую строку, разбивающие вывод на экран в HTML на две строки. Этот вывод выглядит следующим образом:

```output
a: [1]
b: []
```

Вернемся к булевым выражениям. В коде примера 4.2 показывается несколько простых выражений: два уже упомянутых ранее и еще два дополнительных.

**Пример 4.2.** Четыре простых булевых выражения
```php
<?php
  echo "a: . [" (20 > 9) . "]<br>";
  echo "b: . [" (5 == 6) . "]<br>";
  echo "c: . [" (1 == 0) . "]<br>";
  echo "d: . [" (1 == 1) . "]<br>";
?>
```

Этот код выведет следующую информацию:

```output
а: [1]
b: []
c: []
d: [1]
```

К счастью, булевы выражения чаще всего окружены другим кодом, и обычно вас абсолютно не волнует, как выглядит внутреннее отображение `TRUE` и `FALSE`. Фактически эти имена довольно редко попадаются в коде.

---
## Литералы и переменные
---
Это базовые элементы программирования, которые к тому же являются строительными блоками выражений. Под *литералом* просто подразумевается нечто, вычисляющее само в себя, например число 73 или строка "Hello". Переменная, с которой мы уже знакомы, обладает именем, начинающимся со знака доллара, и вычисляется в присвоенное этой переменной значение. Простейшее выражение имеет вид одиночного литерала или переменной, поскольку они возвращают значение.

В примере 4.3 показаны три литерала и две переменные, все они возвращают значения, хотя и разных типов.

**Пример 4.3.** Литералы и переменные
```php
<?php
  $my_name = "Brian";
  $my_age = 37;

  echo "a: " . 73 . "<br>";  // Числовой литерал
  echo "b: " . "Hello" . "<br>";  // Строковый литерал
  echo "c: " . FALSE . "<br>";  // Литерал константы
  echo "d: " . $my_name . "<br>";  // Строковая переменная
  echo "e: " . $my_age . "<br>";  // Числовая переменная
?>
```

Как и ожидалось, в выходной информации вы увидите возвращаемое значение всех этих выражений, за исключением c:, результат вычисления которого равен FALSE и ничего не возвращает:

```output
a: 73 b: 
Hello c:
d: Brian
e: 37
```

Объединив простейшие выражения с операторами, можно создать более сложные выражения, результатом вычисления которых будут какие-нибудь полезные результаты.

Чтобы сформировать *инструкции*, программисты комбинируют выражения с другими конструкциями языка, такими как рассмотренные ранее операторы присваивания. В примере 4.4 показаны две инструкции.

В первой из них осуществляется присваивание результата выражения
`366–$day_ number` переменной `$days_to_new_year`, а во второй выводится приветственное сообщение, если выражение `$days_to_new_year < 30` вычисляется как `TRUE`.

**Пример 4.4.** Выражение и инструкция
```php
<?php
  $days_to_new_year = 366 - $day_number;  // Выражение

  if ($days_to_new_year < 30)
  {
    echo "Скоро новый год!";  // Инструкция
  }
?>
```


## Операторы
---
В PHP имеется множество мощных операторов: от арифметических, строковых и логических до операторов присваивания, сравнения и многих других (табл. 4.1).

![[Таблица 4.1. Типы операторов PHP.jpg]]
![[Таблица 4.1.(окончание) Типы операторов PHP.jpg]]

Различные типы операторов воспринимают разное количество операндов.

- *Унарные* операторы, такие как оператор инкремента `($a++)` или отрицания `(!$a)`, воспринимают только один операнд.
- *Бинарные* операторы, представленные большим количеством операторов PHP, включая операторы сложения, вычитания, умножения и деления, воспринимают два операнда.
- Один *тернарный* оператор, имеющий форму `expr ? x : y` и требующий наличия трех операндов. По сути, это состоящая из трех частей однострочная инструкция `if`, возвращающая x, если expr вычисляется в `TRUE`, и `y`, если `expr` вычисляется в `FALSE`.

---
### Приоритетность операторов
---
Если бы у всех операторов был один и тот же уровень приоритета, то они обрабатывались бы в том порядке, в каком встречались интерпретатору. Фактически многие операторы имеют одинаковый уровень приоритета, что и показано в примере 4.5.

**Пример 4.5.** Три эквивалентных выражения
```math
1 + 2 + 3 – 4 + 5
2 – 4 + 5 + 3 + 1
5 + 2 – 4 + 1 + 3
```

Из примера видно, что, несмотря на перестановку чисел (и предшествующих им операторов), результат каждого выражения — 7, поскольку у операторов «плюс» и «минус» одинаковый уровень приоритета. Можно проделать то же самое с операторами умножения и деления (пример 4.6).

**Пример 4.6.** Три выражения, которые также являются эквивалентными
```math
1 * 2 * 3 / 4 * 5
2 / 4 * 5 * 3 * 1
5 * 2 / 4 * 1 * 3
```

В этом примере итоговое значение всегда равно 7,5. Но все меняется, когда в выражении присутствуют операторы с разными уровнями приоритета как в примере 4.7.

**Пример 4.7.** Три выражения, в которых присутствуют операторы с разными уровнями приоритета
```math
1 + 2 * 3 – 4 * 5
2 – 4 * 5 * 3 + 1
5 + 2 – 4 + 1 * 3
```

Если бы не существовало приоритетности операторов, то в результате вычисления этих выражений получались бы числа **25**, **–29** и **12** соответственно. Но поскольку операторы умножения и деления имеют более высокий уровень приоритета по сравнению с операторами сложения и вычитания, выражения вычисляются так, будто эти части выражений заключены в скобки как математическая запись, показанная в примере 4.8.

**Пример 4.8.** Три выражения, в которых отображены предполагаемые скобки
```math
1 + (2 * 3) – (4 * 5)
2 – (4 * 5 * 3) + 1
5 + 2 – 4 + (1 * 3)
```

Сначала PHP вычисляет подвыражения, заключенные в скобки, чтобы получились частично вычисленные выражения, показанные в примере 4.9.

**Пример 4.9.** Выражения после вычисления подвыражений в скобках
```math
1 + (6) – (20)
2 – (60) + 1
5 + 2 – 4 + (3)
```

Окончательный результат вычисления этих выражений равен,
соответственно, **–13**, *–57* и *6* (что абсолютно отличается от результатов **25**, **–29** и **12**, которые мы увидели бы при отсутствии приоритетности операторов).

Разумеется, исходную приоритетность операторов можно отменить, расставив собственные скобки, и принудительно получить тот порядок вычислений, который вам нужен (пример 4.10).

**Пример 4.10.** Принудительное выполнение вычислений справа налево
```math
((1 + 2) * 3 – 4) * 5
(2 – 4) * 5 * 3 + 1
(5 + 2 – 4 + 1) * 3
```

Теперь, если скобки расставлены правильно, мы увидим значения **25**, **–29** и **12** соответственно.

В табл. 4.2 перечислены операторы PHP в порядке их приоритетности от самого высокого до самого низкого уровня.

![[Таблица 4.2. Операторы PHP, расположенные по уровню их приоритетности(сверху вниз).jpg]]

Порядок следования операторов в этой таблице не является произвольным. Он тщательно разработан таким образом, чтобы наиболее распространенными и интуитивно понятными по приоритетности операторами можно было пользоваться без применения скобок. Например, два выражения сравнения можно разделить оператором and или or и получить вполне ожидаемый результат.

---
### Взаимосвязанность операторов
---
Мы рассматривали обработку выражений слева направо, за исключением тех случаев, в которых вступала в силу приоритетность операторов. Но некоторые операторы могут также потребовать обработки справа налево. Направление обработки обусловливается *взаимосвязанностью* операторов. Для отдельных операторов взаимосвязанность отсутствует.

Взаимосвязанность (подробно показана в табл. 4.3) приобретает большое значение в тех случаях, когда вы явным образом не меняете приоритетности. Для этого вам нужно знать о действиях операторов по умолчанию.

![[Таблица 4.3. Взаимосвязанность операторов.jpg]]

Рассмотрим оператор присваивания, показанный в примере 4.11, где всем трем переменным присваивается значение 0.

**Пример 4.11.** Оператор множественного присваивания
```php
<?php
  $level = $score = $time = 0;
?>
```

Такое множественное присваивание возможно только в том случае, если сначала вычисляется самая правая часть выражения, а затем процесс продолжается справа налево.

>[!info]
>Новичкам следует научиться в процессе работы с PHP избегать потенциальных просчетов в вопросах взаимосвязанности операторов и всегда принудительно задавать порядок вычислений, заключая подвыражения в круглые скобки. Это поможет и другим программистам, которые будут обслуживать ваш код, понять, что в нем происходит.

---
## Операторы отношения
---

*Операторы отношения* отвечают на такие вопросы, как «Имеет ли эта переменная нулевое значение?» и «У какой переменной значение больше?». Эти операторы проверяют значения двух операндов и возвращают логический результат, равный либо `TRUE`, либо `FALSE`. Существует три типа операторов отношения: *операторы равенства*, *сравнения* и *логические операторы*.

---
### Операторы равенства
---
С оператором равенства == (двойным знаком равенства) мы уже не раз встречались в этой книге. Его не следует путать с оператором присваивания = (одинарным знаком равенства). В примере 4.12 первый оператор присваивает значение, а второй проверяет его на равенство.

**Пример 4.12.** Присваивание значения и проверка его на равенство
```php
<?php
  $month = "march";

  if ($month == "march")
  {
    echo "Весна наступила.";
  }
?>
```

Как видно из примера, возвращая значение `TRUE` или `FALSE`, оператор сравнения позволяет проверять условия, используя инструкцию `if`. Но это еще не все, поскольку PHP является языком со слабой типизацией. Если два операнда выражения равенства имеют разные типы, PHP преобразует их к тому типу, который имеет для него наибольший смысл. Редко используемый оператор *тождественности*, состоящий из трех подряд знаков равенства, можно задействовать для сравнения элементов без выполнения преобразования. К примеру, любые строки, составленные полностью из цифр, при сравнении с числами будут преобразованы в числа. В примере 4.13 переменные `$а` и `$b` являются двумя разными строками, и поэтому вряд ли стоило ожидать, что какая-то из инструкций `if` выведет результат.

**Пример 4.13.** Операторы равенства и тождественности
```php
<?php
  $a = "1000";
  $b = "+1000";
  
  if ($a == $b) echo "1";
  if ($a === $b) echo "2";
?>
```

Но если запустить этот пример, то он выведет число. Это означает, что результат вычисления первой инструкции `if` равен `TRUE`. Причина в том, что обе строки сначала конвертируются в числа и 1000 имеет такое же числовое значение, что и +1000. В отличие от первой, во второй инструкции `if` используется оператор тождественности, следовательно, переменные `$а` и `$b` сравниваются как строки и теперь считаются отличающимися друг от друга и на экран ничего не выводится.

Как и в случае с принудительным заданием уровня приоритетности операторов, если возникнут сомнения в том, будет ли PHP конвертировать типы операндов, для отмены такого поведения интерпретатора можно воспользоваться оператором тождественности.

Аналогично применению оператора равенства для определения равенства операндов можно проверить их на неравенство, используя оператор *неравенства* !=. Пример 4.14 является измененным примером 4.13, в котором операторы равенства и тождественности были заменены противоположными им операторами.

*Пример 4.14.* Операторы неравенства и не тождественности
```php
<?php
  $a = "1000";
  $b = "+1000";
  
  if ($a != $b) echo "1";
  if ($a !== $b) echo "2";
?>
```

Как, наверное, и ожидалось, первая инструкция `if` не выводит на экран число 1, потому что в коде ставится вопрос о неравенстве числовых значений переменных `$a` и `$b`. Вместо этого будет выведено число 2, поскольку вторая инструкция `if` ставит вопрос о не тождественности `$а` и `$b` друг другу в их текущем строковом типе, и ответом будет TRUE, потому что они не тождественны.

---
### Операторы сравнения
---
Используя операторы сравнения, можно расширить круг проверок, не ограничивая его только равенством и неравенством. PHP предоставляет вам для этого операторы > (больше), < (меньше), >= (больше или равно) и <= (меньше или равно). В примере 4.15 показано использование этих операторов.

**Пример 4.15.** Четыре оператора сравнения
```php
<?php
  $a = 2; $b = 3;
  
  if ($a > $b) echo "$a больше $b<br>";
  if ($a < $b) echo "$a меньше $b<br>";
  if ($a >= $b) echo "$a больше или равно $b<br>";
  if ($a <= $b) echo "$a меньше или равно $b<br>";
?>
```

Этот пример, в котором переменная `$а` имеет значение 2, а переменная `$b` значение 3, выведет на экран следующую информацию:
```output
2 меньше 3
2 меньше или равно 3
```

Попробуйте самостоятельно запустить этот пример, меняя значения переменных `$а` и `$b`, чтобы увидеть результаты. Присвойте им одинаковые значения и посмотрите, что из этого получится.

---
### Логические операторы
---
*Логические* (или булевы) операторы выдают истинные или ложные результаты. Всего имеется четыре таких оператора (табл. 4.4).

Использование этих операторов показано в примере 4.16. Обратите внимание, что PHP требует использовать вместо слова `NOT` символ `!`. Кроме того, операторы могут быть составлены из букв нижнего или верхнего регистра.

![[Таблица 4.4. Логические операторы.jpg]]
![[Пример 4.4.(2часть) Логические операторы.jpg]]

**Пример 4.16**. Использование логических операторов
```php
<?php
  $a = 1; $b = 0;
  
  echo ($a AND $b) . "<br>";
  echo ($a or $b) . "<br>";
  echo ($a XOR $b) . "<br>";
  echo !$a . "<br>";
?>
```

Этот пример выводит построчно на экран `NULL`, 1, 1, `NULL`. Это значит, что только вторая и третья инструкции echo получают в результате вычисления значение `TRUE`. (Следует помнить, что `NULL`, или ничто, отображает значение `FALSE`.) Такой результат получается, потому что оператору `AND` для возвращения значения `TRUE` нужно, чтобы оба операнда имели истинное значение, а четвертый оператор проводит над значением переменной `$a` операцию `NOT`, превращая его из `TRUE` (значения, равного единице) в `FALSE`. Если есть желание поэкспериментировать, запустите этот код, присваивая переменным `$a` и `$b` разные значения, выбранные из 1 и 0.

>[!info]
>Занимаясь программированием, следует помнить, что у операторов `AND` и `OR` более низкий уровень приоритета, чем у других версий этих операторов — `&&` и `||`.

Использование в инструкции `if` оператора `OR` может стать причиной непредвиденных проблем, поскольку второй операнд не будет вычисляться, если в результате вычисления первого операнда уже получено значение `TRUE`. В примере 4.17 функция `getnext` никогда не будет вызвана, если переменная `$finished` имеет значение 1.

**Пример 4.17.** Инструкция, использующая оператор `OR`
```php
<?php
  if ($finished == 1 OR getnext() == 1) exit;
?>
```

Если нужно, чтобы функция `getnext` вызывалась для каждой инструкции `if`, следует внести в код изменения, показанные в примере 4.18.

**Пример 4.18.** Изменения в инструкции `if` … `OR`, гарантирующие вызов функции `getnext()`
```php
<?php
  $gn = getnext();
  if ($finished == 1 OR $gn == 1) exit;
?>
```

В этом случае код в функции `getnext` будет выполнен и возвращенное значение сохранится в переменной `$gn` еще до выполнения инструкции `if`.

>[!info]
>Другое решение заключается в том, чтобы обеспечить выполнение функции `getnext()` за счет простой перестановки условий местами, поскольку тогда вызов функции будет появляться в выражении первым.

В табл. 4.5 показаны все допустимые варианты использования логических операторов. Следует заметить, что `!TRUE` является эквивалентом `FALSE`, а `!FALSE` эквивалентом `TRUE`.

**Таблица 4.5.** Все логические выражения, допустимые в PHP
![[Таблица 4.5 Все логические выражения, допустимые в PHP.jpg]]

---
## Условия
---
*Условия* изменяют процесс выполнения программы. Они позволяют задавать конкретные вопросы и по-разному реагировать на полученные ответы. Условия играют важную роль при разработке динамических веб-страниц — основной цели использования PHP, поскольку облегчают создание разных вариантов информации, выводимой при каждом просмотре веб-страницы.

В этом разделе будут представлены условные конструкции трех основных типов: инструкции `if` и `switch` и оператор `?`. Кроме того, будут представлены циклические условные конструкции (к изучению которых мы вскоре перейдем), код которых выполняется снова и снова до тех пор, пока не будет соблюдено определенное условие.

---
### Инструкция if
---
Процесс выполнения программы можно представить себе как езду на машине по однополосной магистрали. Эта магистраль большей частью прямолинейна, но иногда встречаются различные дорожные знаки, задающие направление движения.

Когда встречается инструкция `if`, можно представить, что машина подошла к знаку объезда, предписаниям которого необходимо следовать, если определенные условия вычисляются как `TRUE`. При этом вы съезжаете с магистрали и следуете по объездному пути до тех пор, пока не вернетесь снова на магистраль и не продолжите движение по исходному маршруту. Или же, если условие не вычисляется как `TRUE`, вы игнорируете объезд и продолжаете ехать по магистрали как ни в чем не бывало (рис. 4.1).

![[Рис.4.1. Процесс выполнения программы.jpg]]

Содержимым условной инструкции `if` может быть любое допустимое PHP-выражение, включая проверку на равенство, выражения сравнения, проверку на нуль и `NULL` и даже значения, возвращаемые функциями (как встроенными, так и созданными самостоятельно).

Действия, предпринимаемые при вычислении условия `if` в `TRUE`, помещаются, как правило, в фигурные скобки `({ })`. Но эти скобки можно опустить, если нужно выполнить всего одну инструкцию. Тем не менее, если всегда использовать фигурные скобки, можно избежать «охоты» на трудно отслеживаемые ошибки, возникающие, к примеру, когда к условной инструкции добавляется еще одна строка, но забывается о необходимости добавить фигурные скобки, из-за чего строка не вычисляется.

>[!info]
>Пресловутая уязвимость системы безопасности, известная как ошибка `goto fail`, многие годы преследовала код Secure Sockets Layer (SSL) в продуктах Apple, когда программист забывал заключить тело инструкции `if` в фигурные скобки, и это приводило к тому, что функция временами выдавала отчет об успешном подключении, хотя по факту так было не всегда. Это позволяло злоумышленникам получать признание сертификата безопасности в тех условиях, когда он должен был быть отклонен. Если есть сомнения, лучше все же помещать тело инструкций `if` в фигурные скобки.

Учтите, что в целях экономии места и доходчивости материала в тех случаях, когда в примерах, приводимых в книге, была всего одна исполняемая инструкция, я не следовал этому совету и опускал фигурные скобки.

В примере 4.19 следует представить, что подошел конец месяца и нужно платить по всем счетам, поэтому вы проводите некоторые операции с банковским счетом.

**Пример 4.19.** Инструкция if, в которой используются фигурные скобки
```php
<?php
if ($bank_balance < 100)
{
  $money = 1000;
  $bank_balance += $money;
}
?>
```

В этом примере проверяется, не стал ли баланс ниже 100 долларов (или 100 единиц другой используемой вами валюты). Если баланс стал ниже этой суммы, вы платите сами себе 1000 долларов, а затем прибавляете их к балансу. (Хорошо бы так просто зарабатывать деньги!)

Если баланс счета в банке равен 100 долларам или превышает эту сумму, условные инструкции игнорируются и процесс выполнения программы переходит на следующую строку кода (которая здесь не показана).

Одни разработчики предпочитают ставить первую фигурную скобку справа от условного выражения, а другие начинают с нее новую строку. В этой книге открывающая фигурная скобка обычно располагается на новой строке. Подойдет любой из этих вариантов, поскольку PHP позволяет оставлять на ваше усмотрение какие угодно свободные пространства (пробелы, символы новых строк и табуляции). Но код будет легче читаться и отлаживаться, если у каждого уровня условий будет свой отступ, сформированный с помощью символа табуляции.

---
### Инструкция else
---
Бывают случаи, когда условие не вычисляется как `TRUE`, но вам не хочется сразу же продолжать выполнение основного кода программы, а вместо этого нужно сделать что-либо другое. Тогда пригодится инструкция `else`. С ее помощью на вашей магистрали можно организовать второй объезд, показанный на рис. 4.2.

![[Рис.4.2. Процесс выполнения програмы if else.jpg | 600]]

Если при использовании конструкции `if`…`else` условие вычисляется как `TRUE`, то выполняется первая условная инструкция. Но если это условие вычисляется как `FALSE`, то выполняется вторая условная инструкция. Для выполнения должна быть выбрана одна из этих двух инструкций, но обе сразу они не будут выполнены ни при каких условиях и обязательно будет выполнена хотя бы одна из них. Использование конструкции `if`…`else` показано в примере 4.20.

**Пример 4.20.** Конструкция `if`…`else`, в которой используются фигурные скобки
```php
<?php
  if ($bank_balance < 100)
  {
      $money = 1000;
      $bank_balance += $money;
  }
  else
  {
      $saving += 50;
      $bank_balance -= 50;
  }
?>
```

Если в этом примере будет установлено, что в банке лежит $100 или более, то выполняется инструкция `else`, с помощью которой часть этих денег перемещается на ваш сберегательный счет.

Точно так же как и у `if`, если у инструкции `else` есть только одна условная инструкция, то фигурные скобки можно не ставить. (Хотя фигурные скобки рекомендуется использовать в любом случае. Во-первых, при их наличии проще разобраться в коде, а во-вторых, они облегчают последующее добавление инструкций к этому ветвлению.)

---
### Инструкция elseif
---
Случается, что на основе последовательности условий нужно осуществить сразу несколько действий. Достичь желаемого результата можно, используя инструкцию `elseif`. Можно предположить, что она похожа на инструкцию `else`, за исключением того, что до кода условия вставляется еще одно условное выражение. ==`elseif` подобна `elif` в python==. Полноценная конструкция `if`…`elseif`…`else` показана в примере 4.21.

**Пример 4.21.** Конструкция `if`…`elseif`…`else`, в которой используются фигурные скобки
```php
<?php
  if ($bank_balance < 100)
  {
      $money = 1000;
      $bank_balance += $money;
  }
  elseif ($bank_balance > 200)
  {
      $saving += 100;
      $bank_balance -= 100;
  }
  else
  {
      $saving += 50;
      $bank_balance -= 50;
  }
?>
```

В этом примере инструкция `elseif` была вставлена между инструкциями `if` и else. Она проверяет, не превышает ли баланс банковского счета сумму $200, и если превышает, принимается решение о том, что в этом месяце можно позволить себе положить на сберегательный счет $100.

Это все можно представить в виде набора объездов в нескольких направлениях (рис. 4.3).

![[Рис.4.3. Магистраль с объездами if, elseif и else.jpg]]

>[!info]
>Инструкция else завершает либо конструкцию `if`...`else`, либо конструкцию `if`...`elseif`...`else`. Если она не нужна, то финальную инструкцию else можно опустить, но ни одна из этих инструкций не должна стоять перед инструкцией elseif, точно так же как вы не можете поставить инструкцию `elseif` перед инструкцией `if`.

Количество используемых инструкций `elseif` не ограничено. Но по мере роста количества этих инструкций будет лучше, наверное, обратиться к инструкции `switch`, если, конечно, она отвечает вашим запросам. Именно ее мы сейчас и рассмотрим.

---
### Инструкция switch
---
Инструкция `switch` применяется в тех случаях, когда у одной переменной или у результата вычисления выражения может быть несколько значений, каждое из которых должно вызывать особое действие.

Рассмотрим, например, управляемую кодом PHP систему меню, которая в соответствии с пожеланием пользователя передает отдельную строку коду основного меню. Предположим, что есть следующие варианты: **Home**, **About**, **News**, **Login** и **Links**, а переменная `$page` принимает одно из этих значений в соответствии с информацией, введенной пользователем.

Код реализации этого замысла с использованием конструкции `if`…`elseif`… `else` может иметь вид, показанный в примере 4.22.

**Пример 4.22.** Многострочная инструкция if...elseif
```php
<?php
  if ($page == "Home") echo "Вы выбрали Home";
  elseif ($page == "About") echo "Вы выбрали About";
  elseif ($page == "News") echo "Вы выбрали News";
  elseif ($page == "Login") echo "Вы выбрали Login";
  elseif ($page == "Links") echo "Вы выбрали Links";
  else echo "Нераспознанный выбор";
?>
```

Код, в котором используется инструкция `switch`, показан в примере 4.23.

**Пример 4.23.** Инструкция `switch`
```php
<?php
  switch ($page)
  {
      case "Home":
          echo "Вы выбрали Home";
          break;
      case "About":
          echo "Вы выбрали About";
          break;
      case "News":
          echo "Вы выбрали News";
          break;
      case "Login":
          echo "Вы выбрали Login";
          break;
      case "Links":
          echo "Вы выбрали Links";
          break;
  }
?>
```

Как видите, переменная `$page` используется только один раз — в начале инструкции `switch`. После этого все соответствия проверяются командой case. Когда найдено соответствие, выполняется его условная инструкция. Разумеется, в настоящей программе в этом месте будет применяться код отображения или перехода на страницу, а не простое сообщение пользователю о том, что именно он выбрал.

>[!info]
>В инструкциях `switch` внутри команд `case` фигурные скобки не используются. Вместо этого инструкции начинаются с двоеточия и заканчиваются командой `break`. Тем не менее весь перечень команд `case` в инструкции `switch` заключается в фигурные скобки.

---
#### Прекращение работы инструкции switch
---
Если нужно, чтобы инструкция `switch` прекратила свою работу из-за выполнения условия, используется команда break. Она предписывает PHP выйти из инструкции `switch` и перейти к выполнению следующей инструкции.

Если в примере 4.23 не расставить команды break и результат вычисления команды case, проверяющей условие **Home**, получится `TRUE`, то есть будут выполнены все пять условных инструкций, следующих за командами `case`. Или же, если переменная `$page` имела значение **News**, то, начиная с этого места, будут выполнены все оставшиеся команды `case`. Это сделано преднамеренно для расширения возможностей программирования, но в большинстве случаев не следует забывать ставить команду `break` во всех местах, где набор условных инструкций, следующих за командами `case`, завершает свою работу. Надо сказать, что случайный пропуск команд `break` является весьма распространенной ошибкой.

---
#### Действие по умолчанию
---
Типичным требованием для инструкции `switch` является переход к действию по умолчанию, если не будет выполнено ни одно из условий, содержащихся в командах `case`. Например, к коду меню, показанному в примере 4.23, можно непосредственно перед закрывающей фигурной скобкой добавить код, показанный в примере 4.24.

***Пример 4.24.*** Инструкция `default` для добавления к примеру 4.23
```php
  default:
    echo "Нераспознаный выбор";
    break;
```
Тем самым повторяется эффект инструкции `else` из примера 4.22.

Хотя здесь ставить команду `break` не требуется, поскольку `default` является заключительной внутренней инструкцией и процесс выполнения программы автоматически продолжится после закрывающей фигурной скобки, но если вы решите поставить инструкцию `default` выше этого места, ей определенно понадобится команда `break`, для того чтобы процесс выполнения программы не затронул все стоящие ниже условные инструкции. Лучше перестраховаться и в конце этой инструкции всегда ставить команду `break`.

---
#### Альтернативный синтаксис
---
Открывающую фигурную скобку инструкции `switch` можно заменить двоеточием, а закрывающую — командой `endswitch` (*пример 4.25*).

Такой вариант используется довольно редко, и здесь он упоминается на тот случай, если придется столкнуться с ним в коде, созданном кем-нибудь другим.

**Пример 4.25.** Альтернативный синтаксис инструкции `switch`
```php
<?php
  switch ($page):
    case "Home":
      echo "Вы выбрали Home";
      break;
      
     // и т. д.
     
    case "Links":
       echo "Вы выбрали Links";
       break;
  endswitch;
?>
```

---

## Оператор ? (тернарный)
---
Использование тернарного оператора `?` позволяет избежать многословности инструкций `if` и `else`. Необычность этого оператора заключается в том, что он использует не два, как большинство других операторов, а три операнда.

В [[Введение в PHP]] уже состоялось краткое знакомство с этим оператором при выяснении разницы между `print` и `echo`, где он приводился в качестве примера оператора, который хорошо работает с `print`, но не работает с `echo`.

Оператору `?` передается выражение, которое он должен вычислить, и два выполняемых оператора: один для выполнения, когда результат вычисления выражения `TRUE`, а другой — когда `FALSE`.

В примере 4.26 показан код, который может использоваться для вывода предупреждения об уровне топлива в автомобиле на его панель приборов.

**Пример 4.26.** Использование оператора `?`
```php
<?php
  echo $fuel <= 1 ? "Требуется дозаправка" : "Топлива еще достаточно";
?>
```

Если топлива остается всего 1 галлон 1 или меньше (иными словами, переменная `$fuel` имеет значение, равное единице или меньше ее), то этот оператор возвращает предыдущей команде `echo` строку **Требуется дозаправка**. В противном случае он возвращает строку **Топлива еще достаточно**. Значение, возвращаемое оператором `?`, можно также присвоить какой-нибудь переменной (пример 4.27).

**Пример 4.27.** Присваивание условного результата оператора `?` переменной
```php
<?php
  $enough = $fuel <= 1 ? FALSE : TRUE;
?>
```

В этом примере переменной `$enough` будет присвоено значение `TRUE` только в том случае, если в баке более 1 галлона топлива, в противном случае ей будет присвоено значение `FALSE`.

Если вы считаете синтаксис оператора `?` слишком запутанным, то можете вместо него воспользоваться инструкцией `if`, но о нем все равно нужно знать, поскольку он может встретиться в программном коде, созданном другим программистом. Чтение кода, в котором используется этот оператор, может быть сильно затруднено из-за частого применения в нескольких местах одной и той же переменной. Например, весьма популярен код такого вида:

`$saved = $saved >= $new ? $saved : $new;`

Понять, что он делает, можно только после тщательного разбора:

```php
$saved = // Присваивание значения переменной $saved...
    $saved >= $new // Сравнение $saved и $new
  ? // Если сравнение выдает истинный результат...
    $saved // ...ей присваивается текущее значение $saved 
  : // Если сравнение выдает ложный результат...
    $new; // ...ей присваивается значение переменной $new
```

Это весьма компактный способ отслеживания самого большого значения, которое может встретиться в процессе выполнения программы. Самое большое значение содержится в переменной `$saved` и при поступлении нового значения сравнивается со значением переменной `$new`. Программисты, освоившие оператор `?`, считают, что для таких коротких сравнений его удобнее применять, чем инструкции `if`.

Если этот оператор не используется для создания компактного кода, то он обычно применяется для принятия решений, умещающихся на одной строке,
например для проверки того, установлено ли значение переменной, перед передачей ее функции.

---
## Циклы
---
Компьютеры славятся своей способностью быстро и неутомимо повторять вычисления. Зачастую от программы требуется снова и снова повторять одну и ту же последовательность кода, пока не произойдет какое-нибудь событие, например ввод значения пользователем или достижение программой своего естественного окончания. Имеющиеся в PHP разнообразные структуры организации циклов предоставляют великолепные способы решения подобных задач.

Чтобы представить, как это работает, посмотрите на рис. 4.4. Он очень похож на метафору с магистралью, которая использовалась для иллюстрации работы инструкции `if`, за исключением того, что у объезда также есть замкнутый участок, из которого машина может выйти только при соблюдении определенных программных условий.

![[Рис.4.4 Представление цикла как части программы магистральной разметки.jpg | 600]]

---
### Цикл while
---
Превратим автомобильную панель приборов из примера 4.26 в цикл, постоянно проверяющий уровень топлива при езде на машине, в котором используется инструкция цикла `while` (пример 4.28).

**Пример 4.28.** Цикл `while`
```php
<?php
  $fuel = 10;

  while ($fuel > 1)
  {
    // Продолжение поездки...
    echo "Топлива еще достаточно";
  }
?>
```

Вообще-то, вы можете предпочесть выводу текста горящий зеленый сигнал, но суть в том, что любая разновидность позитивной индикации об уровне топлива помещается в цикл `while`. Кстати, учтите, что если вы запустите этот пример на выполнение, то он будет постоянно выводить строку до тех пор, пока вы не остановите работу браузера.

>[!info]
>Здесь, как и в случае с инструкциями `if`, для хранения инструкций внутри цикла `while` используются фигурные скобки, если только в этом цикле не задействована лишь одна инструкция.

В примере 4.29 показан еще один вариант использования цикла `while`, в котором выводится таблица умножения на 12.

**Пример 4.29.** Цикл `while` для вывода таблицы умножения на 12
```php
<?php
  $count = 1;
  
  while ($count < 12)
  {
    echo "Число $count, умноженное на 12, равно " . $count * 12 . "<br>";
    ++$count;
  }
?>
```

В этом примере переменной `$count` присваивается начальное значение 1, а затем запускается цикл while, в котором используется выражение сравнения `$count <= 12`. Цикл будет выполняться до тех пор, пока значение переменной не станет больше 12. Данный код выведет следующий текст:

```output
Число 1, умноженное на 12, равно 12
Число 2, умноженное на 12, равно 24
Число 3, умноженное на 12, равно 36
и т. д.
```

Внутри цикла осуществляется вывод строки, а также значения переменной `$count`, умноженного на 12. Чтобы упорядочить вывод, после всего этого использован тег `<br>`, вызывающий переход на новую строку. Затем перед закрывающей фигурной скобкой, предписывающей PHP вернуться к началу цикла, значение переменной `$count` увеличивается на единицу.

Теперь значение переменной `$count` опять проверяется, чтобы узнать, не превышает ли оно число 12. Оно не превышает этого числа, но теперь оно равно 2, и после 11 последующих прохождений цикла оно станет равно 13. Когда это произойдет, код, находящийся внутри цикла `while`, будет пропущен и станет выполняться код, следующий за циклом, в данном случае это будет завершение программы.

При отсутствии оператора `++$count` (вместо которого с таким же успехом может быть применен оператор `$count++`) этот цикл будет похож на первый, показанный в этом разделе. Он никогда не закончится и будет снова и снова выводить один и тот же результат 1 * 12.

Но есть и более изящный способ написания этого цикла, который должен вам понравиться. Посмотрите на код примера 4.30.

**Пример 4.30.** Укороченная версия **примера 4.29**
```php
<?php
  $count = 0;

  while (++$count <= 12)
  echo "Число $count, умноженное на 12, равно " . $count * 12 . "<br>";
?>
```

В этом примере была возможность перемещения оператора `++$count` из тела цикла `while` непосредственно в выражение условия цикла. Теперь PHP вычисляет значение переменной `$count` в начале каждого прохода цикла (итерации) и, заметив, что перед именем переменной стоит оператор инкремента, сначала увеличивает значение переменной на единицу и только потом сравнивает его с числом 12.

Следовательно, теперь переменной `$count` присваивается начальное значение 0, а не 1, поскольку это значение увеличивается сразу же, как только происходит вход в цикл. Если оставить начальное значение, равное 1, то будут выведены результаты для чисел между 2 и 12.

---
### Циклы do...while
---
Цикл `do`…`while` представляет собой небольшую модификацию цикла `while`, используемую в том случае, когда нужно, чтобы блок кода был исполнен хотя бы один раз, а условие проверялось только после этого.

В примере 4.31 показана модифицированная версия таблицы умножения на 12, в которой использован этот цикл.

**Пример 4.31.** Цикл `do`…`while`, используемый для вывода таблицы умножения на 12
```php
<?php
  $count = 0;
  do
    echo "Число $count, умноженное на 12, равно " . $count * 12 . "<br>";
  while (++$count <= 12);
?>
```

Заметьте, что теперь мы вернулись к присваиванию переменной `$count` начального значения 1 (а не 0), потому что находящаяся в цикле инструкция `echo` выполняется перед появлением у нас возможности увеличения значения переменной на единицу. Во всем остальном этот код очень похож на показанный в примере 4.29.

Разумеется, если внутри цикла `do`…`while` находится несколько инструкций, то не следует забывать ставить вокруг них фигурные скобки, как показано в примере 4.32.

**Пример 4.32.** Расширенная версия **примера 4.31**, использующая фигурные скобки
```php
<?php
  $count = 1;
  do {
    echo "Число $count, умноженное на 12, равно " . $count * 12;
    echo "<br>";
} while (++$count <= 12);
?>
```

---
### Циклы for
---
Цикл `for`, являющийся последней разновидностью инструкций цикла, к тому же еще и самый мощный из них, поскольку в нем сочетаются возможности установки значения переменных при входе в цикл, проверки соблюдения условия при каждом проходе цикла (итерации) и модификации значений переменных после каждой итерации.

В примере 4.33 продемонстрирована возможность вывода таблицы умножения с использованием цикла `for`.

**Пример 4.33.** Вывод таблицы умножения на 12 из цикла `for`
```php
<?php
  for ($count = 1; $count <= 12; ++$count)
    echo "Число $count, умноженное на 12, равно " . $count * 12 . "<br>";
?>
```

Как видите, весь код сведен к одной инструкции `for`, в которой содержится одна условная инструкция. И вот что из этого получается. Каждая инструкция `for` воспринимает три параметра:

- выражение инициализации;
- выражение условия;
- выражение модификации.

Эти три выражения отделяются друг от друга точкой с запятой: 
**for (выражение1 ; выражение2 ; выражение3)**. В начале первой итерации выполняется выражение инициализации. В нашем коде таблицы умножения переменная `$count` инициализируется значением **1**. Затем при каждой итерации проверяется выражение условия (в данном случае `$count <= 12`), и выход из цикла осуществляется только в том случае, если результат вычисления условия будет `TRUE`. И наконец, в завершение каждой итерации выполняется выражение модификации. В случае с таблицей умножения значение переменной `$count` увеличивается на единицу.

Эта структура в явном виде исключает любые требования по размещению управляющих элементов цикла в его собственном теле, освобождая его для инструкций, требующих циклического выполнения.

Если в теле цикла `for` содержится несколько инструкций, не забудьте воспользоваться фигурными скобками (пример 4.34).

**Пример 4.34.** Цикл `for` из **примера 4.33** с добавлением фигурных скобок
```php
<?php
  for ($count = 1 ; $count <= 12 ; ++$count)
  {
    echo "Число $count, умноженное на 12, равно " . $count * 12;
    echo "<br>";
  }
?>
```

Сравним условия, при которых следует использовать циклы `for`, с условиями, при которых нужно применять циклы `while`. Цикл `for` явно создавался под отдельное значение, изменяющееся на постоянную величину. Обычно мы имеем дело с увеличивающимся значением — это похоже на то, как если бы вам передали перечень того, что выбрал пользователь, и от вас бы требовалось обработать каждый его выбор по очереди. Но переменную можно видоизменять по вашему усмотрению. Более сложная форма инструкции `for` позволяет даже осуществлять со всеми тремя параметрами сразу несколько операций:

```php
for ($i = 1, $j = 1 ; $i + $j < 10 ; $i++ , $j++)
{
  // ...
}
```

Однако новичкам использовать такую сложную форму не рекомендуется. Здесь главное — отличать запятые от точки с запятой. Все три параметра должны быть отделены друг от друга точкой с запятой.

Несколько операторов внутри каждого параметра должны быть отделены друг от друга запятыми. Первый и третий параметры в предыдущем примере содержат по два оператора:

```php
$i = 1, $j = 1       // Инициализация переменных
$i + $j < 10         // Условие окончания работы цикла
$i++ , $j++          // Модификация $i и $j в конце каждой итерации
```

Главное, что следует уяснить из этого примера, — три секции параметров должны разделяться точкой с запятой, а не запятыми (которые могут использоваться только для разделения операторов внутри каждой секции параметров).

Тогда при каких условиях следует отдавать предпочтение инструкциям `while` перед инструкциями `for`? Когда ваше условие не зависит от простого изменения переменной на постоянной основе. Например, инструкция `while` применяется в том случае, если нужно проверить, не введено ли какое-то определенное значение или не возникла ли какая-то конкретная ошибка,
и завершить цикл сразу же, как только это произойдет.


### Прекращение работы цикла
Прекратить работу цикла `for` (или любого другого цикла) можно точно так же, как и работу рассмотренной уже инструкции `switch`, — используя команду `break`. К примеру, это может понадобиться, когда одна из ваших инструкций вернет ошибку и продолжать выполнение цикла станет небезопасно.

Один из таких случаев может произойти, когда при записи файла возникнет ошибка, возможно, из-за нехватки места на диске (пример 4.35).

**Пример 4.35.** Запись файла, использующая цикл `for` с перехватом ошибки
```php
  $fp = fopen("text.txt", "wb")

  for ($j = 0; $j < 100; ++$j)
  {
    $written = fwrite($fp, "data");
    if ($written == FALSE) break;
  }
  fclose($fp);
```

Это наиболее сложный из всех ранее приведенных фрагментов кода, но вы уже готовы к его пониманию. Команды обработки файлов будут рассмотрены в главе 7, а сейчас нужно лишь знать, что в первой строке кода открывается файл **`text.txt`** для записи в двоичном режиме, а затем переменной **`$fp`** возвращается указатель на него, который в дальнейшем используется для ссылки на этот открытый файл.

Затем осуществляется 100 проходов цикла (от 0 до 99), записывающих строку **`data`** в файл. После каждой записи функция **`fwrite`** присваивает переменной **`$written`** значение, представляющее собой количество успешно записанных символов. Но если происходит ошибка, то функция **`fwrite`** присваивает этой переменной значение **`FALSE`**.

Поведение функции **`fwrite`** облегчает коду проверку переменной **`$written`** на наличие значения **`FALSE`**, и если она имеет такое значение, код прекращает работу цикла и передает управление инструкции, закрывающей файл.

При желании улучшить код можно упростить строку:
`if ($written == FALSE) break;`

за счет использования оператора `NOT`:
`if (!$written) break;`

Фактически пара инструкций, находящихся внутри цикла, может быть сокращена до одной:
`if (!fwrite($fp, "data")) break;`

Иными словами, переменную **`$written`** можно исключить, поскольку она существует только для проверки значения, возвращенного из функции 
**`fwrite`**. Вместо этого можно протестировать возвращаемое значение напрямую.

Но команда **`break`** обладает более широкими возможностями, чем можно было бы предположить, поскольку если нужно прекратить работу кода, вложенного глубже чем на один уровень, после команды **`break`** можно поставить число, показывающее, работу скольких уровней нужно прекратить, например:
`break 2;`

---
### Инструкция continue
---
Инструкция **`continue`** немного похожа на команду **`break`**, только она предписывает PHP остановить обработку текущей итерации цикла и перейти непосредственно к его следующей итерации, то есть вместо прекращения работы всего цикла PHP осуществляет выход только из текущей итерации.

Этот прием может пригодиться в тех случаях, когда известно, что нет смысла продолжать выполнение текущего цикла и нужно сберечь процессорное время или избежать ошибки путем перехода сразу к следующей итерации цикла. В **примере 4.36** инструкция **`continue`** используется для того, чтобы избежать ошибки деления на нуль за счет ее вызова в тот момент, когда переменная **`$j`** имеет значение **`0`**.

Для всех значений переменной **`$j`** в диапазоне чисел между 10 и –10, за исключением 0, отображается результат деления числа 10 на значение переменной **`$j`**. Но для конкретного случая, когда значение **`$j`** равно 0, вызывается инструкция **`continue`** и дальнейшее выполнение итерации сразу же пропускается с переходом к следующей итерации цикла.

**Пример 4.36.** Перехват ошибки деления на нуль с помощью инструкции `continue`
```php
<?php
  $j = 11;
    while ($j > –10)
    {
      $j--;
      if ($j == 0) continue;
      echo (10 / $j) . "<br>";
    }
?>
```

___
## Неявное и явное преобразование типов
---

PHP является языком со слабой типизацией, который позволяет объявлять переменную и ее тип путем простого использования этой переменной. При необходимости он также осуществляет автоматическое преобразование одного типа в другой. Этот процесс называется *неявным преобразованием типов.*

Однако могут возникнуть ситуации, когда присущее PHP неявное преобразование типов станет совсем нежелательным действием. Рассматривая **пример 4.37**, обратите внимание на то, что входные данные для операции деления являются целыми числами. По умолчанию PHP осуществляет преобразование выходных данных к числу с плавающей точкой, чтобы получалось наиболее точное значение — **`4.66`** и 6 в периоде.

**Пример 4.37.** Этот пример возвращает число с плавающей точкой
```php
<?php
  $a = 56;
  $b = 12;
  $c = $a / $b;
  
  echo $c;
?>
```

Но что делать, если вместо этого нужно получить значение переменной `$c` в виде целого числа? Этого можно добиться разными способами, одним из которых является принудительное преобразование результата `$a / $b` в целое число путем использования оператора преобразования `(int)`:

```php
$c = (int) ($a / $b);
```

Такой способ называется **явным преобразованием типов**. Обратите внимание, что для обеспечения преобразования в целое число значения всего выражения это выражение помещено в круглые скобки. В противном случае преобразованию подверглось бы только значение переменной `$a`, что не имело бы никакого смысла, поскольку деление на значение переменной `$b` все равно вернуло бы результат в виде числа с плавающей точкой.

Можно провести явное преобразование значений в те типы, которые показаны в табл. 4.6.

>[!info]
>Необходимости использования преобразования можно избежать за счет вызова одной из встроенных функций PHP. Например, для получения целочисленного значения можно использовать функцию `intval`. Этот раздел, как и многие другие в данной книге, предназначен в основном для того, чтобы помочь разобраться с чужим кодом, который может вам периодически встречаться.

![[Таблица 4.6. Типы преобразований, доступных в PHP.jpg]]

---
### Динамическое связывание в PHP
---
Поскольку PHP является языком программирования и получаемая в результате его работы выходная информация может быть совершенно разной для различных пользователей, есть возможность запускать целый сайт из одной веб-страницы, созданной с помощью PHP. При каждом щелчке пользователя на каком-нибудь элементе подробности могут отправляться назад той же веб-странице, которая будет принимать решение, что делать дальше, в соответствии с различными объектами cookie и (или) данными сессии, которые могут быть сохранены.

Но несмотря на возможность создания таким способом целого сайта, этого делать не рекомендуется, поскольку исходный код будет все время разрастаться и приобретет громадные размеры по мере того, как ему придется принимать во внимание разнообразные действия пользователя.

Будет куда более благоразумно разделить разработку сайта на несколько разных частей. Например, один автономный процесс будет заниматься подпиской на сайт со всеми вытекающими отсюда проверками допустимости адреса электронной почты, незадействованности имени пользователя и т. д.

Второй модуль неплохо было бы создать для регистрации пользователей, предшествующей их допуску к основной части вашего сайта. Затем можно создать модуль вывода сообщений, в котором пользователи могли бы оставлять свои комментарии, модуль, содержащий ссылки и полезную информацию, еще один модуль, позволяющий загружать на сайт фотографии, и т. д.

Как только будет создано средство для отслеживания действий пользователя на вашем сайте, использующее объекты cookie или переменные сессии (оба этих средства будут более подробно рассмотрены в следующих главах), можно разделить сайт на удобные секции PHP-кода, каждая из которых будет независима от других. Таким образом вы существенно облегчите себе будущую разработку каждого нового свойства и обслуживание уже имеющихся.

---
### Динамическое связывание в действии
---
Одним из наиболее популярных в настоящее время приложений, управляемых PHP, является система управления контентом (CMS) WordPress (рис. 4.5). Этого можно и не понять, но для каждой основной секции выделен свой основной PHP-файл, а огромное количество совместно используемых функций помещено в отдельные файлы, которые включаются основными PHP-страницами по мере необходимости.

![[Рис.4.5. Система управления контентом WordPress.jpg]]

Вся платформа держится на закулисном отслеживании сессии, поэтому вы вряд ли знаете о том, когда осуществляется переход от одной подчиненной секции к другой. Поэтому если веб-разработчик хочет провести тонкую настройку WordPress, ему нетрудно найти конкретный файл, который для этого применяется, и выполнить его проверку и отладку, не теряя понапрасну времени на не связанные с ним части программы. Когда в следующий раз будете использовать WordPress, проследите за адресной строкой своего браузера, особенно при управлении блогом, и тогда вы сможете заметить обращения к разнообразным PHP-файлам, которые используются в этом приложении.

В этой главе были рассмотрены обширные сведения, закладывающие основу для дальнейшего изучения материала книги. Теперь вы уже должны уметь составлять свои собственные небольшие PHP-программы. Но перед тем, как перейти к следующей главе, посвященной функциям и объектам, можете проверить приобретенные знания, ответив на следующие вопросы.


==Следующая тема это== - [[Функции и объекты PHP]]