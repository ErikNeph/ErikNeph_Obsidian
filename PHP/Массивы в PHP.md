---
date of creation: 2024-06-01T09:17:00
tags:
  - PHP
  - Arrays
  - ProgrammingLanguage
  - Developing
  - WebDeveloping
  - Structures
  - foreach
  - as
  - list
  - each
---
---
# Массивы в PHP
В [[Введение в PHP]] у нас уже состоялось краткое знакомство с массивами в PHP, позволившее составить первичное представление об их возможностях. В этой главе будет продемонстрирован большой арсенал приемов работы с массивами, некоторые из них при наличии у вас опыта работы с языками со строгой типизацией, например C, могут удивить своей простотой и изяществом.

Кроме того что они не дают умереть со скуки при создании кода для работы со сложными структурами данных, они предоставляют множество невероятно быстрых способов доступа к данным.


## Основные подходы к массивам
Массивы уже рассматривались в виде группы склеенных вместе спичечных коробков [[Многомерный массиы, смоделировынный с помощью коробков.jpg]]. Их можно представить также в виде нитки бус, где бусины обозначают переменные, которые могут быть числовыми, строковыми и даже другими массивами. Массивы похожи на нитки бус, потому что каждый элемент имеет собственное место и у каждого элемента (кроме первого и последнего) с обеих сторон есть другие элементы.

Часть массивов использует ссылки по числовым индексам, другая позволяет работать с буквенно-цифровыми идентификаторами. Встроенные функции дают возможность проводить сортировку, добавлять и удалять отрезки и перебирать элементы для обработки каждого из них, используя специальный вид цикла. А за счет размещения одного или нескольких массивов внутри других массивов можно создавать массивы любой размерности.


### Массивы с числовой индексацией
---
Представим, что перед вами поставлена задача создать простой сайт для компании по поставке товаров для офиса и сейчас вы ведете разработку его раздела, в котором представлены различные сорта бумаги. Как вариант, различные единицы хранения этой категории можно поместить в числовой массив, чтобы получить возможность управлять ими. Простейший способ реализации этого подхода показан в **примере 6.1.**

**Пример 6.1.** Добавление элементов в массив
```php
<?php
  $paper[] = "Coopier";
  $paper[] = "Inkjet";
  $paper[] = "Laser";
  $paper[] = "Photo";

  print_r($paper);
?>
```

В этом примере при каждом присваивании массиву **`$paper`** значения для хранения последнего используется первое же свободное место, а значение существующего в PHP внутреннего указателя увеличивается на единицу, чтобы указывать на свободное место, готовое для следующей вставки значения. Уже известная нам функция **`print_r`** (которая выводит на экран содержимое переменной, массива или объекта) применяется для проверки правильности заполнения массива. Результат ее работы имеет следующий вид:

```php
Array
(
    [0] => Coopier
    [1] => Inkjet
    [2] => Laser
    [3] => Photo
)

```

Предыдущий код может быть написан и так, как показано в **примере 6.2**, где для каждого элемента указывается точное место в массиве. Но как видите, такой подход требует набора лишних символов и усложняет обслуживание кода в том случае, если будет необходимо вставлять товары в массив или удалять их оттуда. Поэтому если не нужно указывать какой-нибудь другой порядок размещения элементов в массиве, лучше все же позволить PHP самостоятельно заниматься их расстановкой.

**Пример 6.2.** Добавление в массив элементов с конкретным указанием их мест
```php
<?php
  $paper[0] = "Coopier";
  $paper[1] = "Inkjet";
  $paper[2] = "Laser";
  $paper[3] = "Photo";

  print_r($paper);
?>
```

Этот пример выведет такую же информацию, как и предыдущий, но в разрабатываемом сайте вы вряд ли будете пользоваться функцией **`print_r`**, поэтому в **примере 6.3** показано, как с помощью цикла можно распечатать сведения о различных типах бумаги, предлагаемых на сайте.

**Пример 6.3.** Добавление элементов в массив и извлечение их из массива
```php
  $paper[0] = "Coopier";
  $paper[1] = "Inkjet";
  $paper[2] = "Laser";
  $paper[3] = "Photo";

  for ($j = 0; $j < 4; ++$j)
    echo "$j: paper[$j]<br>";
```

Этот пример выведет следующую информацию:
```php
0: Copier
1: Inkjet
2: Laser
3: Photo
```

Итак, вы увидели два способа добавления элементов к массиву и один из способов ссылки на них, но PHP предлагает и много других способов, на которых я кратко остановлюсь в дальнейшем. Сначала рассмотрим другой тип массива.


### Ассоциативные массивы
---
Конечно, можно отслеживать элементы массива по индексам, но тогда придется помнить, какой именно номер на какой товар ссылается. Кроме того, за вашим кодом трудно будет уследить другим программистам.

Самое время обратиться к ассоциативным массивам. Использование этих массивов позволяет ссылаться на элементы массива по именам, а не по номерам. В **примере 6.4** приводится расширенная версия предыдущего кода, где каждому элементу массива дается имя для идентификации и более длинное и информативное строковое значение.

**Пример 6.4.** Добавление элементов к ассоциативному массиву и их извлечение
```php
<?php
  $paper['copier'] = "Coopier & Multipurpose";
  $paper['inkjet'] = "Inkjet Printer";
  $paper['laser'] = "Laser Printer";
  $paper['photo'] = "Photographic Paper";
  
  echo $paper['laser'];
?>
```

Теперь у каждого элемента вместо числа (не содержащего никакой полезной информации, кроме позиции элемента в массиве) имеется уникальное имя,
по которому на него можно сослаться где-нибудь в другом месте, как в случае с инструкцией **`echo`**, которая выводит на экран **`Laser Printer`**. Имена (**`copier`**, **`inkjet`** и т. д.) называются *индексами*, или *ключами*, а присвоенные им элементы (например, **`Laser Printer`**) — *значениями*.

Это весьма мощное свойство PHP часто применяется при извлечении информации из кода XML и HTML. Например, HTML-парсер, используемый в поисковой системе, может помещать все элементы веб-страницы в ассоциативный массив, имена которого отображают структуру страницы:
```php
$html['title'] = "Моя веб-страница";
$html['body'] = "... тело веб-страницы ...";
```

Вполне вероятно, что программа разобьет все найденные на странице ссылки и поместит их в другой массив, а все заголовки и подзаголовки — еще в один массив. При использовании ассоциативных, а не числовых массивов код, ссылающийся на все эти элементы, проще будет создавать и отлаживать.


### Присваивание с использованием ключевого слова array
---
Мы уже видели, как элементам массива присваиваются значения путем последовательного добавления к этому массиву новых элементов. Но это слишком затянутый процесс, независимо от того, что при этом происходит: вы определяете ключи, числовые идентификаторы или позволяете PHP неявным образом заниматься присваиванием числовых идентификаторов. Есть более краткий и быстрый способ присваивания значений с использованием ключевого слова **`array`**. В **примере 6.5** показаны оба массива — числовой и ассоциативный, значения которым присваиваются именно этим способом.

**Пример 6.5.** Добавление элементов к массиву с использованием ключевого слова **`array`**
```php
<?php
  $p1 = array("Copier", "Inkjet", "Laser", "Photo");
  
  echo "Элемент массива p1: " . $p1[2] . "<br>";
  
  $p2 = array("copier" => "Copier & Multipurpose",
			  "inkjet" => "Inkjet Printer",
			  "laser" => "Laser Printer",
			  "photo" => "Photographic Paper");

  echo "Элемент массива p2: " . $p2['inkjet'] . "<br>";
?>
```

В первой части этого кодового фрагмента массиву **`$p1`** присваивается старое, укороченное описание товара. Здесь используются четыре элемента, поэтому они занимают позиции от 0 до 3. Инструкция echo выводит следующий текст:
```php
Элемент массива p1: Laser
```

Во второй части кода массиву **`$p2`** присваиваются ассоциативные идентификаторы и сопутствующие им длинные описания товаров. Для этого применяется формат **`индекс => значение`**. Применение оператора => похоже на использование простого оператора присваивания =, за исключением того, что значение присваивается *индексу*, а не *переменной*. После этого индекс приобретает неразрывную связь с этим значением до тех пор, пока ему не будет присвоено другое значение. Поэтому команда echo выводит следующий текст:
```php
Элемент массива p2: Inkjet Printer
```

В том, что **`$p1`** и **`$p2`** принадлежат к разным типам массивов, можно убедиться, если вставить в код две следующие команды, вызывающие ошибку неопределенного индекса или ошибку неопределенного смещения, поскольку для каждого из массивов используется неподходящий идентификатор:

```php
echo $p1['inkjet'];  // Неопределенный индекс
echo $p2['3'];       // Неопределенное смещение
```


## Цикл **`foreach...as`**
Создатели PHP постарались сделать этот язык простым в использовании. Поэтому они не остановились на уже имеющихся структурах организации цикла, а добавили еще одну структуру, специально предназначенную для массивов, цикл **`foreach...as`**. Используя этот цикл, можно поочередно перебрать все элементы массива и произвести с ними какие-нибудь действия.

Процесс начинается с первого элемента и заканчивается последним, поэтому вам даже не нужно знать, сколько элементов присутствует в массиве.

В **примере 6.6** показано, как цикл **`foreach...as`** может использоваться для переписывания кода **примера 6.3.**

**Пример 6.6.** Последовательный перебор элементов числового массива с использованием цикла **`foreach...as`**
```php
<?php
  $paper = array("Copier", "Inkjet", "Laser", "Photo");
  $j = 0;
  
  foreach ($paper as $item)
  {
      echo "$j: $item<br>";
      ++$j;
  }
?>
```

Когда PHP встречает инструкцию **`foreach`**, он извлекает первый элемент массива и помещает его значение в переменную, указанную после ключевого слова **`as`**, и при каждом возвращении управления инструкции **`foreach`** в эту переменную помещается значение следующего элемента массива. В данном случае переменной **`$item`** присваиваются по очереди все четыре значения, хранящиеся в массиве **`$paper`**. Как только будут использованы все значения, выполнение цикла завершается. Этот код выводит точно такую же информацию, что и код **примера 6.3**.

Теперь посмотрим, как **`foreach`** работает с ассоциативным массивом. В **примере 6.7** переписана вторая часть **примера 6.5**.

**Пример 6.7.** Последовательный перебор элементов ассоциативного массива с использованием цикла **`foreach...as`**
```php
<?php
  $paper = array('copier' => "Copier & Multipurpose",
                 'inkjet' => "Inkjet Printer",
                 'laser' => "Laser Printer",
                 'photo' => "Photographic Paper");
  
  foreach ($paper as $item => $description)
    echo "$item: $description<br>";
?>
```

Вспомним, что ассоциативным массивам не требуются числовые индексы, поэтому переменная **`$j`** в данном примере не используется. Вместо этого каждый элемент массива **`$paper`** вводится в пару «ключ — значение», представленную переменными **`$item`** и **`$description`**, из которых эта пара выводится на экран в следующем виде:

```php
copier: Copier & Multipurpose
inkjet: Inkjet Printer
laser: Laser Printer
photo: Photographic Paper
```

До версии PHP 7.2 в качестве альтернативы синтаксису **`foreach...as`** можно было воспользоваться функцией **`list`** в сочетании с функцией **`each`**. Однако затем функция **`each`** устарела, поэтому применять ее не рекомендуется, ведь она может быть удалена в будущей версии. Это кошмар для программистов PHP, которым надо обновлять устаревший код, тем более что функция **`each`** чрезвычайно полезна. Поэтому я написал замену для each под названием **`myEach`**, которая работает идентично и позволит вам легко обновить старый код как в примере 6.8.

**Пример 6.8.** Последовательный перебор элементов ассоциативного массива с помощью функций **`myEach`** и **`list`**
```php
<?php
  $paper = array('copier' => "Copier & Multipurpose",
                 'inkjet' => "Inkjet Printer",
                 'laser' => "Laser Printer",
                 'photo' => "Photographic Paper");
  
  while (list($item, $description) = myEach($paper))
    echo "$item: $description<br>";

  function myEach(&$array)  // Replacement for the deprecated each function
  {
      $key = key($array);
      $result = ($key === null) ? false :
          [$key, current($array), 'key', 'value' => current($array)];
      next($array);
      return $result;
  }
?>
```

В этом примере организуется цикл **`while`**, который будет продолжать работу до тех пор, пока функция **`myEach`** (эквивалентная функции each в старом PHP) не вернет значение **`FALSE`**. Функция **`myEach`** ведет себя как **`foreach`**: она возвращает из массива **`$paper`** массив, содержащий пару «ключ — значение», а затем перемещает встроенный указатель на следующую пару в исходном массиве. Когда возвращать становится нечего, функция **`myEach`** возвращает значение **`FALSE`**.

Функция **`list`** в качестве аргументов принимает массив (в данном случае пару «ключ — значение», возвращенную функцией **`myEach`**), а затем присваивает значения массива переменным, перечисленным внутри круглых скобок.

Лучше понять работу функции **`list`** можно из **примера 6.9**, где массив создается из двух строк — **`Alice`** и **`Bob`**, а затем передается функции **`list`**, которая присваивает эти строки переменным **`$а`** и **`$b`**.

**Пример 6.9.** Использование функции **list**
```php
<?php
  list($a, $b) = array('Alice', 'Bob');
  echo "a=$a, b=$b";
?>
```

Этот код выводит следующий текст:
```php
a=Alice b=Bob
```

Итак, для перебора элементов массива можно применять различные подходы. Можно воспользоваться конструкцией **`foreach...as`** для создания цикла, извлекающего значения в переменную, которая следует за as, или воспользоваться функцией **`myEach`** и создать собственную систему циклической обработки.


## Многомерные массивы
Простая конструктивная особенность синтаксиса массивов PHP позволяет создавать массивы более чем с одним измерением. Фактически можно создавать массивы любой размерности (хотя приложения редко нуждаются в массивах с размерностью больше трех).

Эта особенность заключается в возможности включать целый массив в состав другого массива, а также делать это снова и снова, как в старом стишке про блох, которых кусают другие блохи поменьше, а тех, в свою очередь, кусают свои блохи, и так до бесконечности.

Рассмотрим, как это работает, для чего возьмем ассоциативный массив из предыдущего примера и расширим его (**пример 6.10**).

**Пример 6.10.** Создание многомерного ассоциативного массива
```php
<?php
  $products = array(
      'paper' => array(
          'copier' => "Copier & Multipurpose",
          'inkjet' => "Inkjet Printer",
          'laser' => "Laset Printer",
          'photo' => "Photographic Paper"),
           
      'pens' => array(
          'ball' => "Ball Point",
          'hilite' => "Highlighters",
          'marker' => "Markers"),
          
      'misc' => array(
          'tape' => "Sticky Tape",
          'glue' => "Adhesives",
          'clips' => "Paperclips")
      );
  
  echo "<pre>";
  
  foreach ($products as $section => $items)
    foreach ($items as $key => $value)
      echo "$section:\t$key\t($value)<br>";

  echo "<pre>";
?>
```

Чтобы упростить понимание начинающего разрастающегося кода, я переименовал часть элементов. Например, поскольку предыдущий массив **`$paper`** стал лишь подразделом более крупного массива, главный массив теперь называется **`$products`**. В этом массиве присутствуют три элемента: бумага — **`paper`**, ручки — **`pens`** и разные товары — **`misc`**, и каждый из них содержит другой массив, состоящий из пар «*ключ — значение*».

При необходимости эти подмассивы могут содержать другие массивы. Например, элемент «шариковые ручки» — **`ball`** — может содержать множество типовых и цветовых решений этого товара, имеющихся в интернет-магазине. Но пока я ограничил код глубиной в два измерения.

После присваивания массивам данных для вывода различных значений я воспользовался парой вложенных циклов **`foreach...as`**. Внешний цикл извлекает из верхнего уровня массива основные разделы, а внутренний цикл извлекает для категорий в каждом разделе пары «*ключ — значение*».

Если вспомнить, что все уровни массива работают одинаково (являясь парой «*ключ — значение*»), можно без особого труда создать код для доступа к любому элементу на любом уровне.

В инструкции **`echo`** используется управляющий символ PHP **`\t`**, который выводит знак табуляции.

Хотя знаки табуляции для браузеров, как правило, ничего не значат, я использовал их в разметке, применив теги **`<pre>...</pre>`**, которые предписывают браузеру форматировать текст с сохранением предварительного формата и фиксированной ширины и не игнорировать неотображаемые символы вроде знаков табуляции и переводов строки. Текст, выводимый этим кодом, будет иметь следующий вид:
```php
paper: copier (Copier & Multipurpose)
paper: inkjet (Inkjet Printer)
paper: laser (Laser Printer)
paper: photo (Photographic Paper)
pens: ball (Ball Point)
pens: hilite (Highlighters)
pens: marker (Markers)
misc: tape (Sticky Tape)
misc: glue (Adhesives)
misc: clips (Paperclips)
```

Непосредственный доступ к конкретному элементу массива можно получить, добавив квадратные скобки:
```php
echo $products['misc']['glue'];
```

Этот код выводит значение **`Adhesives`**.

Можно также создать числовой многомерный массив, непосредственный доступ к элементам которого можно будет получать по индексам, а не по буквенно-цифровым идентификаторам. В **примере 6.11** создается шахматная доска с фигурами на исходных позициях.

**Пример 6.11.** Создание многомерного числового массива
```php
<?php
  $chessboard = array(
    array('r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'),
    array('p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'),
    array(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '),
    array(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '),
    array(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '),
    array(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '),
    array('P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'),
    array('R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R')
  ); 

  echo "<pre?>";

  foreach ($chessboard as $row)
  {
    foreach ($row as $piece)
      echo "$piece ";
    echo "<br>";
  }

  echo "</pre>";
?>
```

В этом примере буквы в нижнем регистре представляют собой черные фигуры, а в верхнем регистре — белые. Используются следующие обозначения: r — rook (ладья), n — knight (конь), b — bishop (слон), k — king (король), q — queen (ферзь) и p — pawn (пешка). Для последовательного перебора массива и демонстрации его содержимого снова используется пара вложенных циклов **`foreach...as`**. Внешний цикл обрабатывает каждую горизонталь и помещает ее в переменную **`$row`**, которая сама по себе является массивом, поскольку для каждой горизонтали массив шахматной доски — **`$chessboard`** — использует подмассив. В этом цикле используются две инструкции, поэтому они заключены в фигурные скобки

Внутренний цикл обрабатывает каждую клетку горизонтали, выводя хранящийся в ней символ (**`$piece`**), за которым следует пробел (чтобы выводимый текст имел форму шахматной доски). У этого цикла одна инструкция, которую не нужно заключать в фигурные скобки. Теги **`<pre>`** и **`</pre>`** обеспечивают правильную форму выводимого текста:

```php
r n b q k b n r  
p p p p p p p p  
  
  
  
  
P P P P P P P P  
R N B Q K B N R
```

Используя квадратные скобки, можно получить непосредственный доступ к любому элементу этого массива:

```php
echo $chessboard[7][3];
```

Эта инструкция выведет букву **`Q`** в верхнем регистре, которая является значением восьмого вниз по вертикали и четвертого по горизонтали элемента (следует помнить, что индексы массива начинаются с нуля, а не с единицы).


## Использование функций для работы с массивами
С функциями **`list`** и **`each`** вы уже знакомы, но в PHP имеется множество других функций, предназначенных для работы с массивами. Их полный перечень представлен в документации (http://tinyurl.com/arraysinphp). Но некоторые из этих функций играют настолько важную роль в программировании на PHP, что мы изучим их подробнее.


### Функция **`is_array`**
---
Массивы и переменные используют одно и то же пространство имен. Это означает, что нельзя иметь строковую переменную по имени **`$fred`** и массив, который также называется **`$fred`**. Если есть сомнения и в коде программы нужно проверить, является ли переменная массивом, можно воспользоваться функцией **`is_array`**:
```php
echo (is_array($fred)) ? "Это массив" : "Это не массив";
```

Заметьте, что переменной **`$fred`** не присвоено никакого значения, поэтому будет выведено сообщение о неопределенной переменной — **`Undefined variable`**.


### Функция **`count`**
---
Несмотря на то что функция **`each`** и структура организации цикла **`foreach...as`** предоставляют отличные способы последовательного перебора всего содержимого массива, иногда нужно точно знать, сколько элементов содержится в вашем массиве, особенно если вы будете обращаться к ним напрямую. Для подсчета всех элементов на верхнем уровне массива используется следующая команда:
```php
echo count($fred);
```

Если нужно узнать, сколько всего элементов содержится в многомерном массиве, можно воспользоваться следующей инструкцией:
```php
echo count($fred, 1);
```

Второй параметр является необязательным и устанавливает режим использования. Он может иметь либо нулевое значение, чтобы ограничить подсчет только верхним уровнем, либо единичное — для принудительного включения рекурсивного подсчета еще и всех элементов, содержащихся в подмассивах.


### Функция **`sort`**
---
Сортировка является настолько распространенной операцией, что PHP предоставляет для нее встроенную функцию. В наипростейшей форме ее можно использовать следующим образом:
```php
sort($fred);
```

Важно помнить, что, в отличие от некоторых других функций, сортировка будет работать непосредственно с предоставленным ей массивом, а не возвращать новый массив с отсортированными элементами. Вместо этого она вернет значение **`TRUE`** при успешном выполнении сортировки и **`FALSE`** — при возникновении ошибки. Эта функция поддерживает также несколько флагов. Основные два флага, которые вам могут пригодиться, предписывают проведение либо числовой, либо строковой сортировки:

```php
sort($fred, SORT_NUMERIC);
sort($fred, SORT_STRING);
```

Массив можно также отсортировать в обратном порядке, воспользовавшись функцией **`rsort`**:

```php
rsort($fred, SORT_NUMERIC);
rsort($fred, SORT_STRING);
```


### Функция **`shuffle`**
---
Иногда, например при создании игры или при игре в карты, требуется, чтобы элементы массива располагались в случайном порядке:

```php
shuffle($cards);
```

Как и функция **`sort`**, функция **`shuffle`** работает непосредственно с предоставленным ей массивом и возвращает значение **`TRUE`** в случае успешного завершения работы и **`FALSE`** — при возникновении ошибки.


### Функция **`explode`**
---
Это очень полезная функция, позволяющая взять строку, содержащую несколько элементов, отделенных друг от друга одиночным символом (или строкой символов), а затем поместить каждый из этих элементов в массив. В **примере 6.12** показан один из случаев полезного применения этой функции, который заключается в разбиении предложения на слова и помещении всех слов, из которого оно состоит, в массив.

**Пример 6.12.** Извлечение слов из строки в массив с использованием 
пробелов
```php
<?php
  $temp = explode(' ', "Это предложение из пяти слов");
  print_r($temp);
?>
```

Этот пример выводит следующую информацию (которая при просмотре в браузере будет отображена в одной строке):
```php
Array
(
  [0] => Это
  [1] => предложение
  [2] => из
  [3] => пяти
  [4] => слов
)
```

Первый параметр — разделитель — необязательно должен быть пробелом или даже одиночным символом. **В примере 6.13** показан этот же код в несколько измененном виде.

**Пример 6.13**. Извлечение слов, разделенных символами **`***`**, из строки в массив
```php
<?php
  $temp = explode('***', "Это***предложение***со***звездочками");
  print_r($temp);
?>
```

**Код примера 6.13** выводит следующую информацию:
```php
  Array
  (
    [0] => Это
    [1] => предложение
    [2] => со
    [3] => звездочками
  )
```


### Функция **`extract`**
---
Иногда бывает удобно превратить пары «*ключ — значение*» из массива в переменные PHP. Один из таких случаев — это обработка переменных **`$_GET`** или **`$_POST`**, отправленных формой сценарию PHP.

Когда форма передается через интернет, веб-сервер распаковывает переменные и помещает их в глобальный массив, предназначенный для сценария PHP. Если переменные были отправлены методом **`GET`**, они будут помещены в ассоциативный массив **`$_GET`**, а при отправке методом **`POST`** — в ассоциативный массив **`$_POST`**.

Разумеется, можно перебрать все элементы этих ассоциативных массивов, воспользовавшись уже рассмотренными в этой главе способами. Но иногда нужно лишь сохранить отправленные значения в переменных для дальнейшего использования. В таком случае можно заставить PHP проделать эту работу за вас в автоматическом режиме: `extract($_GET);`

Таким образом, к примеру, если параметр строки запроса **`q`** отправлен сценарию PHP наряду со связанным с ним значением **`Hi there`**, будет создана новая переменная по имени **`$q`**, которой будет присвоено это значение.

Но к описанному подходу нужно относиться осторожно, поскольку если какиенибудь извлекаемые переменные конфликтуют с уже определенными переменными, то существующие переменные будут переписаны. Чтобы избежать этого, можно воспользоваться одним из многих дополнительных параметров, доступных в данной функции:
`extract($_GET, EXTR_PREFIX_ALL, 'fromget');`

В этом случае имена всех новых переменных будут начинаться с заданного строкового префикса, за которым следует символ подчеркивания, в результате чего **`$q`** превратится в **`$fromget_q`**. Я настоятельно рекомендую при обработке массивов **`$_GET`** и **`$_POST`** или любого другого массива, ключи которого могут контролироваться пользователем, использовать именно эту версию функции, поскольку злоумышленники могут отправлять ключи, специально подобранные для того, чтобы переписать переменные с часто используемыми именами и таким образом угрожать вашему сайту.


### Функция **`compact`**
---
Иногда нужно воспользоваться функцией **`compact`**, которая является противоположностью функции **`extract`**, чтобы создать массив из переменных и их значений. Применение этой функции показано в **примере 6.14**.

**`Пример 6.14.`** Использование функции **`compact`**
```php
<?php
  $fname = "Doctor";

  $sname = "Who";

  $planet = "Gallifrey";

  $system = "Gridlock";

  $constellation = "Kasterborous";


  $contact = compact('fname', 'sname', 'planet', 'system', 'constellation');

  print_r($contact);

?>
```

В результате запуска кода из **примера 6.14** будет выведена следующая информация:
```php
Array
( 
    [fname] => Doctor
    [sname] => Who
    [planet] => Gallifrey
    [system] => Gridlock
    [constellation] => Kasterborous
)
```

Обратите внимание на то, что функции **`compact`** нужны имена переменных, стоящие в кавычках и не содержащие начального символа **`$`**. Причина заключается в том, что функция **`compact`** ==ищет список имен переменных, а не их значений.==

Эту функцию можно использовать также для отладки, когда нужно быстро просмотреть несколько переменных вместе с их значениями как в
**примере 6.15.**

**`Пример 6.15.`** Использование функции **`compact`** для отладки программы
```php
<?php
  $j = 23;
  $temp = "Hello";
  $address = "1 Old Street";
  $age = 61;

  print_r(compact(explode(" ", "j temp address age")));

?>
```

Работа примера основана на использовании функции **`explode`** для извлечения всех слов из строки в массив, который затем передается функции compact, а она, в свою очередь, возвращает массив функции **`print_r`**, которая в итоге показывает его содержимое.

Если скопировать и вставить строку кода, содержащую вызов функции 
**`print_r`**, то в ней нужно будет лишь изменить имена переменных, чтобы быстро вывести группу их значений. В этом примере выводимая информация будет иметь следующий вид:

```php
Array
(
    [j] => 23
    [temp] => Hello
    [address] => 1 Old Street
    [age] => 61
)
```


### Функция **`reset`**
---
Когда с помощью конструкции **`foreach...as`** или функции **`each`** осуществляется последовательный перебор элементов массива, они перемещают внутренний указатель PHP, который показывает, какой из элементов массива нужно извлечь в следующий раз. Если коду программы понадобится вернуться к началу массива, то можно воспользоваться функцией **`reset`**, а она к тому же вернет значение элемента, на котором остановился указатель. Эта функция может быть использована следующим образом:
```php
reset($fred);         // Отбрасывание возвращаемого значения
$item = reset($fred); // Сохранение первого элемента массива
                      // в переменной $ item
```


### Функция **`end`**
---
Можно также переместить внутренний указатель элемента массива PHP на последний элемент, воспользовавшись для этого функцией **`end`**, которая, кроме этого, возвращает значение элемента и может быть использована следующим образом:
```php
end($fred);
$item = end($fred);
```

В этой главе завершается введение в основы PHP. Теперь, используя приобретенные навыки, вы должны справиться с написанием довольно сложных программ. В [[Практикум по программированию на PHP]] будет рассмотрено применение PHP для решения наиболее распространенных практических задач.