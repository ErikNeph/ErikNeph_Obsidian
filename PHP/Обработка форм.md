---
date of creation: 2024-06-07T16:25:00
tags:
  - HTML
  - Forms
  - Web
  - WebDeveloping
  - PHP
  - Developing
aliases:
  - Обработка форм HTML и PHP
---
---
# Обработка форм


==Одним из основных способов взаимодействия пользователей с PHP и MySQL является применение HTML-форм.== Эти формы появились на заре разработки Всемирной паутины, в 1993 году, даже раньше, чем электронная коммерция, и благодаря простоте и легкости использования не утратили своего значения и по сей день, хотя их форматирование может превратиться в настоящий кошмар.

Разумеется, с годами HTML-формы совершенствовались, получая дополнительные функциональные возможности обработки информации, поэтому данная глава познакомит вас с современными методами обработки формы и продемонстрирует самые лучшие способы реализации форм для достижения наибольшей степени удобства и безопасности. Плюс к этому чуть позже вы увидите, что в спецификации HTML5 предусмотрено улучшенное использование форм.


## Создание форм
---

Обработка форм — многоступенчатый процесс. Сначала создается форма, в которую пользователь может вводить необходимые данные. Затем эти данные отправляются веб-серверу, где происходит их разбор, зачастую совмещаемый с проверкой на отсутствие ошибок. Если код PHP найдет одно или несколько полей, требующих повторного ввода, форма может быть заново отображена вместе с сообщением об ошибке. Когда качество введенных данных удовлетворяет программу, она предпринимает некоторые действия, часто привлекая для этого базы данных, к примеру для ввода сведений о покупке.

Для создания формы потребуются как минимум следующие элементы:

- открывающий и закрывающий теги — **`<form>`** и **`</form>`** соответственно;
- тип передачи данных, задаваемый одним из двух методов — **`GET`** или **`POST`**;
- одно или несколько полей для ввода данных;
- URL-адрес назначения, по которому будут отправлены данные формы.

**В примере 12.1** показана очень простая форма, созданная с использованием кода PHP. Наберите этот код и сохраните его в файле formtest.php.

**Пример 12.1.** formtest.php — простой обработчик формы на PHP
```php
<?php // formtest.php
echo <<<_END
  <html>
    <head>
      <title>Form Test</title>
    </head>
    <body>
    <form method="post" action="formtest.php">
      What is your name?
      <input type="text" name="name">
      <input type="submit">
    </form>
    </body>
  </html>
_END;
?>
```

В первую очередь следует отметить, что в этом примере использован прием, уже встречавшийся в книге: вместо многократного входа в PHP-код и выхода из него для вывода многострочного HTML-кода я обычно применяю конструкцию echo **`<<<_END..._END`**.

Внутри этого многострочного вывода находится стандартный код, с которого начинается HTML-документ, отображающий заголовок документа и обозначающий начало его тела. Затем следует форма, настроенная на отправку своих данных с использованием POST-метода в адрес PHP-программы formtest.php, то есть этой самой программы.

Остальной код программы закрывает все открытые элементы: форму, тело HTML-документа и PHP-инструкцию **`echo <<<_END`**. Результат запуска этой программы в браузере показан на **рис. 12.1.**

![[Рис. 12.1. Результат запуска программы formtest.php в браузере.jpg]]
>  **Рис. 12.1.** Результат запуска программы formtest.php в браузере


### Извлечение отправленных данных
---

В **примере 12.1** представлена только одна из частей многоступенчатого процесса обработки формы. Если ввести имя и нажать кнопку Отправить запрос, то абсолютно ничего, кроме повторного отображения формы и потери введенных данных, не произойдет. Поэтому сейчас нужно добавить PHP-код, обрабатывающий отправляемые формой данные.

В **примере 12.2** показана расширенная версия предыдущей программы, включающая обработку данных. Наберите этот код или измените код программы formtest.php, добавив в него новые строки, сохраните программу в файле formtest2.php и попробуйте ее запустить. Результат запуска программы и введенное имя показаны на **рис. 12.2**.

![[Рис. 12.2. Программа formtest.php с обработкой данных.jpg]]
   >   **Рис. 12.2.** Программа formtest.php с обработкой данных

**Пример 12.2.** Обновленная версия formtest.php
```php
<?php // formtest2.php
  if (!empty(($_POST['name']))) $name = $_POST['name'];
  else $name = "(Not Entered)";

  echo <<<_END
  <html>
    <head>
      <title>Form Test</title>
    </head>
    <body>
    Your name is: $name<br>
    <form method="post" action="formtest2.php">
      What is your name?
      <input type="text" name="name">
      <input type="submit">
    </form>
    </body>
  </html>
_END;
?>
```

Изменения касаются двух строк в начале программы, где проверяется содержимое поля name в ассоциативном массиве **`$_POST`**, которое отправляется назад пользователю с помощью команды **`echo`**. Ассоциативный массив **`$_POST`** был рассмотрен в [[Доступ к MySQL с использованием PHP]], ==он включает в себя элемент для каждого поля HTMLформы==. В **примере 12.2** для вводимого имени использовалось поле **`name`**, а для отправки данных формы был избран метод **`POST`**, поэтому значение элемента name массива **`$_POST`** содержится в элементе массива **`$_POST['name']`**.

PHP-функция **`isset`** используется для проверки наличия значения у элемента **`$_POST['name']`**. Если значение не было отправлено, то программа присваивает переменной **`$name`** значение (Не введено). А если значение было отправлено, то оно сохраняется в этой переменной. После тега **`<body>`** была введена еще одна строка, предназначенная для отображения значения, сохраненного в переменной **`$name`**.


### Значения по умолчанию
---

Иногда представляется удобным предложить посетителям вашего сайта принять в веб-форме значения по умолчанию. Предположим, вы разместили на сайте по недвижимости приложение, представляющее собой калькулятор погашения кредита. При этом есть смысл ввести в него значения по умолчанию, скажем, 15 лет и 3 % годовых, чтобы пользователю осталось только ввести либо основную сумму заимствования, либо посильную для него сумму ежемесячных выплат. HTML-код для этих двух значений мог бы иметь вид, показанный в **примере 12.3**.

**Пример 12.3.** Установка значений по умолчанию
```php
<form method="post" action="calc.php"><pre>
Сумма заимствования <input type="text" name="principal">
  Количество лет <input type="text" name="years" value="15">
  Процент годовых <input type="text" name="interest" value="3">
                  <input type="submit">
</pre></form>
```

Обратите внимание на третий и четвертый элементы ввода данных. За счет указания значения для атрибута **`value`** в поле отображается значение по умолчанию, которое пользователи в дальнейшем смогут изменить, если у них появится такое желание. Задавая вполне обоснованные значения по умолчанию, можно добиться более дружелюбного поведения от своих веб-форм за счет минимизации необязательного ввода данных. Результат работы предыдущего кода показан на **рис. 12.3.** Разумеется, он был создан только для иллюстрации значений по умолчанию, и поскольку программа calc.php не была написана, форма после передачи данных выдаст сообщение об ошибке 404.

Значения по умолчанию используются также для скрытых полей, которые применяются тогда, когда вы хотите наряду с данными, введенными пользователем, отправить из веб-страницы в свою программу какую-нибудь дополнительную информацию. Скрытые поля будут рассмотрены в этой главе чуть позже.

![[Рис. 12.3. Использование значений по умолчанию для избранных полей формы.jpg]]
> **Рис. 12.3.** Использование значений по умолчанию для избранных полей                                   формы


### Типы элементов ввода данных
---

HTML-формы обладают завидной универсальностью, позволяя отправлять данные из довольно широкого диапазона различных типов элементов ввода, начиная с текстовых полей и текстовых областей и заканчивая флажками, переключателями и т. п.


#### Текстовое поле
---

Наверное, самым распространенным типом элемента, применяемого для ввода данных, является текстовое поле. Оно воспринимает широкий диапазон буквенно-цифрового текста и других символов в пределах однострочного окна. Типовой формат текстового поля для ввода информации имеет следующий вид:

```html
<input type="text" nаmе="имя" size="paзмep" maxlength="длина" value="значение">
```

Атрибуты **`name`** (*имя*) и **`value`** (*значение*) мы уже рассматривали, но здесь представлены еще два атрибута: **`size`** (*размер*) и **`maxlength`** (максимальная длина). Атрибут **`size`** определяет ширину поля в символах текущего шрифта, каким оно появится на экране, а **`maxlength`** определяет максимальное количество символов, которое пользователю разрешено вводить в это поле.

Единственными обязательными атрибутами являются **`type`** (тип), сообщающий браузеру ожидаемый тип элемента ввода данных, и name (имя), дающий вводимым данным имя, которое используется в дальнейшем для обработки поля после получения отправленной формы.


#### Текстовая область **`<textarea>`**
---

Когда нужно принять вводимые данные, превышающие по объему короткую строку текста, используется текстовая область. Она похожа на текстовое поле, но поскольку в нее разрешается вводить сразу несколько строк, имеет несколько иные атрибуты. Ее типовой формат выглядит следующим образом:

```html
<textarea name="имя" cols="ширина" rows="высота" wrap="тип"></textarea>
```

Первое, на что следует обратить внимание, — использование текстовой областью собственного тега **`<textarea>`**, который не является подвидом тега **`<input>`**, поэтому для него нужен закрывающий тег **`</textarea>`**, чтобы закрыть элемент ввода данных.

Если есть какой-нибудь текст, который нужно отобразить по умолчанию, то вместо использования атрибута, позволяющего задавать подобное значение, нужно поместить этот текст перед закрывающим тегом **`</textarea>`**, и тогда он будет отображен и сможет редактироваться пользователем:

```html
<textarea name="имя" соls="ширина" rows="высота" wrap="тип">
  Это текст, отображаемый по умолчанию.
</textarea>
```

Для управления шириной и высотой текстовой области используются атрибуты **`cols`** (*графы*) и **`rows`** (*строки*). Для задания размеров области в обоих атрибутах в качестве единицы измерения применяются пространства, занимаемые символом текущего шрифта. Если эти значения опустить, то будет создана текстовая область с размерами по умолчанию, которые зависят от используемого браузера, поэтому чтобы точно знать, в каком виде должна появиться ваша веб-форма, нужно всегда задавать значения этих атрибутов.

И наконец, с помощью атрибута **`wrap`** (*перенос*) можно управлять порядком переноса вводимого в область текста (и тем, как этот перенос будет отправляться на сервер). **В табл. 12.1** показаны доступные типы переноса. Если не указывать значение атрибута **`wrap`**, будет задействован мягкий перенос.

**Таблица 12.1.** Типы переноса, доступные в области ввода **`<textarea>`**
![[Таблица 12.1. Типы переноса, доступные в области ввода textarea.jpg]]


#### Флажки
---

Если пользователю нужно предложить выбор из нескольких вариантов данных, при котором он может остановиться на одном или нескольких вариантах, то для этого всегда используются флажки. Формат флажков выглядит следующим образом:

```html
<input type="checkbox" name ="имя" value="значение" checked="checked">
```

По умолчанию флажки имеют форму квадрата. Если в этот формат включается атрибут **`checked`** (*установлен*), флажок появляется в браузере в уже установленном виде. Строка, присваиваемая атрибуту, либо должна быть заключена в пару двойных или одинарных кавычек, либо быть значением **`"checked"`**, либо присваиваемого значения быть не должно (только **`checked`**). Если данный атрибут не включать в формат, флажок будет отображен в неустановленном виде. Примером задания такого флажка может послужить следующий код:

```html
Я согласен <input type="checkbox" name="agree">
```

Если пользователь не установит флажок, значение передано не будет. Но если флажок будет установлен, то для поля по имени **`agree`** будет передано значение **`on`**. Если вы предпочитаете вместо **`on`** отправить собственное значение (например, число 1), можно воспользоваться таким синтаксисом:

```html
Я согласен <input type="checkbox" name="agree" value="1">
```

В то же время если вы хотите при отправке формы предложить своим читателям информационный бюллетень, то может появиться желание отобразить флажок установленным по умолчанию:

```html
Подписаться? <input type="checkbox" name="news" checked="checked">
```

Если есть потребность в одновременном выборе группы элементов, то всем им нужно присвоить одинаковые имена. Но при этом нужно иметь в виду, что, если в качестве имени не будет передано имя массива, будет отправлен только последний отмеченный элемент формы. Код из **примера 12.4** позволяет пользователю выбрать любимые сорта мороженого (результат работы этого кода в браузере показан на **рис. 12.4**).

**Пример 12.4.** Предложение сделать выбор, установив сразу несколько флажков
```html
Ванильное <input type="checkbox" name="ice" value="Vanilla">
Шоколадное <input type="checkbox" name="ice" value="Chocolate">
Земляничное <input type="checkbox" name="ice" value="Strawberry">
```

![[Рис. 12.4. Использование флажков для быстрого выбора.jpg]]
   >   **Рис. 12.4.** Использование флажков для быстрого выбора

Если установлен только один флажок, например второй, то будет передан только этот элемент (полю с именем *`ice`* будет присвоено значение Шоколадное). Но если будут выбраны два и более флажка, будет отправлено только последнее значение, а все предыдущие будут проигнорированы.

Если нужно добиться исключающего поведения, то есть передачи только одного элемента, лучше воспользоваться переключателями (см. следующий подраздел), но чтобы позволить отправку сразу нескольких значений, необходимо немного изменить код HTML, как показано в **примере 12.5** (обратите внимание на добавление квадратных скобок (**`[]`**) после значений **`ice`**):

**Пример 12.5.** Отправка нескольких значений с помощью массива
```html
Ванильное <input type="checkbox" name="ice[]" value="Vanilla">
Шоколадное <input type="checkbox" name="ice[]" value="Chocolate">
Земляничное <input type="checkbox" name="ice[]" value="Strawberry">
```

Теперь, если при отправке формы установлены какие-нибудь из этих флажков, будет отправлен массив по имени **`ice`**, содержащий все выбранные значения. В любом случае можно извлечь в переменную либо отдельное значение, либо массив значений:

```php
$ice = $_POST['ice'];
```

Если поле **`ice`** было отправлено в виде отдельного значения, то переменная **`$ice`** будет содержать отдельную строку, например *Земляничное*. Но если в форме под именем **`ice`** был определен массив (как в **примере 12.5**), переменная **`$ice`** будет массивом и номера элементов этого массива будут номерами отправленных значений.

В **табл. 12.2** показаны семь возможных наборов значений, которые могут быть переданы этим HTML-кодом для одного, двух или трех установленных флажков. В каждом из случаев будет создаваться массив из одного, двух или трех элементов.

**Таблица 12.2.** Семь возможных наборов значений для массива **`Sice`**
![[Таблица 12.2. Семь возможных наборов значений для массива Sice.jpg]]

Если переменная **`$ice`** является массивом, то для отображения ее содержимого можно использовать очень простой PHP-код:

```php
foreach($ice as $item) echo "$item<br>";
```

В нем применяется стандартная PHP-конструкция **`foreach`**, осуществляющая последовательный перебор элементов массива **`$ice`** и передающая значение каждого элемента переменной **`$item`**, содержимое которой затем отображается с помощью команды **`echo`**. Тег **`<br>`** служит только для HTML-форматирования, чтобы после отображения каждого сорта осуществлялся перевод на новую строку.


#### Переключатели
---

Переключатели (**radio buttons** — *«кнопки радиоприемника»*) названы так по аналогии с утапливаемыми кнопками настройки на фиксированные частоты,
которые встречались на многих старых радиоприемниках, где любая ранее утопленная кнопка при нажатии другой кнопки возвращалась в первоначальную позицию. Переключатели применяются в тех случаях, когда нужно из двух и более вариантов выбрать и вернуть только один. Все кнопки группы должны использовать одно и то же имя, и поскольку возвращается только одно значение, массив передавать не требуется.

К примеру, если сайт предлагает выбор времени доставки покупок из вашего магазина, то для этого можно воспользоваться HTML-кодом, показанным в **`примере 12.6`** (результат его работы изображен на **`рис. 12.5`**). По умолчанию переключатели имеют форму окружностей.

**Пример 12.6.** Использование переключателей
```html
8.00-12.00<input type="radio" name="time" value="1">
12.00-16.00<input type="radio" name="time" value="2" checked="checked">
16.00-20.00<input type="radio" name="time" value="3">
```

![[Рис. 12.5. Выбор единственного значения с помощью переключателей.jpg]]
   >  **Рис. 12.5.** Выбор единственного значения с помощью переключателей

Здесь по умолчанию задается второй вариант: 12.00–16.00. Наличие значения по умолчанию гарантирует, что пользователь выберет хотя бы одно время доставки, которое затем может быть изменено на любое из двух оставшихся в соответствии с его предпочтениями. Если бы не был заранее выбран один из этих вариантов, пользователь мог бы забыть сделать свой выбор и для времени доставки не было бы передано никакого значения.


#### Скрытые поля
---

Иногда бывает удобно пользоваться скрытыми полями формы, чтобы получить возможность отслеживать состояние ее ввода. Например, может потребоваться узнать, отправлена форма или нет. Эти сведения можно получить, добавив к PHP-коду фрагмент кода HTML:

```php
echo '<input type="hidden" name="submitted" value="yes">'
```

Это простая PHP-инструкция **`echo`**, добавленная к полю ввода HTML-формы. Предположим, форма была создана вне программы и показана пользователю. При первом получении PHP-программой введенных данных эта строка кода не будет запущена, поэтому поля с именем **`submitted`** не будет. Программа PHP воссоздает форму, добавляя к ней поле ввода.

Поэтому когда пользователь отправит форму еще раз, PHP-программа получит ее с полем **`submitted`**, имеющим значение **`yes`**. Существование этого поля можно легко проверить с помощью следующего кода:

```php
if (isset($_POST['submitted']))
{...
```

Скрытые поля могут пригодиться также для хранения других сведений, например идентификационной строки сеанса, которая может быть создана для идентификации пользователя, и т. д.

>[!danger]
>Скрытые поля нельзя считать безопасными, поскольку они этим свойством не обладают. Код HTML, которым задаются эти поля, может быть легко просмотрен с помощью свойства браузера, позволяющего просматривать исходный код страницы. Злоумышленник может также создать сообщение, которое удаляет, добавляет или изменяет скрытое поле.


#### Тег **`<select>`**

Тег **`<select>`** позволяет создавать раскрывающийся список, предлагающий выбор одного или нескольких значений. Для его создания используется следующий синтаксис:

```html
<select name="имя" size="paзмep" multiple="multiple">
```

Атрибут **`size`** (*размер*) задает количество строк, отображаемых до разворачивания раскрывающегося списка. Нажатие кнопки отображения приводит к раскрытию списка, показывающего все варианты. Если применяется атрибут **`multiple`** (*множественный выбор*), из списка путем удерживания во время нажатия клавиши **Ctrl** могут быть выбраны сразу несколько вариантов. Чтобы спросить у пользователя, какой из пяти видов овощей он любит больше всего, можно воспользоваться кодом, предлагающим единичный выбор (**пример 12.7**).

**Пример 12.7.** Использование поля со списком
```html
Овощи
<select name="veg" size="1">
  <option value="Горох">Горох</option>
  <option value="Фасоль">Фасоль</option>
  <option value="Морковь">Морковь</option>
  <option value="Капуста">Капуста</option>
  <option value="Брокколи">Брокколи</option>
</select>
```

Этот HTML-код предлагает пять вариантов, на первый из которых, *Горох*, выпадает предварительный выбор (благодаря тому, что он стоит первым в списке). На **рис. 12.6** показан внешний вид раскрытого щелчком списка, после того как был выделен вариант *Морковь*. Если требуется выбрать другой вариант, предлагаемый по умолчанию (например, *Фасоль*), нужно воспользоваться атрибутом **`selected`**:

```html
<option selected="selected" value="Фасоль">Фасоль</option>
```

Можно также дать пользователям возможность выбрать несколько вариантов (**пример 12.8**).

**Пример 12.8.** Использование **`<select>`** с атрибутом **`multiple`**
```html
Овощи
<select name="veg" size="5" multiple="multiple">
  <option value="Горох">Горох</option>
  <option value="Фасоль">Фасоль</option>
  <option value="Морковь">Морковь</option>
  <option value="Капуста">Капуста</option>
  <option value="Брокколи">Брокколи</option>
</select>
```

![[Рис. 12.6. Создание раскрывающегося списка с помощью тега select.jpg]]
> ***Рис. 12.6.*** Создание раскрывающегося списка с помощью тега **`<select>`**

Код HTML не претерпел при этом значительных изменений, было лишь изменено значение атрибута size на 5 и добавлен атрибут multiple. Но теперь, судя по рис. 12.7, можно выбрать более одного варианта, удерживая при щелчке нажатой клавишу Ctrl. При желании можете отказаться от атрибута size, внешний вид от этого не изменится, но с более длинным списком может отображаться больше элементов, поэтому я рекомендую вам подобрать подходящее количество строк и придерживаться своего выбора. Я также советую не делать поля со списком, работающие в режиме множественного выбора, меньше двух строк в высоту, поскольку некоторые браузеры могут при этом некорректно отображать полосы прокрутки, необходимые для доступа к данным.

![[Рис. 12.7. Использование поля со списком с атрибутом multiple.jpg]]
   >   **Рис. 12.7.** Использование поля со списком с атрибутом **`multiple`**

При определении поля со списком, работающего в режиме множественного выбора, можно также воспользоваться атрибутом **`selected`** для задания при необходимости более одного заранее выбранного варианта.


#### Теги **`<label>`**
---
За счет использования тегов **`<label>`** можно сделать работу пользователя еще удобнее. В эти теги можно заключить элемент формы, обеспечивая его выбор щелчком на любой видимой части, содержащейся между открывающим и закрывающим тегами **`<label>`**.

Возвращаясь к примеру выбора времени доставки, можно позволить пользователю щелкать как на самом переключателе, так и на связанном с ним тексте:

```html
<label>8.00-12.00<input type="radio" name="time" value="1"></label>
```

При этом текст не будет подчеркиваться при прохождении над ним указателя мыши, как это происходит с гиперссылкой, но указатель мыши из текстового курсора будет превращаться в стрелку, показывая, что щелкать можно на всем тексте.


#### Кнопка отправки
---

Чтобы согласовать текст на кнопке отправки с разновидностью отправляемой формы, его можно изменить по своему усмотрению, воспользовавшись атрибутом **`value`**:

```html
<input type="submit" value="поиск">
```

Можно также заменить стандартный текст на кнопке выбранным вами графическим изображением, используя следующий код HTML:

```html
<input type="image" name="submit" src="image.gif">
```


### Обезвреживание введенных данных
---

Вернемся к программированию на PHP. Нелишне будет еще раз напомнить, что обработка данных, введенных пользователем, представляет большую угрозу для безопасности системы, и поэтому очень важно научиться с самого начала работать с ними предельно осторожно. На самом деле очистить введенные пользователем данные от потенциальных попыток взлома не так уж сложно, но сделать это совершенно необходимо.

Прежде всего нужно запомнить, что, невзирая на те ограничения, которые были наложены на HTML-форму в отношении типов элементов и размеров вводимых данных, взломщику ничего не стоит воспользоваться свойством браузера, позволяющим просмотреть исходный код страницы, извлечь форму и внести в нее изменения для отправки на ваш сайт вредоносного кода под видом введенных данных.

Поэтому не следует доверять какой-либо переменной, извлеченной из массива **`$_GET`** или **`$_POST`**, до тех пор пока она не пройдет обезвреживание. Если такую обработку не провести, пользователи могут предпринять попытку внедрить в данные код JavaScript, мешающий работе ваших сайтов, или даже добавить команды MySQL, подвергающие угрозе содержимое вашей базы данных.

Таким образом, нужно не только считывать введенные пользователем данные с помощью следующего кода:

```php
$variable = $_POST['user_input'];
```

но также воспользоваться еще одной или несколькими строками кода. К примеру, чтобы предотвратить внедрение escape-символов в строку, которая будет представлена MySQL, можно применить код, приведенный ниже, чтобы скрыть все необходимые символы, а также добавить кавычки в начало и конец строки. Следует напомнить, что эта функция учитывает текущий набор символов, используемый при подключении к MySQL, поэтому она должна быть использована с объектом подключения **PDO** (в данном случае **$pdo**) в соответствии с порядком, рассмотренным в [[Доступ к MySQL с использованием PHP]]:

```php
$variable = $connection->real_escape_string($variable);
```

>[!info]
>Следует помнить, что самым безопасным способом уберечь MySQL от попыток взлома является рассмотренное в [[Доступ к MySQL с использованием PHP]] использование указателей мест заполнения и предварительно определенных запросов. Если этот способ применять для всех обращений к MySQL, отпадет необходимость в обезвреживании данных, переносимых в базу данных или из этой базы. Но пользовательский ввод перед включением его в HTML обезвреживать все же придется.

Чтобы избавиться от нежелательных слеш-символов, нужно сначала проверить в PHP включение свойства «волшебные кавычки» (при котором кавычки выключаются путем добавления слеш-символов), и если оно включено, вызвать функцию **`stripslashes`**:

```php
if (get_magic_quotes_gpc())
$variable = stripslashes($variable);
```

А для удаления из строки любого HTML-кода используется такой код PHP:

```php
$variable = htmlentities ($variable);
```

Например, этот код интерпретируемого HTML **`<b>hi</b>`** заменяется строкой **`&lt;b&gt;hi&lt;/b&gt;`**, которая отображается как простой текст и не будет интерпретироваться как теги HTML.

И наконец, если нужно полностью очистить введенные данные от HTML, используется следующий код (но использовать его нужно до вызова функции **`htmlentities`**, которая заменяет все угловые скобки, используемые в качестве составляющих HTML-тегов):

```php
$variable = strip_tags($variable);
```

А пока вы не решите, какое именно обезвреживание требуется для вашей программы, рассмотрите две функции, показанные в **примере 12.9**, в которых собраны вместе все эти ограничения, обеспечивающие довольно высокий уровень безопасности.

**Пример 12.9.** Функции **`sanitizeString`** и **`sanitizeMySQL`**
```php
<?php
  function sanitizeString($var)
  {
    if (get_magic_quotes_gpc())
      $var = stripslashes($var);
    $var = strip_tags($var);
    $var = htmlentities($var);
    return $var;
  }

  function sanitizeMySQL($pdo, $var)
  {
    $var = $pdo->quote($var);
    $var = sanitizeString($var);
    return $var;
  }
?>
```

Добавьте этот код в последние строки своих программ, и тогда вы сможете вызвать его для обезвреживания всех вводимых пользователями данных:

```php
$var = sanitizeString($_POST['user_input']);
```

или, если имеется открытое подключение к MySQL и объект подключения **PDO** (который в данном случае называется **`$pdo`**):

```php
$var = sanitizeMySQL($connection, $_POST['user_input']);
```


## Пример программы
---

Рассмотрим, как происходит настоящее объединение PHP-программы с HTMLформой, для чего создадим программу convert.php, код которой показан в **примере 12.10.** Наберите этот код и проверьте его работу.

**Пример 12.10.** Программа перевода значений между шкалами Фаренгейта и Цельсия
```php
<?php // convert.php
  $f = $c = '';

  if (isset($_POST['f'])) $f = sanitizeString($_POST['f']);
  if (isset($_POST['c'])) $c = sanitizeString($_POST['c']);

  if (is_numeric($f))
  {
    $c = intval((5 / 9) * ($f - 32));
    $out = "$f &deg;f equals $c &deg;c";
  }
  elseif(is_numeric($c))
  {
    $f = intval((9 / 5) * $c + 32);
    $out = "$c &deg;c equals $f &deg;f";
  }
  else $out = "";

  echo <<<_END
<html>
  <head>
    <title>Temperature Converter</title>
  </head>
  <body>
    <pre>
      Enter either Fahrenheit or Celsius and click on Convert
        
      <b>$out</b>
      <form method="post" action="convert.php">
        Fahrenheit <input type="text" name="f" size="7">
           Celsius <input type="text" name="c" size="7">
                   <input type="submit" value="Convert">
      </form>
    </pre>
  </body>
</html>
_END;

function sanitizeString($var)
{
  if (get_magic_quotes_gpc())
    $var = stripslashes($var);
	$var = htmlentities($var);
	$var = strip_tags($var);
	return $var;
}
?>
```

Когда программа convert.php будет вызвана в браузере, результат будет похож на копию экрана, показанную на **рис. 12.8.**

![[Рис. 12.8. Работающая программа перевода температуры.jpg]]
   >   **Рис. 12.8.** Работающая программа перевода температур

Проанализируем эту программу. В первой строке инициализируются переменные **`$c`** **`$f`** на тот случай, если их значения не были отправлены программе. В следующих двух строках извлекаются значения либо из поля **`f`**, либо из поля **`с`**. Эти поля предназначены для ввода значений температуры по Фаренгейту или по Цельсию. Если пользователь введет оба значения, то значение по Цельсию будет проигнорировано, а переведено будет значение по Фаренгейту. В качестве меры безопасности в программе также используется новая функция **`sanitizeString`** из **примера 12.9.**

Итак, располагая либо отправленными значениями, либо пустыми строками в обеих переменных, `$f` и `$c`, следующая часть кода использует структуру `if... elseif...else`, которая сначала проверяет, имеет ли числовое значение переменная `$f`. Если эта переменная не имеет числового значения, проверяется переменная `$c`. Если переменная `$c` также не имеет числового значения, переменной `$out` присваивается пустая строка (к этому месту мы еще вернемся).

Если обнаружится, что у переменной `$f` есть числовое значение, переменной `$с` будет присвоено простое математическое выражение, которое переводит значение переменной `$f` из значения по Фаренгейту в значение по Цельсию. Для этого используется формула **`По_Цельсию`** = (5/9) ⋅ (**`По_Фаренгейту`** – 32). Затем переменной `$out` присваивается строковое значение, в котором содержится сообщение о результатах перевода.

Если же окажется, что у переменной **`$c`** есть числовое значение, выполнится обратная операция по переводу значения **`$c`** из значения по Цельсию в значение по Фаренгейту с присваиванием результата переменной **`$f`**. При этом используется следующая формула: **`По_Фаренгейту`** = (9/5) ⋅ **`По_Цельсию`** + 32. Как и в предыдущем разделе, переменной `$out` затем присваивается строковое значение, в котором содержится сообщение о результатах перевода.

Для превращения результатов перевода в целое число в обоих переводах вызывается PHP-функция **`intval`**. В этом нет особой необходимости, но результат выглядит лучше.

Теперь, после выполнения всех арифметических вычислений, программа выдает HTML-код, который начинается с базовых элементов **`head`** и **`title`** и содержит вводный текст, предшествующий отображению значения переменной **`$out`**. Если перевод температуры не осуществлялся, переменная **`$out`** будет иметь значение **`NULL`** и выводиться на экран ничего не будет, что, собственно, нам и нужно до тех пор, пока не будут отправлены данные формы. Но если перевод состоялся, переменная **`$out`** содержит результат, который отображается на экране.

Затем следует форма, настроенная на отправку данных самой программе (представленной парой двойных кавычек, чтобы файл мог быть сохранен с любым именем) с использованием метода **`POST`**. Внутри формы содержатся два поля для ввода температуры как по *Фаренгейту*, так и по *Цельсию*. Затем отображается кнопка отправки данных, имеющая надпись Перевести, и форма закрывается.

После вывода HTML-кода, закрывающего документ, программа завершается функцией **`sanitizeString`** из **примера 12.9.** Проверьте пример в работе, вводя в поля различные значения. А сможете ли вы подобрать значение, для которого температура как по *Фаренгейту*, так и по *Цельсию* будет одинакова?

>[!info]
>Все примеры, показанные в данной главе, используют для отправки данных формы метод **`POST`**. Я рекомендую применять именно его как наиболее подходящий и безопасный. Разумеется, формы можно легко перестроить под использование метода **`GET`**, тогда значения нужно будет извлекать не из массива **`$_POST`**, а из массива **`$_GET`**. Причины применения другого метода могут заключаться в предоставлении возможности создания закладок или непосредственных ссылок с другой страницы на результаты поиска.


## Усовершенствования, появившиеся в HTML5
---

Благодаря HTML5 разработчики могут воспользоваться рядом полезных усовершенствований по обработке форм, упрощающих работу как никогда ранее. В языке разметки появились новые атрибуты, окна выбора цвета, даты и времени, новые типы вводимых данных. На сайте caniuse.com вы всегда можете проверить, насколько широко та или иная функция реализована в различных браузерах.


### Атрибут **`autocomplete`**
---

Атрибут autocomplete можно применить либо к элементу **`<form>`**, либо к любому из типов элемента **`<input>`**: **`color`**, **`date`**, **`email`**, **`password`**, **`range`**, **`search`**, **`tel`**, **`text`** или **`url`**.

При включении атрибута **`autocomplete`** заново вызываются ранее введенные пользователем данные, которые автоматически вводятся в поля в качестве предложений. Это свойство также можно отключить путем переключения **`autocomplete`** на **`off`**.

В следующем коде показано, как включить **`autocomplete`** для всей формы, но отключить этот атрибут для конкретных полей (выделено полужирным шрифтом):

```html
<form action='myform.php' method='post' autocomplete='on'>
  <input type='text' name='username'>
  <input type='password' name='password' autocomplete='off'>
</form>
```


### Атрибут **`autofocus`**
---

Атрибут autofocus приводит к моментальной установке фокуса на элемент при загрузке страницы. Может быть применен к любому элементу **`<input>`**, **`<textarea>`** или **`<button>`**, например:

```html
<input type='text' name='query' autofocus='autofocus'>
```

Поскольку это свойство вызывает перемещение фокуса на элемент ввода данных, нажатие клавиши **Backspace** больше не позволяет пользователю вернуться на ранее просмотренную веб-страницу (хотя сочетания **Alt+←** и **Alt+→** по-прежнему можно применять для переходов по истории просмотров назад и вперед).

>[!info]
>Браузеры, использующие интерфейсы сенсорных экранов (Android или iOS), обычно игнорируют атрибут **`autofocus`**, оставляя за пользователем право прикоснуться к изображению элемента, чтобы он получил фокус. Если бы это было не так, то генерируемые включением этого атрибута увеличения элемента, фокусировки и появления экранной клавиатуры очень скоро стали бы сильно раздражать пользователей.


### Атрибут **`placeholder`**
---

Атрибут **`placeholder`** позволяет помещать в пустое поле ввода полезную подсказку, объясняющую пользователям, что именно им нужно ввести. Он применяется следующим образом:

```html
<input type='text' name='name' size='50' placeholder='Имя и фамилия'>
```

В поле ввода текст заполнителя будет показан в качестве подсказки до тех пор, пока пользователь не начнет набирать текст. В этот момент заполнитель исчезнет.


### Атрибут **`required`**
---

Атрибут **`required`** предназначен для обеспечения обязательного заполнения поля перед отправкой формы:

```html
<input type='text' name='creditcard' required='required'>
```

Когда браузер обнаружит попытку отправки формы с незаполненным обязательным вводом, пользователю будет выведено приглашение на заполнение поля.


### Атрибуты подмены **`formaction`**
---

С помощью этих атрибутов можно подменить настройки формы на поэлементной основе. К примеру, используя атрибут **`formaction`**, можно указать, что при нажатии кнопки отправки данные формы будут отправлены по URL-адресу, отличающемуся от того адреса, который указан в самой форме (исходный URLадрес действия и тот адрес, которым он подменяется, показаны полужирным шрифтом):

```html
<form *action='url1.php'* method='post'>
  <input type='text' name='field'>
  <input type='submit' *formaction='url2.php'*>
</form>
```

В HTML5 также появилась поддержка для атрибутов подмены **`formenctype`**, **`formmethod`**, **`formnovalidate`** и **`formtarget`**, которые могут использоваться точно так же, как и атрибут **`formaction`** для подмены одной из соответствующих их именам настроек.


### Атрибуты **`width`** и **`height`**
---

Используя эти новые атрибуты, можно изменить размеры вводимого изображения:

```html
<input type='image' src='picture.png' width='120' height='80'>
```


### Атрибуты **`min`** и **`max`**
---

Используя атрибуты **`min`** и **`max`**, можно указать для полей ввода минимальное и максимальное значения. Атрибуты применяются следующим образом:

```html
<input type='time' name='alarm' value='07:00' min='05:00' max='09:00'>
```

Затем браузер либо предложит для диапазона разрешенных значений селекторы «больше-меньше» («вверх-вниз»), либо просто запретит ввод значений, выходящих за пределы диапазона.


### Атрибут **`step`**
---

Атрибут **`step`** зачастую используется с атрибутами **`min`** и **`max`** и поддерживает пошаговый перебор значений, связанных с числами и датами, например:

```html
<input type='time' name='meeting' value='12:00'
min='09:00' max='16:00' step='3600'>
```

При пошаговом переборе значений дат и времени единицей измерения служит одна секунда.


### Атрибут **`form`**
---

В HTML5 элементы **`<input>`** уже не нужно помещать в элементы **`<form>`**, поскольку форму, к которой применяется элемент ввода, можно указать, предоставив этому элементу атрибут **`form`**. В следующем коде показана созданная форма, но с элементом ввода, находящимся за пределами тегов **`<form>`** и **`</form>`**:

```html
<form action='myscript.php' method='post' id='form1'>
</form>

<input type='text' name='username' form='form1'>
```

Чтобы иметь такую возможность, форме нужно присвоить идентификатор, воспользовавшись атрибутом **`id`**, и сослаться на этот идентификатор в атрибуте **`form`** элемента **`input`**. В наибольшей степени это пригодится для добавления скрытых полей ввода, поскольку вы не в состоянии контролировать, как именно поле расположено внутри формы, или для использования JavaScript с целью изменения форм и полей ввода в процессе обработки.


### Атрибут **`list`**
---

В HTML5 поддерживаются прикрепляемые списки для ввода данных, которые упрощают пользователям выбор из предопределенных списков. Их можно применить следующим образом:

```html
Выберите нужный сайт:
<input type='url' name='site' list='links'>

<datalist id='links'>
  <option label='Google' value='http://google.com'>
  <option label='Yahoo!' value='http://yahoo.com'>
  <option label='Bing' value='http://bing.com'>
  <option label='Ask' value='http://ask.com'>
</datalist>
```


### Тип ввода **`color`**
---

Тип ввода **`color`** вызывает на экран окно выбора цвета, позволяющее выбрать цвет простым щелчком кнопки мыши. Он используется следующим образом:

```html
Выберите цвет <input type='color' name='color'>
```


### Типы ввода **`number`** и **`range`**
---

Типы ввода **`number`** и **`range`** ограничивают ввод числом, а также, как вариант, допустимым диапазоном чисел, например:

```html
<input type='number' name='age'>
<input type='range' name='num' min='0' max='100' value='50' step='1'>
```


### Окно выбора даты и времени
---

При выборе типа ввода **`date`**, **`month`**, **`week`**, **`time`**, **`datetime`** или **`datetimelocal`** в поддерживающих это свойство браузерах будет появляться окно выбора, в котором пользователь может сделать свой выбор, как, например, в следующем коде, где вводится время:

```html
<input type='time' name='time' value='12:34'>
```

В следующей главе будет показано, как cookie и аутентификация применяются с целью сохранения и загрузки пользовательских предпочтений и как можно управлять всей сессией пользователя [[Cookie-файлы, сессии и аутентификация]].


## Вопросы
---

- [x] 1. Данные, содержащиеся в форме, могут быть отправлены с использованием одного из двух методов — **`POST`** или **`GET`**. Какие ассоциативные массивы применяются для передачи этих данных PHP-программе?
- [x] 2. Чем отличаются друг от друга текстовое поле и текстовая область?
- [x] 3. Если форма предлагает пользователю три варианта выбора, каждый из которых исключает все оставшиеся (то есть выбран может быть только один из вариантов), то какой тип элемента ввода данных нужно использовать в этом случае, если есть выбор между флажками и переключателями?
- [ ] 4. Как из веб-формы отправить группу значений из поля со списком, используя только одно имя поля?
- [x] 5. Как отправить данные поля формы, не отображая их на экране браузера?
- [x] 6. В какой HTML-тег можно поместить элемент формы, чтобы весь его текст или изображение превратились в область выбора этого элемента по щелчку кнопкой мыши?
- [ ] 7. Какая PHP-функция предназначена для преобразования кода HTML в формат, который может быть отображен на экране, но не может интерпретироваться браузером в качестве кода HTML?
- [x] 8. Какой атрибут формы может быть применен, чтобы помочь пользователям заполнить поля ввода?
- [x] 9. Как обеспечить обязательное заполнение поля ввода перед отправкой формы?

