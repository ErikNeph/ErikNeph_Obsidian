---
date of creation: 2024-06-07T21:33:00
tags:
  - Cookies
  - Sessions
  - Authentication
  - PHP
  - Developing
  - WebDeveloping
  - HTML
aliases:
  - PHP Cookie сессии и аутентификация
---
---
# Cookie-файлы, сессии и аутентификация


По мере укрупнения и усложнения вашего проекта будут возрастать и потребности в учете его пользователей. Даже если не предлагается ввод имени пользователя и пароля, то довольно часто возникает необходимость в хранении сведений о ходе текущей сессии пользователя и, возможно, в том, чтобы узнать его при возвращении на ваш сайт.

Подобное взаимодействие с пользователем поддерживается с помощью нескольких технологий: от простых браузерных **cookie** до обработки сессий и HTTP-аутентификации. В совокупности они позволяют настроить сайт на пользовательские предпочтения, обеспечивая комфортное путешествие по его страницам.


### Использование **cookie** в PHP
---

**`Cookie`** ==представляет собой элемент данных, который веб-сервер с помощью браузера сохраняет на жестком диске вашего компьютера.== Этот элемент может содержать практически любую буквенно-цифровую информацию (объемом не более 4 Кбайт) и может быть извлечен из вашего компьютера и возвращен на сервер. Чаще всего **cookie** используются для отслеживания хода сессий, обобщения данных нескольких визитов, хранения содержимого корзины покупателя, хранения сведений, необходимых для входа в систему, и т.д.

В силу своей закрытости cookie могут быть считаны только из создавшего их домена. Иными словами, если cookie, к примеру, был создан на oreilly.com, он может быть извлечен лишь веб-сервером, использующим этот домен. Это не позволяет другим сайтам получить доступ к сведениям, на владение которыми у них нет разрешения.

Из-за особенностей работы интернета многие элементы веб-страницы могут быть вставлены из нескольких доменов, каждый из которых может создавать свои собственные cookie. Они называются *сторонними* cookie. Чаще всего они создаются рекламными компаниями для отслеживания пользователей на нескольких сайтах или в аналитических целях.

Поэтому большинство браузеров позволяют пользователям отключать cookie либо от домена текущего сервера, либо от сторонних серверов, либо и от тех и от других. К счастью, большинство пользователей, отключающих cookie, делают это только в отношении сторонних сайтов.

Обмен cookie осуществляется во время передачи заголовков еще до того, как будет отправлен код HTML веб-страницы. Отправить cookie после передачи HTML-кода уже невозможно. Поэтому четкое планирование использования cookie приобретает особую важность. На **рис. 13.1** показан типичный диалог с передачей cookie в форме «запрос — ответ» между браузером и веб-сервером.

![[Рис. 13.1. Диалог браузера и сервера в режиме «запрос — ответ» с использованием cookie.jpg]]
> **Рис. 13.1.** Диалог браузера и сервера в режиме «запрос — ответ» с                        использованием cookie

В этом обмене данными показан браузер, получающий две страницы.

1. Браузер выдает запрос на извлечение главной страницы **index.html** с сайта http://www.webserver.com. В первом заголовке указывается файл, а во втором — сервер.
2. Когда веб-сервер на **webserver.com** получает эту пару заголовков, он возвращает несколько своих заголовков. Во втором заголовке определяется тип отправляемого содержимого (**text/html**), а в третьем отправляется cookie с именем **name**, имеющий значение **value**. И только после этого передается содержимое веб-страницы.
3. После того как браузер получит cookie, он должен возвращать его с каждым последующим запросом, сделанным в адрес сервера, создавшего cookie, пока у cookie не истечет срок действия или этот cookie не будет удален. Поэтому когда браузер запрашивает новую страницу **/news.html**, он также возвращает cookie name со значением **value**.
4. Поскольку на момент отправки **/news.html** cookie уже был установлен, сервер не должен заново посылать этот cookie и возвращает только запрошенную страницу.

>[!info]
>Cookie-файлы легко редактируются непосредственно из браузера с помощью встроенного инструмента разработчика или специальных расширений. Поэтому, исходя из того, что пользователи могут изменять значения cookie-файлов, в эти файлы не следует помещать такую информацию, как имя пользователя, иначе можно столкнуться с манипулированием вашим веб-сайтом неожиданным для вас образом. Cookie-файлы лучше использовать для сохранения данных вроде настроек на используемый язык или валюту.


### Установка cookie
---

Установка cookie в PHP осуществляется довольно просто. До передачи кода HTML нужно вызвать функцию **`setcookie`**, для чего используется следующий синтаксис (**табл. 13.1**):

```php
setcookie(name, value, expire, path, domain, secure, httponly);
```

**Таблица 13.1.** Параметры функции **`setcookie`**
![[Таблица 13.1. Параметры функции setcookie.jpg]]
![[Таблица 13.1. Параметры функции setcookie 2.jpg]]

Для создания cookie-файла по имени **`location`** со значением USA, к которому имеется доступ со всего веб-сервера текущего домена и который будет удален из браузерного кэша через семь дней, используется следующая строка кода:

```php
setcookie('location', 'USA', time() + 60 * 60 * 24 * 7, '/');
```


### Доступ к cookie
---

Для чтения значения cookie нужно просто обратиться к системному массиву **`$_COOKIE`**. Например, если нужно посмотреть, хранится ли на текущем браузере cookie по имени **`location`**, и если хранится, прочитать его значение, то используется следующая строка кода:

```php
if (isset($_COOKIE['location'])) $location = $_COOKIE['location'];
```

Учтите, что прочитать значение cookie можно только после того, как он был отправлен браузеру. Это означает, что при установке cookie его нельзя прочитать до тех пор, пока браузер не перезагрузит страницу (или не совершит какое-нибудь другое действие с доступом к cookie) с вашего сайта и не передаст cookie в ходе этого процесса обратно на сервер.


### Удаление cookie
---

ля удаления cookie его нужно повторно установить с настройкой даты истечения срока действия на прошедшее время. При этом важно, чтобы все параметры нового вызова функции setcookie, за исключением timestamp, в точности повторяли те параметры, которые указывались при создании cookie, в противном случае удаление не состоится. Поэтому для удаления ранее созданного cookie нужно воспользоваться следующей строкой кода:

```php
setcookie('location', 'USA', time() – 2592000, '/');
```

Поскольку указано уже прошедшее время, cookie будет удален. Здесь я использовал время, равное 2 592 000 с в прошлом (что соответствует одному месяцу). Это сделано в расчете на неправильную установку даты и времени на компьютере клиента. Можно также указать для значения cookie пустую строку (или значение FALSE), и тогда PHP автоматически установит для вас свое время на прошлое.


## HTTP-аутентификация
---

HTTP-аутентификация использует веб-сервер для управления пользователями и паролями при работе приложения. Ее можно применять в простых приложениях, требующих от пользователей входа в приложение, хотя для многих приложений нужны особые меры или соблюдение более строгих требований безопасности, для чего следует обратиться к другим технологическим приемам.

Чтобы воспользоваться HTTP-аутентификацией, PHP отправляет заголовок запроса, инициирующий аутентификационный диалог с браузером. Чтобы эта технология заработала, на сервере должно быть включено соответствующее свойство, но скорее всего, в силу своей высокой востребованности это свойство на вашем сервере уже включено.

>[!info]
>Хотя, как правило, аутентификационный модуль HTTP устанавливается вместе с Apache, это еще не означает, что он установлен на используемом вами сервере. Поэтому при попытке запуска представленных здесь примеров может быть сгенерирована ошибка и выдано сообщение о том, что это свойство недоступно. В таком случае нужно либо установить соответствующий модуль и изменить для загрузки модуля файл конфигурации, либо попросить своего системного администратора внести все эти изменения.

Пользователи при вводе в браузер URL-адреса или при переходе по ссылке на страницу видят окно с требованием пройти аутентификацию Требуется аутентификация, в котором выводится приглашение заполнить два поля: для имени пользователя и пароля (на **рис. 13.2** показано, как это выглядит в браузере Firefox). Код, обеспечивающий аутентификацию, приведен в **примере 13.1.**

**`Пример 13.1.`** PHP-аутентификация
```php
<?php
  if (isset($_SERVER['PHP_AUTH_USER']) &&
  	  isset($_SERVER['PHP_AUTH_PW']))
  {
    echo "Welcome User: " . htmlspecialchars($_SERVER['PHP_AUTH_USER']) .
         " Password: "    . htmlspecialchars($_SERVER['PHP_AUTH_PW']);
  }
  else
  {
    header('WWW-Authenticate: Basic realm="Restricted Area"');
    header('HTTP/1.0 401 Unauthorized');
    die("Please enter your username and password");
  }
?>
```

![[Рис. 13.2. Приглашение войти в систему в режиме HTTP-аутентификации.jpg]]
> **Рис. 13.2.** Приглашение войти в систему в режиме HTTP-аутентификации

Сначала программа ищет значения конкретных элементов массива: **`$_SERVER['PHP_AUTH_USER']`** и **`$_SERVER['PHP_AUTH_PW']`**. В этих элементах в случае их существования содержатся имя пользователя и пароль, введенные пользователем при приглашении пройти аутентификацию.

>[!info]
>Обратите внимание, что значения, возвращаемые в массиве **`$_SERVER`**, прежде чем выводиться на экран, обрабатываются функцией **`htmlspecialchars`**. Дело в том, что эти значения вводятся пользователем и из-за этого не могут вызывать доверие, поскольку злоумышленником может быть предпринята попытка межсайтового выполнения сценария путем добавления во вводимую информацию символов HTML и каких-либо иных символов. Функция преобразует подобный ввод в безвредное HTML-содержимое.

Если какое-нибудь из значений отсутствует, то пользователь еще не прошел аутентификацию и появляющееся окно с приглашением, показанное на **рис. 13.2**, отображается с выдачей следующего заголовка, составной частью которого является имя защищенного раздела — Basic realm:

```HTML
WWW-Authenticate: Basic realm="Restricted Section"
```

Если пользователь заполнит поля, PHP-программа будет запущена снова с самого начала. Но если пользователь нажмет кнопку **Отмена**, программа перейдет к следующим двум строкам, которые отправят такой заголовок и сообщение об ошибке:

```html
HTTP/1.0 401 Unauthorized
```

Инструкция **`die`** выведет следующий текст: Пожалуйста, введите имя пользователя и пароль (**рис. 13.3**).

![[Рис. 13.3. Результат нажатия кнопки Отмена.jpg]]
   >   **Рис. 13.3.** Результат нажатия кнопки Отмена

>[!info]
>После прохождения пользователем аутентификации заставить появиться диалоговое окно для аутентификации уже не удастся до тех пор, пока пользователь не закроет и не откроет снова все окна браузера, поскольку браузер будет постоянно возвращать PHP-программе имя пользователя и пароль. Чтобы при изучении этого раздела испытать все возможные режимы работы, может потребоваться несколько раз закрыть и снова открыть ваш браузер. Проще всего добиться желаемого результата, открыв для запуска этих примеров новое частное или анонимное окно, и тогда не придется закрывать весь браузер.

Теперь проверим допустимость пользовательского имени и пароля. Для добавления этой проверки вносить большие изменения в код **примера 13.1** не придется: нам нужно лишь изменить прежнее приветственное сообщение и превратить его в проверку правильности имени пользователя и пароля, за которой последует приветствие. Неудачная аутентификация вызовет отправку сообщения об ошибке (**пример 13.2**).

**Пример 13.2.** PHP-аутентификация с проверкой вводимой информации
```php
<?php
  $username = 'admin';
  $password = 'letmein';

  if (isset($_SERVER['PHP_AUTH_USER']) &&
      isset($_SERVER['PHP_AUTH_PW']))
  {
    if ($_SERVER['PHP_AUTH_USER'] === $username &&
        $_SERVER['PHP_AUTH_PW']   === $password)
          echo "You are now logged in";
    else die("Invalid username/password combination");
  }
  else
  {
    header('WWW-Authenticate: Basic realm="Restricted Area"');
    header('HTTP/1.0 401 Unauthorized');
    die ("Please enter your username and password");
  }
?>
```

При сравнении имен пользователей и паролей используется не оператор равенства (**`==`**), а оператор тождественности (**`===`**). Дело в том, что нами ведется проверка на *полное соответствие* одного значения другому. Например **`'0e123' == '0e456'`**, и это неподходящее соответствие ни для имени пользователя, ни для пароля.

В предыдущем примере **`0е123`** равно нулю, умноженному на 10, возведенному в 123-ю степень, что в результате дает ноль, а **`0е456`** равно нулю, умноженному на 10, возведенному в 456-ю степень, что также в результате равно нулю. Поэтому при использовании оператора **`==`** они будут совпадать, так как оба их значения равны нулю, то есть результат сравнения будет **`true`**. Но оператор **`===`** говорит, что две части должны быть идентичными во всем, а так как эти две строки разные, тест вернет значение **`false`**.

Теперь у нас есть механизм аутентификации пользователей, но только для одного имени пользователя и пароля. К тому же пароль появляется в файле PHP в виде простого текста, и если кому-нибудь удастся взломать ваш сервер, он тут же вскроет и пароль. Поэтому рассмотрим более подходящий способ работы с именами пользователей и паролями.


### Сохранение имен пользователей и паролей
---

Безусловно, самым естественным способом сохранения имен пользователей и паролей будет задействование MySQL. Но опять-таки, хранить пароли в виде простого текста не хочется, поскольку если база данных будет взломана, сайт подвергнется опасности. Вместо этого будет использован тонкий прием с применением так называемой *односторонней функции.*

Функции этого типа просты в использовании и способны превращать строку текста в строку, напоминающую набор произвольных символов. Односторонние функции невозможно применять в обратном направлении, поэтому производимая ими выходная информация может безопасно храниться в базе данных и ее похититель ничего не узнает об используемых паролях.

В предыдущем издании этой книги для обеспечения безопасности данных рекомендовалось использовать алгоритм хеширования MD5. Но времена меняются, и теперь считается, что алгоритм MD5 легко поддается взлому, и поэтому его применение не обеспечивает должной безопасности. И даже рекомендуемый ранее ему на замену алгоритм **SHA-1** может быть также, по-видимому, взломан.

Поэтому теперь, когда практически повсеместно минимальным стандартом является использование PHP 5.5, я перешел к использованию встроенной функции хеширования, которая проводит обработку куда более безопасно и аккуратно.

В прежние времена для безопасного сохранения пароля к нему нужно было добавлять произвольные данные, то есть добавлять к паролю дополнительные символы, которые не вводились пользователем (чтобы его завуалировать еще больше). Затем нужно было пропускать полученный результат через одностороннюю функцию, чтобы превратить его в, казалось бы, случайный набор символов, трудно поддающийся взлому.

Например, выполнение следующего кода (который при нынешнем быстродействии и эффективности современных графических процессоров уже не обеспечивает должного уровня безопасности):

```php
echo hash('ripemd128', 'saltstringmypassword');
```

приведет к выводу на экран следующего значения:

```php
9eb8eb0584f82e5d505489e6928741e7
```

Следует запомнить, что подобный метод не рекомендуется использовать ни в коем случае. Считайте это примером того, как *не нужно* делать, поскольку это небезопасно. И вместо этого, пожалуйста, прочтите следующие разделы.


### Функция **`password_hash`**
---

Начиная с версии 5.5, в PHP появился куда более эффективный способ добавления произвольных данных с созданием хешированного пароля: применение функции **`password_hash`**. Чтобы заставить функцию выбрать наиболее безопасную на данный момент функцию хеширования, следует в качестве ее второго (обязательного) аргумента указать **`PASSWORD_DEFAULT`**. Функция **`password_hash`** выберет также для каждого пароля произвольные данные. (Не пытайтесь добавить от себя дополнительные произвольные данные, поскольку это может подорвать безопасность алгоритма.) Следующий код:

```php
echo password_hash("mypassword", PASSWORD_DEFAULT);
```

возвратит показанную ниже строку, включающую произвольные данные и всю информацию, необходимую для проверки допустимости пароля:
`$2y$10$k0YljbC2dmmCq8WKGf8oteBGiXlM9Zx0ss4PEtb5kz22EoIkXBtbG`

>[!info]
>Разрешая PHP выбрать для вас алгоритм хеширования, нужно позволить возвращаемому хешу со временем увеличиваться в размере по мере повышения уровня безопасности. Разработчики PHP рекомендуют сохранять хеши в поле базы данных, способном расширяться как минимум до 255 символов (даже если сейчас средней используемой длиной является 60–72 символа). При желании можно вручную выбрать алгоритм **BCRYPT**, чтобы гарантированно ограничить длину хеш-строки 60 символами, для чего использовать в качестве второго аргумента функции константу **PASSWORD_BCRYPT**. Но я не рекомендую делать это без особо веских причин.

Для дальнейшего определения порядка вычисления хешей можно указать в виде необязательного третьего аргумента параметры, например затраты или объем процессорного времени, распределяемого на хеширование (чем больше времени, тем выше безопасность, но медленнее сервер). По умолчанию параметр затрат определяется числом 10, которое является минимально возможным при использовании алгоритма **BCRYPT**.

Чтобы не отпугнуть вас излишней информацией, ограничусь тем минимумом, который необходим для безопасного сохранения хешей паролей без чрезмерных затрат, поэтому за более подробными сведениями о доступных вариантах можно при желании обратиться к соответствующей документации, находящейся по адресу http://php.net/password-hash. Вы можете даже выбрать собственные подмешиваемые произвольные данные, хотя, начиная с версии PHP 7.0, такой прием не приветствуется из-за недостаточной безопасности, если только вы не знаете наверняка, что делаете, как в случае с WordPress, который по-прежнему обрабатывает свои дополнительные произвольные данные.


### Функция **`password_verify`**
---

Для проверки соответствия пароля хешу следует воспользоваться функцией **`password_verify`**, передав ей строку пароля, только что введенную пользователем, и значение сохраненного хеша для пользовательского пароля (как правило, извлекаемое из вашей базы данных).

Итак, при условии, что ваш пользователь ранее ввел весьма примитивный с точки зрения безопасности пароль **`mypassword`** и у вас уже есть строка хеша этого пароля (с того времени, когда пользователь создал свой пароль), сохраненная в переменной **`$hash`**, вы можете проверить их взаимное соответствие:

```php
if (password_verify("mypassword", $hash))
  echo "Подходящий";
```

Если для хеша предоставлен правильный пароль, функция **`password_verify`** возвращает значение **`TRUE`** и показанная здесь инструкция **`if`** выведет на экран слово Подходящий. Если пароль не будет соответствовать хешу, будет возвращено значение **`FALSE`**, и вы попросите пользователя повторить попытку.


## Пример программы
---

Посмотрим на совместную работу этих функций в сочетании с MySQL. Сначала нужно создать новую таблицу для хранения хешей паролей, поэтому наберите код программы, показанной в **примере 13.3**, и сохраните его в файле с именем `setupusers.php` (или загрузите этот файл с GitHub, https://github.com/RobinNixon/lpmj6), а затем откройте этот файл в своем браузере.

**Пример 13.3.** Создание таблицы **`users`** и добавление к ней двух учетных записей
```php
<?php //setupusers.php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (\PDOException $e)
  {
    throw new \PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query = "CREATE TABLE users (
    forename VARCHAR(32) NOT NULL,
    surname  VARCHAR(32) NOT NULL,
    username VARCHAR(32) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL
  )";

  $result = $pdo->query($query);

  $forename = 'Bill';
  $surname  = 'Smith';
  $username = 'bsmith';
  $password = 'mysecret';
  $hash     = password_hash($password, PASSWORD_DEFAULT);
  
  add_user($pdo, $forename, $surname, $username, $hash);

  $forename = 'Pauline';
  $surname  = 'Jones';
  $username = 'pjones';
  $password = 'acrobat';
  $hash     = password_hash($password, PASSWORD_DEFAULT);
  
  add_user($pdo, $forename, $surname, $username, $hash);

  function add_user($pdo, $fn, $sn, $un, $pw)
  {
    $stmt = $pdo->prepare('INSERT INTO users(forename,surname,username,password) VALUES(?,?,?,?)');

    $stmt->bindParam(1, $fn, PDO::PARAM_STR,  32);
    $stmt->bindParam(2, $sn, PDO::PARAM_STR,  32);
    $stmt->bindParam(3, $un, PDO::PARAM_STR,  32);
    $stmt->bindParam(4, $pw, PDO::PARAM_STR, 255);

    $stmt->execute([$fn, $sn, $un, $pw]);
  }
?>
```

Программа создаст в вашей базе данных **`publications`** (или в той базе данных, на которую вы настроились в файле `login.php` в [[Доступ к MySQL с использованием PHP]]) таблицу **`users`**. В этой таблице будут созданы два пользователя — **`Bill Smith`** и **`Pauline Jones`** с именами пользователей и паролями **`bsmith`** — **`mysecret`** и **`pjones`** — **`acrobat`** соответственно.

Теперь, используя данные, имеющиеся в этой таблице, мы можем модифицировать код **примера 13.2** для вполне приемлемой аутентификации пользователей. Необходимый для этого код показан в **примере 13.4**. Наберите этот код или загрузите соответствующий файл с сайта https://github.com/RobinNixon/lpmj6, сохраните его в файле `authenticate.php` и вызовите эту программу в своем браузере.

**Пример 13.4.** PHP-аутентификация с использованием MySQL
```php
<?php // authenticate.php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (\PDOException $e)
  {
    throw new \PDOException($e->getMessage(), (int)$e->getCode());
  }

  if (isset($_SERVER['PHP_AUTH_USER']) &&
      isset($_SERVER['PHP_AUTH_PW']))
  {
    $un_temp = sanitise($pdo, $_SERVER['PHP_AUTH_USER']);
    $pw_temp = sanitise($pdo, $_SERVER['PHP_AUTH_PW']);
    $query   = "SELECT * FROM users WHERE username=$un_temp";
    $result  = $pdo->query($query);

    if (!$result->rowCount()) die("User not found");

    $row = $result->fetch();
    $fn  = $row['forename'];
    $sn  = $row['surname'];
    $un  = $row['username'];
    $pw  = $row['password'];
      
    if (password_verify(str_replace("'", "", $pw_temp), $pw))
      echo htmlspecialchars("$fn $sn : Hi $fn,
        you are now logged in as '$un'");
    else die("Invalid username/password combination");
  }
  else
  {
    header('WWW-Authenticate: Basic realm="Restricted Area"');
    header('HTTP/1.0 401 Unauthorized');
    die ("Please enter your username and password");
  }
  
  function sanitise($pdo, $str)
  {
    $str = htmlentities($str);
    return $pdo->quote($str);
  }
?>
```

>[!info]
>При HTTP-аутентификации применение функции password_verify с паролями, прошедшими хеширование с помощью алгоритма BCRYPT при используемом по умолчанию значении затрат, равном 10, приведет к замедлению примерно в 80 мс. Это замедление послужит барьером для атакующих, не позволяющим им предпринять попытку взлома пароля на максимальной скорости. Из-за этого замедления HTTP-аутентификация не считается приемлемым решением для слишком нагруженных сайтов, где вы, наверное, отдадите предпочтение использованию сессий (которые рассматриваются в следующем разделе).

Рост объема кода в некоторых приводимых в книге примерах, наверное, вполне соответствует вашим ожиданиям. Но переживать по этому поводу не стоит. В настоящий момент практический интерес для вас должны представлять только те строки, которые выделены полужирным шрифтом. Они начинаются с присваивания значений двум переменным — **`$un_temp`** и **`$pw_temp`** — с использованием отправленного имени пользователя и пароля, пропущенных через функцию **`sanitize`**, чтобы изменить любые символы HTML на безопасные символьные строки с помощью функции **`htmlentities`** и добавить одинарные кавычки в начало и конец строки с помощью метода quote.

Затем выдается запрос к MySQL на поиск пользователя с именем **`$un_temp`**, и если будет возвращен результат, значение его первой строки присваивается переменной **`$row`**. Поскольку имя пользователя уникально, возвращена будет только одна строка.

Теперь остается лишь сравнить значение хеша, хранящееся в базе данных в четвертой графе и находящееся в **`$row[password]`**, и предыдущее хеш-значение, вычисленное функцией **`password_hash`** при создании пользователем пароля.

Если хеш и только что предоставленный пользователем пароль проходят проверку, функция **`password_verify`** возвращает **`TRUE`** и выдается строка приветствия, в которой содержится обращение к пользователю по его настоящему имени **(рис. 13.4)**. В противном случае выдается сообщение об ошибке. Поскольку мы очистили пароль при помощи quote, то когда вызываем **`password_verify`**, сначала при помощи **`str_replace`** удаляются преобразующие одинарные кавычки.

![[Рис. 13.4. Аутентификация пользователя Bill Smith прошла успешно.jpg]]
> **Рис. 13.4.** Аутентификация пользователя Bill Smith прошла успешно

Вы можете самостоятельно испытать эту программу в работе, вызвав ее в браузере и набрав имя пользователя **`bsmith`** и пароль **`mysecret`** (или набрав пару **`pjones`** и **`acrobat`**), то есть те значения, которые были сохранены в базе данных программой из **примера 13.3.**

>[!info]
>Обрабатывая входные данные сразу же после их появления, вы заблокируете любые атаки, которые проводятся путем внедрения вредоносного HTML-, JavaScript- или MySQL-кода, еще до того, как они будут предприняты, и тогда не придется обезвреживать эти данные еще раз. Если пользователь, к примеру, задает в пароле такие символы, как **`<`** или **`&`**, функция **`htmlentities`** превратит их в последовательности символов **`&lt`**; или **`&amp`**;. Но пока ваш код будет разрешать получаемым в конечном итоге строкам быть длиннее предоставленной ширины ввода и пока вы неизменно будете пропускать пароли через эту обработку, все будет в порядке.


## Использование сессий
---

Поскольку ваша программа не может сообщить о том, какие значения были присвоены переменным в других программах, или даже о том, какие значения были присвоены переменным при ее предыдущем запуске, иногда приходится отслеживать действия пользователя, переходящего со страницы на страницу. Это можно сделать за счет установки в форме скрытых полей, как было показано в [[Доступ к MySQL с использованием PHP]], и проверки значений этих полей после отправки формы, но PHP предоставляет более простое, безопасное и действенное решение — *сессии*. *Сессии* ==— это группы переменных, которые хранятся на сервере, но относятся только к текущему пользователю.== Чтобы обеспечить обращение нужных пользователей к нужным переменным, для уникальной идентификации этих пользователей PHP сохраняет файлы cookie на пользовательских браузерах.

>[!info]
>В 2009 году компания Google объявила о том, что работает над постепенным отказом от сторонних файлов cookies в своем браузере в рамках проекта Privacy Sandbox. Без сомнения, этому примеру последуют и другие браузеры, в первую очередь Opera и Microsoft Edge, опирающиеся на кодовую базу Google Chrome. Однако это привлекает внимание регулирующих органов, поскольку некоторые компании предполагают, что это может привести к еще большим расходам средств на экосистему Google, так что реализация этого проекта может измениться. Все отчетливее начинает проявляться недовольство по поводу предупреждений об использовании cookie практически на всех посещаемых сайтах, поэтому их дни сочтены. Если пояснить вкратце, то Google намеревается разделить пользователей на группы примерно по 1000 человек, имеющих схожие интересы при использовании браузера и продуктов, так, чтобы невозможно было однозначно идентифицировать или отследить кого-либо. Однако окончательное удаление файлов cookie может вызвать проблемы с вашим кодом. Поэтому рекомендую следить за развитием событий в этой области: они могут повлиять на то, как пользователи взаимодействуют с разрабатываемым вами кодом.

Эти cookie имеют значение только для веб-сервера и не могут быть использованы для извлечения какой-либо информации о пользователе. Вы можете спросить о том, как быть с теми пользователями, которые отключили cookie. В наши дни каждый, кто отключает cookie, не может рассчитывать на получение всей полноты предоставляемой информации, и если обнаружится, что у пользователя отключены cookie, нужно, наверное, проинформировать его, что при желании в полной мере воспользоваться преимуществами использования вашего сайта им нужно включить cookie, а не пытаться каким-то образом обойти их использование во избежание возникновения проблем безопасности.


### Начало сессии
---

Чтобы инициировать работу сессии, нужно перед выводом на экран любого кода HTML вызвать PHP-функцию **`session_start`** точно так же, как это делалось при отправке cookie в процессе обмена заголовками. Затем, чтобы приступить к сохранению переменных сессии, им нужно присвоить значения как элементам массива **`$_SESSION`**:

```php
$_SESSION['имя_переменной'] = $переменная_со_значением;
```

При последующих запусках программы их значения можно будет снова прочитать, воспользовавшись таким кодом:

```php
$имя_переменной = $_SESSION['имя_переменной'];
```

Предположим, у вас есть приложение, которому всегда нужен доступ к имени и фамилии каждого пользователя в том виде, в каком они сохранены в базе данных в таблице **`users`**, созданной совсем недавно. Выполним еще одну модификацию программы `authenticate.php` из **примера 13.4**, чтобы инициировать работу сессии сразу же после идентификации пользователя.

Все необходимые изменения показаны в **примере 13.5**. Единственное отличие касается раздела **`if (password_verify…`**, который теперь начинается с открытия сессии и сохранения в ней четырех переменных. Наберите код этой программы (или измените код **`примера 13.4`**) и сохраните его в файле `authenticate2.php`. Но пока не запускайте эту программу в браузере, поскольку нужно будет создать еще и вторую программу.

**Пример 13.5.** Открытие сессии после успешной аутентификации
```php
<?php // authenticate2.php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (\PDOException $e)
  {
    throw new \PDOException($e->getMessage(), (int)$e->getCode());
  }

  if (isset($_SERVER['PHP_AUTH_USER']) &&
      isset($_SERVER['PHP_AUTH_PW']))
  {
    $un_temp = sanitise($pdo, $_SERVER['PHP_AUTH_USER']);
    $pw_temp = sanitise($pdo, $_SERVER['PHP_AUTH_PW']);
    $query   = "SELECT * FROM users WHERE username=$un_temp";
    $result  = $pdo->query($query);

    if (!$result->rowCount()) die("User not found");

    $row = $result->fetch();
    $fn  = $row['forename'];
    $sn  = $row['surname'];
    $un  = $row['username'];
    $pw  = $row['password'];

    if (password_verify(str_replace("'", "", $pw_temp), $pw))
    {
      session_start();

      $_SESSION['forename'] = $fn;
      $_SESSION['surname']  = $sn;

      echo htmlspecialchars("$fn $sn : Hi $fn,
        you are now logged in as '$un'");
      die ("<p><a href='continue.php'>Click here to continue</a></p>");
    }
    else die("Invalid username/password combination");
  }
  else
  {
    header('WWW-Authenticate: Basic realm="Restricted Area"');
    header('HTTP/1.0 401 Unauthorized');
    die ("Please enter your username and password");
  }

  function sanitise($pdo, $str)
  {
    $str = htmlentities($str);
    return $pdo->quote($str);
  }
?>
```

К программе также добавлена ссылка Щелкните здесь для продолжения с URLадресом `continue.php`. Она будет использована для иллюстрации того, как сессия будет перенесена на другую программу или веб-страницу PHP-программы. Поэтому создайте файл `continue.php`, набрав и сохранив в нем программу из **примера 13.6.**

**`Пример 13.6.`** Извлечение переменных сессии
```php
<?php // continue.php
  session_start();

  if (isset($_SESSION['forename']))
  {
    $forename = htmlspecialchars($_SESSION['forename']);
    $surname  = htmlspecialchars($_SESSION['surname']);

    echo "Welcome back $forename.<br>
          Your full name is $forename $surname.<br>";
  }
  else echo "Please <a href='authenticate2.php'>Click Here</a> to log in.";
?>
```

Теперь можно вызвать в браузере `authenticate2.php`, после появления приглашения ввести имя пользователя **`bsmith`** и пароль **`mysecret`** (или **`pjones`** и **`acrobat`**) и щелкнуть на ссылке для загрузки программы `continue.php.` Когда браузер вызовет эту программу, появится результат, аналогичный показанному на **рис. 13.5.**

![[Рис. 13.5. Поддержка пользовательских данных с помощью сессий.jpg]]
   >   **Рис. 13.5.** Поддержка пользовательских данных с помощью сессий

Сессии искусно ограничивают одной программой весь объемный код, необходимый для аутентификации и регистрации пользователя. После аутентификации пользователя и создания сессии весь остальной программный код действительно упрощается. Нужно лишь вызвать функцию **`session_start`** и найти в массиве **`$_SESSION`** любые переменные, к которым нужен доступ.

В **примере 13.6** быстрой проверки наличия значения у элемента **`$_SESSION['forename']`** вполне достаточно для того, чтобы узнать об аутентификации текущего пользователя, ==потому что переменные сессии хранятся на сервере (в отличие от cookie, которые хранятся на машине браузера) и им можно доверять.==

Если элементу **`$_SESSION['forename']`** значение присвоено не было, значит, активная сессия отсутствует, и поэтому последняя строка кода в **`примере 13.6`** перенаправляет пользователей на страницу регистрации на сайте, которая находится в программе `authenticate2.php`.


### Завершение сессии
---

Обычно, когда пользователю нужно уйти с вашего сайта, наступает момент завершения работы сессии, для чего, как показано в **примере 13.7**, можно воспользоваться функцией **`session_destroy`**. В этом примере предоставляется полезная функция для полного уничтожения сессии, выхода пользователя и очистки всех переменных сессии.

**Пример 13.7.** Полезная функция уничтожения сессии и ее данных
```php
<?php
function destroy_session_and_data()
{
   session_start();
   $_SESSION = array();
   setcookie(session_name(), '', time() - 2592000, '/');
   session_destroy();
}
?>
```

Чтобы увидеть этот код в действии, можно модифицировать программу `continue.php`, как показано в **примере 13.8.**

**Пример 13.8.** Извлечение переменных сессии перед ее уничтожением
```php
<?php // continue.php = version 2
  session_start();

  if (isset($_SESSION['forename']))
  {
    $forename = $_SESSION['forename'];
    $surname  = $_SESSION['surname'];

    destroy_session_and_data();
	
    echo htmlspecialchars("Welcome back $forename");
		echo "<br>";
    echo htmlspecialchars("Your full name is $forename $surname.");
  }
  else echo "Please <a href='authenticate.php'>click here</a> to log in.";

  function destroy_session_and_data()
  {
    $_SESSION = array();
    setcookie(session_name(), '', time() - 2592000, '/');
    session_destroy();
  }
?>
```

При первом переходе из `authenticate2.php` в `continue.php` будут выведены все переменные сессии. Но если после этого нажать в браузере кнопку обновления страницы, в результате предшествующего этому вызова функции **`destroy_session_and_data`** сессия уже будет уничтожена и появится приглашение вернуться на страницу регистрации.


### Установка времени ожидания
---

Есть и другие причины, по которым может потребоваться самостоятельное закрытие пользовательской сессии, например, если пользователь забыл зарегистрироваться или проигнорировал этот процесс и нужно, чтобы программа закрыла его сессию ради собственной безопасности. Это можно сделать, установив время ожидания, по истечении которого, если не предпринять активных действий, произойдет автоматическое завершение работы.

Для этого используется функция **`ini_set`**. В данном примере время ожидания устанавливается ровно на сутки (буквы `gc` означают сбор мусора):

```php
ini_set('session.gc_maxlifetime', 60 * 60 * 24);
```

Если нужно узнать текущее время ожидания, его можно отобразить, воспользовавшись следующим кодом:

```php
echo ini_get('session.gc_maxlifetime');
```


### Безопасность сессии
---

Все мои прежние заверения в том, что после аутентификации пользователя и начала сессии можно спокойно предположить, что переменные сессии заслуживают доверия, не вполне соответствуют действительности. Дело в том, что для вскрытия идентификаторов сессий, передаваемых по Сети, можно организовать *анализ пакетов* — *packet sniffing* (перехват набора данных). Кроме того, если идентификатор (ID) сессии передается в области GET-запроса URL-адреса, он может появиться в файлах регистрации внешних сайтов.

Единственный по-настоящему безопасный способ предотвращения вскрытия заключается в применении *протокола защищенных сокетов* — Secure Socket Layer ([[SSL]]) — и запуске веб-страниц, использующих вместо протокола HTTP протокол HTTPS. Эта тема выходит за рамки данной книги, но за подробностями настроек безопасности веб-сервера можно обратиться к документации Apache по адресу http://tinyurl.com/apachetls.


### Предупреждение хищения сессии
---

Когда применение ТSL не представляется возможным, можно продолжить аутентификацию пользователей за счет хранения наряду с остальными сведениями их IP-адресов. Для этого нужно при сохранении их сессии добавить следующую строку кода:

```php
$_SESSION['ip'] = $_SERVER['REMOTE_ADDR'];
```

Затем в качестве дополнительной меры контроля при любой загрузке страницы и доступности сессии проводится следующая проверка, которая при несоответствии текущего IP-адреса сохраненному вызывает функцию **`different_user`**:

```php
if ($_SESSION['ip'] != $_SERVER['REMOTE_ADDR']) different_user();
```

Какой код будет у функции **`different_user`** — решать вам, но я рекомендую либо удалить текущую сессию и попросить пользователя пройти повторную регистрацию вследствие технической ошибки, либо, если у вас есть электронный адрес пользователя, отправить ему ссылку на подтверждение его личности, что позволит ему сохранить все данные в сессии. Больше ни о чем сообщать не нужно, иначе произойдет утечка потенциально ценной информации.

Разумеется, нужно принимать в расчет, что пользователи, работающие через один и тот же прокси-сервер или использующие одинаковые общие IP-адреса в домашней или офисной сети, будут иметь один и тот же IP-адрес. Если это вызовет проблему, нужно опять обратиться к протоколу HTTPS. Можно также сохранить копию браузерной *строки агента пользователя* (той самой строки, которую разработчики помещают в свои браузеры, для того чтобы идентифицировать их по типу и версии), с помощью которой также возможно отличить пользователей друг от друга благодаря существованию широкого выбора типов, версий и компьютерных платформ (хотя это далеко не идеальное решение, и при автообновлении браузера строка претерпит изменения). Для сохранения агента пользователя можно ввести следующий код:
```php
$_SESSION['ua'] = $_SERVER['HTTP_USER_AGENT'];
```

А для сравнения текущей строки агента-пользователя с сохраненной можно воспользоваться таким кодом:
```php
if ($_SESSION['ua'] != $_SERVER['HTTP_USER_AGENT']) different_user();
```

Или, что еще лучше, можно объединить эти две проверки и сохранить их комбинацию в виде шестнадцатеричной строки, получаемой от функции **`hash`**:
```php
$_SESSION['check'] = hash('ripemd128',$_SERVER['REMOTE_ADDR'] .
  $_SERVER['HTTP_USER_AGENT']);
```

Затем для сравнения текущей и сохраненной строк можно применить такой код:
```php
if ($_SESSION['check'] != hash('ripemd128',$_SERVER['REMOTE_ADDR'] .
    $_SERVER['HTTP_USER_AGENT'])) different_user();
```


### Предотвращение фиксации сессии
---

*Фиксация* сессии возникает, когда сторонний злоумышленник получает верный идентификатор сессии (который может быть сгенерирован сервером) и заставляет пользователя аутентифицироваться с этим идентификатором сессии вместо его самостоятельной аутентификации. Это происходит в том случае, если атакующий злоумышленник пользуется возможностью передачи идентификатора сессии в области GET-запроса URL-адреса, например, таким образом:
```browser
http://yourserver.com/authenticate.php? PHPSESSID=123456789
```

В данном случае серверу будет передан вымышленный ID сессии 123456789. А теперь рассмотрим **пример 13.9**, код которого восприимчив к фиксации сессии. Чтобы увидеть его в действии, наберите текст примера и сохраните его в файле `sessiontest.php`.

**Пример 13.9.** Сессия, восприимчивая к фиксации сессии
```php
<?php // sessiontest.php
  session_start();

  if (!isset($_SESSION['count'])) $_SESSION['count'] = 0; 
  else ++$_SESSION['count']; 

  echo $_SESSION['count'];
?>
```

После того как код будет сохранен, вызовите программу в вашем браузере, используя следующий URL (предваряя его правильным путевым именем, например http://localhost):

```browser
sessiontest.php?PHPSESSID=1234
```

Через некоторое время, нажав кнопку обновления страницы, вы увидите увеличение значения счетчика. Теперь попробуйте ввести в браузер следующий URL-адрес:

```browser
sessiontest.php?PHPSESSID=5678
```

Несколько раз нажмите кнопку обновления страницы, и вы увидите, что его показания меняются в сторону повышения. Оставьте показания счетчика на номере, отличающемся от его показаний при использовании первого URL-адреса, вернитесь на первый URL-адрес и посмотрите на то, как показания счетчика вернулись к первоначальному значению. Вы по собственному усмотрению создали две разные сессии и без особого труда можете создать их в любом количестве.

Особая опасность этого подхода состоит в том, что затеявший атаку злоумышленник может попытаться распространить такие URL-адреса среди ничего не подозревающих пользователей, и если кто-нибудь из них перейдет по ссылкам с этими адресами, атакующий сможет вернуться и перехватить любую сессию, которая не была удалена или срок действия которой еще не истек, — представьте себе, что это была бы сессия на сайте магазина или даже еще хуже — банка!

С целью предотвращения фиксации сессии нужно как можно быстрее воспользоваться для изменения ID сессии функцией **`session_regenerate_id`**. Она сохраняет значения всех переменных текущей сессии, но заменяет ID сессии новым, о котором не может знать атакующий.

Для этого при получении запроса проверьте факт существования специальной переменной сессии, которую вы выдумали произвольным образом. Если ее не существует, вы будете знать, что создана новая сессия, поэтому вы просто меняете **`ID`** сессии и устанавливаете значение ее специальной переменной, позволяющей заметить изменение.

В **примере 13.10** показано, как может выглядеть код, использующий переменную сессии **`initiated`**.

**Пример 13.10.** Регенерация сессии
```php
<?php
  session_start();

  if (!isset($_SESSION['initiated']))
  {
    session_regenerate_id();
    $_SESSION['initiated'] = 1; 
  }

  if (!isset($_SESSION['count'])) $_SESSION['count'] = 0; 
  else ++$_SESSION['count'];

  echo $_SESSION['count'];
?>
```

Атакующий может вернуться на ваш сайт, используя любые сгенерированные им ID-номера сессии, но ни один из них не приведет к вызову другой пользовательской сессии, поскольку все они будут заменены регенерированными ID-номерами.


### Преднамеренная настройка на сессии, использующие исключительно cookie
---

Если вы собираетесь потребовать от своих пользователей включить cookie при просмотре ваших сайтов, то можете обратиться к функции **`ini_set`**:

```php
ini_set('session.use_only_cookies', 1);
```

С такой настройкой трюк с **`?PHPSESSID=`** будет полностью проигнорирован. Если вы воспользуетесь этой мерой безопасности, рекомендую также проинформировать пользователей о том, что для работы с вашим сайтом требуются cookie (но только если пользователь отключил cookie и особенно если он находится в той части мира, где требуются уведомления о файлах cookie), чтобы пользователи знали причину, по которой им не удается получить требуемые результаты.


### Использование общего сервера
---

Если вы делите общий сервер с владельцами других учетных записей, то вам наверняка не захочется, чтобы все данные ваших сессий хранились в том же каталоге, где хранятся данные других пользователей. Вместо этого нужно выбрать для хранения ваших сессий каталог, доступный только пользователю с вашей учетной записью (и поэтому невидимый в сетевом окружении). Для этого придется ближе к началу программы поместить вызов функции **`ini_set`**:

```php
ini_set('session.save_path', '/home/user/myaccount/sessions');
```

В результате такой настройки конфигурации новое значение будет сохраняться лишь на время выполнения программы, а как только она завершит свою работу, будут возвращены исходные настройки.

Папка с данными сессий будет быстро заполняться, и в зависимости от занятости вашего сервера может потребоваться ее периодическая очистка от данных устаревших сессий. Чем чаще она будет использоваться, тем реже будет возникать желание хранить данные сессий.

>[!info]
>Следует помнить о том, что ваши сайты могут и будут подвергаться попыткам взлома. Существуют так называемые боты (bots), или сетевые автоматические программы, будоражащие интернет попытками отыскать уязвимые для атак сайты. Поэтому, что бы вы ни делали, если в своей программе вы проводите какую-либо обработку данных, не имеющих стопроцентной гарантии безопасности, к ним всегда нужно относиться с предельной осторожностью.

Теперь, когда вы в достаточной степени усвоили и PHP и MySQL, в [[Изучение JavaScript]] мы ознакомимся с JavaScript — третьей основной технологической составляющей, рассматриваемой в данной книге.


## Вопросы
---

- [ ] 1. Почему cookie должны быть переданы в начале работы программы?
- [x] 2. Какая PHP-функция сохраняет cookie на машине браузера?
- [ ] 3. Как можно удалить cookie?
- [x] 4. Где в PHP-программе сохраняются имя пользователя и пароль при использовании HTTP-аутентификации?
- [x] 5. Почему функция **`password_hash`** считается мощным средством защиты?
- [ ] 6. Что подразумевается под подмешиванием произвольных данных в строку?
- [x] 7. Что такое PHP-сессия?
- [x] 8. Как инициируется PHP-сессия?
- [x] 9. Что такое хищение сессии?
- [x] 10. Что такое фиксация сессии?

---