---
date: 2024-05-29T12:15:00
tags:
  - PHP
  - Backend
  - Web
  - WebDeveloping
  - IT
  - objects
  - Function
---
---
# **Функции и объекты PHP**

К основным требованиям к любому языку программирования относится наличие места для хранения данных, средств для направления процесса выполнения программы и других мелочей, таких как вычисление выражений, управление файлами и вывод текста. PHP обладает всем этим, и вдобавок у него имеется облегчающий жизнь инструментарий наподобие инструкций else и elseif. Но даже если все это входит в наш набор инструментов, программирование может быть слишком нудным и утомительным занятием, особенно если регулярно будет возникать необходимость вновь и вновь набирать очень похожие друг на друга фрагменты кода.

И тут нам на помощь приходят *функции* и объекты. Нетрудно догадаться, что функция — это набор инструкций, который выполняет конкретную задачу и в дополнение к этому может вернуть какое-нибудь значение. Можно извлечь фрагмент кода, который используется более одного раза, поместить его в функцию и вызвать функцию по имени в тот момент, когда этот код нужно будет выполнить.

По сравнению с непрерывным линейным кодом у функций есть масса преимуществ.

- Экономия времени при наборе текста программы.
- Сокращение количества синтаксических и прочих ошибок программирования.
- Сокращение времени загрузки файлов программы.
- Сокращение времени выполнения, поскольку каждая функция компилируется только один раз, независимо от частоты ее вызовов.
- Возможность использовать функции как в рядовых, так и в особенных случаях, поскольку они воспринимают аргументы.

Объекты являются дальнейшим развитием этой концепции. *Объект* объединяет одну или несколько функций и данные, которые ими используются, в единую структуру, которая называется *классом*.

В этой главе будет рассмотрено все, что касается использования функций, — от их определения и вызова до различных способов передачи данных. Вооружившись этими знаниями, вы сможете создавать функции и использовать их в собственных объектах (в которых они будут упоминаться как *методы*).

>[!info]
>Временами еще встречаются случаи использования любой версии PHP ниже 5.4, что, несомненно, не рекомендуется делать. Поэтому при изучении данной главы предполагается, что выпуск с этим номером является той самой младшей версией, с которой вы будете работать. Вообще-то, я рекомендую пользоваться версией 5.6 либо новой версией 7.0 или 7.1 (выпуск версии 6 не состоялся). Любую из этих версий можно выбрать на панели управления AMPPS, воспользовавшись рекомендациями из главы 2.

---
## **Функции PHP**
PHP поставляется с несколькими сотнями готовых к работе встроенных функций, превращающих его в язык с очень богатыми возможностями. Чтобы воспользоваться функцией, ее нужно вызвать по имени. Посмотрим, например, как работает функция date:

```php
echo date("l");  // Показывает день недели
```

Круглые скобки сообщают PHP, что вы ссылаетесь на функцию. В противном случае будет считаться, что вы ссылаетесь на константу или на переменную.

Функции могут принимать любое количество аргументов, включая нулевое. Например, показанная ниже функция `phpinfo` отображает массу информации о текущей установке PHP и не требует никаких аргументов:

```php
phpinfo();
```

Результат вызова этой функции показан на рис. 5.1.

>[!danger]
>Функция phpinfo весьма полезна для получения информации о текущей установке PHP, но этой информацией могут воспользоваться и потенциальные злоумышленники. Поэтому никогда не оставляйте вызов этой функции в коде, подготовленном для работы в Сети.

В **примере 5.1** показано несколько встроенных функций, использующих один аргумент и более.

**Пример 5.1.** Три функции для работы со строками
```php
<?php
  echo strrev(" .dlrow olleH");  // Реверисирование строки
  echo str_repeat("Hip ", 2);    // Повторение строки
  echo strtoupper("hooray!");    // Преобразование строки в верхний регистр
?>
```

![[Рис.5.1. Информация, выводимая встроенной в PHP функцией phpinfo.jpg | 700]]

В этом примере используются три функции для обработки строк, выводящие следующий текст:

`Hello world. Hip Hip HOORAY!`

Как следует из результата, функция **`strrev`** реверсирует порядок символов в строке, функция **`str_repeat`** дважды повторяет строку **`"Hip "`** (в соответствии с требованием второго аргумента), а функция **`strtoupper`** переводит буквы в слове **`"hooray!"`** в верхний регистр.

---
### Определение функции
---
В общем виде для функции используется следующий синтаксис:

```php
function имя_функции([параметр [, ...]])
{
  // Инструкции
}

```

В первой строке синтаксиса показано следующее:

- определение начинается со слова function;
- за ним следует имя, которое должно начинаться с буквы или символа подчеркивания; за ними может следовать любое количество букв, цифр или знаков подчеркивания;
- наличие круглых скобок обязательно;
- к необязательному элементу (обозначаемому тем, что он заключен в квадратные скобки) относится один или несколько параметров, разделенных запятыми.

Имена функций нечувствительны к регистру использующихся в них букв, поэтому все следующие строки могут ссылаться на одну и ту же функцию **`print`**: **`PRINT`**, **`Print`** и **`PrInT`**.

С открывающей фигурной скобки начинаются инструкции, которые будут выполнены при вызове функции; они должны завершаться закрывающей фигурной скобкой, составляющей пару первой скобке. В составе этих инструкций должна быть одна или несколько инструкций **`return`**, заставляющих функцию прекратить выполнение и вернуть управление вызывавшему функцию коду. Если инструкция **`return`** продолжена каким-нибудь значением, то вызывающий код может его извлечь, что мы сейчас и увидим.

---
## **Возвращения значения**
Рассмотрим простую функцию, преобразующую буквы чьих-нибудь полных имен в нижний регистр, а затем переводящую в верхний регистр первую букву каждой из составных частей имени.

В примере 5.1 нам уже встречалась встроенная PHP-функция **`strtoupper`**. Для нашей текущей функции будет использована ее противоположность: функция **`strtolower`**:

`$lowered = strtolower("люБОЕ нУжное Вам количество Букв и Знаков Пунктуации");`
`echo $lowered;`

На выходе этого эксперимента получается следующая строка:

`любое нужное вам количество букв и знаков пунктуации`

Но нам не нужны имена, полностью состоящие из букв нижнего регистра, мы хотим превратить в прописные первые буквы каждой части предложения. (Не будем в этом примере брать в расчет такие редкие имена, как Мари Энн или Хо Ши Мин.) Нам и здесь сопутствует удача: PHP предоставляет также функцию **`ucfirst`**, которая переводит первую букву строки в верхний регистр:

```php
$ucfixed = ucfirst("любое нужное вам количество букв и знаков пунктуации");
echo $ucfixed;
```

На выходе получается следующая строка:

`Любое нужное вам количество букв и знаков пунктуации`

Теперь мы можем внести свою лепту в конструирование программы: чтобы получить слово с первой прописной буквой, сначала для строки будет вызвана функция **`strtolower`**, а затем функция **`ucfirst`**. Для этого вызов функции **`strtolower`** будет вложен в вызов функции **`ucfirst`**. Посмотрим, зачем это делается, потому что нам важно понять порядок вычисления кода.

Если воспользоваться следующим простым вызовом функции print:

**`print(5-8);`**

то сначала будет вычислено выражение **`5 – 8`** и на выходе будет получено число **`–3`**. (В предыдущей главе уже было показано, что PHP для отображения этого результата превращает его в строку.) Если выражение содержит функцию, то сначала вычисляется эта функция:

**`print(abs(5-8));`**

Для выполнения этой короткой инструкции PHP совершает следующие действия.

1. Вычисляет 5 – 8, выдавая результат –3.
2. Использует функцию abs, превращая –3 в 3.
3. Превращает результат в строку и выводит его,
   используя функцию **`print`**.

Такой порядок работы обусловлен тем, что PHP вычисляет каждый элемент, начиная с самого внутреннего и заканчивая тем, который находится снаружи. То же самое происходит при обработке следующего вызова:

```php
ucfirst(strtolower("люБОЕ нУжное Вам количество Букв и Знаков Пунктуации"))
```

PHP передает нашу строку функции **`strtolower`**, а затем функции **`ucfirst`**, выдавая следующий результат (который мы уже видели, когда вызывали функции отдельно друг от друга):

```php
Любое нужное вам количество букв и знаков пунктуации
```

Теперь определим функцию (показанную в примере 5.2), которая берет три имени и переводит их буквы в нижний регистр, после чего превращает первую букву в прописную.

**Пример 5.2.** Приведение в порядок полного имени
```php
<?php
  echo fix_names("WILLIAM", "henry", "gaTES");
  
  function fix_names($n1, $n2, $n3)
  {
      $n1 = ucfirst(strtolower($n1));
      $n2 = ucfirst(strtolower($n2));
      $n3 = ucfirst(strtolower($n3));
      
      return $n1 . " " . $n2 . " " . $n3;
  }
?>
```

Пользователи часто забывают вовремя выключить режим CapsLock, случайно ставят прописные буквы не там, где нужно, и даже вообще забывают о них, от чего вы тоже не застрахованы. В результате выполнения кода этого примера будет выведен следующий текст:

```output
William Henry Gates
```

---
### Возвращения массива
---
Выше была рассмотрена функция, возвращающая единственное значение. Но существуют также способы получения при выполнении функции сразу нескольких значений.

Самый подходящий из них возвращает эти значения в виде массива. В главе 3 уже было показано, что массив похож на связку переменных в одной строке. Использование массива для возвращения значений функции отображено в примере 5.3.

**Пример 5.3.** Возвращение нескольких значений в массиве
```php
<?php
  $names = fix_names("WILLIAM", "henry", "gaTES");
  echo $names[0] . " " . $names[1] . " " . $names[2];
  
  function fix_names($n1, $n2, $n3)
  {
      $n1 = ucfirst(strtolower($n1));
      $n2 = ucfirst(strtolower($n2));
      $n3 = ucfirst(strtolower($n3));
      
      return array($n1, $n2, $n3);
  }
?>
```

У этого метода есть преимущество, заключающееся в том, что все три имени содержатся по отдельности, а не объединяются в одну строку, что дает возможность обращаться к любому пользователю просто по его имени или фамилии, не извлекая каждое имя из возвращаемой строки.

---
### Передача аргументов по ссылке
---
В версиях PHP, предшествующих версии 5.3, вы привыкли пользоваться возможностью употребления при вызове функции символа **`&`** (например, **`increment(&$myvar);`**), чтобы заставить парсер передавать ссылку на переменную, а не значение самой переменной. Тем самым функции предоставлялся доступ к переменной (позволяющий записывать в нее различные значения).

>[!danger]
>В версии PHP 5.3 передача по ссылке при вызове функции попала в число нерекомендуемых приемов, а из версии PHP 5.4.0 возможность такой передачи была удалена. Поэтому вам не следует пользоваться этим приемом нигде, кроме как на устаревших сайтах, и даже при этом рекомендуется переписать код, передающий значения по ссылке, поскольку в новых версиях PHP он будет приводить к остановке программы с выдачей неустранимой ошибки.

Но *внутри* определения функции можно продолжать обращаться к аргументам по ссылке. Этот подход может представлять для вас определенные сложности, поэтому вернемся к метафоре со спичечным коробком, которая использовалась [[Введение в PHP]].

Представьте, что вы не вынимаете клочок бумаги из коробка, не читаете то, что на нем написано, не копируете эту надпись на другой клочок бумаги, не возвращаете оригинал в коробок и не передаете копию функции, а просто привязываете нитку к исходному клочку бумаги и передаете функции второй конец этой нитки (**рис. 5.2**).

![[Рис.5.2. Представление ссылки в виде нитки, привязанной к значению переменной.jpg | 600]]

Теперь, чтобы найти данные, к которым она обращается, функция может проследовать по нитке. Таким образом предотвращаются все издержки на создание копии переменной, предназначенной только для того, чтобы в функции можно было воспользоваться ее значением. Более того, теперь функция может изменить значение переменной.

Значит, **пример 5.3** можно переписать: передать ссылки на все параметры, чтобы после этого функция напрямую смогла внести в них изменения (**пример 5.4**).

**Пример 5.4**. Передача значений в функцию по ссылке
```php
<?php
  $a1 = "WILLIAM";
  $a2 = "henry";
  $a3 = "gaTES";
  
  echo $a1 . " " . $a2 . " " . $a3 . "<br>";
  fix_names($a1, $a2, $a3);
  echo $a1 . " " . $a2 . " " . $a3;
  
  function fix_names(&$n1, &$n2, &$n3)
  {
      $n1 = ucfirst(strtolower($n1));
      $n2 = ucfirst(strtolower($n2));
      $n3 = ucfirst(strtolower($n3));
  }
?>
```

Вместо передачи строк непосредственно функции они сначала присваиваются в качестве значений переменным и выводятся на экран, чтобы чтобы можно было посмотреть их состояние «до». Затем, как и раньше, вызывается функция, но внутри определения функции перед именем каждого параметра, передаваемого по ссылке, ставится символ **`&`**.

Теперь к переменным **`$n1, $n2 и $n3`** привязаны «ниточки», ведущие к значениям переменных **`$a1, $a2 и $a3`**. Иными словами, существует одна группа значений, но два набора имен переменных, позволяющих к ним обратиться.

Поэтому функции **`fix_names`** нужно только присвоить новые значения переменным **`$n1, $n2 и $n3`**, чтобы обновить значения переменных **`$a1, $a2 и $a3`**. В результате выполнения этого кода будут выведены следующие строки:

```php
WILLIAM henry gatES
William Henry Gates
```

Как видите, в обеих инструкциях **`echo`** используются только значения переменных **`$a1, $a2 и $a3`**.

---
### Возвращение глобальных переменных
---
Лучшим способом предоставления функции доступа к переменной, созданной за ее пределами и не передающейся в качестве аргумента, является объявление ее глобальной прямо из тела функции. За ключевым словом **`global`** должно следовать имя переменной, тогда полный доступ к этой переменной можно будет получить из любой части вашего кода (**пример 5.5**).

**Пример 5.5.** Возвращение значений в глобальных переменных
```php
<?php
  $a1 = "WILLIAM";
  $a2 = "henry";
  $a3 = "gaTES";
  
  echo $a1 . " " . $a2 . " " . $a3 . "<br>";
  fix_names();
  echo $a1 . " " . $a2 . " " . $a3;
  
  function fix_names()
  {
      global $a1; $a1 = ucfirst(strtolower($a1));
      global $a2; $a2 = ucfirst(strtolower($a2));
      global $a3; $a3 = ucfirst(strtolower($a3));
  }
?>
```

Теперь уже не нужно передавать функции параметры, и она не должна их принимать. После объявления эти переменные остаются глобальными и доступными коду всей остальной программы, включая ее функции.

---
#### И еще раз об области видимости переменных
---
Кратко напомню те сведения, которые были получены при изучении
[[Введение в PHP]].

- *Локальные переменные* доступны лишь из той части кода, в которой они были определены. Если это произошло за пределами функции, доступ к переменным будет возможен из всего кода, находящегося за пределами функций, классов и т. д. Если переменная была определена внутри функции, значит, доступ к ней может получить только код этой функции и ее значение теряется при выходе из функции.
- *Глобальные переменные* доступны из любых частей вашего кода, как внутри, так и вне рамок функций.
- *Статические переменные* доступны только внутри функции, в которой они были объявлены, но при этом они сохраняют свое значение в процессе многократных вызовов функции.


---
## Включение и запрос файлов
По мере приобретения навыков программирования на PHP вы, скорее всего, приступите к созданию библиотеки, состоящей из функций, которые, по вашему мнению, смогут пригодиться в будущем. Кроме того, наверное, вы начнете пользоваться библиотеками, созданными другими программистами.

Копировать эти функции и вставлять их в свой код не имеет никакого смысла. Можно сохранить эти функции в отдельных файлах и воспользоваться командами для их извлечения. Для этого существуют две команды: **`include`** (включить) и **`require`** (затребовать).

---
### Инструкция `include`
---
При использовании инструкции **`include`** можно потребовать у PHP извлечения конкретного файла и загрузки всего его содержимого. Это равносильно вставке включаемого файла в данное место текущего файла. В примере 5.6 показано, как нужно включать файл под названием **`library.php`**.

**Пример 5.6.** Включение файла PHP
```php
<?php
  include "library.php";
  // Сюда помещается ваш код
?>
```

---
### Инструкция `include_once`
---
При каждом использовании директивы **`include`** она снова вставляет требуемый файл, даже если он уже был вставлен. Предположим, к примеру, что в библиотеке **`library.php`** содержится масса полезных функций. Вы включаете ее в свой файл, но кроме нее включаете еще одну библиотеку, которая содержит **`library.php`** . Из-за этой вложенности вы непреднамеренно вставляете **`library.php`** дважды. В результате будут появляться сообщения об ошибках, потому что будет предпринята попытка несколько раз объявить одну и ту же константу или функцию. Поэтому вместо данной директивы нужно использовать инструкцию **`include_once`** (пример 5.7).

**Пример 5.7.** Однократное включение файла PHP
```php
<?php
  include_once "library.php";
  // Сюда помещается ваш код
?>
```

Теперь любые дальнейшие попытки включения того же самого файла (с помощью **`include`** или **`include_once`**) будут проигнорированы. Чтобы определить, был ли запрошенный файл уже включен, абсолютный путь к нему сравнивается со всеми раскрытыми относительными путями (соответствует их абсолютным путям) и файлом, найденным в пути, который указан в вашей инструкции **`include`**.

>[!info]
>Вообще-то, наверное, лучше будет придерживаться использования инструкции **`include_once`** и не применять инструкцию **`include`**. Тогда у вас никогда не будет проблем с тем, что файлы вставляются по нескольку раз.

---
### Инструкции `require` и `require_once`
---
Потенциальная проблема, возникающая при использовании инструкций **`include`** и **`include_once`**, состоит в том, что для вставки нужного файла PHP предпримет всего одну попытку. Выполнение программы продолжится даже в том случае, если файл не будет найден.

Когда вставка файла имеет принципиальную важность, его нужно затребовать, то есть применить инструкцию **`require`**. По тем же причинам, которые излагались при рассмотрении использования инструкции 
**`include_once`**, я рекомендую, чтобы вы, когда нужно затребовать файл, придерживались главным образом использования инструкции **`require_once`** (пример 5.8).

**Пример 5.8.** Однократное востребование файла PHP
```php
<?php
  require_once "library.php";
  // Сюда помещается ваш код
?>
```

---
## Совместимость версий PHP
PHP продолжает совершенствоваться и существует в нескольких версиях. Если нужно проверить доступность в вашем коде какой-нибудь конкретной функции, можно воспользоваться функцией **`function_exists`**, которая проверяет все предопределенные и созданные пользователем функции.

**В примере 5.9** проверяется доступность функции **`array_combine`**, которая 
имеется лишь в некоторых версиях PHP.
```php
<?php
  if (function_exists("array_combine"))
  {
      echo "Функция существует!";
  }
  else
  {
      echo "Функция не существует, желательно создать её самостоятельно.";
  }
?>
```

Используя подобный код, можно воспользоваться любыми функциональными возможностями, имеющимися в новых версиях PHP, которые вам придется смоделировать, если нужно будет, чтобы ваш код работал и в более ранних версиях, в которых недоступны новые возможности. Ваши функции могут работать медленнее встроенных, но код по крайней мере будет обладать более широкой переносимостью.

Чтобы определить версию PHP, под которой запущен ваш код, можно также воспользоваться функцией **`phpversion`**. Возвращаемый результат в зависимости от версии будет иметь следующий вид:
`8.0.0`

---
## [Объекты PHP](https://www.php.net/manual/ru/language.types.object.php)
Практически так же, как применение функций стало фактором существенного увеличения эффективности программирования на заре развития вычислительной техники (когда лучшим из доступных средств программной навигации порой была самая элементарная инструкция `GOTO` или `GOSUB`), [[объектно-ориентированное программирование]] (ООП) направило использование функций в другую сторону.

Как только у вас появится навык сведения повторно используемых фрагментов кода в функции, останется сделать еще один небольшой шаг и присмотреться к связыванию функций и данных, которыми они оперируют, в объекты.

Рассмотрим сайт социальной сети, состоящий из множества различных частей. Одна из таких частей управляет всеми пользовательскими функциями: ее код позволяет новым пользователям записаться, а уже записавшимся — изменить свои личные данные. В стандартном PHP можно создать для управления всеми этими действиями ряд функций и встроить несколько вызовов к базе данных MySQL, чтобы вести данные по всем пользователям.

Для создания объекта, представляющего текущего пользователя, можно создать класс по имени User, в котором будет содержаться весь код, необходимый для обслуживания пользователей, и все переменные, требующиеся для работы с данными внутри класса. Затем, когда понадобится управлять пользовательскими данными, можно будет просто создать новый объект класса User.

Этот новый объект можно будет рассматривать в качестве настоящего пользователя. Например, объекту можно передать имя, пароль и адрес электронной почты, спросить его о том, существует ли уже такой пользователь, и если нет, заставить его создать нового пользователя с данными атрибутами. Можно даже иметь объект мгновенных сообщений или объект, позволяющий учитывать дружеские отношения между двумя пользователями.

---
## Терминология
При создании программы, рассчитанной на использование объектов, нужно сконструировать некую совокупность данных и кода, называемую классом. Каждый новый объект, основанный на этом классе, называется *экземпляром* (или *случаем употребления*) этого класса.

Данные, связанные с объектом, называются его *свойствами*, а используемые им функции — *методами*. При определении класса задаются имена его свойств и код для его методов. На рис. 5.3 показана метафора объекта в виде музыкального автомата. Компакт-диски в его карусели можно рассматривать в качестве его свойств, а метод их проигрывания заключается в нажатии кнопки на передней панели. Есть также щель для опускания монет (метод, используемый для активизации объекта) и устройство чтения компакт-дисков (метод, используемый для извлечения музыки, или свойств, с компакт-дисков).

![[Рис.5.3. Музыкальный автомат как подходящий пример автономного объекта.jpg | 700]]

При создании объектов предпочтительно воспользоваться инкапсуляцией или создавать класс таким образом, чтобы с его свойствами могли работать только его собственные методы. Иными словами, нужно запретить внешнему коду непосредственный доступ к данным объекта. Предоставляемые объектом методы известны как *интерфейс* объекта.

Такой подход упрощает отладку: дефектный код придется исправлять только в пределах класса.

Кроме того, когда нужно будет обновить программу, при использовании надлежащей инкапсуляции и поддержке одинакового интерфейса можно будет просто разработать новые классы для замены старых, полностью их отладить, а затем заменить ими старые классы. Если они будут в чем-то неработоспособными, можно будет вернуть назад старые классы для немедленного устранения проблемы перед дальнейшей отладкой новых классов.

Как только класс будет создан, может выясниться, что нужен еще один, похожий на него, но все же несколько отличающийся класс. Быстрее и проще всего будет определить новый класс, воспользовавшись наследованием. При этом ваш новый класс сохранит все свойства, присущие тому классу, чьим наследником он является.

Исходный класс теперь будет называться *родительским* (или временами *суперклассом*), а новый класс — *подклассом* (или *производным классом*).

Вернемся к примеру с музыкальным автоматом. Если вы изобретаете новый музыкальный автомат, который наряду с музыкой может воспроизводить и видеоклипы, то можете сохранить все свойства и методы исходного музыкального автомата и добавить несколько новых свойств (видеоклипов) и новых методов (видеоплееров).

Существенным преимуществом этой системы является то, что если вы увеличили скорость работы или улучшили другие аспекты работы суперкласса, его подклассы пользуются теми же самыми усовершенствованиями. С другой стороны, любое изменение, внесенное в родительский/суперкласс, может сломать подкласс.

---
## Объявления класса
---

Перед тем как получить возможность использования объекта, нужно определить класс с помощью ключевого слова **`class`**. Определение класса включает в себя имя класса (чувствительное к регистру букв), его свойства и методы. В примере 5.10 дается определение класса **`User`**, имеющего два свойства: **`$name`** и **`$password`** (которые обозначены ключевым словом **`public`** — см. подраздел ==«Область видимости свойств и методов»== данного раздела). В нем также создается новый экземпляр этого класса (по имени **`$object`**).

**Пример 5.10.** Объявление класса и проверка объекта
```php
<?php
  $object = new User;
  print_r($object);
  
  class User {
      public $name, $password;
      
      function save_user()
      {
          echo "Сюда помещается код, сохраняющие данные пользователя.";
      }
  }
?>
```

Здесь также задействована поистине бесценная функция под названием **`print_r`**. Она требует от PHP отобразить информацию о переменной в удобной для восприятия человеком форме, о чем говорит элемент **`_r`** в ее имени (означающий readable — «читаемый»). Для нового объекта **`$object`** эта функция выводит следующую информацию:

```output
User Object
(
  [name] =>
  [password] =>
)
```

Но браузер сжимает все пустые пространства, поэтому выводимая в нем информация читается немного сложнее:

```output
User Object ( [name] => [password] => )
```

В любом случае выведенная информация свидетельствует о том, что **`$object`** является объектом, определенным пользователем, и содержит свойства 
**`name`** и **`password`**.

---
### Создание объекта
---
Для создания объекта определенного класса используется ключевое слово new, применяемое в выражении: **`$объект = new Класс`**. Вот два способа создания объектов:

```php
  $object = new User;
  $temp = new User('name', 'password');
```

В первой строке мы просто назначаем объект классу **`User`**. А во второй строке передаем вызову аргументы.

Класс может требовать или запрещать аргументы; он также может разрешать аргументы без их явного востребования.

---
### Доступ к объектам
---
Добавим к примеру 5.10 еще несколько строк и проверим результаты. В примере 5.11 предыдущий код расширяется за счет установки свойств объекта и вызова метода.

**Пример 5.11.** Создание объекта и взаимодействие с ним
```php
<?php
  $object = new User;
  print_r($object); echo "<br>";
  
  $object->name = "Joe";
  $object->password = "mypass";
  print_r($object); echo "<br>";
  
  $object->save_user();
  
  class User {
      public $name, $password;
      
      function save_user()
      {
          echo "Сюда помещается код, сохраняющие данные пользователя.";
      }
  }
?>
```

Из примера видно, что для доступа к свойству объекта используется следующий синтаксис: **`$объект->свойство`**. Подобным образом можно вызвать и метод: **`$объект->метод()`**.

Можно было заметить, что перед именами свойств и методов отсутствует символ доллара (**`$`**). Если на первой позиции имен поставить символ **`$`**, то код не будет работать, поскольку он попробует обратиться к значению, хранящемуся в переменной. Например, выражение **`$object->$property`** будет пытаться найти значение, присвоенное переменной по имени **`$property`** (скажем, это значение является строкой **`brown`**), а затем обратиться к свойству **`$object->brown`**. Если переменная **`$property`** не определена, то будет предпринята попытка обратиться к свойству **`$object->NULL`**, что спровоцирует возникновение ошибки.

Если организовать просмотр, используя имеющееся в браузере средство для просмотра исходного кода, то код примера 5.11 выведет следующую информацию:
```output
User Object
(
    [name] => 
    [password] => 
)
<br>User Object
(
    [name] => Joe
    [password] => mypass
)
<br>Сюда помещается код, сохраняющие данные пользователя.
```

Здесь также используется функция **`print_r`**, которая предоставляет содержимое переменной **`$object`** до и после присваивания свойству значения. В дальнейшем я не буду использовать инструкцию **`print_r`**, но если материал этой книги будет прорабатываться на вашем разработочном сервере, вы сможете поместить в код несколько таких инструкций, чтобы иметь полное представление о том, что происходит.

Также можно было заметить, что благодаря вызову метода **`save_user`** был выполнен код этого метода, который вывел строку, напоминающую о том, что нужно создать некий код.

>[!info]
>Определения функций и классов можно помещать в любое место вашего кода, до или после инструкций, в которых они используются. Но правилом хорошего тона считается помещать их ближе к концу файла.

---
### Клонирование объектов
---
Если объект уже создан, то в качестве параметра он передается по ссылке. Если воспользоваться метафорой спичечного коробка, то это похоже на привязывание сразу нескольких ниток к объекту, хранящемуся в коробке, что позволяет получить к нему доступ, следуя по любой из привязанных ниток.

==Иными словами, присваивание объектов не приводит к их полному копированию.==

Как это работает, показано в **примере 5.12**, где определяется очень простой пользовательский класс **`User`**, который не имеет методов и содержит всего лишь одно свойство **`name`**.

**Пример 5.12.** Копирование объекта
```php
<?php
  $object1 = new User();
  $object1->name = "Alice";
  $object2 = $object1;
  $object2->name = "Amy";
  
  echo "object1 name = " . $object1->name . "<br>";
  echo "object2 name = " . $object2->name;
  
  class User{
      public $name;
  }
?>
```

Мы создали объект **`$object1`** и присвоили свойству name значение **Alice**. Затем создали **`$object2`**, присвоили ему значение **`$object1`** и присвоили значение **`Amy`** непосредственно свойству name объекта **`$object2`** — или подумали, что присвоили. Но этот код выдаст следующую информацию:

```output
object1 name = Amy
object2 name = Amy
```

Что же произошло? И **`$object1`** и **`$object2`** ссылаются *на один и тот же* объект, поэтому изменение свойства name, принадлежащего **`$object2`**, на Amy устанавливает такое же значение и для свойства, принадлежащего **`$object1`**.

Во избежание подобной путаницы следует использовать инструкцию **`clone`**, которая создает новый экземпляр класса и копирует значения свойств из исходного класса в новый экземпляр. Применение этой инструкции показано в примере 5.13.

**Пример 5.13.** Клонирование объекта
```php
<?php
  $object1 = new User();
  $object1->name = "Alice";
  $object2 = clone $object1;
  $object2->name = "Amy";
  
  echo "object1 name = " . $object1->name . "<br>";
  echo "object2 name = " . $object2->name;
  
  class User{
      public $name;
  }
?>
```

Вот и все. Этот код выдает то, что нам требовалось получить с самого начала:

```output
object1 name = Alice
object2 name = Amy
```

---
### Конструкторы
---
При создании нового объекта вызываемому классу можно передать перечень аргументов. Они передаются специальному методу внутри класса, который называется *конструктором* и занимается инициализацией различных свойств.

Для этого используется функция по имени **`__construct`** (то есть перед construct ставятся два символа подчеркивания) как в примере 5.14.

**Пример 5.14.** Создание метода-конструктора
```php
<?php
  class User
  {
      function __construct($param1, $param2)
      {
          // Сюда помещаются инструкции конструктора
          public $username = "Guest";
      }
  }
?>
```

---
### Деструкторы
---
Имеется также возможность создания *методов-деструкторов*. Эта возможность подходит для тех случаев, когда код ссылается на объект в последний раз или когда сценарий подошел к концу. В примере 5.15 показано, как создается метод деструктор. Деструктор может выполнять очистку, например, сбросить подключение к базе данных или к каким-нибудь другим ресурсам, зарезервированным в классе. Поскольку ресурсы резервируются внутри класса, их высвобождение должно здесь и происходить, или же они будут удерживаться до бесконечности. Когда программа резервирует ресурсы и забывает их высвободить, возникают проблемы общесистемного характера.

**Пример 5.15.** Создание метода-деструктора
```php
<?php
  class User{
      function __destruct()
      {
          // Сюда помещается код деструктора.
      }
  }
?>
```

---
### Написание методов
---
Как видите, объявление метода похоже на объявление функции, но есть некоторые отличия. Так, имена методов, начинающиеся с двойного подчеркивания **`(__)`**, являются зарезервированными словами (например, **`__construct и __destruct`**), и вы не должны больше создавать ничего подобного.

Кроме того, существует специальная переменная **`$this`**, которая может использоваться для доступа к свойствам текущего объекта. Чтобы понять, как это работает, посмотрите на код примера 5.16, содержащий еще один метод из определения класса User, который называется **`get_password`**.

**Пример 5.16.** Использование в методе переменной **`$this`**
```php
<?php
  class User {
      public $name, $password;
      
      function get_password()
      {
          return $this->password;
      }
  }
?>
```

Метод получения пароля — **`get_password`** — применяет переменную **`$this`** для доступа к текущему объекту, а затем возвращает значение свойства password, принадлежащего этому объекту. Обратите внимание на то, как при использовании оператора **`->`** в имени свойства **`$password`** опускается первый символ **`$`**. Если оставить его на прежнем месте, особенно при первом применении этого свойства, будет допущена весьма типичная ошибка.

Класс, определенный в **примере 5.16**, нужно использовать следующим образом:
```output
$object = new User;
$object->password = "secret";

echo $object->get_password();
```

Этот код выводит пароль **`secret`**.

---
### Объявление свойств
---
В явном объявлении свойств внутри классов нет необходимости, поскольку они могут быть определены неявным образом при первом же их использовании. Для иллюстрации этой особенности класс **`User`** в примере 5.17 не имеет ни свойств, ни методов, но при этом в коде его определения нет ничего противозаконного.

**Пример 5.17.** Неявное объявление свойства
```php
<?php
  $object1 = new User();
  $object1->name = "Alice";
  
  echo $object->name;
  
  class User {}
?>
```

Этот код вполне корректно и без проблем выведет строку **`Alice`**, поскольку PHP неявным образом объявит для вас свойство **`$object1->name`**. Но такой стиль программирования может привести к ошибкам, найти которые будет невероятно трудно, поскольку свойство name было объявлено за пределами класса.

Чтобы не создавать трудностей ни себе, ни тому, кто впоследствии будет обслуживать ваш код, я советую выработать привычку всегда объявлять свойства внутри класса в явном виде. И поверьте, вы об этом никогда не пожалеете.

К тому же когда свойство объявляется внутри класса, ему можно присвоить значение по умолчанию. Используемое вами значение должно быть константой, а не результатом вызова функции или вычисления выражения. Несколько допустимых и недопустимых присваиваний показано в **примере 5.18.**

**Пример 5.18.** Допустимые и недопустимые объявления свойств
```php
<?php
  class Test {
      public $name = "Paul Smith";  // Допустимое
      public $age = 31;             // Допустимое
      public $time = time();        // Недопустимое - вызывает функцию
      public $score = $level * 2;   // Недопустимое - использует выражение
  }
?>
```

---
### Объявление констант
---
По аналогии с созданием глобальных констант внутри определения функций можно определять константы и внутри классов. Чтобы константы выделялись на общем фоне, обычно для их имен используют буквы верхнего регистра (пример 5.19).

**Пример 5.19.** Определение констант внутри класса
```php
<?php
  Translate::lookup();
  
  class Translate {
      const ENGLISH = 0;
      const SPANISH = 1;
      const FRENCH = 2;
      const GERMAN = 3;
      // ...
      
      Static function lookup()
      {
          echo self::SPANISH;
      }
  }
?>
```

К константам можно обращаться напрямую, с помощью ключевого слова **`self`** и оператора двойного двоеточия. Обратите внимание на то, что этот код, в первой строке которого используется оператор двойного двоеточия, вызывает класс напрямую, без предварительного создания его экземпляра. Как и ожидалось, значение, выводимое при запуске этого кода на выполнение, будет равно 1.

==Запомните, что константа после ее определения не может быть изменена.==

---
### Область видимости свойств и методов
---
PHP предоставляет три ключевых слова для управления областью видимости свойств и методов (*элементов*).

- **`public`** (открытые). На открытые элементы можно ссылаться откуда угодно, включая другие классы и экземпляры объекта. Свойства с этой областью видимости получаются по умолчанию при объявлении переменной с помощью ключевых слов **`var`** или **`public`** либо когда переменная объявляется неявно при первом же ее использовании.

  Ключевые слова **`var`** и **`public`** являются взаимозаменяемыми. Хотя сейчас использование **`var`** не приветствуется, оно сохранено для совместимости с предыдущими версиями PHP. Методы считаются открытыми по умолчанию.
- **`protected`** (защищенные). На эти элементы можно ссылаться только через принадлежащие объектам методы класса и такие же методы любых подклассов.
- **`private`** (закрытые). К представителям класса с этой областью видимости можно обращаться через методы этого же класса, но не через методы его подклассов.

Решение о том, какую область видимости применить, принимается на основе следующих положений:

- открытую (**`public`**) область видимости следует применять, когда к представителю класса нужен доступ из внешнего кода и когда расширенные классы должны его наследовать;
- защищенную (**`protected`**) область видимости необходимо использовать, когда к представителю класса не должно быть доступа из внешнего кода, но расширенные классы все же должны его наследовать;
- закрытую (**`private`**) область видимости следует применять, когда к представителю класса не должно быть доступа из внешнего кода и когда расширенные классы не должны его наследовать.

Применение этих ключевых слов показано в **примере 5.20.**

**Пример 5.20.** Изменение области видимости свойства и метода
```php
<?php
  class Example {
      var $name = "Rick";     // Нерекомендуемая форма, аналогичная public
      public $age = 23;       // Открытое свойство
      protected $usercount;   // Защищищенное свойство
      
      private function admin()  // Закрытый метод
      {
          // Сюда помещается код метода admin
      }
  }
?>
```

---
### Статические методы
---
Метод можно определить в качестве статического, **`static`**, это будет означать, что он вызывается классом, а не объектом. Статический метод не имеет доступа к свойствам объекта. Порядок его создания и доступа к нему показан в **примере 5.21.**

**Пример 5.21.** Создание статического метода и обращение к нему
```php
<?php
  User::pwd_string();
  
  class User {
      static function pwd_string()
      {
          echo "Пожалуйста, введите ваш пароль.";
      }
  }
?>
```

Обратите внимание на вызов самого класса со статическим методом, при котором используется двойное двоеточие (также известное как *оператор разрешения области видимости*), а не сочетание символов **`->`**. Статические функции применяются для выполнения действий, относящихся к самому классу, а не к конкретным экземплярам класса. В **примере 5.19** можно увидеть еще один вариант применения статического метода.

>[!info]
>При попытке получить доступ из статической функции к свойству текущего объекта с помощью выражения **`$this->property`** или обратиться к другим свойствам объекта будет получено сообщение об ошибке.

---
### Статические свойства
---
Большинство данных и методов применяются в экземплярах класса. Например, в классе **`User`** следует установить конкретный пароль пользователя или проверить, когда пользователь был зарегистрирован. Эти факты и операции имеют особое отношение к каждому конкретному пользователю и поэтому применяют специфические для экземпляра свойства и методы.

Но время от времени возникает потребность обслуживать данные, относящиеся целиком ко всему классу. Например, для отчета о том, сколько пользователей зарегистрировалось, будет храниться переменная, имеющая отношение ко всему классу **`User`**. Для таких данных PHP предоставляет статические свойства и методы.

В **примере 5.21** было показано, что объявление представителей класса статическими делает их доступными и без создания экземпляров класса. Свойство, объявленное статическим, **`static`**, не может быть доступно непосредственно из экземпляра класса, но может быть доступно из статического метода.

В **примере 5.22** определяется класс по имени **`Test`**, в котором содержатся статическое свойство и открытый метод.

**Пример 5.22.** Определение класса со статическим свойством
```php
<?php
  $temp = new Test();
  
  echo "Тест А: " . Test::$static_property . "<br>";
  echo "Тест Б: " . $temp->get_sp() . "<br>";
  echo "Тест В: " . $temp->static_property . "<br>";
  
  class Test {
      static $static_property = "Это статическое свойство.";
      
      function get_sp()
      {
          return self::$static_property;
      }
  }
?>
```

Когда код будет запущен на выполнение, он выдаст следующую информацию:
```outline
Tест A: Это статическое свойство
Tест Б: Это статическое свойство 
Notice: Undefined property: Test::$static_property Tест И:
```

В этом примере показано, что на свойство **`$static_property`** можно ссылаться напрямую из самого класса, используя в тесте **`A`** оператор двойного двоеточия. Тест **`Б`** также может получить его значение путем вызова метода **`get_sp`** объекта **`$temp`**, созданного из класса **`Test`**. Но тест В терпит неудачу, потому что статическое свойство **`$static_property`** недоступно объекту **`$temp`**.

Обратите внимание на то, как метод **`get_sp`** получает доступ к свойству **`$static_ property`**, используя ключевое слово **`self`**. Именно таким способом можно получить непосредственный доступ к статическому свойству или константе внутри класса.

---
### Наследование
___
Как только класс будет создан, из него можно будет получить подкласс. Это сэкономит массу времени: вместо скрупулезного переписывания кода можно будет взять класс, похожий на тот, который следует создать, распространить его на подкласс и просто внести изменения в те места, которые будут иметь характерные особенности. Это достигается за счет использования ключевого слова **`extends`**.

В **примере 5.23** класс **`Subscriber`** объявляется подклассом User путем использования инструкции **`extends`**.

**Пример 5.23.** Наследование и распространение класса
```php
<?php
  $object = new Subscriber;
  $object->name = "Fred";
  $object->password = "pword";
  $object->phone = "012 999 211 23";
  $object->email = "fred@blogs.com";
  $object->display();
  
  class User
  {
      public $name, $password;
      
      function save_user()
      {
          echo "Сюда помещается код, сохраняющий данные пользователя.";
      }
  }
  
  class Subscriber extends User
  {
      public $phone, $email;
      
      function display()
      {
          echo "Name: " . $this->name . "<br>";
          echo "Pass: " . $this->password . "<br>";
          echo "Phone: " . $this->phone . "<br>";
          echo "Email: " . $this->email;
      }
  }
?>
```

У исходного класса **`User`** имеются два свойства — **`$name`** и **`$password`**, а также метод для сохранения данных текущего пользователя в базе данных. Подкласс **`Subscriber`** расширяет этот класс за счет добавления еще двух свойств — **`$phone`** и **`$email`** и включения метода, отображающего свойства текущего объекта, который использует переменную **`$this`**. Данная переменная ссылается на текущее значение объекта, к которому осуществляется доступ. Этот код выведет следующую информацию:

```output
Name: Fred
Pass: pword
Phone: 012 345 6789
Email: fred@bloggs.com
```

---
### Ключевое слово **`parent`**
---
Когда в подклассе создается метод с именем, которое уже фигурирует в его родительском классе, его инструкции переписывают инструкции из родительского класса. Иногда такое поведение идет вразрез с вашими желаниями, и вам нужно получить доступ к родительскому методу. Для этого можно воспользоваться инструкцией **`parent`**, которая показана в **примере 5.24.**

**Пример 5.24.** Переписывание метода и использование инструкции **`parent`**
```php
<?php
  $object = new Son;
  $object->test();
  $object->test2();
  
  class Dad
  {
      function test()
      {
          echo "[Class Dad] Я твой отец<br>";
      }
  }
  
  class Son extends Dad
  {
      function test()
      {
          echo "[Class Son] Я люк<br>";
      }
      
      function test2()
      {
          parent::test();
      }
  }
?>
```

Этот код создает класс по имени **`Dad`** (Отец), а затем подкласс по имени **`Son`** (Сын), который наследует свойства и методы родительского класса, а затем переписывает метод **`test`**. Поэтому когда во второй строке кода вызывается метод **`test`**, выполняется новый метод. Единственный способ выполнения переписанного метода **`test`** в том варианте, в каком он существует в классе Dad, заключается в использовании инструкции **`parent`**, как показано в функции **`test2`** класса **`Son`**. Этот код выведет следующую информацию:

```output
[Class Son] Я Люк
[Class Dad] Я твой отец
```

Если нужно обеспечить вызов метода из текущего класса, можно воспользоваться ключевым словом **`self`**:
`self::method();`

---
### Конструкторы подкласса
---
При распространении класса и объявлении собственного конструктора вы должны знать, что PHP не станет автоматически вызывать метод-конструктор родительского класса. Чтобы обеспечивалось выполнение всего кода инициализации, подкласс, как показано в **`примере 5.25`**, всегда должен вызывать родительские конструкторы.

**Пример 5.25.** Вызов конструктора родительского класса
```php
<?php
  $object = new Tiger();
  echo "У тигров есть...<br>";
  echo "Мех: " . $object->fur . "<br>";
  echo "Полосы: " . $object->stripes;
  
  class Wildcat
  {
      public $fur;  // У диких кошек есть мех
      
      function __construct()
      {
          $this->fur = "TRUE";
      }
  }
  
  class Tiger extends Wildcat
  {
      public $stripes;  // У тигров есть полосы
      
      function __construct()
      {
          parent::__construct();  // Первоочередный вызов родительского
                                  // конструктора
          $this->stripes = "TRUE";
      }
  }
?>
```

В этом примере используются обычные преимущества наследования. В классе **`Wildcat`** (Дикая кошка) создается свойство **`$fur`** (мех), которое хотелось бы использовать многократно, поэтому мы создаем класс **`Tiger`** (Тигр), наследующий свойство **`$fur`**, и дополнительно создаем еще одно свойство — **`$stripes`** (полосы). Чтобы проверить вызов обоих конструкторов, программа выводит следующую информацию:

```output
У тигров есть...
Мех: TRUE
Полосы: TRUE
```

---
### Методы **`final`**
---
При необходимости помешать подклассу переписать метод суперкласса можно воспользоваться ключевым словом **`final`**. Как это делается, показано в **примере 5.26**.

**`Пример 5.26.`** Создание метода **`final`**
```php
<?php
  class User
  {
      final function copyright()
      {
          echo "Этот класс был создан Джо Смитом.";
      }
  }
?>
```

Усвоив содержание этой главы, вы должны приобрести твердое представление о том, что PHP может для вас сделать. Вы сможете без особого труда воспользоваться функциями и при необходимости создать объектно-ориентированный код. В [[Массивы в PHP]] мы завершим начальное исследование PHP и рассмотрим работу с массивами.

---
