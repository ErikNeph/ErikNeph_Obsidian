---
date of creation: 2024-06-01T13:40:00
tags:
  - PHP
  - Programming
  - Practicum
  - Backend
  - WebDeveloping
  - IT
  - Practice
---
---
# Практикум по программированию на PHP



В предыдущих главах рассматривались элементы языка PHP. А эта глава поможет вам приобрести навыки программирования в процессе решения типовых, но тем не менее важных практических задач. Здесь будут представлены лучшие способы обработки строк, позволяющие получить вполне понятный и лаконичный код, который включает усовершенствованное управление отображением даты и времени и демонстрируется браузерами в точном соответствии с вашими желаниями. Вы также узнаете о создании и разнообразных способах изменения файлов, включая файлы, выложенные на сайт пользователями.


## Функция **`printf`**
---

Ранее нам уже встречались функции **`print`** и **`echo`**, которые использовались для простого вывода текста в браузер. Но существует намного более мощная функция **`printf`**, управляющая форматом выводимых данных путем вставки в строку специальных форматирующих символов. Функция **`printf`** ожидает, что для каждого форматирующего символа будет предоставлен аргумент, который будет отображаться с использованием заданного формата. Например, в следующем фрагменте применяется спецификатор преобразования **`%d`**, чтобы значение 3 отображалось в виде десятичного числа:

```php
printf("В вашей корзине находится %d покупки", 3);
```

Если заменить **`%d`** на **`%b`**, значение 3 будет отображено в виде двоичного числа (11). В **табл. 7.1** показаны поддерживаемые функцией спецификаторы преобразования.

В функции **`printf`** можно использовать любое количество спецификаторов, если им передается соответствующее количество аргументов и если каждый спецификатор предваряется символом **`%`**. Поэтому следующий код имеет вполне
допустимую форму и выводит предложение **`Меня зовут Симон. Мне 33 года, то есть 21 в шестнадцатеричном представлении`**:

```php
printf("Меня зовут %s. Мне %d года, то есть %Х в шестнадцатеричном
    представлении", 'Симон', 33, 33);
```

**Таблица 7.1.** Спецификаторы преобразования, используемые в функции **`printf`**
![[Таблица 7.1. Спецификаторы преобразования, используемые в функции printf.jpg]]

Если пропустить какой-нибудь аргумент, то будет получена ошибка синтаксического разбора, информирующая о том, что правая круглая скобка (**`)`**) встретилась в неожиданном месте или что аргументов слишком мало.

Более полезный с практической точки зрения пример использования функции **`printf`** устанавливает цвета в коде HTML, используя для этого десятичные числа. Предположим, к примеру, что вам нужен цвет, составленный из трех значений: 65 для красного, 127 для зеленого и 245 для синего цвета, но вам не хочется самостоятельно переводить эти числа в шестнадцатеричный формат. Для этого есть более простое решение:

```php
printf("<span style='color:#%X%X%X'>Привет</span>", 65, 127, 245);
```

Тщательно разберитесь с цветовой спецификацией, которая заключена в апострофы (**`''`**). Сначала ставится знак решетки (**`#`**), ожидаемый в цветовой спецификации. Затем следуют три форматирующие спецификации **`%X`**, по одной для каждого из ваших чисел. В результате эта команда выдаст такой текст:
```php
<span style='color:#417FF5'>Привет</span>
```

Обычно представляется удобным в качестве аргументов **`printf`** использовать переменные или выражения. Например, если значения для цветового решения хранятся в трех переменных — **`$r`**, **`$g`** и **`$b`**, то более темный оттенок можно получить с помощью выражения:

```php
printf("<span style='color:#%X%X%X'>Привет</span>", $r-20, $g-20, $b-20);
```


### Настройка представления данных
---
Можно указать не только тип преобразования, но и точность отображаемого результата. Например, суммы в валюте отображаются, как правило, с точностью до двух цифр. Но после вычисления значение может иметь более высокую точность (например, если разделить 123,42 на 12, то получится 10,285). Чтобы обеспечить правильное внутреннее хранение таких значений, но при этом организовать их отображение с точностью только до двух цифр, можно между символом **`%`** и спецификатором преобразования вставить строку **`".2"`**:

```php
printf("Результат: $%.2f", 123.42 / 12);
```

Эта команда выводит следующий текст:

```php
Результат: $10.29
```

Но доступные средства управления на этом не заканчиваются, потому что можно также указать, где и чем — нулями или пробелами — дополнить выводимый текст, поставив перед спецификатором соответствующие значения. В **примере 7.1** показаны пять возможных комбинаций.

**Пример 7.1.** Настройка преставления данных точности
```php
<?php
  echo "<pre>";  // Тег позволяющий отображать все пустые пространства

  // Дополнение пробелами до 15 знакомест
  printf("Результат равен $%15f\n", 123.42 / 12);

  // Дополнение нулями до 15 знакомест
  printf("Результат равен $%015f\n", 123.42 / 12);

  // Дополнение пробелами до 15 знакомест и вывод с точностью
  // до двух десятичных знаков
  printf("Результат равен $%15.2f\n", 123.42 / 12);

  // Дополнение нулями до 15 знакомест и округление до 2х десятичных знаков
  printf("Результат равен $%015.2f\n", 123.42 / 12);

  // Дополнение символами # до 15 знакомест и вывод с точностью
  // до двух десятичных знаков
  printf("Результат равен $%'#15.2f\n", 123.42 / 12);
?>
```

Этот пример выводит следующий текст:

```php
Результат равен $ 10.285000
Результат равен $00000010.285000
Результат равен $ 10.29
Результат равен $000000000010.29
Результат равен $##########10.29
```

Проследить работу спецификатора проще, если изучать его слева направо **`(табл. 7.2)`**. Обратите внимание на следующие моменты.

- Крайним справа символом спецификатора преобразования в данном случае является **`f`**, означающий преобразование в число с плавающей точкой.
- Если сразу же перед спецификатором преобразования стоит сочетание точки и числа, значит, этим числом указана точность выводимой информации.
- Независимо от присутствия спецификатора точности, если в общем спецификаторе есть число, то оно представляет собой количество знакомест, выделяемых под выводимую информацию. В предыдущем примере это количество равно 15. Если выводимая информация уже равна количеству выделяемых знакомест или превышает его, то данный аргумент игнорируется.
- После крайнего слева символа **`%`** разрешается поставить символ 0, который игнорируется, если не указано количество выделяемых знакомест. Если это количество указано, то вместо пробелов дополнение производится нулями. Если нужно, чтобы пустующие знакоместа заполнялись не нулями или пробелами, а каким-нибудь другим символом, то можно выбрать любой символ, поставив перед ним одинарную кавычку: **`'#`**.
- В левой части спецификатора ставится символ **`%`**, с позиции которого и начинается преобразование.

**Таблица 7.2.** Компоненты спецификатора преобразования
![[Таблица 7.2. Компоненты спецификатора преобразования.jpg]]


### Дополнение строк
---
Дополнить до требуемой длины можно не только числа, но и строки, выбирая для этого различные дополняющие символы и даже левую или правую границу выравнивания. Возможные варианты показаны в **примере 7.2.**

**Пример 7.2.** Дополнение строк
```php
<?php
  echo "<pre>";  // Тег позволяющий отображать все пустые пространства
  $h = 'Rasmus';

  printf("[%s]\n",            $h);  // Стандартный вывод строки
  printf("[%12s]\n",          $h);  // Выравнивание пробелами по правому краю
  printf("[%-12s]\n",         $h);  // Выравнивание пробелами по левому краю
  printf("[%-12.2s]\n",       $h);  // Выравнивание пробелами по левому краю                                      // и округление до 2х знаков
  printf("[%'#12s]\n",        $h);  // Использование специального выбранного                                      // символа дополнения '#'
  $d = 'Rasmus Lerdorf';

  printf("[%12.8s]\n",        $d);  // Выравнивание по правому краю с                                             //  усечением до 8 символов
  printf("[%-12.12s]\n",      $d);  // Выравнивание по левому краю с                                              //  усечением до 12 символов
  printf("[%-'@12.10s]\n",    $d);  // Выравнивание по левому краю с                                              //  усечением до 12 символов и замена                                         //  пробелов на символ '@'
?>
```

Обратите внимание на то, что для получения нужной разметки на веб-странице я воспользовался HTML-тегом **`<pre>`**, который оставляет нетронутыми все пустые пространства и после каждой отображаемой строки выводит на экран символ новой строки **`\n`**. В этом примере выводится следующий текст:

```php
[Rasmus]
[ Rasmus]
[Rasmus ]
[Ra ] 
[######Rasmus]

[ Rasmus L]
[Rasmus Lerdo]
[Rasmus Ler@@]
```

Если при указании количества знакомест длина строки уже равна этому количеству или превышает его, это указание будет проигнорировано, если только заданное количество символов, до которого нужно усечь строку, не будет меньше указанного количества знакомест.

**В табл. 7.3** показаны спецификаторы преобразования строки, разложенные на компоненты.

**Таблица 7.3.** Компоненты спецификаторов преобразования строки
![[Таблица 7.3. Компоненты спецификаторов преобразования строки.jpg]]


### Функция **`sprintf`**
---
Зачастую результат преобразования нужно не выводить на экран, а использовать в самом коде программы. Для этого предназначена функция sprintf. Она позволяет не отправлять выходную информацию браузеру, а присваивать ее какой-нибудь переменной.

Функции **`sprintf`** можно использовать для преобразования, возвращающего шестнадцатеричное строковое значение для цветового сочетания RGB 65, 127, 245, которое присваивается переменной **`$hexstring`**:

```php
$hexstring = sprintf("%X%X%X", 65, 127, 245);
```

Или же она может пригодиться для сохранения выходной информации в переменной для иного использования или демонстрации:

```php
$out = sprintf("Результат: $%.2f", 123.42 / 12);
echo $out;
```


## Функции даты и времени
Для отслеживания даты и времени в PHP используются ==стандартные отметки времени UNIX==, представляющие собой простое количество секунд, прошедших с начала отсчета — 1 января 1970 года. Для определения текущей отметки времени можно воспользоваться функцией **`time`**:

```php
echo time();
```

Поскольку значение хранится в секундах, для получения метки времени ровно через неделю можно воспользоваться следующим выражением, в котором к возвращаемому значению прибавляется 7 дней × 24 ч × 60 мин × 60 с:

```php
echo time() + 7 * 24 * 60 * 60;
```

Если нужно получить отметку времени для заданной даты, можно воспользоваться функцией **`mktime`**. Она выводит отметку времени 1669852800 для первой секунды первой минуты первого часа первого дня декабря 2022 года:

```php
echo mktime(0, 0, 0, 12, 1, 2022);
```

Этой функции передаются следующие параметры (слева направо):

- количество часов (0–23);
- количество минут (0–59);
- количество секунд (0–59);
- номер месяца (1–12);
- номер дня (1–31);
- год (1970–2038, или 1901–2038 при использовании PHP 5.1.0 + 32-разрядной системы со знаком числа).

>[!info]
>Вы можете спросить: почему годы ограничены отрезком с 1970-го до 2038-й? Причина в том, что разработчики первой версии UNIX выбрали 1970 год в качестве начала отсчета времени, опускаться ниже которого не понадобится ни одному программисту.
>
>К счастью, благодаря тому что PHP, начиная с версии 5.1.0, поддерживает системы, использующие 32-разрядные целые числа со знаком, в нем разрешается применение дат от 1901 и до 2038 года. Но второе ограничение еще хуже первого и обусловлено тем, что разработчики UNIX также решили, что по прошествии 70 лет никто уже не будет пользоваться их системой, и поэтому они были уверены, что для хранения отметки времени им вполне хватит 32-разрядного значения, которое будет вмещать даты только до 19 января 2038 года.
>
>Это ограничение вызовет сбой, известный как **Y2K38** (очень похожий на проблему 2000 года, которая была вызвана тем, что года хранились в виде значений из двух цифр, и также требовала своего решения). Для решения этой проблемы в PHP версии 5.2 был введен класс **`DateTime`**, но он работает только в 64-разрядной архитектуре, на основе которой в наше время построено большинство компьютеров (но перед использованием этого класса нужно все же убедиться в наличии такой архитектуры).

Для отображения даты используется функция **`date`**, поддерживающая множество настроек форматирования, которые позволяют выводить дату любым желаемым способом. Эта функция имеет следующий синтаксис:

```php
date($format, $timestamp);
```

Параметр **`$format`** должен быть строкой, в которой содержатся спецификаторы форматирования, подробно описанные в **табл. 7.4**, а параметр **`$timestamp`** должен быть ==отметкой времени в стандарте UNIX==. Полный перечень спецификаторов приведен в документации по адресу https://tinyurl.com/phpdate. Следующая команда выведет текущее время и дату в формате
**`Monday February 17th, 2025 – 1:38pm`**:

```php
echo date("l F jS, Y – g:ia", time());
```

**Таблица 7.4.** Основные спецификаторы формата, использующиеся в функции **`date`**
![[Таблица 7.4. Основные спецификаторы формата, использующиеся в функции date.jpg]]
![[Таблица 7.4. Основные спецификаторы формата, использующиеся в функции date 2 часть.jpg]]


### Константы, связанные с датами
---
Существуют полезные константы, которые можно использовать с командами, связанными с датами, для того чтобы они вернули дату в определенном формате. Например, **`date(DATE_RSS)`** возвращает текущую дату и время в формате, который применяется в RSS-потоке. Наиболее часто используются следующие константы.

- **`DATE_ATOM`** — формат для потоков Atom. PHP-формат имеет вид **`"Y-m-d\ TH:i:sP"`**, а выводимая информация — **`"2025-05-15T12:00:00+00:00"`**.
- **`DATE_COOKIE`** — формат для cookie, устанавливаемый веб-сервером или JavaScript. PHP-формат имеет вид **`"l, d-M-y H:i:s T"`**, а выводимая информация — **`"Thursday, 15-May-25 12:00:00 UTC"`**.
- **`DATE_RSS`** — формат для потоков RSS. PHP-формат имеет вид **`"D, d M Y H:i:s T"`**, а выводимая информация — **`"Thu,15 May 2025 12:00:00 UTC"`**.
- **`DATE_W3C`** — формат для Консорциума Всемирной паутины, World Wide Web Consortium. PHP-формат имеет вид **`"Y-m-d\TH:i:sP"`**, а выводимая информация — **`"2025-05-15T12:00:00+00:00"`**.

Полный перечень приведен по адресу https://tinyurl.com/phpdatetime.


### Функция **`checkdate`**
---
Как отобразить допустимую дату в различных форматах, вы уже видели. А как проверить, что пользователь передал такую дату вашей программе? Нужно передать месяц, день и год функции **`checkdate`**, которая вернет значение **`TRUE`**, если ей передана допустимая дата, или значение **`FALSE`** в противном случае.

Например, если введена дата 31 сентября любого года, то она всегда будет недопустимой. В **примере 7.3** показан код, который можно использовать для этой цели. В данных условиях он признает указанную дату недопустимой.

**Пример 7.3.** Проверка допустимости даты
```php
<?php
  $month = 9;  // Сентябрь (в котором 30 дней)
  $day = 31;  // 31-е
  $year = 2025;  // 2025

  if (checkdate($month, $day, $year)) echo "Допустимая дата";
  else echo "Недопустимая дата";
?>
```


## Работа с файлами
При всех своих достоинствах MySQL не является единственным (или самым лучшим) способом хранения всех данных на веб-сервере. Иногда бывает быстрее и удобнее обращаться непосредственно к файлам, хранящимся на диске. Это может потребоваться при изменении изображений, например выложенных пользователями аватаров, или файлов регистрационных журналов, требующих обработки.

Прежде всего следует упомянуть об именах файлов. Если создается код, который может использоваться на различных установках PHP, то узнать о том, чувствительна система к регистру букв или нет, практически невозможно. Например, имена файлов в Windows и macOS нечувствительны к регистру, а в Linux и UNIX — чувствительны. Поэтому нужно принять за основу то, что система чувствительна к регистру, и придерживаться соглашения о присваивании файлам имен в нижнем регистре.


### Проверка существования файла
---
Чтобы проверить факт существования файла, можно воспользоваться функцией **`file_exists`**, которая возвращает либо **`TRUE`**, либо **`FALSE`** и применяется следующим образом:

```php
if (file_exists("testfile.txt")) echo "Файл существует";
```


### Создание файла
---
В данный момент файла **`testfile.txt`** не существует, поэтому создадим его и запишем в него несколько строк. Наберите код, показанный в **примере 7.4**, и сохраните его под именем **`testfile.php`**.

**Пример 7.4.** Создание простого текстового файла
```php
<?php  // testfile.php
  $fh = fopen("testfile.txt", "w") or die("Создать файл не удалось");
  $text = <<<_END
  Строка 1
  Строка 2
  Строка 3
  _END;

    fwrite($fh, $text) or die("Сбой записи файла");
    fclose($fh);
    echo "Файл 'testfile.txt' создан успешно";
?>
```

Если в программе выполняется вызов функции **`die`**, открытый файл автоматически закрывается в рамках общего завершения программы.

Если этот код будет запущен через браузер, то при его успешном выполнении появится следующее сообщение: Файл **`'testfile.txt'`** записан успешно. Если будет выведено сообщение об ошибке, значит, на диске недостаточно свободного места или, что более вероятно, отсутствует разрешение на создание файла или на запись в этот файл. В таком случае нужно изменить атрибуты папки назначения в соответствии с требованиями вашей операционной системы. Если все обойдется без ошибки, то файл **`testfile.txt`** попадет в ту же папку, где был сохранен программный файл **`testfile.php`**. Если открыть файл в текстовом или программном редакторе, в нем будет следующее содержимое:

```txt
Строка 1
Строка 2
Строка 3
```

В этом простом примере показана последовательность работы со всеми файлами.

1. Все начинается с открытия файла с помощью вызова функции **`fopen`**.
2. После этого можно вызывать другие функции. В данном случае в файл велась запись (**`fwrite`**), но можно также читать данные из уже существующего файла (**`fread`** или **`fgets`**) и осуществлять с ним другие действия.
3. Работа завершается закрытием файла (**`fclose`**). Хотя программа перед завершением своей работы делает это за вас, но все же вы должны удостовериться в том, что по окончании работы с файлом он будет закрыт.

Каждому открытому файлу требуется файловый ресурс, чтобы PHP-программа могла к нему обращаться и им управлять. В предыдущем примере переменной **`$fh`** (которую я выбрал в качестве *описателя* файла) присваивается значение, возвращаемое функцией **`fopen`**. После этого каждой функции обработки файла, которая получает к нему доступ, например **`fwrite`** или **`fclose`**, в качестве параметра должна быть передана переменная **`$fh`**, чтобы идентифицировать обрабатываемый файл. Интересоваться содержимым переменной **`$fh`** не стоит, это всего лишь номер, используемый PHP для ссылки на внутреннюю информацию о файле. Данная переменная используется только для передачи другим функциям.

В случае сбоя функция **`fopen`** возвращает значение **`FALSE`**. В предыдущем примере показан простой способ перехвата управления и реакции на сбой: в нем вызывается функция **`die`**, которая завершает программу и выдает пользователю сообщение об ошибке. Это упрощенный способ выхода подходит лишь для наших учебных программ, а выходить с его помощью из веб-приложения не следует ни в коем случае (вместо этого нужно создать веб-страницу с сообщением об ошибке).

Обратите внимание на второй параметр, используемый в вызове функции **`fopen`**. Это символ **`w`**, предписывающий функции открыть файл для записи. Если такого файла нет, то он будет создан. Применять эту функцию следует с оглядкой: если файл уже существует, то параметр режима работы **`w`** заставит функцию **`fopen`** удалить все его прежнее содержимое (даже если в него не будет записано ничего нового!).

В **табл. 7.5** перечислены различные параметры режима работы, которые могут быть использованы при вызове этой функции. Режимы, включающие символ **`+`**, будут рассмотрены далее в разделе «Обновление файлов».

**Таблица 7.5.** Режимы работы, поддерживаемые функцией **`fopen`**
![[Таблица 7.5. Режим работы, поддерживаемые функцией fopen.jpg]]


### Чтение файлов
---
Проще всего прочитать текстовый файл, извлекая из него всю строку целиком, для чего, как в **примере 7.5**, используется функция **`fgets`** (последняя буква s в названии функции означает string — «строка»).

**Пример 7.5.** Чтение файла с помощью функции **`fgets`**
```php
<?php
  $fh = fopen("testfile.txt", "r") or
  die("Файла не существует или вы не обладаете правами на его открытие!");
  $line = fgets($fh);

  fclose($fh);
  echo $line;
?>
```

Если используется файл, созданный кодом из **примера 7.4**, будет получена первая строка:

```php
Строка 1
```

Можно также извлечь из файла сразу несколько строк или фрагменты строк, воспользовавшись функцией **`fread`**, как показано в **примере 7.6**.

**`Пример 7.6.`** Чтение файла с помощью функции **`fread`**
```php
<?php
  $fh = fopen("testfile.txt", "r") or
  die("Файла не существует!");

  $text = fread($fh, 3);
  fclose($fh);
  echo $text;
?>
```

При вызове функции **`fread`** было запрошено чтение трех символов, поэтому программа отобразит следующий текст:

```php
Стр
```

Функция **`fread`** обычно применяется для чтения двоичных данных. Но если она используется для чтения текстовых данных объемом более одной строки, следует принимать в расчет символы новой строки.


### Копирование файлов
---
Попробуем создать клон нашего файла **`testfile.txt`**, воспользовавшись PHP функцией **`copy`**. Наберите текст **примера 7.7** и сохраните его в файле **`copyfile.php`**, а затем вызовите программу через браузер.

**Пример 7.7.** Копирование файла
```php
<?php
  copy("testfile.txt", "testfile2.txt") or die("Копирование невозможно");
  echo "Файл успешно скопирован в testfile2.txt";
?>
```

Если еще раз проверить содержимое вашей папки, в ней окажется новый файл **`testfile2.txt`**. Кстати, если вам не нужно, чтобы программа завершала свою работу после неудачной попытки копирования, можно воспользоваться другим вариантом синтаксиса, который показан в **примере 7.8**. В качестве быстрой и краткой записи в нем задействуется оператор ! (**`NOT`**). Его наличие перед выражением означает применение оператора **`NOT`** ко всему выражению, следовательно, эквивалентным утверждением становится «Если копирование невозможно…».

**Пример 7.8.** Альтернативный синтаксис для копирования файла
```php
<?php
  if (!copy("testfile.txt", "testfile2.txt")) echo "Копирование невозможно";
  else echo "Файл успешно скопирован в testfile2.txt";
?>
```


### Перемещение файла
---
Для перемещения файла его необходимо переименовать, как показано в **примере 7.9**.

**Пример 7.9.** Перемещение файла
```php
<?php
  if (rename("testfile2.txt", "testfile2.new"))
    echo "Переименование невозможно.";
  else echo "Файл успешно переименован в testfile2.new";
?>
```

Функцию переименования можно применять и к каталогам. Чтобы избежать предупреждений при отсутствии исходных файлов, сначала для проверки факта их существования можно вызвать функцию **`file_exists`**.


### Удаление файла
---
Для удаления файла из файловой системы достаточно, как показано в **примере 7.10**, воспользоваться функцией **`unlink`**, позволяющей сделать это.

**Пример 7.10.** Удаление файла
```php
<?php
  if (!unlink('testfile2.new')) echo "Удаление невозможно.";
  else echo "Файл 'testfile2.new' удален успешно.";
?>
```

>[!danger]
>При непосредственном доступе к файлам на жестком диске нужна гарантия того, что ваша файловая система не будет поставлена под угрозу. Например, при удалении файла на основе введенной пользователем информации нужно быть абсолютно уверенным в том, что этот файл может быть удален без ущерба безопасности системы и что пользователю разрешено удалять его.

В данном случае, как и при операции перемещения, если файла с таким именем не существует, будет выведено предупреждение, появления которого можно избежать, если использовать функцию **`file_exists`** для проверки его существования перед вызовом функции **`unlink`**.


### Обновление файлов
---
Довольно часто возникает потребность добавлять к сохраненному файлу дополнительные данные, для чего существует множество способов. Можно воспользоваться одним из режимов добавления данных (см. табл. 7.5) или же задействовать режим, поддерживающий запись, и просто открыть файл для чтения и записи и переместить указатель файла в то место, с которого необходимо вести запись в файл или чтение из файла.

*Указатель* файла — это позиция внутри файла, с которой будет осуществлен очередной доступ к файлу при чтении или записи. Его не следует путать с *описателем* файла (который в **примере 7.4** хранился в переменной **`$fh`**), содержащим сведения о том файле, к которому осуществляется доступ.

Если набрать код, показанный в **примере 7.11**, сохранить его в файле **`update.php`**, а затем вызвать его из своего браузера, то можно увидеть работу указателя.

**Пример 7.11.** Обновление файла
```php
<?php
  $fh = fopen("testfile.txt", "r+") or die("Сбой открытия файла");
  $text = fgets($fh);

  fseek($fh, 0, SEEK_END);
  fwrite($fh, "\n$text") or die("Сбой записи файла");
  fclose($fh);
 
  echo "Файл 'testfile.txt' успешно обновлен.";
?>
```

Эта программа открывает файл **`testfile.txt`** для чтения и записи, для чего указывается режим работы **`'r+'`**, в котором указатель устанавливается в самое начало файла. Затем используется функция **`fgets`**, с помощью которой из файла считывается одна строка (до встречи первого символа перевода строки). После этого вызывается функция **`fseek`**, чтобы переместить указатель файла в самый конец, куда затем добавляется строка, которая была извлечена из начала файла и сохранена в переменной **`$text `**(перед этим выводится строка **`\n`**), после чего файл закрывается. Получившийся в итоге файл имеет следующий вид:

```txt
Строка 1
Строка 2
Строка 3
Строка 1
```

Первая строка была успешно скопирована, а затем добавлена в конец файла.
В данном примере функции **`fseek`**, кроме *описателя* файла **`$fh`**, были переданы еще два параметра — 0 и **`SEEK_END`**. Параметр **`SEEK_END`** предписывает функции переместить указатель файла в его конец, а параметр 0 показывает, на сколько позиций нужно вернуться назад из этой позиции. В **примере 7.11** используется значение 0, потому что указатель должен оставаться в конце файла.

С функцией **`fseek`** можно задействовать еще два режима установки указателя: **`SEEK_SET`** и **`SEEK_CUR`**. Режим **`SEEK_SET`** предписывает функции установку указателя файла на конкретную позицию, заданную предыдущим параметром. Поэтому в следующем примере указатель файла перемещается на позицию 18:

```php
fseek($fh, 18, SEEK_SET);
```

Режим **`SEEK_CUR`** приводит к установке указателя файла на позицию, которая смещена от текущей позиции на заданное значение. Если в данный момент указатель файла находится на позиции 18, то следующий вызов функции переместит его на позицию 23:

```php
fseek($fh, 5, SEEK_CUR);
```


### Блокирование файлов при коллективном доступе
---
Веб-программы довольно часто вызываются многими пользователями в одно и то же время. Когда одновременно предпринимается попытка записи в файл более чем одним пользователем, файл может быть поврежден. А когда один пользователь ведет в него запись, а другой считывает из него данные, с файлом ничего не случится, но читающий может получить весьма странные результаты.

Чтобы обслужить сразу несколько одновременно обращающихся к файлу пользователей, нужно воспользоваться функцией блокировки файла **`flock`**. Эта функция ставит в очередь все другие запросы на доступ к файлу до тех пор, пока ваша программа не снимет блокировку. Когда ваши программы обращаются к файлу, который может быть одновременно доступен нескольким пользователям, с намерением произвести в него запись, к коду нужно также добавлять задание на блокировку файла как в *примере 7.12*, который является обновленной версией *примера 7.11*.

**Пример 7.12.** Обновление файла с использованием блокировки
```php
<?php
  $fh = fopen("testfile.txt", "r+") or die("Сбой открытия файла");
  $text = fgets($fh);

  if (flock($fh, LOCK_EX))
  {
    fseek($fh, 0, SEEK_END);
    fwrite($fh, "$text") or die("Сбой записи файла");
    flock($fh, LOCK_UN);
  }

  fclose($fh);
  echo "Файл 'testfile.txt' успешно обновлен.";
?>
```

При блокировке файла для посетителей вашего сайта нужно добиться наименьшего времени отклика: блокировку следует ставить непосредственно перед внесением изменений в файл и снимать ее сразу же после их внесения. Блокировка файла на более длительный период приведет к неоправданному замедлению работы приложения. Поэтому в **примере 7.12** функция **`flock`** вызывается непосредственно до и после вызова функции **`fwrite`**.

При первом вызове **`flock`** с помощью параметра **`LOCK_EX`** устанавливается эксклюзивная блокировка того файла, ссылка на который содержится в переменной **`$fh`**:

```php
flock($fh, LOCK_EX);
```

С этого момента и далее никакой другой процесс не может осуществлять не только запись, но даже чтение файла до тех пор, пока блокировка не будет снята с помощью передачи функции параметра **`LOCKJJN`**:

```php
flock($fh, LOCKJJN);
```

Как только блокировка будет снята, другие процессы снова получат возможность доступа к файлу. Это одна из причин, по которой необходимо заново обращаться к нужному месту в файле при каждом чтении или записи данных: со времени последнего обращения к нему другой процесс мог внести в этот файл изменения.

Кстати, вы заметили, что вызов с требованием эксклюзивной блокировки вложен в структуру инструкции **`if`**? Дело в том, что **`flock`** поддерживается не во всех системах, и поэтому есть смысл проверить успешность установки блокировки, так как известно, что некоторые системы на это не способны.

>[!danger]
>Функция **`flock`** не будет работать в сетевой файловой системе NFS и во многих других файловых системах, основанных на применении сетей. Не стоит полагаться на flock и при использовании многопоточных серверов типа ISAPI, потому что она не защитит файлы от доступа из кода PHP-сценариев, запущенных в параллельных потоках на том же физическом сервере. Кроме того, **`flock`** не поддерживается в любых системах, использующих устаревшую файловую систему FAT, например в устаревших версиях Windows, хотя (я надеюсь) вам вряд ли придется столкнуться с такими системами.
>
>Если на этот счет есть сомнения, можно попробовать установить в начале программы быструю блокировку на тестовый файл, чтобы посмотреть, можно ли получить блокировку на файл. Не забудьте после проверки снять с него блокировку (и, возможно, удалить его, если он больше не нужен).
>
>Не следует также забывать, что любой вызов функции **`die`** приводит к автоматическому снятию блокировки и закрытию файла в рамках общего завершения программы.

Следует также принять во внимание, что действия функции **`flock`** относятся к так называемой *рекомендательной* блокировке. Это означает, что блокируются только те процессы, которые вызывают эту функцию. Если есть код, который действует напрямую и изменяет файлы, не блокируя их с помощью **`flock`**, он всегда сможет обойти блокировку и внести хаос в ваши файлы.

Кстати, если в каком-то кодовом фрагменте заблокировать файл, а затем по рассеянности забыть его разблокировать, это может привести к ошибке, которую будет очень трудно обнаружить.


### Чтение всего файла целиком
---
Для чтения целиком всего файла без использования описателей файлов можно воспользоваться очень удобной функцией **`file_get_contents`**. Она очень проста в применении, о чем свидетельствует код **примера 7.13**.

**Пример 7.13**. Использование функции **`file_get_contents`**
```php
<?php
  echo "<pre>";  // Тег, позволяющий отображать переводы строк
  echo file_get_contents("testfile.txt");
  echo "</pre>";  // Прекращение действия тега <pre>
?>
```

Но эту функцию можно использовать и с большей пользой. С ее помощью можно извлечь файл с сервера через интернет. В **примере 7.14** показан запрос кода HTML с главной страницы сайта O’Reilly с последующим ее отображением, как при обычном переходе на саму веб-страницу. Полученный результат будет похож на копию страницы, приведенную на **рис. 7.1.**

**Пример 7.14.** Захват главной страницы сайта O’Reilly
```php
<?php
  echo file_get_contents("http://oreilly.com");
?>
```


### Загрузка файлов на веб-сервер
---
Загрузка файлов на веб-сервер вызывает затруднения у многих пользователей, но сделать этот процесс еще проще, чем он есть на самом деле, не представляется возможным. Для загрузки файла из формы нужно лишь выбрать специальный тип кодировки, который называется multipart/form-data, а все остальное сделает ваш браузер. Чтобы увидеть этот процесс в работе, наберите программу, представленную в **примере 7.15**, и сохраните ее в файле под именем **`upload.php`**. Когда этот файл будет запущен, в браузере появится форма, позволяющая загружать на сервер любой выбранный файл.

![[Рис. 7.1. Главная страница O`Reilly, захваченная с помощью функции file_get_contents.jpg]]
**Рис. 7.1.** Главная страница сайта O’Reilly, захваченная с помощью функции **`file_get_contents`**

**Пример 7.15.** Программа для загрузки изображений, хранящаяся
в файле **`upload.php`**
```php
<?php
  echo <<<_END
  <html><head><title>PHP форма для загрузки файлов
  на сервер</title></head><body> <form method='post'
  action='upload.php' enctype='multipart/form-data'>
  Выберете файл: <input type='file' name='filename' size='10'>
  <input type='submit' value='Загрузить'>
  </form>

_END;

  if ($_FILES)
  {
    $name = $_FILES['filename']['name'];
    move_uploaded_file($_FILES['filename']['tmp_name'], $name);
    echo "Загружаемое изображение '$name'<br><img src='$name'>";
  }

  echo "</body></html>";
?>
```

Проанализируем программу по блокам. В первой строке многострочной инструкции **`echo`** задается начало HTML-документа, отображается заголовок, а затем начинается тело документа.

Далее идет форма, для передачи содержимого которой выбран метод **`POST`**, задается предназначение всех отправляемых программе **`upload.php`** (то есть нашей программе) данных и указывается браузеру на то, что отправляемые данные должны быть закодированы с использованием типа содержимого **`multipart/form-data`**, вид **`mime`**, используемый для загрузки файлов.

Для подготовки формы в следующих строках задается отображение приглашения Выберите файл, а затем дважды запрашивается пользовательский ввод. Сначала от пользователя требуется указать файл. В параметрах ввода задается тип вводимой информации — **`input type`**, в качестве которого указан файл — **`file`**, имя — **`name`**, в качестве которого определено имя файла — **`filename`**, а также размер поля ввода — **`size`**, в качестве которого указана ширина поля, составляющая 10 символов.

Затем от пользователя требуется ввести команду на отправку данных формы, для чего служит кнопка с надписью Загрузить (эта надпись заменяет текст, используемый по умолчанию, — **`Submit Query`**, что означает «Отправить запрос»). После этого форма закрывается.

В этой небольшой программе показана весьма распространенная технология веб-программирования, в которой одна и та же программа вызывается дважды: один раз при первом посещении страницы, а второй — когда пользователь нажимает кнопку отправки формы.

PHP-код, предназначенный для приема загружаемых данных, предельно прост, поскольку все загружаемые на сервер файлы помещаются в ассоциативный системный массив **`$_FILES`**. Поэтому для установки факта отправки пользователем файла достаточно проверить, есть ли у массива **`$_FILES`** хоть какое-нибудь содержимое. Эта проверка осуществляется с помощью инструкции **`if ($_FILES)`**.

При первом посещении страницы пользователем, которое происходит еще до загрузки файла, массив **`$_FILES`** пуст, поэтому программа пропускает этот блок кода. Когда пользователь загружает файл, программа запускается еще раз и обнаруживает присутствие элемента в массиве **`$_FILES`**.

Когда программа обнаружит, что файл был загружен, его имя, каким оно было прочитано из компьютера, занимавшегося загрузкой, извлекается и помещается в переменную **`$name`**. Теперь нужно только переместить файл из временного места, где PHP хранит загруженные файлы, в постоянное место хранения. Это делается с помощью функции **`move_uploaded_file`**, которой передается исходное имя файла, сохраняемого в текущем каталоге.

И наконец, загруженное на сервер изображение отображается путем помещения его имени в тег **`IMG`**. Возможный результат показан на **рис. 7.2**.

>[!danger]
>Если при запуске программы в ответ на вызов функции **`move_uploaded_file`** будет получено предупреждение об отсутствии прав доступа — Permission denied, значит, у вас нет права на доступ к папке, из которой запущена программа.

![[Рис. 7.2. Загрузка изображения с помощью формы данных.jpg]]


### Использование массива **`$_FILES`**
---
При загрузке файла на сервер в массиве **`$_FILES`** сохраняются пять элементов, показанных в **табл. 7.6** (где используется загружаемый файл, имя которого предоставляется отправляемой серверу формой).

**Таблица 7.6.** Содержимое массива **`$_FILES`**
![[Таблица 7.6. Содержимое массива _FILES.jpg]]

Типы содержимого обычно называли *MIME-типами* (Multipurpose Internet Mail Extension — многоцелевые почтовые расширения в интернете). Но поскольку позже они были распространены на все виды передаваемой через интернет информации, то теперь их часто называют *типами информации, используемой в интернете*(Internet Media Types). **В табл. 7.7** показаны некоторые из наиболее часто используемых типов, появляющиеся в элементе массива **`$_FILES['файл']['тип'].`**

Дополнительная информация о MIME-типах - [[MIME-типы(MIME-types)]]

**Таблица 7.7.** Некоторые наиболее распространенные типы информации, используемой в интернете
![[Таблица 7.7. Некоторые наиболее распространенные типы информации, используемой в интернете.jpg]]


### Проверка допустимости
---
Надеюсь, что не нужно говорить (хотя я все равно это сделаю) о крайней важности проверки допустимости присланных формой данных, обусловленной существующей для пользователей возможностью взломать ваш сервер.

Вдобавок к проверке вредоносности введенных данных нужно также проверить, был ли файл получен, и если он получен, то был ли отправлен правильный тип данных.

С учетом всего этого программа **`upload.php`** была превращена в программу **`upload2.php`**, показанную в **примере 7.16.**

**Пример 7.16**. Более безопасная версия **`upload.php`**
```php
<?php
echo <<<_END
  <html?><head><title>PHP-форма для загрузки файлов
  на сервер</title></head><body>
  <form method='post' action='upload2.php' enctype='multipart/form-data'>
  Выберете файл с расширением JPG, GIF, PNG или TIF:
  <input type='file' name='filename' size='10'>
  <input type='submit' value='Загрузить'></form>
_END;

if ($_FILES) {
    $name = $_FILES['filename']['name'];
    
    switch ($_FILES['filename']['type']) {
        case 'image/jpeg':
            $ext = 'jpg';
            break;
        case 'image/gif':
            $ext = 'gif';
            break;
        case 'image/png':
            $ext = 'png';
            break;
        case 'image/tiff':
            $ext = 'tif';
            break;
        default:
            $ext = '';
            break;
    }

    if ($ext) {
        $n = "image.$ext";
        move_uploaded_file($_FILES['filename']['tmp_name'], $n);
        echo "Загружено изображение '$name' под именем '$n':<br>";
        echo "<img src='$n'>";

    } else echo "'$name' - непреемлемый файл изображения";

} else echo "Загрузки изображений не произошло.";

echo "</body></html>";
```

Блок, не содержащий HTML-кода, был расширен, и теперь вместо шести строк примера 7.15 в нем содержится 20 строк, начиная с **`if ($_FILES)`**.

Как и в предыдущей версии, в этой строке **`if`** выполняется проверка факта отправки данных, но теперь у этой инструкции ближе к концу программы есть и соответствующая ей инструкция **`else`**, которая выводит на экран сообщение о том, что загрузки изображения не произошло.

В теле инструкции **`if`** переменной **`$name`** присваивается значение имени файла, полученное (как и прежде) от загружающего компьютера, но на этот раз мы не полагаемся на то, что пользователь отправил нам приемлемые данные. Вместо этого используется инструкция **`switch`**, предназначенная для проверки соответствия типа загружаемого контекста четырем типам изображений, которые поддерживаются этой программой. При обнаружении соответствия переменной **`$ext`** присваивается трехсимвольное расширение имени файла, относящееся к этому типу. Если соответствие не обнаружится, значит, загруженный файл не относится к приемлемому типу и переменной **`$ext`** будет присвоена пустая строка "".

>[!info]
>В этом примере тип файла все еще определяется браузером и может быть модифицирован или изменен пользователем, загружающим файл. В данном случае подобные манипуляции пользователя не вызывают беспокойства, поскольку файлы рассматриваются только в качестве изображений. Но если файл может быть исполняемым, вам не следует полагаться на информацию, в абсолютной достоверности которой вы не убедились.

В следующем блоке кода проверяется, содержит ли переменная **`$ext`** строку, и при положительном ответе в переменной **`$n`** создается новое имя файла, составленное из основы image и расширения, сохраненного в переменной **`$ext`**. Это означает, что программа полностью контролирует тип создаваемого файла и этим типом может быть только один из следующих: ==image.jpg, image.gif, image.png или image.tif.==****

Поскольку программе больше ничего не угрожает, остальной PHP-код похож на код предыдущей версии. Он перемещает загруженное временное изображение на его новое место, затем выводит его на экран, а вместе с ним отображает старое и новое имена изображения.

>[!info]
>Об удалении временного файла, созданного PHP в процессе загрузки, беспокоиться не стоит, поскольку если файл не был перемещен или переименован, он будет удален автоматически, как только программа завершит свою работу.

Когда по условию инструкции **`if`** произойдет переход к инструкции **`else`**, которая выполняется только в том случае, если загружен неподдерживаемый тип изображения, программа выводит сообщение об ошибке.

Я настоятельно рекомендую применить такой же подход и использовать заранее подобранные имена и места для загружаемых файлов, когда вы будете создавать собственную программу загрузки. Тогда будут исключены любые попытки добавления к используемым переменным каких-нибудь других путевых имен и других данных, способных нанести вред. Если подразумевается, что несколько пользователей могут загружать файл с одним и тем же именем, то такие файлы можно снабжать префиксами, представляющими собой имена пользователей, или сохранять их в отдельных папках, созданных для каждого пользователя.

Но если нужно использовать предоставленное имя файла, его следует обезвредить, разрешив применение только буквенно-цифровых символов и точки, что можно сделать с помощью следующей команды, использующей регулярное выражение для осуществления поиска и замены символов в значении переменной **$name**:
```php
$name = preg_replace("[^A-Za-z0-9.]/", "", $name);
```

Эта команда оставляет в строковой переменной $name только символы A–Z, a–z, 0–9 и точку, а прочие символы удаляет.

Для обеспечения работы своей программы во всех системах, независимо от их чувствительности к регистру букв, стоит воспользоваться другой командой, которая одновременно с предыдущими действиями переводит все символы верхнего регистра в нижний:

```php
$name = strtolower(preg_replace("[^A-Za-z0-9.]", "", $name));
```

>[!info]
>Иногда можно встретить тип содержимого image/pjpeg, который служит признаком прогрессивного JPEG-формата. Этот тип можно без лишних опасений добавить к вашему коду в качестве альтернативы для image/jpeg:
>```php
>case 'image/pjpeg':
case 'image/jpeg': $ext = 'jpg'; break;


### Системные вызовы
---
Иногда функцию для осуществления конкретного действия можно найти не в PHP, а в операционной системе, под управлением которой запущен этот язык. В таком случае для выполнения задачи можно применить системный вызов **`exec`**.

Например, для быстрого просмотра содержимого текущего каталога можно воспользоваться программой, показанной в **примере 7.17**. В процессе работы в системе Windows она не потребует изменений и задействует Windows-команду **`dir`**. В Linux, UNIX или macOS нужно будет закомментировать или удалить первую строку и убрать символы комментария из второй строки, чтобы применить системную команду **`ls`**. При желании можете набрать текст этой программы, сохранить его как **exec.php** и вызвать из своего браузера.

**Пример 7.17.** Выполнение системной команды
```php
<?php
  $cmd = "dir";
  // $cmd = "ls"; Для Linux, MacOS и иногда Windows!

  exec(escapeshellarg($cmd), $output, $status);

  if ($status) echo "Команда exec не выполнена";
  else
  {
    echo "<pre>";
    foreach ($output as $line) echo htmlspecialchars("$line\n");
    echo "<pre>";
  }
?>
```

**Пример 7.17(a).** Альтернативный код, если есть проблема с кодировкой в Windows 10/11
```php
<?php
  $cmd = "dir";
  exec($cmd, $output, $status);

  echo "Статус: $status<br>";  // Для отладки 0 - хорошо, 1 - плохо

  if ($status) echo "Команда exec не выполнена";
  else
  {
    echo "<pre>";
    foreach ($output as $line) {
        // Преобразуем каждую строку из CP866 в UTF-8
        $line_utf8 = iconv("CP866", "UTF-8", $line);
        echo htmlspecialchars("$line_utf8\n");
    }
    echo "</pre>";
  }
?>
```

Мой вывод:
```php
Статус: 0  

 Том в устройстве C не имеет метки.
 Серийный номер тома: 4A09-B346

 Содержимое папки C:\MAMP\htdocs

02.06.2024  09:01    <DIR>          .
02.06.2024  09:01    <DIR>          ..
02.06.2024  06:04           533 017 101917.jpg
01.06.2024  16:43               182 copyfile.php
01.06.2024  16:47               188 copyfile2.php
01.06.2024  16:59               159 deletefile.php
02.06.2024  09:26               449 exec.php
02.06.2024  07:48            49 786 gidle-minnie-2-0501231.jpeg
02.06.2024  07:58           174 430 image.jpg
03.03.2019  02:01             4 070 index.php
03.03.2019  02:01             5 793 MAMP-PRO-Logo.png
02.06.2024  06:06           677 166 Mona_Lisa.jpg
01.06.2024  16:54               208 movefile.php
24.05.2024  19:22               268 test.html
01.06.2024  18:15                60 test1.php
01.06.2024  16:08               358 testfile.php
01.06.2024  17:57                79 testfile.txt
01.06.2024  17:19               293 update.php
01.06.2024  17:53               371 update2.php
02.06.2024  05:56               616 upload.php
02.06.2024  07:50             1 317 upload2.php
              19 файлов      1 448 810 байт
               2 папок  163 891 781 632 байт свободно
```

Функция **`htmlspecialchars`** вызывается с целью превращения любых специальных символов, возвращаемых системой, в символы, которые могут быть восприняты и правильно отображены как код HTML, упорядочивая тем самым вывод.

В зависимости от рабочей системы в результате запуска этой программы будет выведена следующая информация (полученная при использовании *Windows-команды* **`dir`**):

```php
Volume in drive C is Hard Disk
    Volume Serial Number is DC63-0E29

    Directory of C:\Program Files (x86)\Ampps\www
11/04/2025 11:58 <DIR> .
11/04/2025 11:58 <DIR> .. 
28/01/2025 16:45 <DIR> 5th_edition_examples
08/01/2025 10:34 <DIR> cgi-bin
08/01/2025 10:34 <DIR> error
29/01/2025 16:18 1,150 favicon.ico
		1 File(s) 1,150 bytes
		5 Dir(s) 1,611,387,486,208 bytes free
```

Функция **`exec`** воспринимает три аргумента:

- саму команду (в предыдущем случае это **`$cmd`**);
- массив, в который система поместит информацию, получаемую в результате выполнения команды (в предыдущем случае это **`$output`**);
- переменную для хранения возвращаемого статуса вызова (в предыдущем случае это **`$status`**).

При желании параметры **`$output`** и **`$status`** можно опустить, но тогда ничего не будет известно ни о выходной информации, созданной в результате вызова, ни даже о том, насколько успешен был сам вызов.

Обратите внимание также на применение функции **`escapeshellcmd`**. Желательно выработать привычку постоянно использовать эту функцию при вызове функции exec, поскольку она обезвреживает содержимое командной строки, предотвращая выполнение случайных команд в том случае, если пользователю предоставляется возможность их ввода.

>[!danger]
>Как правило, функции системных вызовов на веб-хостах общего пользования запрещены как представляющие угрозу системе безопасности. По возможности все задачи нужно стараться решить средствами PHP и обращаться к системе напрямую только при крайней необходимости. Кроме того, вы должны знать, что обращение к системе выполняется довольно медленно, и если приложение рассчитано на запуск как в Windows, так и в Linux/UNIX, для него следует создавать две реализации вызова.


## XHTML или HTML5?
Поскольку документы XHTML должны иметь строго заданное оформление, их парсинг может проводиться с использованием стандартных XML-парсеров, в отличие от документов HTML, для которых требуется менее привередливый, специально приспособленный под HTML парсер. Поэтому XHTML так и не завоевал популярности, и когда настало время разработать новый стандарт, W3C отдал предпочтение не новому стандарту XHTML2, а поддержке HTML5.

HTML5 обладает множеством свойств как HTML4, так и XHTML, но при этом он намного проще в использовании и менее строг к проверке, и к нашему удовольствию, теперь имеется только один тип документа, объявляемый в заголовке документа HTML5 (вместо ранее требуемых разнообразных строгих, переходных и кадрированных типов):

```html
<!DOCTYPE html>
```

Простого слова **`html`** достаточно, чтобы сообщить браузеру, что ваша веб-страница разработана для HTML5, и поскольку все самые последние версии наиболее популярных браузеров начиная приблизительно с 2011 года поддер-живают большинство HTML5-спецификаций, этот тип документа, как правило, является единственно необходимым, если, конечно, не сделать выбор в пользу обслуживания устаревших браузеров.

Для всех целей и намерений при написании HTML-документов веб-разработчики могут спокойно игнорировать старые типы и синтаксис XHTML-документов (например, использование **`<br/>`** вместо простого тега **`<br>`**). Но если придется обслуживать очень старые браузеры или какое-нибудь необычное приложение, основанное на XHTML, то информацию о том, как это сделать, можно найти по адресу http://xhtml.com.