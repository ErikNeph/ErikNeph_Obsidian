---
date of creation: 2024-06-22T11:00:00
tags:
  - CSS3
  - Frontend/CSS3
  - IT/CSS
  - Programming
  - Developing/CSS3
aliases:
  - Стилизация страниц с помощью CSS3
---
---
# Продвинутая стилизация страниц с помощью CSS3


Первая реализация CSS была разработана в 1996 году, выпущена в 1999 году и к 2001 году была поддержана всеми выпусками браузеров. Стандарт для этой версии, CSS1, был еще раз пересмотрен в 2008 году. Со второй спецификацией, CSS2, разработчики начали работать в 1998 году, ее стандарт был в конечном итоге завершен в 2007 году, а затем еще раз пересмотрен в 2009 году.

В 2001 году началась разработка спецификации CSS3. Ее характеристики были предложены сравнительно недавно, в 2009 году, а самые последние рекомендации были включены еще в 2020 году.

Рабочей группой CSS уже предлагается спецификация CSS4, хотя она не является существенным рывком вперед. Скорее это более глубокая проработка одной части CSS — селекторов, и рассмотрение ее подробностей выходит за рамки темы данной книги, тем более с учетом того, что в 2021 году, на момент написания этих строк, все еще шла разработка рекомендаций. Те из вас, кому это будет интересно, могут ознакомиться с ресурсами на сайте https://tinyurl.com/l4selectors.

В этой главе будут описаны функциональные особенности CSS3, которые уже приняты всеми основными браузерами. Многие из них предоставляют такие функциональные возможности, которые до этого могли быть осуществлены лишь с помощью JavaScript.

Я рекомендую использовать CSS3 для реализации динамических свойств везде, где только можно, вместо JavaScript. Предоставляемые CSS свойства делают атрибуты документа частью самого документа, они уже не присоединяются к нему с помощью JavaScript. А когда они являются частью документа, замысел становится понятнее.

>[!info]-
>Следует заметить, что функций CSS запланировано очень много, и различные установки по-разному реализуются браузерами (если вообще реализуются). Поэтому при желании убедиться в работоспособности создаваемых вами установок CSS во всех браузерах я рекомендую сначала получить соответствующую справку на сайте http://caniuse.com. Там содержится свежая информация о том, какие функции доступны в браузерах.


## Селекторы атрибутов
---

В предыдущей главе были подробно рассмотрены различные селекторы атрибутов [[Введение в CSS]], применяемые в CSS, которые мы сейчас вкратце повторим. Селекторы используются в CSS для сопоставления с HTML-элементами. Существует десять разных типов селекторов, показанных в **табл. 20.1.**

**Таблица 20.1.** CSS-селекторы, псевдоклассы и псевдоэлементы
![[Таблица 20.1. CSS-селекторы, псевдоклассы и псевдоэлементы.jpg]]

Разработчики CSS3 решили, что большинство из этих селекторов работают достаточно хорошо и в представленном на данный момент виде, но три усовершенствования, направленные на упрощение поиска соответствия элементам на основе содержимого их атрибутов, они все же внесли. Эти усовершенствования будут рассмотрены в следующих разделах.


### Соответствие частям строк
---
В CSS2 для поиска соответствия строке __`'info.htm'`__, находящейся в **`href`** атрибуте, можно было использовать такой селектор, как **`a[href='info.htm']`**, но поиска соответствия только части строки не существовало. В CSS3 пошли дальше и определили три новых оператора: **`^`**, **`$`** и **`*`**. Если один из них непосредственно предшествует символу равенства (**`=`**), то с помощью этих символов в том порядке, в каком они перечислены, можно искать соответствие в начале, в конце или в любой части строки.


### Оператор **`^=`**
---

==Этот оператор задает поиск соответствия в начале строки==, например, следующему селектору будет соответствовать любой **`href`**-атрибут, чье значение начинается со строки http://website:
```css
a[href^='http;//website']
```

Таким образом, ему будет соответствовать следующий элемент:
```css
<a href="http://website.com">
```

А этот элемент соответствовать не будет:
```css
<a href='http://mywebsite.com'>
```


### Оператор **`$=`**
---

==Для поиска соответствия только в конце строки== можно использовать следующий селектор, которому будет соответствовать любой **`img`**-тег, чей **`src`**-атрибут заканчивается на **`.png`**:
```css
img[src$='.png']
```

Например, ему будет соответствовать такой тег:
```css
<img src=,photo.png' />
```

А этот тег соответствовать не будет:
```css
<img src=,snapshot.jpg' />
```


### Оператор **`*=`**
---

==Для поиска соответствия любой подстроке, находящейся где-либо в атрибуте==, можно воспользоваться следующим селектором. Он найдет любые ссылки на странице, имеющие строку `google` в любом месте ссылки:
```css
a[href*='google']
```

Например, ему будет соответствовать эта часть кода HTML:
```css
<a href='http://google.com'>
```

а эта часть соответствовать не будет:
```css
<a href='http://gmail.com'>
```


### Свойство **`box-sizing`**
---

В модели блока W3C определено, что ширина и высота объекта должны относиться только к размерам содержимого элемента, игнорируя любые отступы или границы. Но некоторые веб-дизайнеры выразили желание указывать размеры, относящиеся ко всему элементу, включая любые отступы и границы.

Чтобы предоставить такое свойство, CSS3 позволяет вам выбрать желаемую модель блока со свойством задания размеров блока — **`box-sizing`**. Например, для использования общей ширины и высоты объекта, включая отступы и границы, нужно применять следующее объявление:

```css
box-sizing:border-box;
```

Или, чтобы ширина и высота объекта относились только к содержимому, нужно воспользоваться таким объявлением (применяемым по умолчанию):

```css
box-sizing:content-box;
```


## Создание фона в CSS3
---

Спецификация CSS3 предоставляет два новых свойства: **`background-clip`** и **`background-origin`**, ==которые могут использоваться для указания, где фон должен начинаться внутри элемента и как усекать фон так, чтобы он не появлялся в тех частях модели блока, где это нежелательно.==

Для выполнения названных задач оба свойства поддерживают следующие значения:

- **`border-box`** — относится к внешнему краю границы;
- **`padding-box`** — относится к внешнему краю области отступа;
- **`content-box`** — относится к внешнему краю области содержимого.


### Свойство **`background-clip`**
---

==Это свойство определяет, должен ли фон игнорироваться== (усекаться), если он появляется либо внутри границы, либо в области отступов элемента. Например, следующее объявление определяет, что фон может отображаться во всех частях элемента, вплоть до внешнего края границы:

```css
background-clip:border-box;
```

Если не нужно, чтобы фон появлялся в области границы элемента, его можно ограничить только той частью элемента, которая находится внутри и заканчивается внешним краем его области отступов, например:

```css
background-clip:padding-box;
```

Или же можно ограничить фон, чтобы он отображался только внутри области содержимого элемента, воспользовавшись следующим объявлением:

```css
background-clip:content-box;
```

На [[#^d8a5a6|**рис. 20.1**]] показаны три ряда элементов, отображаемых в браузере Safari: в первом ряду для свойства **`background-clip`** используется значение **`borderbox`**, во втором применяется значение **`padding-box`**, а в третьем используется значение **`content-box`**.

В первом ряду внутреннему блоку (файлу изображения, загруженному в левую верхнюю часть элемента с отключенным повторением) разрешается отображаться в элементе везде. Можно также совершенно отчетливо видеть, что он отображается в области границы первого блока, поскольку стиль границы указан пунктирным.

Во втором ряду в области границы не отображается ни фоновое изображение, ни фоновое затенение, поскольку они были усечены по области отступов с помощью установки для свойства **`background-clip`** значения **`padding-box`**.

И наконец, в третьем ряду и фоновое затенение, и фоновое изображение были усечены для отображения только внутри области содержимого каждого элемента (показанного внутри светлого, ограниченного пунктирной линией блока) путем установки для свойства **`background-clip`** значения **`content-box`**.


### Свойство **`background-origin`**
---

С помощью этого свойства можно также указать, где должно располагаться фоновое изображение, определив для этого, где должен начинаться левый верхний угол данного изображения. Например, следующее объявление указывает, что начало фонового изображения должно быть в левом верхнем углу внешнего края границы:

```css
background-origin:border-box;
```

Чтобы установить начало изображения в левый верхний внешний угол области отступов, нужно воспользоваться таким объявлением:

```css
background-origin:padding-box;
```

![[Рис. 20.1. Разные способы сочетания свойств фона CSS3.jpg]] ^d8a5a6
>**Рис. 20.1.** Разные способы сочетания свойств фона CSS3

И чтобы установить начало изображения в левый верхний угол области внутреннего содержимого элемента, нужно воспользоваться следующим объявлением:

```css
background-origin:content-box;
```

Посмотрите еще раз на **рис. 20.1.** В каждом ряду для первого блока используется свойство **`background-origin`** со значением **`border-box`**, для второго блока это же свойство применяется со значением **`padding-box`**, а для третьего — со значением **`content-box`**. Следовательно, в каждом ряду меньший по размеру внутренний блок отображается для первого блока в левом верхнем углу границы, для второго он отображается в левом верхнем углу области отступов, а для третьего — в левом верхнем углу содержимого.

>[!info]
>Единственное отличие рядов, которое стоит отметить в отношении начала внутреннего блока на [[#^d8a5a6|рис. 20.1]], состоит в том, что в рядах 2 и 3 внутренний блок усекается, соответственно, областями отступов и содержимого, поэтому та часть блока, которая находится за пределами этих областей, не отображается.


### Свойство **`background-size`**
---

Точно так же как это делалось для указания ширины и высоты изображения при использовании тега **`<img>`**, в последних версиях всех браузеров можно сделать то же самое для изображений фона.

Свойство можно применить следующим образом (здесь **`ww`** — ширина, а **`hh`** высота):

```css
background-size:wwpx hhpx;
```

При необходимости можно использовать только один аргумент, и для обоих размеров будет установлено указанное значение. Кроме того, если применить данное свойство к блочному элементу, например к **`<div>`** (но не к такому встроенному элементу, как **`<span>`**), можно указать ширину и (или) высоту в процентном отношении, а не в виде фиксированного значения.


### Использование значения **`auto`**
---

Если нужно масштабировать только один размер фонового изображения, чтобы при этом автоматически масштабировался и другой его размер для соблюдения прежних пропорций, для другого размера можно воспользоваться значением **`auto`**:

```css
background-size:100px auto;
```

Этим объявлением устанавливается ширина, равная 100 пикселам, и высота, равная значению, пропорциональному увеличению или уменьшению ширины.

>[!info]
>Разные браузеры могут требовать различных версий имен свойства
background, поэтому при их использовании обратитесь к сайту http://caniuse.com, чтобы убедиться, что вы применяете все версии, требуемые тем браузерам, на работу с которыми вы рассчитываете.


### Использование нескольких фонов
---

Используя CSS3, вы можете прикрепить к элементу несколько фонов, каждый из которых может применять ранее рассмотренные свойства фона CSS3. Соответствующий пример показан на **рис. 20.2.** На этом рисунке в качестве фона были назначены восемь изображений, которые используются для создания четырех углов и четырех кромок границы сертификата.

>![[Рис. 20.2. Фон, созданный с помощью нескольких изображений.jpg]]
   **Рис. 20.2.** Фон, созданный с помощью нескольких изображений

Для вывода нескольких фоновых изображений с помощью одного CSSобъявления нужно разделить их запятыми. В **примере 20.1** показан код HTML и CSS, использованный для создания фона **рис. 20.2.**

**Пример 20.1.** Использование в фоне сразу нескольких изображений
```html
<!DOCTYPE html>
<html> <!-- backgroundimages.html -->
  <head>
    <title>CSS3 Multiple Backgrounds Example</title>
    <style>
      .border {
        font-family:'Times New Roman';
        font-style :italic;
        font-size  :170%;
        text-align :center;
        padding    :60px;
        width      :350px;
        height     :500px;
        background :url('b1.gif') top    left  no-repeat,
                    url('b2.gif') top    right no-repeat,
                    url('b3.gif') bottom left  no-repeat,
                    url('b4.gif') bottom right no-repeat,
                    url('ba.gif') top          repeat-x,
                    url('bb.gif') left         repeat-y,
                    url('bc.gif') right        repeat-y,
                    url('bd.gif') bottom       repeat-x
      }
    </style>
  </head>
  <body>
    <div class='border'>
      <h1>Employee of the month</h1>
      <h2>Awarded To:</h2>
      <h3>__________________</h3>
      <h2>Date:</h2>
      <h3>___/___/_____</h3>
    </div>
  </body>
</html>
```

Первые четыре строки объявления фона в блоке CSS расставляют угловые изображения по четырем углам элемента, а последние четыре строки помещают изображения кромок, которые обрабатываются в последнюю очередь, потому что порядок приоритетности для фоновых изображений имеет направление сверху вниз. Иными словами, когда они накладываются друг на друга, дополнительные фоновые изображения будут появляться позади уже размещенных изображений. Если бы GIF-изображения были перечислены в обратном порядке, то повторяющиеся изображения кромок отображались бы поверх углов, что было бы неправильно.

>[!tip]-
>Используя этот код CSS, можно изменять размеры содержащего фон элемента по любым направлениям, и граница будет всегда правильно изменяться в размерах, чтобы поместиться в элементе, что намного проще, чем применять таблицы или несколько элементов для получения такого же эффекта.


## Границы в CSS3
---

CSS3 также придает намного больше гибкости способам возможного представления границ, разрешая независимо менять цвета всех четырех кромок, отображать изображения для кромок и углов, предоставлять значения радиусов для придания границам закругленных углов и помещать прямоугольные тени под элементами.


### Свойство **`border-color`**
---

Применять цвета к границе можно двумя способами. Начнем с того, что свойству можно передать всего один цвет:

```css
border-color:#888;
```

Это объявление устанавливает светло-серый цвет для всех границ элемента. Можно также установить цвета границ по отдельности (здесь цвета границы устанавливаются в различные градации серого):

```css
border-top-color :#000;
border-left-color :#444;
border-right-color :#888;
border-bottom-color:#ccc;
```

Кроме того, можно назначить все цвета по отдельности в одном объявлении:

```css
border-color:#f00 #0f0 #880 #00f;
```

Это объявление устанавливает цвет верхней границы в **`#f00`**, правой границы в **`#0f0`**, нижней границы — в **`#880`** и левой границы — в **`#00f`** (в красный, зеленый, оранжевый и синий соответственно). Можно также использовать в качестве аргументов названия цветов.


### Свойство **`border-radius`**
---

До появления CSS3 способные веб-разработчики придумали множество различных настроек с целью получения закругленных границ, используя, как правило, теги **`<table>`** или **`<div>`**.

Но теперь добавление закругленных границ к элементу дается по-настоящему легко, и, как показано на **рис. 20.3**, работает в последних версиях всех основных браузеров. На этом рисунке граница толщиной 10 пикселов выведена различными способами. Код HTML для получения такого результата показан в **примере 20.2.**

**Пример 20.2.** Свойство **`border-radius`**
```css
<!DOCTYPE html>
<html> <!-- borderradius.html -->
  <head>
    <title>CSS3 Border Radius Examples</title>
    <style>
      .box {
        margin-bottom:10px;   
        font-family  :'Courier New', monospace;
        font-size    :12pt;
        text-align   :center;
        padding      :10px;
        width        :380px;
        height       :75px;
        border       :10px solid #006;
      }
      .b1 {
        -moz-border-radius   :40px;
        -webkit-border-radius:40px;
        border-radius        :40px;
      }
      .b2 {
        border-radius        :40px 40px 20px 20px;
      }
      .b3 {
        border-top-left-radius            :20px;
        border-top-right-radius           :40px;
        border-bottom-left-radius         :60px;
        border-bottom-right-radius        :80px;
      }
      .b4 {
        border-top-left-radius            :40px 20px;
        border-top-right-radius           :40px 20px;
        border-bottom-left-radius         :20px 40px;
        border-bottom-right-radius        :20px 40px;
      }
    </style>
  </head>
  <body>
    <div class='box b1'>
      border-radius:40px;
    </div>

    <div class='box b2'>
      border-radius:40px 40px 20px 20px;
    </div>

    <div class='box b3'>
      border-top-left-radius &nbsp;&nbsp;&nbsp;:20px;<br>
      border-top-right-radius &nbsp;&nbsp;:40px;<br>
      border-bottom-left-radius :60px;<br>
      border-bottom-right-radius:80px;
    </div>

    <div class='box b4'>
      border-top-left-radius &nbsp;&nbsp;&nbsp;:40px 20px;<br>
      border-top-right-radius &nbsp;&nbsp;:40px 20px;<br>
      border-bottom-left-radius :20px 40px;<br>
      border-bottom-right-radius:20px 40px;
    </div>
  </body>
</html>
```

>![[Рис. 20.3. Смешивания и сопоставления различных свойств радиусов границы.jpg]]
 **Рис. 20.3.** Смешивания и сопоставления различных свойств радиусов                               границы

Так, например, для создания закругленной границы с радиусом 20 пикселов можно просто воспользоваться следующим объявлением:

```css
border-radius: 20px;
```

Можно указать отдельные радиусы для каждого из четырех углов (по часовой стрелке, начиная с левого верхнего угла):

```css
border-radius: 10px 20px 30px 40px;
```

При необходимости можете также указать радиус отдельно для каждого угла элемента:

```css
border-top-left-radius :20px;
border-top-right-radius :40px;
border-bottom-left-radius :60px;
border-bottom-right-radius :80px;
```

И при ссылке на отдельные углы можно предоставить два аргумента, выбирая тем самым разные вертикальные и горизонтальные радиусы (в результате чего получаются более интересные и тонко настраиваемые границы):

```css
border-top-left-radius :40px 20px;
border-top-right-radius :40px 20px;
border-bottom-left-radius :20px 40px;
border-bottom-right-radius :20px 40px;
```

Первым аргументом задается горизонтальный, а вторым — вертикальный радиус.


#### Прямоугольные тени
---

Для применения прямоугольной тени нужно указать горизонтальное и вертикальное смещение от объекта и величину размытости, добавляемой к тени, а также используемый для тени цвет:

```css
box-shadow:15px 15px 10px #888;
```

Два значения по **`15px`** задают (по порядку) горизонтальное и вертикальное смещение от элемента, и эти значения могут быть отрицательными, нулевыми или положительными. Значение **`10px`** указывает величину, где меньшие значения приводят к меньшей размытости, а **`#888`** — это цвет тени, который может быть любым допустимым цветом. Результат этого объявления можно увидеть на **`рис. 20.4.`**

>![[Рис. 20.4. Прямоугольная тень, отображенная под элементом.jpg]]
>   **Рис. 20.4**. Прямоугольная тень, отображенная под элементом


### Выход элемента за пределы размеров
---

В CSS2 можно определить, что делать, когда один элемент слишком велик, чтобы полностью поместиться в другом, родительском по отношению к нему элементе, путем указания для свойства **`overflow`** значения **`hidden`**, **`visible`**, **`scroll`** или **`auto`**. Но теперь в CSS3 можно также отдельно применить эти значения к горизонтальному или вертикальному направлению, как в следующих примерах объявлений:

```css
overflow-x:hidden;
overflow-x:visible;
overflow-y:auto;
overflow-y:scroll;
```


### Разметка с использованием нескольких колонок
---

Использование нескольких колонок уже давно стало у веб-разработчиков наиболее востребованным свойством, и в CSS3 оно наконец-то было реализовано.

==Теперь перетекание текста по нескольким колонкам задать не сложнее, чем указать количество колонок==, а затем (дополнительно) выбрать разрядку между ними и тип разделительной линии (если она нужна). На **рис. 20.5** показан результат выполнения кода **примера 20.3.**

>![[Рис. 20.5. Перетекание текста по нескольким колонкам.jpg]]
>   **Рис. 20.5.** Перетекание текста по нескольким колонкам

>**Пример 20.3.** Использование CSS для создания нескольких колонок
```html
<!DOCTYPE html>
<html> <!—- multiplecolumns.html -->
  <head>
    <title>Multiple Columns</title>
    <style>
      .columns {
        text-align          :justify;
        font-size           :16pt;
        column-count        :3;
        column-gap          :1em;
        column-rule         :1px solid black;
      }
    </style>
  </head>
  <body>
    <div class='columns'>
      Now is the winter of our discontent
      Made glorious summer by this sun of York;
      And all the clouds that lour'd upon our house
      In the deep bosom of the ocean buried.
      Now are our brows bound with victorious wreaths;
      Our bruised arms hung up for monuments;
      Our stern alarums changed to merry meetings,
      Our dreadful marches to delightful measures.
      Grim-visaged war hath smooth'd his wrinkled front;
      And now, instead of mounting barded steeds
      To fright the souls of fearful adversaries,
      He capers nimbly in a lady's chamber
      To the lascivious pleasing of a lute.
    </div>
  </body>
</html>
```

Внутри класса **`.columns`** первые две строки просто предписывают браузеру выровнять текст по правому краю и установить для него размер шрифта **`16pt`**. Эти объявления для нескольких колонок не нужны, но они улучшают отображение текста. В остальных строках элемент настраивается таким образом, чтобы внутри него текст перетекал по трем колонкам с разрывом между колонками, равным **`1em`**, и с границей 1 пиксел, проходящей посередине каждого разрыва.


## Цвета и непрозрачность
---

Способы определения цветов в CSS3 существенно расширились: теперь вы можете также использовать CSS-функции для применения цветов в широко распространенных форматах **RGB** (красный, зеленый, синий), RGBA (красный, зеленый, синий, альфа), **HSL** (тон, насыщенность, яркость) и **HSLA** (тон, насыщенность, яркость, альфа). Значение *альфа* определяет прозрачность цвета, позволяющую увидеть элементы, расположенные ниже.


### Цвета **`HSL`**
---

Для определения цвета с помощью функции **`hsl`** ==сначала нужно выбрать из цветового круга значение для тона в диапазоне от 0 до 359==. Любой более высокий номер цвета просто возвращается по кругу к началу, таким образом, значение 0 соответствует красному цвету точно так же, как и значения 360 и 720.

В ==цветовом круге основные цвета — красный, зеленый и синий== — занимают по 120 градусов, поэтому чистый красный цвет соответствует значению 0, зеленый — значению 120, а синий — значению 240. Числа между этими значениями представляют собой оттенки, содержащие различные пропорции основных цветов с обеих сторон.

==Затем нужен уровень насыщенности, значение которого лежит в диапазоне от 0 до 100 %.== Он определяет то, насколько сильно цвет будет размыт или ярок. Значения насыщенности начинаются в центре колеса со светло-серого цвета (насыщенность равна 0 %), а затем по направлению к краю (где насыщенность равна 100 %) она становится все более отчетливой.

==Вам остается только решить, насколько ярким требуется цвет, для чего нужно выбрать значение яркости в диапазоне от 0 до 100 %==. Значение 50% для яркости дает наполненный, яркий цвет, а уменьшение значения (вниз, вплоть до минимума 0%) делает его темнее до тех пор, пока цвет не станет черным. Увеличение значения (вверх, вплоть до максимума 100%) делает цвет светлее до тех пор, пока он не станет белым. Вы можете визуально представить это подмешиванием в цвет либо черного, либо белого цвета.

Так, например, для выбора полностью насыщенного желтого цвета со стандартной яркостью нужно воспользоваться следующим объявлением:

```css
color:hsl(60, 100%, 50%);
```

Или для выбора темно-синего цвета можно воспользоваться таким объявлением:

```css
color:hsl(240, 100%, 40%);
```

Этим также можно воспользоваться (как и всеми остальными CSS-функциями, связанными с заданием цвета) с любым свойством, ожидающим применения цветовых настроек, например с **`background-color`** и т. д.


### Цвета **`HSLA`**
---

Для обеспечения еще большего контроля над способом цветоообразования можно воспользоваться функцией **`hsla`**, предоставив ей четвертый (альфа) уровень настройки цвета, значение которого задается числом с плавающей точкой в диапазоне от 0 до 1. Значение 0 определяет, что цвет полностью прозрачный, а число 1 задает полную непрозрачность цвета.

Выбрать желтый цвет с полной насыщенностью, стандартной яркостью и 30%-ной непрозрачностью можно с помощью следующего объявления:

```css
color:hsla(60, 100%, 50%, 0.3);
```

Или же для выбора полностью насыщенного, но чуть более светлого синего цвета с 82%-ной непрозрачностью можно воспользоваться таким объявлением:

```css
color:hsla(240, 100%, 60%, 0.82);
```


### Цвета **`RGB`**
---

Наверное, вам более знакома система выбора цвета RGB, поскольку она похожа на использование форматов цвета `#nnnnnn `и `#nnn`. Например, для задания желтого цвета можно воспользоваться любым из следующих объявлений (первое из них поддерживает 16 миллионов цветов, а второе — 4 тысячи):

```css
color :#ffff00;
color :#ff 0;
```

Для получения такого же результата можно также воспользоваться CSS-функцией rgb, но при этом нужно применять не шестнадцатеричные, а десятичные числа (где десятичное число 255 соответствует шестнадцатеричному числу **`ff`**):

```css
color:rgb(255, 255, 0);
```

Но еще лучше вам будет даже не задумываться больше о том, чему соответствуют значения до 256, поскольку можно указать процентные значения:

```css
color:rgb(100%, 100%, 0);
```

Фактически теперь вы можете с большой точностью определить настройки для нужного цвета, просто думая о его основных цветовых составляющих. Например, сочетание зеленого и синего дает бирюзовый цвет, поэтому для задания цвета, близкого к бирюзовому, но с синей составляющей, преобладающей над зеленой, можно составить первое предположение, что для него нужно определить 0 % красного, 40 % зеленого и 60 % синего цвета и попробовать воспользоваться следующим объявлением:

```css
color:rgb(0%, 40%, 60%);
```


### Цвета **`RGBA`**
---

Как и функция **`hsla`**, функция **`rgba`** поддерживает четвертый (альфа) аргумент, позволяющий, к примеру, с помощью следующего объявления применить к прежнему фиолетовому цвету 40 %-ную непрозрачность:

```css
color:rgba(0%, 40%, 60%, 0.4);
```


### Свойство **`opacity`**
---

Свойство **`opacity`** предоставляет такое же альфа-управление, что и функции **`hsla`** и **`rgba`**, но позволяет изменять непрозрачность объекта (или прозрачность, если это вам больше нравится) отдельно от его цвета.

Для использования этого цвета нужно применить к элементу следующее объявление (которое в данном примере устанавливает непрозрачность, равную 25 %, или прозрачность, равную 75 %):

```css
opacity:0.25;
```


## Эффекты, применяемые к тексту
---

Теперь с помощью CSS3 к тексту могут применяться новые эффекты, включая тени текста, наложение, применяемое к тексту, и перенос слов.


### Свойство **`text-shadow`**
---

Это свойство аналогично свойству **`box-shadow`** и получает такой же набор аргументов: ==горизонтальное и вертикальное смещение, величину размытости и используемый цвет.== Например, следующее объявление задает смещение тени на 3 пиксела как в горизонтальном, так и в вертикальном направлении и отображает тень темно-серым цветом с размытостью 4 пиксела:

```css
text-shadow:3px 3px 4px #444;
```

Результат применения этого объявления выглядит так, как показано на **рис. 20.6.** Это объявление работает в последних версиях всех основных браузеров (кроме Internet Explorer 9 или ниже).

![[Рис. 20.6. Применение тени к тексту.jpg]]
>**Рис. 20.6.** Применение тени к тексту


### Свойство **`text-overflow`**
---

При использовании любого из CSS-свойств **`overflow`** со значением, равным **`hidden`**, можно также воспользоваться свойством **`text-overflow`** для помещения многоточия сразу же после текста, подвергшегося усечению:

```css
text-overflow:ellipsis;
```

Если это свойство не использовать, то когда текст «To be, or not to be. That is the question.» усекается, результат выглядит так, как показано на **рис. 20.7.** С применением объявления результат выглядит так, как изображено на **рис. 20.8.**

![[Рис. 20.7. Текст автоматически усекается.jpg]]
>**Рис. 20.7.** Текст автоматически усекается

![[Рис. 20.8. Вместо простого усечения текст завершается многоточием.jpg]]
>**Рис. 20.8.** Вместо простого усечения текст завершается многоточием

Чтобы это работало, требуется выполнить три условия.

- У элемента должно быть свойство **`overflow`**, настроенное на невидимость, например **`overflow:hidden`**.
- Элемент должен иметь свойство **`white-space:nowrap`**, настраивающее на ограничение текста.
- Ширина элемента должна быть меньше, чем усекаемый текст.


### Свойство **`word-wrap`**
---

Когда используется по-настоящему длинное слово, шире того элемента, в котором оно содержится, оно либо выйдет за пределы, либо будет усечено. Но в качестве альтернативного варианта свойству **`text-overflow`** и усечению текста можно воспользоваться свойством **`word-wrap`** со значением **`break-word`** для переноса длинных строк:

```css
word-wrap:break-word;
```

Например, на **рис. 20.9** показано, что слово `Honorificabilitudinitatibus` шире, чем содержащее его поле (правый край которого показан в виде сплошной вертикальной черты между буквами t и a), и поскольку свойство **`overflow`** применено не было, слово выходит за границу своего контейнера.

![[Рис. 20.9. Слово имеет слишком большую ширину для своего контейнера.jpg]]
>**Рис. 20.9.** Слово имеет слишком большую ширину для своего контейнера,
 поэтому выходит за его границу

Но на **рис. 20.10** свойству **`word-wrap`** элемента было присвоено значение `breakword`, поэтому слово аккуратно перенесено на следующую строку.

![[Рис. 20.10. Теперь слово переносится по достижении правого края.jpg]]
>**Рис. 20.10.** Теперь слово переносится по достижении правого края


## Веб-шрифты
---

Применение веб-шрифтов CSS3 существенно повысило возможности оформления текста, доступные веб-дизайнерам, позволяя загружать шрифты из интернета, а не только со своего пользовательского компьютера, и отображать их по всей Всемирной сети. Для достижения такого результата нужно объявить веб-шрифт с помощью свойства **`@font-face`**:

```css
@font-face
{
  font-family:FontName;
  src:url('FontName.otf');
}
```

Функция **`url`** требует значение, содержащее путь или URL-адрес шрифта. В большинстве браузеров можно использовать либо шрифты TrueType (`.ttf`), либо шрифты OpenType (`.otf`), но Internet Explorer ограничивает вас применением шрифтов TrueType, преобразованных в шрифты Embedded Open Type (`.eot`).

Чтобы сообщить браузеру тип шрифта, можно воспользоваться функцией **`format`**, как в следующем примере для шрифтов OpenType:

```css
@font-face
{
  font-family:FontName;
  src:url('FontName.otf') format('opentype');
}
```

или в этом примере (для шрифтов TrueType):

```css
@font-face
{
  font-family:FontName;
  src:url('FontName.ttf') format('truetype');
}
```

Но поскольку Internet Explorer принимает только EOT-шрифты, он игнорирует объявления **`@font-face`**, содержащие функцию **`format`**.


### Веб-шрифты Google
---

Один из лучших способов использования веб-шрифтов — их бесплатная загрузка с серверов Google. Дополнительную информацию по данному вопросу можно найти на сайте веб-шрифтов Google (http://google.com/webfonts) (**рис. 20.11**), где можно получить доступ более чем к тысяче шрифтов!

Чтобы вы увидели, насколько легко можно использовать один из этих шрифтов, в следующем примере показано, как загрузить шрифт Google (в данном случае Lobster) в ваш HTML-код для использования в заголовках **`<h1>`**:

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      h1 { font-family:'Lobster', arial, serif; }
      <link href='http://fonts.googleapis.com/css?family=Lobster'
         rel='stylesheet'
    </style>
  </head>
  <body>
    <h1>Hello</h1>
  </body>
</html>
```

При выборе шрифта с сайта Google предоставляет тег **`<link>`** для копирования и вставки его в раздел **`<head>`** вашей веб-страницы.


## Трансформации
---

Используя трансформации, можно наклонять, вращать, растягивать и сжимать элементы в любом из трех измерений. Это упрощает создание впечатляющих эффектов путем выхода за пределы однообразных макетов на основе **`<div>`**-контейнеров и других элементов, поскольку теперь они могут быть показаны под различными углами и в различных формах.

Для выполнения трансформаций нужно воспользоваться свойством **`transform`**. К свойству **`transform`** можно применять множество значений, начиная со значения none, которое переключает объект в состояние, не допускающее трансформаций:
```css
transform:none;
```

Свойство **`transform`** можно дополнить одной или несколькими из следующих разнообразных функций:

- **`matrix`** — трансформирует объект, применяя к нему матрицу значений;
- **`translate`** — перемещает исходную точку элемента;
- **`scale`** — масштабирует объект;
- **`rotate`** — вращает объект;
- **`skew`** — наклоняет объект.

![[Рис. 20.11. Включить веб-шрифты Google не составляет труда.jpg]]
>**Рис. 20.11.** Включить веб-шрифты Google не составляет труда

Единственное, с чем может быть трудно разобраться, — это наклон (**`skew`**). При применении этой функции одна из координат смещается в одном из направлений пропорционально своему расстоянию от координатной плоскости или оси. Таким образом при наклоне прямоугольник, к примеру, преобразуется в параллелограмм.

Существуют также отдельные версии многих из этих функций, например **`translateX`**, **`scaleY`** и т. д.

Так, например, чтобы повернуть элемент по часовой стрелке на 45°, можно применить к нему такое объявление:
```css
transform:rotate(45deg);
```

В то же время вы можете увеличить объект, как это делается с помощью следующего объявления, приводящего к увеличению его ширины в полтора, а высоты в два раза с дальнейшим поворотом:
```css
transform:scale(1.5, 2) rotate(45deg);
```

На **рис. 20.12** показан объект до и после применения трансформации.
![[Рис. 20.12. Объект до и после трансформации.jpg]]
>   **Рис. 20.12.** Объект до и после трансформации


### Трехмерная трансформация
---

Объекты можно также трансформировать в трех измерениях, используя следующие свойства трехмерной трансформации CSS3:

- **`perspective`** — освобождение элемента из двумерного пространства и создание третьего измерения, в котором он может перемещаться; требуется для работы с 3D-функциями CSS;
- **`transform-origin`** — установка с использованием перспективы того места, где все линии сходятся в одну точку;
- **`translate3d`** — перемещение элемента в другое место трехмерного пространства;
- **`scale3d`** — изменение масштаба одного или нескольких измерений;
- **`rotate3d`** — вращение элемента вокруг любой из осей X, Y и Z.

На **рис. 20.13** показан двумерный объект, подвергшийся вращению в трехмерном пространстве с помощью следующего CSS-правила:

```css
transform:perspective(200px) rotateX(10deg) rotateY(20deg) rotateZ(30deg);
```

![[Рис. 20.13. Вращение объекта в трехмерном пространстве.jpg]]
>   **Рис. 20.13.** Вращение объекта в трехмерном пространстве


### Переходы
---

В последних версиях основных браузеров (включая Internet Explorer 10, не ниже) появилось новое динамичное свойство, называемое переходами. Переходы определяют эффект анимации, который нужно применить при трансформации элемента, и браузер автоматически позаботится за вас обо всех промежуточных кадрах.

Для настройки перехода можно предоставить четыре свойства:

```css
transition-property        :свойство;
transition-duration        :время;
transition-delay           :время;
transition-timing-function :тип;
```


### Свойства, применяемые к переходам
---

У переходов есть такие свойства, как **`height`** и **`border-color`**. При указании свойств преследуется цель изменения CSS-свойства по имени **`transition-property`** (здесь слово **`property`** («свойства») используется двумя разными способами: для CSS-свойства и для устанавливаемых им свойств переходов). Можно включить в объявление сразу несколько свойств, разделяя их запятыми:

```css
transition-property:width, height, opacity;
```

Или, если вам нужно абсолютно все, относящееся к элементу, подвергаемому переходу (включая цвета), используется значение **`all`**:

```css
transition-property:all;
```


### Продолжительность перехода
---

Свойство **`transition-duration`** требует значения от нуля и более секунд. Следующее объявление задает завершение перехода через 1,25 с:
```css
transition-duration :1.25s;
```


### Задержка перехода
---

Если свойству **`transition-delay`** дается значение более нуля секунд (то есть более значения по умолчанию), происходит задержка между исходным отображением элемента и началом его перехода. Следующее объявление задает начало перехода после задержки 0,1 с:

```css
transition-delay:0.1s;
```

Если свойству **`transition-delay`** дается значение меньше нуля секунд (иными словами, отрицательное значение), переход будет выполнен в момент изменения свойства, но проявится таким образом, будто оно началось с указанным смещением по времени, то есть на каком-то своем промежуточном цикле.


### Задание скорости перехода
---

Свойству **`transition-timing-function`** требуется присвоить одно из следующих значений:

- **`ease`** — медленное начало, ускорение и медленное завершение;
- **`linear`** — переход с постоянной скоростью;
- **`ease-in`** — медленное начало, а затем быстрый переход до самого завершения;
- **`ease-out`** — быстрое начало, сохранение высокой скорости почти до завершения и медленное завершение;
- **`ease-in-out`** — медленное начало, быстрый переход, затем медленное завершение.

Использование любого из этих значений со словом **`ease`** обеспечивает исключительную плавность и естественность перехода в отличие от линейного (**`linear`**) перехода, который выглядит более механическим. И если этих изменений вам недостаточно, вы можете также создать свой собственный переход, используя функцию **`cubic-bezier`**.

Например, следующие объявления применялись для создания пяти предыдущих типов переходов и показывают, как просто можно создавать свои собственные переходы:

```css
transition-timing-function:cubic-bezier(0.25, 0.1, 0.25, 1);
transition-timing-function:cubic-bezier(0, 0, 1, 1);
transition-timing-function:cubic-bezier(0.42, 0, 1, 1);
transition-timing-function:cubic-bezier(0, 0, 0.58, 1);
transition-timing-function:cubic-bezier(0.42, 0, 0.58, 1);
```


### Сокращенный синтаксис
---

==Возможно, проще будет воспользоваться сокращенной версией этого свойства и включить все значения в одно объявление (такое, как показано далее), которым задается переход всех свойств в линейном режиме за период 0,3 с, после начальной (необязательной) задержки 0,2 с:==

```css
transition:all .3s linear .2s;
```

Это избавит вас от хлопот, связанных со вводом многих очень похожих друг на друга объявлений, особенно если вы поддерживаете префиксы всех основных браузеров.

В **примере 20.4** продемонстрировано, как можно сразу воспользоваться и переходом, и трансформацией. С помощью CSS создается квадратный оранжевый элемент с неким текстом внутри, а псевдокласс **`hover`** указывает на то, что при проходе над этим объектом указателя мыши объект должен повернуться на 180° и изменить свой цвет с оранжевого на желтый (**рис. 20.14**).

>**Пример 20.4.** Эффект перемещения, связанный с применением псевдокласса **`hover`**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Transitioning on hover</title>
    <style>
      #square {
        position          :absolute;
        top               :50px;
        left              :50px;
        width             :100px;
        height            :100px;
        padding           :2px;
        text-align        :center;
        border-width      :1px;
        border-style      :solid;
        background        :orange;
        transition        :all .8s ease-in-out;
      }
      #square:hover {
        background        :yellow;
        transform         :rotate(180deg);
      }
    </style>
  </head>
  <body>
    <div id='square'>
      Square shape<br>
      created using<br>
      a simple div<br>
      element with<br>
      a 1px border
    </div>
  </body>
</html>
```

![[Рис. 20.14. Объект поворачивается и меняет цвет при прохождении.jpg]]
>**Рис. 20.14.** Объект поворачивается и меняет цвет при прохождении
 над ним указателя мыши

Пример кода удовлетворяет требованиям всех разнообразных браузеров благодаря предоставлению версий объявлений, характерных для тех или иных браузеров. На всех самых последних браузерах (включая Internet Explorer 10 и выше) объект будет поворачиваться по часовой стрелке при прохождении над ним указателя мыши и в то же время станет медленно менять свой цвет с оранжевого на желтый.

CSS-переходы выполняются вполне продуманно, это выражается в том, что после прекращения перехода все плавно возвращается к своему исходному значению. Поэтому если убрать указатель мыши до завершения перехода, он тут же пойдет в обратную сторону и начнет переход назад к своему исходному состоянию.


## Вопросы
---

- [x] 1. Чем занимаются операторы селектора атрибутов CSS3 **`^=`**, **`$=`** и **`*=?`**
- [x] 2. Какое свойство используется для указания размера фонового изображения?
- [x] 3. С помощью какого свойства можно указать радиус границы?
- [?] 4. Как можно задать перетекание текста по нескольким колонкам?
- [/] 5. Назовите четыре функции, с помощью которых можно указать CSS-цвета.
- [x] 6. Как можно создать серую тень под каким-нибудь текстом с диагональным отступом вправо и вниз на 5 пикселов и с размытостью 3 пиксела?
- [x] 7. Как можно показать многоточием, что текст усечен?
- [x] 8. Как включить в состав своей веб-страницы веб-шрифты Google?
- [x] 9. Какое CSS-объявление нужно использовать для поворота объекта на 90°?
- [x] 10. Как указать переход объекта таким образом, чтобы при изменении любого из его свойств переход осуществлялся сразу в линейном режиме в течение 0,5 с?


---


