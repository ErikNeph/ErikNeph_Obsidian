---
date of creation: 2024-06-15T00:41:00
tags:
  - CSS
  - CSS3
  - Frontend
  - Developing/CSS3
  - IT/CSS
aliases:
  - введение в CSS
---
---
# Введение в CSS



Используя ==каскадные таблицы стилей== — ==Cascading Style Sheets== (CSS), — вы можете применить стиль к своим веб-страницам, чтобы придать им желаемый внешний вид. Работа CSS основана на их подключении к объектной модели документа — Document Object Model (DOM), которая была рассмотрена в [[Изучение JavaScript]]

Используя CSS и их интеграцию с DOM, можно быстро и просто изменить стиль любого элемента. Например, если не нравится исходный вид заголовков, определяемых тегами **`<h1>`**, **`<h2>`** и т. д., можно назначить новый стиль, отменяющий исходные настройки, касающиеся используемого семейства шрифтов и размера, применения полужирного шрифта или курсива, а также многих других свойств.

Один из способов добавления стилей к веб-странице заключается во вставке требуемых для этого инструкций в заголовок страницы между тегами **`<head>`** и **`</head>`**. Поэтому для изменения стиля, применяемого к содержимому тега **`<h1>`**, нужно воспользоваться следующим кодом (синтаксис которого будет рассмотрен чуть позже):

```css
<style>
  hi { color:red; font-size:3em; font-family:Arial; }
</style>
```


>**Пример 19.1.** Простая HTML-страница
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Hello World</title>
    <style>
      h1 {
        color      :red;
        font-size  :3em;
        font-family:Arial;
      }
    </style>
  </head>
  <body>
    <h1>Hello there</h1>
  </body>
</html>
```
![[Рис. 18.1. Стилизация тега, оригинальный стиль которого показан во вставке.jpg]]
>**Рис. 18.1.** Стилизация тега, оригинальный стиль которого показан во                                    вставке


---
## Импортирование таблицы стилей
---

==Когда стиль нужно применить не к одной странице, а ко всему сайту, лучше управлять таблицами стилей путем их полного перемещения из веб-страниц в отдельные файлы с последующим импортом той таблицы, которая вам нужна.== Тем самым предоставляется возможность применения разных таблиц стилей к разным форматам подачи информации (например, в варианте просматриваемой веб-страницы и в варианте вывода на печать) без изменения HTML.

Этого можно достичь двумя различными способами, первый из которых заключается в использовании CSS-директивы **`@import`**:

```css
<style>
  @import url('styles.css');
</style>
```

Эта инструкция заставляет браузер извлечь таблицу стилей с именем **`styles.css`**. Гибкость, присущая команде **`@import`**, позволяет создавать таблицы стилей, которые сами импортируют другие таблицы стилей, а те, в свою очередь, могут импортировать другие таблицы и т. д. А вот теги **`<style>`** и **`</style>`** при вызове внешних таблиц стилей из других таблиц не нужны, и их присутствие сделает инструкцию неработоспособной.


### Импортирование CSS из HTML-кода
---

Включить таблицу стилей можно также с помощью HTML-тега **`<link>`**:

```css
<link rel='stylesheet' href='styles.css'>
```

Результат будет точно таким же, как и при использовании директивы **`@import`**, но **`<link>`** является тегом, применяемым только в HTML, и не относится к стилевым директивам, поэтому он не может задействоваться в одной таблице стилей для импорта другой такой таблицы. Он также не может помещаться внутри пары тегов **`<style>...</style>`**.

Точно так же как в CSS, можно использовать несколько директив **`@import`** для включения в состав таблицы стилей нескольких внешних таблиц, в коде HTML можно применять любое нужное количество элементов, задействующих теги **`<link>`**.


### Встроенные настройки стиля
---

Можно также выполнять индивидуальные настройки или заменять конкретные стили, вставляя объявления стилей непосредственно в код HTML следующим образом (в данном случае внутри тегов задается курсивный текст синего цвета):

```css
<div style='font-style:italic; color:blue;'>Всем привет</div>
```

Но подобные настройки стоит отложить до тех пор, пока не возникнут самые крайние обстоятельства, поскольку они нарушают принцип отделения содержимого от представления и, следовательно, поддержание их становится кошмаром.


## Идентификаторы (ID)
---

Более удачным решением для настроек стиля отдельно взятого элемента является назначение формирующему его ==HTML-коду идентификатора==:

```html
<div id='welcome'>Всем привет</div>
```

Тем самым устанавливается, что содержимое **`<div>`**-контейнера с идентификатором, имеющим значение **`welcome`**, должно иметь применяемый к нему стиль, который определен в стилевых настройках **`welcome`**. Соответствующая *CSS-инструкция* для этого может иметь такой вид:

```css
#welcome { font-style:italic; color:blue; }
```

>[!info]
>Обратите внимание на использование символа «решетка» (**`#`**), который указывает на то, что эта инструкция задает стилевые настройки только для идентификатора по имени **`welcome`**.


### Классы
---

Значение элемента **`id`** ==на веб-странице должно быть уникальным, так как именно это позволяет ему служить в качестве идентификатора==. Если нужно применить один и тот же стиль ко многим элементам, не следует давать каждому из них особый идентификатор, поскольку для управления всеми этими элементами можно указать класс:

```html
<div class='welcome'>Привет</div>
```

Тем самым утверждается, что стиль, определенный в классе **`iblue`**, должен применяться к содержимому данного элемента (и любых других элементов, относящихся к этому классу). При использовании класса можно либо в заголовке страницы, либо во внешней таблице стилей задействовать для настройки стилей класса следующее правило:

```css
.welcome {
  font-style:italic;
  color:blue;
}
```

Вместо использования символа «решетка» (**`#`**), который закреплен за идентификаторами (**`ID`**), инструкции, относящиеся к классу, предваряются символом «точка» (**`.`**).

**Так же есть небольшая UML-диаграмма для ID и классов в CSS** - [[ID и классы в CSS.canvas|ID и классы в CSS]]


### Точки с запятой
---

В CSS точки с запятой применяются в качестве разделителей нескольких инструкций CSS, расположенных в одной и той же строке. Но при наличии в правиле только одной инструкции (или при встраивании настройки стиля в HTML-теге) точку с запятой можно опустить, и то же самое можно сделать в отношении последней инструкции в группе.

==Но чтобы при использовании CSS избавиться от ошибок, которые трудно будет распознать, можно взять за правило использовать точку с запятой после каждой настройки CSS.== В дальнейшем их можно копировать и вставлять или же изменять свойства, не заботясь об удалении точек с запятой там, где они в принципе не нужны, или о добавлении их туда, где они необходимы.


## Правила CSS
---

Каждая инструкция в CSS-правиле начинается с *селектора*, являющегося элементом, к которому будет применяться правило. Например, в следующем назначении **`hi`** является селектором, для которого задается размер шрифта на 240 % больше, чем у используемого по умолчанию:

```css
hi {
  font-size:240%;
}
```

**`font-size`** является свойством. Задавая для принадлежащего селектору **`hi`** свойства **`font-size`** значение `240%`, мы гарантируем, что содержимое всех пар тегов **`<h1>...</h1>`** будет отображено с размером шрифта, превосходящим на `240 %` исходный размер. Все изменения в правиле должны быть внутри символов **`{`** и **`}`**, следующих за селектором. В **`font-size:240%;`** та часть, которая находится перед : (двоеточием), ==является *свойством*, а все остальное является применяемым к нему *значением*.==

И наконец, следует точка с запятой (**`;`**), завершающая инструкцию. В данном примере, поскольку **`font-size`** является последним свойством правила, точка с запятой не требуется (но она должна присутствовать, если за этим свойством будет задано значение еще одного свойства).


### Множественные задания стиля
---

Задать несколько стилевых настроек можно двумя разными способами. Можно объединить их в одной строке:

```css
hi { font-size:240%; color:blue; }
```

Здесь добавлено второе задание стиля, изменяющее цвет всех заголовков, задаваемых тегом **`<hi>`**, на синий. Можно также расположить задания построчно:

```css
hi {
  font-size:240%;
  color:blue;
}
```

==Или же можно разнести задания еще дальше, расположив столбцами по двоеточиям, что, по всей видимости, является наиболее предпочтительным методом в наше время:==

```css
hi {
  font-size :240%;
  color :blue;
}
```

==Тогда будет проще заметить, где начинается каждый новый набор правил, поскольку селектор всегда находится в первом столбце, а следующие за ним задания аккуратно выстраиваются благодаря одинаковому горизонтальному смещению всех значений свойств.== В предыдущих примерах замыкающие точки с запятой не нужны, но если придется объединять какие-нибудь подобные группы инструкций в одну строку, то при наличии всех точек с запятой это можно будет сделать довольно быстро.

Один и тот же селектор можно указывать произвольное количество раз, и CSS будет объединять все свойства. Иными словами, предыдущему примеру можно также придать следующий вид:

```css
hi { font-size: 240%; }
hi { color : blue; }
```

>[!tip]
>Каких-либо правильных или неправильных способов раскладки кода CSS не существует, но я рекомендую вам по крайней мере стараться соблюдать единообразие в построении каждого блока CSS, чтобы в нем можно было разобраться с первого взгляда.

==А что произойдет, если задать одно и то же свойство для одного и того же селектора дважды?==

```css
hi { color : red; }
hi { color : blue; }
```

==Будет применено последнее заданное свойство==, в данном случае то, которое имеет значение **`blue`**. Повторять в одном файле одно и то же свойство для одного и того же селектора было бы бессмысленно, ==но такие повторения часто бывают при реальном использовании веб-страниц, когда для них применяются сразу несколько стилей. Это и есть одно из ценных свойств CSS, которое называется== *каскадированием*.


#### Использование комментариев
---

CSS-правила желательно прокомментировать: пусть даже не все или не основную их часть, а только главную группу инструкций. Это делается путем размещения комментариев внутри пары следующих тегов:

```css
/* Это комментарий CSS */
```

Комментарий можно развернуть и на несколько строк:

```css
/*
Много-
строчный
комментарий
*/
```

>[!info]
>При использовании многострочного комментария нужно иметь в виду, что в них нельзя вкладывать однострочные (или любые другие) комментарии. Это может привести к непредсказуемым ошибкам.


## Типы стилей
---

Существует несколько разных типов стилей, начиная с исходных стилей, установленных в вашем браузере (и любых пользовательских стилей, которые вы можете применить в своем браузере, чтобы переопределить исходные значения), продолжая вложенными или встроенными стилями и заканчивая внешними таблицами стилей. Для стилей, которые были определены, действует иерархическая последовательность выполнения, направленная снизу вверх.

Более подробно все касающееся понятия *каскадности* таблиц стилей будет рассмотрено в разделе «[[#Каскадность CSS]]» далее в этой главе. Но прежде чем перейти к деталям, будет полезно предложить вам краткое введение.


### Исходные стили
---

==В браузере применяется задание исходных стилей, имеющих самый низкий уровень приоритета.== Этот набор стилей создается на тот случай, когда у веб-страницы нет определений каких-нибудь других стилей. Он предназначен для использования в качестве общего набора стилей, достаточно корректно отображаемого в большинстве случаев.

До создания CSS это были только стили, применяемые к документу, и лишь небольшая часть этих стилей могла быть изменена веб-страницей (например, внешний вид шрифта, его цвет и размер плюс несколько аргументов, относящихся к размеру элементов).


### Пользовательские стили
---

==У пользовательских стилей следующий высочайший уровень приоритета==. Они поддерживаются большинством современных браузеров, но каждым из них реализуются по-разному, поэтому сегодня для создания своих собственных предпочитаемых стилей оформления просматриваемой информации проще всего воспользоваться таким дополнительным модулем, как **Stylish** (http://userstyles.org/).

Если вы захотите создать собственные исходные настройки стилей для просмотра веб-страниц, **Stylish** будет наиболее простым способом. Вбейте в поиск «stylish extension» и установите расширение в свой браузер, как показано на **рис. 19.2.**

Если задан пользовательский стиль, который уже был определен в качестве исходного стиля браузера, то пользовательский стиль заменит исходный стиль браузера. Любые стили, не определенные в пользовательской таблице стилей, сохранят свои исходные значения, установленные в браузере.

>![[Рис. 19.2. Stylish — один из способов оформить веб-страницу по своему вкусу.jpg]]
>**Рис. 19.2**. Stylish — один из способов оформить веб-страницу по своему вкусу


### Внешние таблицы стилей
---

==К следующему типу относятся стили, которые задаются во внешней таблице стилей и заменяют любые стили, заданные как пользователем, так и браузером.== Внешние таблицы стилей являются рекомендуемым способом создания ваших стилей, поскольку вы можете создавать разные таблицы стилей для разных целей, например для общего использования в интернете, для просмотра страниц в браузерах мобильных устройств с небольшими экранами, для получения распечатки и т. д. Нужно будет просто применить при создании веб-страницы один нужный набор стилей для каждого типа носителя информации.


### Внутренние стили
---

==Затем следуют внутренние стили, создаваемые внутри тегов **`<style>...</style>`**, которые имеют более высокий уровень приоритета над всеми предыдущими типами стилей==. Но с этого момента принцип разделения стилевого оформления и содержимого начинает нарушаться, поскольку любые внешние таблицы стилей, загруженные в то же самое время, будут иметь более низкий уровень приоритета.


### Внедренные стили
---

==И наконец, рассмотрим внедренные стили, представляющие собой назначение свойства непосредственно элементу==. Они также имеют наивысший уровень приоритета над любым типом стилей. Вот пример их использования:

```html
<a href="http://google.com" style="color:green;">Посетите Google</a>
```

В этом примере определяемая ссылка будет отображена зеленым цветом, независимо от любых исходных или других цветовых настроек, применяемых любой другой таблицей стилей либо непосредственно к этой ссылке, либо общим порядком ко всем ссылкам.

>[!info]
>При использовании этого типа образования стилей вы нарушаете отделение разметки от содержимого, поэтому применять подобные решения рекомендуется только при крайней необходимости.



## Селекторы CSS
---

Средства доступа к одному или нескольким элементам называются *селекцией*, а та часть правила CSS, которая этим занимается, известна как *селектор*. И как вы уже, наверное, догадались, существует множество разнообразных селекторов.


### Селектор типа
---

Селектор типа работает в отношении типов HTML-элементов, например **`<p>`** или **`<i>`**. Следующее правило, к примеру, обеспечивает полное выравнивание всего текста, находящегося между тегами **`<p>...</p>`**:

```css
p { text-align:justify; }
```


### Селектор потомков
---

==Селекторы потомков позволяют применять стили к элементам, содержащимся внутри других элементов.== Например, следующее правило настраивает вывод всего текста внутри тегов **`<b>...</b>`** красным цветом, но только если эти теги окажутся внутри тегов **`<p>...</p>`** (как в этом случае: **`<p><b>Hello</b> there</p>`**):

```css
p b { color:red; }
```

Вложенность селекторов потомков может продолжаться до бесконечности, поэтому следующее правило является вполне приемлемым для того, чтобы полужирный текст внутри элемента маркированного списка выводился синим цветом:

```css
ul li b { color:blue; }
```

В качестве практического примера представим себе, что нужно использовать другую систему нумерации, отличающуюся от исходной для пронумерованного списка, вложенного в другой пронумерованный список. Этого можно достичь следующим способом, заменяющим исходную нумерацию (начинающуюся с **`1`**) буквами в нижнем регистре (начинающимися с **`a`**):

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      ol ol { list-style-type:lower-alpha; }
    </style>
  </head>
  <body>
    <ol>
      <li>Один</li>
      <li>Два</li>
      <li>Три
        <ol>
          <li>Один</li>
          <li>Два</li>
          <li>Три</li>
        </ol>
      </li>
    </ol>
  </body>
</html>
```

Загрузка этого кода HTML в браузер даст следующий результат — как видите, элементы второго списка отображаются иначе:


1. Один
2. Два
3. Три
  *a. Один*
  *b. Два*
  *c. Три*



### Селектор дочерних элементов
---

==Селектор дочерних элементов похож на селектор потомков, но он еще больше конкретизирует область применения стиля, выбирая только те элементы, которые являются непосредственными дочерними элементами другого элемента.== Например, следующий код использует селектор потомков, который изменит цвет любого текста, выделенного полужирным шрифтом, внутри абзаца на красный, даже если сам полужирный текст находится внутри выделения курсивом (подобно следующему коду: **`<p><i><b>Привет</b>всем</i></p>`**):

```css
p b { color:red; }
```

В данном случае слово **Привет** отображается красным цветом. Но когда этот более общий тип поведения не требуется, чтобы сузить область применения селектора еще больше, может использоваться селектор дочерних элементов. Например, в следующем правиле знак «больше чем» вставлен с целью создания селектора дочерних элементов, устанавливающего красный цвет для текста, выделенного полужирным шрифтом, только в том случае, если элемент будет непосредственным дочерним элементом абзаца и внутри не содержится другой элемент:

```css
p > b { color:red; }
```

Теперь слово **Привет** ==не изменит свой цвет==, потому что оно не является непосредственным дочерним элементом абзаца.

В качестве практического примера представим себе, что нужно применить стиль только к тем **`<li>`**-элементам, которые являются непосредственными дочерними элементами **`<ol>`**-элементов. Добиться этого можно с помощью следующего кода, где к **`<li>`**-элементам, являющимся непосредственными дочерними элементами **`<ul>`**-элементов, стиль применяться не будет:

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
    ol > li { font-weight:bold; }
    </style>
  </head>
  <body>
    <ol>
      <li>Один</li>
      <li>Два</li>
      <li>Три</li>
    </ol>
    <ul>
      <li>Один</li>
      <li>Два</li>
      <li>Три</li>
    </ul>
  </body>
</html>
```

Результат загрузки этого HTML-кода в браузер будет иметь следующий вид:

**1. Один**
**2. Два** 
**3. Три**
- Один
- Два
- Три


### Селектор элементов, имеющих идентификатор
---

Если у элемента есть имя-идентификатор (наподобие следующего: **`<div id='mydiv'>`**), к нему можно обратиться из CSS напрямую следующим способом, выделяющим весь текст в названном элементе курсивом:

```css
#mydiv { font-style:italic; }
```

==Каждый идентификатор может использоваться в документе только один раз, поэтому только первое найденное появление идентификатора приведет к применению нового значения того или иного свойства, заданного правилом CSS.== Но в CSS можно непосредственно ссылаться на любые идентификаторы, имеющие одинаковые имена, если они появляются в элементах разного типа:

```html
<div id='myid'>Привет</div> <span id='myid'>Привет</span>
```

Поскольку идентификаторы обычно применяются только к уникальным элементам, следующее правило будет задавать подчеркивание только первому появлению **`myid`**:

```css
#myid { text-decoration:underline; }
```

Но можно добиться того, чтобы правило в CSS применялось к обоим появлениям данного идентификатора:

```css
span#myid { text-decoration:underline; }
div#myid { text-decoration:underline; }
```

Или в сокращенной записи (см. раздел «Групповая селекция» далее в этой главе): **`span#myid,div#myid { text-decoration:underline; }`**

>[!danger]
>Я не рекомендую использовать такую форму селекции, поскольку она возводит барьеры в использовании JavaScript. Любой код JavaScript, который также должен обращаться к данным элементам, не сможет с этим справиться, так как широко применяемая функция **`getElementById`** вернет только первое появление элемента с таким идентификатором. Для ссылки на любые другие экземпляры программе придется перебрать весь список элементов в документе, что является куда более сложной задачей. Лучше всегда выбирать для идентификаторов только уникальные имена.


### Селектор класса
---

==Когда на странице имеются элементы, для которых нужно применить один и тот же стиль, всем этим элементам можно задать одно и то же имя класса== (например: **`<span class='myclass'>`**), а затем создать единое правило для одновременного изменения всех этих элементов как в следующем правиле. Оно создает смещение левого края на 10 пикселов для всех элементов, которые используют данный класс:

```css
.myclass { margin-left:10px; }
```

В современных браузерах могут быть HTML-элементы, использующие более одного класса, если имена классов разделить пробелами, например: **`<span class='class1 class2 class3'>`**.

Вы можете сузить область действия класса, указав тип элементов, к которым должно применяться правило. Например, следующее правило применяет настройки только к абзацам, использующим класс **`main`**:

```css
p.main { text-indent:30px; }
```

В данном примере только те абзацы, которые используют класс main (как этот: **`<p class="main">`**), получат новое значение свойства. На любые другие типы элементов, которые могут применять этот класс (такие, как **`<div class="main">`**), это правило распространяться не будет.


### Селектор атрибутов
---

Многие HTML-теги поддерживают атрибуты, и использование селектора данного типа может избавить вас от применения идентификаторов и классов для ссылок на элементы, задаваемые этими тегами. Например, можно непосредственно сослаться на атрибуты следующим образом, установив для всех элементов, задействующих атрибут **`type="submit"`**, ширину, равную 100 пикселам:

```css
[type="submit"] { width:100px; }
```

Если нужно ограничить область действия селектора до, к примеру, элементов ввода, принадлежащих форме и имеющих это значение атрибута типа, можно вместо предыдущего воспользоваться следующим правилом:

```css
form input[type="submit"] { width:100px; }
```
>[!info]
>Селекторы атрибутов также работают применительно к идентификаторам и классам, например, селектор **`[class~=»dassname»]`** работает точно так же, как и **`.classname`** (за исключением того, что у последнего из них более высокий уровень приоритета). Точно таким же образом селектор **`[id=»idname»]`** может использоваться вместо селектора идентификатора **`#idname`**. Селекторы классов и идентификаторов, предваряемые символами «решетка» (**`#`**) и «точка» (**`.`**), могут рассматриваться в качестве краткой формы селекторов атрибутов, имеющей при этом более высокий уровень приоритета. Оператор **`~=`** определяет соответствие атрибуту, даже если он входит в группу атрибутов, разделенных запятыми.


### Универсальный селектор
---

==Групповой символ== **`*`**==, или универсальный селектор, соответствует любому элементу, поэтому следующее правило приведет к полному беспорядку в документе, установив зеленое обрамление для всех его элементов:==

```css
* { border:1px solid green; }
```

Скорее всего, универсальный селектор будет использоваться не сам по себе, а как часть какого-нибудь составного правила, где он будет весьма эффективен. Например, следующее правило будет применять тот же самый стиль, что предыдущее, но только ко всем абзацам, являющимся подчиненными для того элемента, у которого имеется идентификатор со значением **`boxout`**, и только в том случае, если они не являются непосредственными дочерними элементами:

```css
#boxout * p {border:1px solid green; }
```

Разберемся в том, что здесь происходит. Первым селектором, следующим за **`#boxout`**, является символ «звездочка» (**`*`**), стало быть, он ссылается на любой элемент внутри объекта boxout. Затем следующий селектор **`p`** сужает фокус селекции, направляя его только на абзацы (что и определяется символом **`p`**), являющиеся подчиненными элементами, возвращаемыми селектором **`*`**. Поэтому данное CSS-правило приводит к выполнению следующих действий (в которых для ссылки на одни и те же вещи я использую взаимозаменяемые понятия «*объект*» и «*элемент*»).

1. Поиск объекта с идентификатором, имеющим значение boxout.
2. Поиск всех подчиненных элементов объекта, возвращенного при выполнении действия 1.
3. Поиск всех подчиненных *p-элементов* тех объектов, которые были возвращены при выполнении действия 2, и поскольку это последний селектор в группе, поиск также всех подчиненных *p-элементов*, подчиняющихся этим подчиненным элементам (и т. д.) того объекта, который был возвращен при выполнении действия 2.
4. Применение стилей, заданных внутри символов **`{`** и **`}`**, к объектам, возвращенным при выполнении действия 3.

В результате зеленое обрамление применяется только к абзацам, являющимся внучатыми (или правнучатыми и т. д.) элементами основного элемента.


### Групповая селекция
---

==При использовании CSS имеется возможность одновременного применения правила более чем к одному элементу, классу или любому другому типу селектора путем разделения селекторов запятыми==. Например, следующее правило поместит пунктирную оранжевую линию под всеми абзацами, элементом с идентификатором **`idname`** и всеми элементами, использующими класс со значением **`classname`**:

```css
p, #idname, .classname { border-bottom:1px dotted orange; }
```

На **рис. 19.3** показан результат применения разных селекторов, а рядом показаны применяемые к ним правила.
![[Рис. 19.3. Фрагменты кода HTML и применяемые в отношении этих фрагментов правила CSS.jpg]]
> **Рис. 19.3.** Фрагменты кода HTML и применяемые в отношении этих фрагментов правила CSS


## Каскадность CSS
---

Как уже вкратце упоминалось, одной из основополагающих особенностей свойств CSS является их *каскадность*, благодаря которой они и называются каскадными таблицами стилей (Cascading Style Sheets). Но что это означает?

==**Каскадирование** — это метод, используемый для решения потенциальных конфликтов между различными типами стилей, поддерживаемых браузером, и применения их в порядке приоритетности в зависимости от создателя стилей, от метода, который использован для создания стиля, и от типов выбранных свойств.==


### Создатели таблиц стилей
---

Все современные браузеры поддерживают три основных типа таблиц стилей. В порядке приоритетности сверху вниз они располагаются следующим образом.

1) созданные автором документа;
2) созданные пользователем;
3) созданные браузером.

Эти три набора таблиц стилей обрабатываются в обратном порядке. Сначала к документу применяются исходные настройки браузера. Без них веб-страницы, не использующие таблицы стилей, выглядели бы ужасно. Они включают внешний вид, размер и цвет шрифта, интервалы между элементами, обрамление и отступы в таблицах и все остальные разумные стандарты, ожидаемые пользователем.

Затем, если пользователь создал какие-нибудь стили, которые предпочитает применять в качестве стандартных, эти стили заменяют исходные стили браузера, с которыми они могут конфликтовать.

И наконец, применяются любые стили, созданные автором текущего документа, заменяя любые стили, либо созданные в качестве исходных стилей браузера, либо созданные пользователем.


### Методы создания таблиц стилей
---

Таблицы стилей могут создаваться с помощью трех различных методов. Если расположить их в порядке приоритетности сверху вниз, получится следующий список.

1) внедренные стили;
2) встроенная таблица стилей;
3) внешняя таблица стилей.

Эти методы создания таблиц стилей также применяются в порядке, обратном порядку их приоритетности. Поэтому сначала обрабатываются все внешние таблицы стилей, и к документу применяются их стили.

Затем обрабатываются любые встроенные стили (которые находятся внутри тегов **`<style>...</style>`**). Все, что конфликтует с внешними правилами, получает приоритет и заменяет эти правила.

И наконец, наивысший приоритет получают любые стили, применяемые непосредственно к элементу в качестве внедренного стиля (такие, как **`<div style="...">...</div>),`** которые заменяют все предыдущие заданные свойства.


### Селекторы таблиц стилей
---

Существует три разных способа выбора стилизуемых элементов. В порядке убывания приоритетности их список имеет такой вид.

1) обращение по индивидуальному идентификатору или селектор атрибутов;
2) обращение в группах по классу;
3) обращение по тегам элементов.

Селекторы обрабатываются согласно количеству и типам элементов, подпадающих под правило, которое несколько отличается от предыдущих двух правил разрешения конфликтов. ==Причина состоит в том, что правила не должны сразу применяться только к одному типу селектора и могут иметь отношение к разным селекторам.==

Таким образом, метод, необходимый для определения уровня приоритета правил, может содержать любую комбинацию селекторов. Это делается вычислением специфики каждого правила путем выстраивания их в порядке убывания области действия.


### Вычисление специфики
---

==Специфика правила вычисляется путем создания тернарных чисел на основе типов селекторов в показанном выше списке.== Эти составные числа сначала выглядят как **`[0,0,0]`**. При обработке правила каждый селектор, который ссылается на идентификатор, увеличивает первое число на единицу, и составное число приобретает вид **`[1,0,0]`**.

Посмотрим на следующее правило. У него имеется семь ссылок, три из которых — ID-ссылки (**`#heading`**, **`#main`** и **`#menu`**), поэтому составное число приобретает вид **`[3,0,0]`**:

```css
#heading #main #menu .text .quote p span {
  // Здесь размещаются правила;
}
```

Количество классов в селекторе помещается во второй части составного числа. В данном примере два класса (**`.text`** и **`.quote`**), поэтому составное число приобретает вид **`[3,2,0]`**.

И наконец, вычисляется количество селекторов, ссылающихся на теги элементов, и результат помещается в последнюю часть составного числа. В нашем примере таких селекторов два (**`p`** и **`span`**), поэтому составное число приобретает следующий окончательный вид: **`[3,2,2]`**.

Этого вполне достаточно для сравнения специфики данного правила с другими спецификами. В случаях, подобных этому, когда в составном числе набирается девять или меньше селекторов каждого типа, его можно преобразовать непосредственно в десятичное число, в нашем случае это 322. Правила с меньшим числом, чем это, будут иметь меньший приоритет, а правила с более высоким числом будут иметь больший приоритет. Когда у двух правил будет одно и то же значение, выиграет последнее из применявшихся.

Предположим, к примеру, что у нас также есть следующее правило:

```css
#heading #main .text .quote .news p span {
  // Здесь размещаются правила;
}
```

Здесь, несмотря на то что ссылка также идет на семь элементов, имеется только две ID-ссылки, но три ссылки на классы, в результате чего получается составное число **`[2,3,2]`**. Поскольку 322 больше, чем 232, у первого примера приоритет выше, чем у второго.


### Использование другой системы счисления
---

Когда в составном числе набирается более девяти типов селекторов, нужно переходить к использованию «более старшей» системы. Например, составное число **`[11,7,19]`** не подлежит преобразованию в десятичное простым объединением трех частей.

Вместо этого его можно преобразовать в число с более высоким основанием системы счисления, например с основанием 20 (или выше, если будет больше 19 селекторов любого типа).

Для этого нужно умножить все три части и сложить результаты, как показано ниже, начиная с крайнего справа числа и переходя влево:

```math

20 х 19 = 380
20x20 х 7 = 2800
20x20x20 х 11 = 88000
Всего в десятичном виде = 91180
```

Замените значения **20** слева значениями применяемого по необходимости основания. Затем, когда все составные числа набора правил пройдут преобразование из этого основания в десятичное, будет просто определить специфику, а стало быть, и уровень приоритета каждого.

К счастью, процессор CSS делает все это за вас, но понимание принципов данной работы поможет правильно создавать правила и разбираться в тех уровнях приоритета, которые у них будут.

>[!tip]
>Если предыдущие вычисления кажутся вам слишком сложными, полезно будет усвоить одно простое общее правило, которого можно придерживаться в большинстве случаев: чем меньше подвергаемых изменению элементов и чем более конкретно они указаны, тем более высокий приоритет получает правило.


### Одни правила бывают «равнее» других
---

Когда два правила задания стилей или более имеют абсолютно одинаковый уровень приоритета, то по умолчанию будет применяться последнее обработанное правило. Но вы можете придать правилу более высокий уровень приоритета по сравнению с другими равными ему правилами, используя объявление **`!important`**:

```css
p { color:#ff0000 !important; }
```

При этом все предыдущие равные настройки заменяются (даже те, в которых используется объявление **`!important`**), и любые равные правила, обрабатываемые позже, игнорируются. Например, второе из двух следующих правил в обычном случае имело бы приоритет, но из-за применения объявления **`!important`** в ранее заданном правиле оно игнорируется:

```css
p { color:#ff0000 !important; }
p { color:#ffff00 }
```

>[!info]
>Пользовательские таблицы стилей могут создаваться для определения исходных стилей браузера, и в них может применяться объявление **`!important`**. В этом случае пользовательская настройка стиля будет иметь преимущество над аналогичными свойствами, указанными на текущей веб-странице. Также следует заметить, что установки пользовательского стиля, не имеющие объявления **`!important`**, будут переписаны любыми стилями с этим объявлением, имеющимися на веб-странице.


## Разница между элементами div и span
---

Оба элемента — **`<div>`** и **`<span>`** — относятся к контейнерам, но некоторые качества у них отличаются. По умолчанию **`<div>`**-==элемент имеет бесконечную ширину== (как минимум до края окна браузера), которую можно увидеть, если применить к контейнеру единичное обрамление:

```html
<div style="border:1px solid green;">Привет</div>
```

А **`<span>`**-==элемент не шире того текста, который в нем содержится. Поэтому следующий код HTML создаст обрамление только вокруг слова Привет, и оно не будет расширяться до правого края браузерного экрана:==

```html
<span style="border:1px solid green;">Привет</span>
```

Кроме того, **`<span>`**-элемент сопровождает текст или другие объекты и при их переносе на следующие строки, поэтому может иметь довольно сложное обрамление. Например, в **примере 19.2** код CSS использован для создания желтого фона для всех **`<div>`**-элементов, для создания голубого фона для всех **`<span>`**-элементов и для добавления обрамления и к тем и к другим, перед тем как создать несколько примеров **`<span>`**- и **`<div>`**-блоков.

>**Пример 19.2.** Пример контейнеров **`<div>`** и **`<span>`**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Div and span example</title>
    <style>
      div, span { border          :1px solid black; }
      div       { background-color:yellow;          }
      span      { background-color:cyan;            }
    </style>
  </head>
  <body>
    <div>Этот текст находится внутри тега div</div>
    А этот – нет. <div>A этот снова внутри тега div.</div><br>

    <span>Этот текст находится внутри тега span .</span>
    А этот – нет. <span>А этот снова внутри тега span.</span><br><br>

    <div>Это более объемный текст в теге div, который переносится
    на следующую строку браузера</div><br>

    <span>Это более объемный текст в теге span, который переносится
    на следующую строку браузера</span>
  </body>
</html>
```

Как выполнение кода этого примера выглядит в окне браузера, показано на **рис. 19.4.** Хотя все в печатной версии книги изображается в серых тонах, на рисунке четко показано, как **`<div>`**-элементы расширяются до правого края окна браузера и заставляют следующее за ними содержимое появляться с начала первой доступной позиции ниже себя.

![[Рис. 19.4. Разнообразные элементы, имеющие разную ширину.jpg]]
>   **Рис. 19.4.** Разнообразные элементы, имеющие разную ширину

На рисунке также видно, как ведут себя **`<span>`**-элементы, занимая только то пространство, которое требуется для размещения их содержимого, не заставляя при этом последующее содержимое страницы появляться под ними.

Вдобавок к этому в двух самых нижних примерах, показанных на рисунке, можно увидеть, что когда **`<div>`**-элементы при достижении края экрана переносятся на новую строку, они сохраняют прямоугольную форму, в то время как **`<span>`**-элементы просто следуют за потоком содержащегося в них текста (или другого содержимого).

>[!tip]
>Поскольку **`<div>`**-теги могут создавать только прямоугольные контейнеры, они лучше подходят для содержания таких объектов, как изображения, блоки, цитаты и т. д., а контейнеры, создаваемые **`<span>`**-тегами, больше подходят для текста или других атрибутов, которые размещаются один за другим на одной линии и должны располагаться слева направо (или в некоторых языках справа налево).


## Измерения
---

CSS поддерживает впечатляющий диапазон различных единиц измерения, позволяя очень точно выкраивать веб-страницы для конкретных значений или относительных размеров. Я обычно пользуюсь следующими единицами измерения (и считаю, что вам они также будут наиболее полезны): [[Введение в CSS#^47337a|пикселами]], [[#^278a36|пунктами]], [[#^79087a|эмами]] и [[#^868313|процентами]]. Рассмотрим подробнее эти, а также другие единицы измерения.

- *Пиксел* (**pixel**) — его размер варьируется в соответствии с размерами и глубиной пиксела на пользовательском экране. Один пиксел равен ширине и высоте отдельной точки на экране, поэтому данную единицу измерения лучше всего использовать для экранов, а не для распечаток. Например: ^47337a

```css
.classname {margin: 5px;}
```

- *Пункт* (**point**) — равен по размеру 1/72 дюйма. Эта единица измерения пришла из полиграфии и лучше всего подходит для той среды, но также широко используется и для отображений на экранах. Например: ^278a36
```css
.classname {font-size: 14pt;}
```

- *Дюйм* (**inch**) — равен 72 пунктам и также относится к типу единиц измерения, наиболее приспособленных для организации вывода на печать. Например:
```css
.classname {width: 3in;}
```

- *Сантиметр* (**centimeter**) — еще одна единица измерения, которая наиболее пригодна для организации вывода на печать. Один сантиметр немного превышает по размеру 28 пунктов. Например:
```css
.classname {height: 4cm;}
```

- *Миллиметр* (**millimeter**) — это 1/10 сантиметра (или почти 3 пункта). Миллиметры являются еще одной единицей измерения, наиболее подходящей для организации вывода на печать. Например:
```css
.classname {font-size: 4mm;}
```

- *Пика* (**pica**) — еще одна типографская единица измерения, равная 12 пунктам. Например:
```css
.classname { font-size:1pc; }
```

- *Эм* (**em**) — равен текущему размеру шрифта (ширине латинской буквы **m**). Это одна из наиболее полезных единиц измерения для CSS, поскольку используется для описания относительных размеров. Например: ^79087a
```css
.classname {font-size: 2em;}
```

- *Экс* (**ex**) — также относится к текущему размеру шрифта. Он равен высоте буквы **x** нижнего регистра. Это менее популярная единица измерения, которая чаще всего используется в качестве хорошего приблизительного значения, помогающего установить ширину прямоугольного блока, который будет содержать некий текст. Например:
```css
.classname { width:20ex; }
```

- *Процент* (**percent**) — эта единица сродни *эму* (**em**) и ровно в 100 раз больше (применительно к шрифту). Если 1 em эквивалентен текущему размеру шрифта, в процентах тот же размер выражается цифрой 100. Когда эта единица не относится к шрифту, она относится к размеру того контейнера, к которому применяется данное свойство. Например: ^868313
```css
.classname {height: 120%;}
```

**На рис. 19.5** каждый из этих типов измерений показан по очереди применительно к отображаемому тексту почти одинаковых размеров.


## Шрифты и оформление
---

С помощью CSS можно настроить четыре основных свойства шрифта: семейство — **family**, стиль — **style**, размер — **size** и насыщенность — **weight**. Пользуясь этими свойствами, можно точно настроить способ отображения текста в ваших веб-страницах и (или) вывода его на печать.


### Свойство **`font-family`**
---

Это свойство назначает используемый шрифт. Оно также поддерживает перечисление множества шрифтов в порядке предпочтения слева направо, чтобы стилевое оформление при отсутствии у пользователя установленного

![[Рис. 19.5. Различные измерения, приводящие примерно к одинаковому результату.jpg]]
>**Рис. 19.5.** Различные измерения, приводящие примерно к одинаковому результату

предпочитаемого шрифта постепенно переходило в сторону менее предпочитаемых шрифтов. Например, для установки шрифта по умолчанию для абзацев можно воспользоваться следующим CSS-правилом:

```css
p {font-family: Verdana, Arial, Helvetica, sans-serif;}
```

Если название шрифта состоит из двух и более слов, его нужно заключить в кавычки:

```css
p { font-family:"Times New Roman", Georgia, serif; }
```

>[!info]
>Для использования на веб-страницах больше всего подходит такое семейство шрифтов, как Arial, Helvetica, Times New Roman, Times, Courier New и Courier, поскольку все эти шрифты доступны практически во всех браузерах и операционных системах. Шрифты Verdana, Georgia, Comic Sans MS, Trebuchet MS, Arial Black и Impact можно смело применять на Mac и PC, но они могут быть не установлены в других операционных системах, таких как Linux. Другими распространенными, но менее надежными шрифтами являются Palatino, Garamond, Bookman и Avant Garde. Если используется один из менее надежных шрифтов, нужно убедиться, что в ваших настройках CSS предложен один или несколько менее предпочтительных шрифтов, чтобы веб-страницы в отсутствие в браузерах предпочитаемых вами шрифтов шли в их использовании по нисходящей.

**На рис. 19.6** показано применение этих двух наборов CSS-правил.

![[Рис. 19.6. Выбор семейства шрифтов.jpg]]
>**Рис. 19.6.** Выбор семейства шрифтов


### Свойство **`font-style`**
---

С помощью этого свойства можно выбрать вывод шрифта в обычном — **normal**, курсивном — *italic* или наклонном — *oblique* виде. Следующие правила создают три класса (normal, italic и oblique), которые могут применяться к элементам для создания соответствующих эффектов:

```css
.normal {font-style: normal;}
.italic {font-style: italic;}
.oblique {font-style: oblique;}
```


### Свойство **`font-size`**
---

В [[#Измерения|предыдущем разделе]], касающемся единиц измерения, было рассмотрено множество способов изменения размера шрифта, но все они сводятся к двум основным типам: *фиксированному* и *относительному*. Фиксированная настройка похожа на следующее правило, которым для абзацев устанавливается размер шрифта, равный 14 пунктам:

```css
p { font-size:14pt; }
```

В качестве альтернативы можно предпочесть работу с текущим размером шрифта по умолчанию, используя его для стилевого решения таких видов текста, как заголовки. В следующих правилах определены относительные размеры некоторых заголовков, где тег **`<h4>`** начинает с прибавки в 20 % к размеру по умолчанию и каждое возрастание размера задается на 40 % больше предыдущего :

```css
h1 { font-size:240%; }
h2 { font-size:200%; }
h3 { font-size:160%; }
h4 { font-size:120%; }
```

**На рис. 19.7** показана подборка размеров шрифтов в действии.

![[Рис. 19.7..jpg]]
>**Рис. 19.7.** Настройка четырех размеров заголовков и размер абзаца,
                    используемый по умолчанию


### Свойство **`font-weight`**
---

Используя это свойство, можно задать насыщенность, или степень жирности, шрифта. Оно поддерживает несколько значений, но в основном востребованы **`normal`** и **`bold`**:

```css
.bold {font-weight: bold;}
```


## Управление стилями текста
---

Независимо от используемого шрифта в способ вывода текста можно внести дополнительные изменения, меняя его [[#Оформление|оформление]] — **`decoration`**, [[#Разрядка|разрядку]] **`spacing`** и [[#Выравнивание|выравнивание]] — **`alignment`**. Но свойства текста и шрифта перекликаются в том смысле, что курсивный и полужирный текст можно получить, используя свойства **`font-style`** и **`font-weight`**, в то время как другой текст, например подчеркнутый, требует применения свойства **`text-decoration`**.


### Оформление
---

Используя свойство **`text-decoration`**, можно применить к тексту такие эффекты, как подчеркивание — **`underline`**, перечеркивание — **`line-through`**, верхнее подчеркивание — **`overline`** и мигание — **`blink`**. Следующее правило создает новый класс по имени **`over`**, который применяет верхнее подчеркивание к тексту (насыщенность линий, используемых для подчеркивания снизу и сверху и для перечеркивания, будет соответствовать насыщенности шрифта):

```css
.over {text-decoration: overline;}
```

**На рис. 19.8** можно увидеть подборку стилей, насыщенности и оформления шрифтов.

![[Рис. 19.8. Примеры доступных правил стилевых решений и оформления.jpg]]
>  **Рис. 19.8.** Примеры доступных правил стилевых решений и оформления


### Разрядка
---

Существуют свойства, позволяющие изменить разрядку строк, слов и букв. Например, следующие правила настраивают разрядку строк для абзацев путем изменения свойства **`line-height`**, делая его на 25 % больше, устанавливают свойство **`word-spacing`** равным 30 пикселам и разрядку букв 3 пиксела:

```css
p {
  line-height: 125%;
  word-spacing: 30px;
  letter-spacing: 3px;
}
```

Процентным значением можно также воспользоваться для настройки значения свойства **`word-spacing`** или **`letter-spacing`** с целью уменьшения или увеличения исходной разрядки, применяемой к шрифту, используя значения меньше или больше 100 %, что будет приемлемо как для пропорциональных, так и для непропорциональных (моноширинных) шрифтов.


### Выравнивание
---

В CSS доступны четыре типа выравнивания текста: по левому краю — **`left`**, по правому краю — **`right`**, по центру — **`center`** и по ==ширине содержимого== — **`justify`**. В следующем правиле текст абзаца изначально настроен на полное выравнивание по ширине:

```css
p { text-align:justify; }
```


### Преобразование
---

Для преобразования текста доступны четыре свойства: отсутствие преобразования — **`none`**, преобразование первых букв слов в заглавные — **`capitalize`**, преобразование всех букв в заглавные — **`uppercase`** и преобразование всех букв в строчные — **`lowercase`**. Следующее правило создает класс по имени **`upper`**, гарантирующий при его применении вывод всего текста в верхнем регистре:

```css
.upper {text-transform: uppercase;}
```


### Отступы
---

С помощью свойства **`text-indent`** можно создать отступ первой строки блока текста на указанную величину. Следующее правило создает отступ первой строки каждого абзаца на 20 пикселов, но могут быть применены и другие единицы измерения или процентное увеличение:

```css
p { text-indent:20px; }
```

На **рис. 19.9** к блоку текста было применено следующее правило:

```css
p {
  line-height: 150%;
  word-spacing: 10px;
  letter-spacing: 1px;
}
.justify {text-align: justify;}
.uppercase {text-transform: uppercase;}
.indent {text-indent: 20px;}
```
![[Рис. 19.9. Примененные правила отступа, преобразования в верхний регистр и разрядки.jpg]]
>**Рис. 19.9.** Примененные правила отступа, преобразования в верхний регистр                              и разрядки


## Цвета в CSS
---

Цвета могут применяться к первому плану, а также к фону текста и объектов путем использования свойства цвета — **`color`** и фонового цвета — **`backgroundcolor`** (или путем предоставления единственного аргумента свойству фона background). Указанный цвет может быть одним из именованных цветов (например, red или blue), цветом, составленным из трех шестнадцатеричных чисел RGB (например, **`#ff0000`** или **`#0000ff`**), или цветом, составленным с использованием CSS-функции rgb.

Названия стандартных 16 цветов, определенных организацией по стандартам W3C (http://www.w3.org), следующие: аквамарин — `aqua`, черный — `black`, синий — `blue`, яркий пурпурно-красный, или фуксия, — `fuchsia`, серый — `gray`, зеленый — `green`, яркий светло-зеленый — `lime`, красно-коричневый — maroon, темно-синий — `navy`, оливковый — `olive`, фиолетовый — `purple`, красный — `red`, серебристый — `silver`, зеленовато-голубой — `teal`, белый — `white` и желтый `yellow`. Следующее правило использует одно из этих названий для установки фонового цвета для объекта с ID, имеющим значение **`object`**:

```css
#object {background-color: silver;}
```

В показанном ниже правиле фоновый цвет текста во всех **`<div>`**-элементах установлен желтым (поскольку на мониторе шестнадцатеричные уровни `ff` красного плюс `ff` зеленого плюс `00` синего составляют желтый цвет):

```css
div {color: #ffff00;}
```

Или, если не хочется работать с шестнадцатеричными числами, можно указать свои три цветовые составляющие с помощью функции **`rgb`** как в следующем правиле, которое изменяет фоновый цвет текущего документа на аквамарин:

```css
body {background-color: rgb(0, 255, 255);}
```

>[!tip]
>Если вы не хотите работать в диапазоне 256 уровней для каждого основного цвета, можете вместо них в функции `rgb` использовать процентный показатель со значениями от 0 до 100, в диапазоне от самого низкого (0) количества до самого высокого (100) основного цвета, например: `rgb(58%, 95%, 74%)`. Можно также для более тонкого управления цветом применять числа с плавающей точкой, например: `rgb(23.4%, 67.6%, 15.5%)`.


### Сокращенные цветовые строки
---

Есть также короткая форма строки шестнадцатеричных чисел, в которой для каждого цвета используется только первое число из каждой двухбайтовой пары. Например, вместо назначения цвета `#fe4692` можно применять `#f49`, где опущены вторые шестнадцатеричные цифры из каждой пары, что равно цветовому значению `#ff4499`.

Получается почти такой же цвет. Подобную запись можно применить, когда точный цвет не нужен. Разница между строками из шести и из трех цифр в том, что первые поддерживают 16 миллионов различных цветов, а вторые — всего 4 тысячи.

Там, где используется такой цвет, как `#883366`, полным эквивалентом ему будет `#836` (поскольку повторяющиеся цифры подразумеваются в сокращенной версии) и для создания одного и того же цвета можно применять любую строку.


### Градиенты
---

Вместо использования сплошного цветового фона можно применить градиент, который будет автоматически переходить от выбранного исходного до выбранного конечного цвета. Градиент лучше использовать в связке с простым цветовым правилом, чтобы браузеры, не поддерживающие градиенты, отображали хотя бы сплошной цвет.

В **примере 19.3** задействуется правило отображения оранжевого градиента (или просто обычного оранжевого цвета в браузерах, не поддерживающих градиенты), как показано в средней части **рис. 19.10.**

![[Рис. 19.10. Сплошной цвет фона, а также линейный и радиальный градиенты.jpg]]
>  **Рис. 19.10**. Сплошной цвет фона, а также линейный и радиальный градиенты

**Пример 19.3.** Создание линейного градиента
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Создание линейного градиента</title>
    <style>
      .orangegrad {
        background:orange;
        background:linear-gradient(top, #fb0, #f50);
        background:-moz-linear-gradient(top, #fb0, #f50);
        background:-webkit-linear-gradient(top, #fb0, #f50);
    </style>
  </head>
  <body>
    <div class='orangegrad'>Черный текст<br>
    на оранжевым<br>линейном градиенте</div>
  </body>
</html>
```

Для создания градиента нужно выбрать, где он будет начинаться: вверху (`top`), внизу (`bottom`), слева (`left`), справа (`right`), по центру (`center`) или в любых составных местах, например в левом верхнем углу (`top left`) или от центра вправо (`center right`). Затем следует ввести нужные начальный и конечный цвета и применить правило либо линейного (`linear-gradient`), либо радиального (`radial-gradient`) градиента, обеспечив правила для всех браузеров, на которые вы нацелились.

Вы также можете не только использовать начальный и конечный цвета, но и предоставлять между ними в качестве дополнительных аргументов составляющие *конечные* цвета. Например, если предоставлены пять аргументов, каждый из них будет управлять изменением цвета одной пятой области (в соответствии с его местом в списке аргументов).

Кроме градиентов, к CSS-объектам можно также применять такое свойство, как прозрачность, более подробно рассматриваемое в [[Продвинутая стилизация страниц с помощью CSS3]].


## Позиционирование элементов
---

Элементы попадают на веб-страницу туда, где они находятся в документе, но могут перемещаться путем изменения свойства позиции элемента от исходной статической (**`static`**) до абсолютной (**`absolute`**), относительной (**`relative`**), прилипчивой (**`sticky`**) или фиксированной (**`fixed`**).


### Абсолютное позиционирование
---

==Элемент с абсолютным позиционированием удаляется из документа, и любые другие элементы, которые в состоянии это сделать, займут освободившееся пространство.== Затем вы можете позиционировать объект в любое нужное место в документе, используя свойства «верх» — **`top`**, «право» — **`right`**, «низ» — **`bottom`** и «лево» — **`left`**.

==Например, для перемещения объекта с ID, имеющим значение **`object`**, в абсолютное место, находящееся на 100 пикселов ниже начала документа и на 200 пикселов от левого края, к нему нужно применить следующие правила== (вы также можете использовать любые другие единицы измерений, поддерживаемые CSS):

```css
#object {
  position:absolute;
  top :100px;
  left :200px;
}
```

Объект будет располагаться либо поверх других элементов, либо за другими, перекрывающими его элементами, в зависимости от значения, присвоенного свойству **`z-index`** (которое работает только в отношении позиционированных элементов). По умолчанию это свойство имеет значение **`auto`**, присваиваемое браузером без вашего участия. Вместо этого вы можете дать этому свойству целочисленное значение (которое может быть и отрицательным):

```css
#object {
  position:absolute;
  top :100px;
  left :200px;
  z-index:100;
}
```

После этого объекты будут появляться на экране в порядке от самого низкого и до самого высокого значения их свойства **`z-index`**, при этом объекты с более высокими значениями станут отображаться поверх объектов с более низкими значениями. По умолчанию значение **`z-index`** для элемента html равно 0, все остальные значения по умолчанию являются автоматическими.


### Относительное позиционирование
---

==Подобным образом можно переместить объект относительно того места, которое он занимал бы при обычном ходе формирования документа.== Так, например, для перемещения объекта на 10 пикселов вниз и 10 пикселов вправо от его обычного положения нужно воспользоваться следующими правилами:

```css
#object {
  position:relative;
  top :10px;
  left :10px;
}
```


### Фиксированное позиционирование
---

Заключительные настройки свойства **`position`** позволяют переместить объект в абсолютное положение, но только внутри окна просмотра текущего браузера. Затем при прокрутке документа объект остается именно там, куда он был помещен, а основной документ будет прокручиваться под ним — это неплохой способ создания док-панелей и других подобных устройств. Для фиксирования объекта в левом верхнем углу браузера нужно воспользоваться следующими правилами:

```css
#object {
  position:fixed;
  top :0px;
  left :0px;
}
```

В **примере 19.4** показано применение к объектам на странице различных значений позиционирования.

>**Пример 19.4**. Применение разных значений позиционирования
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Positioning</title>
    <style>
      #container {
        position  :absolute;
        top       :50px;
        left      :0px;
      }
      #object1 {
        position  :absolute;
        background:pink;
        width     :100px;
        height    :100px;
        top       :0px;
        left      :0px;
      }
      #object2 {
        position  :relative;
        background:lightgreen;
        width     :100px;
        height    :100px;
        top       :0px;
        left      :110px;
      }
      #object3 {
        position  :fixed;
        background:yellow;
        width     :100px;
        height    :100px;
        top       :50px;
        left      :220px;
      }
    </style>
  </head>
  <body>
	  <br><br><br><br><br>
    <div id='container'>
      <div id='object1'>Absolute Positioning</div>
      <div id='object2'>Relative Positioning</div>
      <div id='object3'>Fixed Positioning</div>
    </div>
 </body>
</html>
```

На **рис. 19.11** код **примера 19.4** был загружен в браузер и окно браузера было уменьшено по ширине и высоте. В результате появилась необходимость в прокрутке вниз, чтобы можно было увидеть всю веб-страницу.

![[Рис. 19.11. Использование разных значений позиционирования.jpg]]
>**Рис. 19.11.** Использование разных значений позиционирования

После прокрутки тут же выяснится, что элемент с фиксированной позицией (**`object3`**) останется на своем месте, несмотря на прокрутку. Также можно будет наблюдать, что элемент-контейнер (по имени **`container`**) обладает абсолютным позиционированием и размещается в точности на 50 пикселов ниже, с горизонтальным смещением 0 пикселов, поэтому элемент **`object1`** (имеющий абсолютное позиционирование внутри элемента **`container`**) появляется именно в этом месте. А элемент **`object2`** имеет относительное позиционирование, поэтому он смещен от левой границы элемента container на 110 пикселов, выстраиваясь рядом с элементом **`object1`**.

Показанный на рисунке элемент **`object3`**, несмотря на то что он в коде HTML появляется внутри элемента **`container`**, имеет фиксированное позиционирование, в результате чего он фактически совершенно независим от других объектов и не скован границами элемента **`container`**. Изначально он был настроен на нахождение на одной линии с элементами **`object1`** и **`object2`**, но остался на месте, в то время как другие элементы были прокручены вверх по странице, и теперь **`object3`** смещен ниже этих элементов.


## Псевдоклассы
---

Существуют селекторы и классы, используемые только внутри таблиц стилей и не имеющие каких-либо соответствующих тегов или атрибутов в HTML. Их задача заключается в том, чтобы классифицировать элементы, используя характеристики, отличные от их имен, атрибутов или содержимого, то есть характеристики, которые не могут быть прослежены по дереву документа. К их числу относятся такие псевдоклассы, как **`link`** и **`visited`**. Существуют также псевдоэлементы, с помощью которых осуществляется выбор и которые могут состоять из отдельных элементов, таких как первая строка — **`first-line`** или первая буква — **`first-letter`**.

Псевдоклассы и псевдоэлементы отделяются с помощью символа «двоеточие» (**`:`**). Например, для создания класса по имени **`bigfirst`** для выделения первой буквы элемента можно воспользоваться таким правилом:

```css
.bigfirst:first-letter {
  font-size: 400%;
  float: left;
}
```

Когда класс **`bigfirst`** применится к элементу, первая буква будет отображаться сильно увеличенной, а остальной текст будет показан в обычном размере, аккуратно ее обтекая (благодаря свойству **`float`**), как будто первая буква является изображением или другим объектом. В число псевдоклассов входят **`hover`**, **`link`**, **`active`** и **`visited`**. Все они наиболее полезны применительно к **`anchor`**-элементам, как показано в следующих правилах, которые устанавливают для ссылок в качестве исходного синий цвет, а для посещенных ссылок — светло-синий:

```css
a:link { color:blue; }
a:visited { color:lightblue; }
```

Следующие правила интересны тем, что в них используется псевдокласс **`hover`**, поэтому они применяются только при нахождении указателя мыши над элементом. В этом примере они изменяют в ссылке цвет текста на белый на красном фоне, предоставляя динамический эффект, который можно было бы ожидать только от использования кода JavaScript:

```css
a:hover {
  color: white;
  background: red;
}
```

Здесь вместо более длинного свойства цвета фона **`background-color`** я использовал свойство фона **`background`** с единственным аргументом.

Псевдокласс **`active`** также имеет динамический характер, выражающийся в том, что он влияет на изменение ссылки в промежутке времени между щелчком кнопки мыши и освобождением этой кнопки как в следующем правиле, изменяющем цвет ссылки на темно-синий:

```css
a:active { color:darkblue; }
```

Еще одним интересным динамическим псевдоклассом является **`focus`**, который применяется, только когда элемент получает фокус путем выбора его пользователем с помощью клавиатуры или мыши. Следующее правило применяет универсальный селектор, чтобы всегда помещать светло-серую пунктирную границу толщиной 2 пиксела вокруг объекта, имеющего фокус:

```css
*:focus { border:2px dotted #888888; }
```

>[!info]
>Здесь рассматриваются вопросы применительно к традиционной веб-разработке, а не к разработке для мобильных устройств с сенсорными экранами, речь о которой пойдет в главе 23, где будет рассмотрена работа с библиотекой jQuery Mobile.


Как показано на **рис. 19.12**, код **примера 19.5** выводит две ссылки и поле ввода. Первая ссылка показана серым цветом, поскольку она уже посещалась в этом браузере, а вторая ссылка еще не посещалась и показана синим цветом. Была нажата клавиша Tab, и фокусом ввода теперь служит поле ввода, поэтому цвет его фона поменялся на желтый. Когда пользователь щелкнет кнопкой мыши на любой из ссылок, она отобразится фиолетовым цветом, а когда над ней будет проходить указатель мыши, она станет красной.

>**Пример 19.5.** Псевдоклассы **`link`** и **`focus`**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Pseudo classes</title>
    <style>
      a:link    { color:blue; }
      a:visited { color:gray; }
      a:hover   { color:red; }
      a:active  { color:purple; }
      *:focus   { background:yellow; }
    </style>
  </head>
  <body>
    <a href='http://google.com'>Link to Google'</a><br>
    <a href='nowhere'>Link to nowhere'</a><br>
    <input type='text'>
  </body>
</html>
```

Доступны и другие псевдоклассы, дополнительную информацию о них можно получить на сайте http://tinyurl.com/pseudodasses.

![[Рис. 19.12. Псевдоклассы, примененные к подборке элементов.jpg]]
>   **Рис. 19.12.** Псевдоклассы, примененные к подборке элементов


## Сокращенная запись правил
---

Для экономии пространства группы родственных CSS-свойств могут объединяться в простое сокращенное назначение. Например, я уже несколько раз использовал сокращение для создания границы как в правиле focus в предыдущем разделе:

```css
*:focus { border:2px dotted #ff8800; }
```

На самом деле это сокращенное объединение такого набора правил:

```css
*:focus {
  border-width: 2px;
  border-style: dotted;
  border-color: #ff8800;
}
```

При использовании сокращенной записи правила нужно лишь применить свойства к тому пункту, у которого следует изменить значения. Для установки только ширины и стиля границы без изменения ее цвета можно также использовать следующее правило:

```css
*:focus {border: 2px dotted;}
```

>[!tip]
>Порядок размещения свойств в сокращенной записи правила может играть важную роль, и их неправильная расстановка приводит обычно к неожиданным результатам. Поскольку изложить многочисленные подробности в данной главе не представляется возможным, при необходимости воспользоваться сокращенной записью CSS вы сможете найти описание свойств, задаваемых по умолчанию, и порядок их применения в руководстве по CSS или в какой-нибудь поисковой системе.


## Модель блока и макет страницы
---

Свойства CSS, влияющие на макет страницы, основаны на модели блока, вложенном наборе свойств, окружающем элемент. Фактически такие свойства есть (или могут быть) у всех элементов, включая тело документа, чье поле вы можете (к примеру) удалить с помощью следующего правила:
```css
body { margin:0px; }
```

Модель блока объекта начинается снаружи, с поля объекта. Внутри него находится граница, затем следует отступ содержимого от границы. И наконец, идет содержимое объекта.

Если приобрести навыки работы с моделью блока, то можно существенно продвинуться на пути создания профессионально спланированных страниц, поскольку даже только эти свойства во многом определяют стилевое оформление страницы.


### Установка полей
---

Поле является самым крайним уровнем модели блока. Оно отделяет элементы друг от друга и требует разумного использования. Предположим, к примеру, что вы решили выбрать по умолчанию поле 10 пикселов вокруг каждого из нескольких элементов. Именно на этот промежуток между элементами вы станете рассчитывать, располагая два элемента друг над другом, но если у каждого из них будет поле в 10 пикселов, станет ли этот промежуток составлять 20 пикселов?

На самом деле CSS устраняет эту потенциальную проблему: когда два элемента с полями позиционируются непосредственно один над другим, для отделения их друг от друга используется только самое большое из двух полей. Если оба поля имеют одинаковую ширину, применяется только одна ширина. Благодаря этому вы, скорее всего, добьетесь желаемого результата. Но при этом имейте в виду, что поля элементов с заданным абсолютным позиционированием или встраиваемых элементов не подвергаются поглощению другими полями.

Поля элемента могут быть изменены целиком с помощью свойства **`margin`** или отдельно друг от друга с помощью свойств **`margin-left`**, **`margin-top`**, **`margin-right`** и **`margin-bottom`**. При установке свойства **`margin`** можно предоставить один, два, три или четыре аргумента, в результате чего получится эффект, прокомментированный в следующих правилах:

```css
/* Установка всех полей шириной 1 пиксел */
margin:1px;

/* Установка верхнего и нижнего полей шириной 1 пиксел, а левого и правого – 2 пиксела */
margin:1px 2px;

/* Установка верхнего поля шириной 1 пиксел, левого и правого – 2 пиксела и нижнего – 3 пиксела */
margin:1px 2px 3px;

/* Установка верхнего поля шириной 1 пиксел, правого – 2, нижнего – 3 и левого 4 пиксела */
margin:1px 2px 3px 4px;
```

В **`примере 19.6`** правило свойства **`margin`** (выделенное в коде полужирным шрифтом) применяется к прямоугольным элементам, помещенным внутри элемента **`table`**. На **`рис. 19.13`** показан результат выполнения кода этого примера после его загрузки в браузер. Размер таблицы не задан, поэтому она будет просто охватывать как можно плотнее внутренний **`<div>`**-элемент. Вследствие этого сверху будет поле шириной 10 пикселов, справа — поле шириной 20 пикселов, снизу — поле шириной 30 пикселов и слева — поле шириной 40 пикселов.

>**Пример 19.6.** Порядок применения полей
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Поля CSS</title>
    <style>
      #object1 {
        background  :lightgreen;
        border-style:solid;
        border-width:1px;
        font-family :"Courier New";
        font-size   :9px;
        width       :100px;
        height      :100px;
        padding     :5px;
        margin      :10px 20px 30px 40px;
      }
      table {
        padding     :0;
        border      :1px solid black;
        background  :cyan;
      }
    </style>
  </head>
  <body>
    <table>
      <tr>
        <td>
          <div id='object1'>margin:<br>10px 20px 30px 40px;</div>
        </td>
      </tr>
    </table>
  </body>
</html>
```

![[Рис. 19.13. Охватывающая таблица расширяется в соответствии с шириной полей.jpg]]
>**Рис. 19.13.** Охватывающая таблица расширяется в соответствии с шириной полей


### Применение границ
---

Уровень границ модели блока похож на уровень полей, за исключением того, что здесь отсутствует поглощение. Это следующий уровень по мере продвижения к центру модели блока. Основными свойствами, используемыми для изменения границ, являются **`border`**, **`border-left`**,**` border-top`**, **`border-right`** и **`border-bottom`**. Каждое из них может иметь другие *подсвойства*, добавляемые в виде суффиксов, например **`-color`**, **`-style`** и **`-width`**.

Четыре способа установки отдельных свойств, которые использовались для свойства **`margin`**, применимы и для свойства ширины границы — **`border-width`**, поэтому все следующие правила составлены верно:

```css
/* Все границы */
border-width:1px;

/* Верхняя/нижняя и левая/правая */
border-width:1px 5px;

/* Верхняя, левая/правая и нижняя */
border-width:1px 5px 10px;

/* Верхняя, правая, нижняя и левая */
border-width:1px 5px 10px 15px;
```

На **рис. 19.14** показано каждое из этих правил, примененное по очереди к группе квадратных элементов. Если смотреть на первый из них, сразу становится понятно, что ширина всех границ равна 1 пикселу. А вот у второго элемента верхняя и нижняя границы имеют ширину 1 пиксел, а его боковые границы имеют ширину по 5 пикселов. У третьего элемента верхняя граница шириной 1 пиксел, его боковые границы — по 5 пикселов, а нижняя — 10 пикселов. Четвертый элемент изображен с верхней границей шириной 1 пиксел, правой границей 5 пикселов, нижней — шириной 10 пикселов и левой — шириной 15 пикселов.

![[Рис. 19.14. Применение правил задания границ в полной и сокращенной записи.jpg]]
>**Рис. 19.14.** Применение правил задания границ в полной и сокращенной                                  записи

Для последнего элемента, расположенного под предыдущими элементами, сокращенная запись правил не использовалась. Вместо этого каждая из его границ задавалась отдельно. Как видите, для получения аналогичного результата потребовалось набрать значительно больше символов.


### Настройка отступов
---

Самыми глубокими уровнями модели блока (отличающимися от содержимого элемента) выступают отступы, применяемые внутри любых границ и (или) полей. Основными свойствами, используемыми для изменения отступов, являются **`padding`**, **`padding-left`**, **`padding-top`**, **`padding-right`** и **`padding-bottom`**.

Те четыре способа установки отдельных свойств, которые задействовались для свойств **`margin`** и **`border`**, применимы и для свойства отступа — **`padding`**, поэтому все следующие правила составлены верно:

```css
/* Все отступы */
padding:1px;

/* Верхний/нижний и левый/правый */
padding:1px 2px;

/* Верхний, левый/правый и нижний */
padding:1px 2px 3px;

/* Верхний, правый, нижний и левый */
padding:1px 2px 3px 4px;
```

На **рис. 19.15** показаны правила отступов, выделенные в **примере 19.7** полужирным шрифтом и примененные к тексту в ячейке таблицы (как определено с помощью правила **`display:table-cell`**;, которое задает охват **`<div>`**-элемента наподобие ячейки таблицы). Размеры ячейки не заданы, поэтому она максимально плотно охватывает текст. Вследствие этого получается отступ, равный 10 пикселам над внутренним элементом, 20 пикселам справа, 30 пикселам снизу и 40 пикселам слева.

>**Пример 19.7.** Применение отступов
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Padding</title>
    <style>
      #object1 {
        border-style:solid;
        border-width:1px;
        background  :orange;
        color       :darkred;
        font-family :Arial;
        font-size   :12px;
        text-align  :justify;
        display     :table-cell;
        width       :148px;
        padding     :10px 20px 30px 40px; }
    </style>
  </head>
  <body>
    <div id='object1'>To be, or not to be that is the question:
    Whether 'tis Nobler in the mind to suffer
    The Slings and Arrows of outrageous Fortune,
    Or to take Arms against a Sea of troubles,
    And by opposing end them.</div>
  </body>
</html>
```

![[Рис. 19.15. Применение к объекту разных значений отступов.jpg]]


### Содержимое объекта
---

И наконец, в глубине модели блока, в его центре, находится элемент, стиль которого может быть задан всеми способами, рассмотренными ранее в этой главе. Как вы теперь уже знаете, этот элемент может содержать (а зачастую и содержит) еще и подчиненные элементы, у которых, в свою очередь, могут быть свои подчиненные элементы и т. д., и у каждого из них могут быть свои настройки стиля и модели блока.


## Вопросы
---

- [x] 1. Какая инструкция используется для импорта одной таблицы стилей в другую (или в блок **`<style>`** кода HTML)?
- [x] 2. Каким HTML-тегом можно воспользоваться для импорта таблицы стилей в документ?
- [x] 3. Какой атрибут HTML-тега применяется для непосредственной вставки стиля в элемент?
- [?] 4. В чем разница между идентификатором CSS и классом CSS?
- [x] 5. Какие символы используются в качестве префиксов в CSS-правилах: а) идентификаторы и б) классы?
- [x] 6. Каково назначение точки с запятой в CSS-правилах?
- [x] 7. Как в таблице стилей добавляется комментарий?
- [x] 8. Какой символ используется CSS для представления «любого элемента»?
- [/] 9. Как в CSS можно выбрать группу разных элементов и (или) типов элементов?
- [x] 10. Как можно задать преимущество одного из двух CSS-правил, имеющих одинаковый уровень приоритета?


---