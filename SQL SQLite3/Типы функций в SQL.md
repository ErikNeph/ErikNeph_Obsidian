
*Функции* в SQL — это специальные ключевые слова, которые принимают определенные параметры, выполняют определенные операции и возвращают результат в виде значения.
мы уже рассматривали функцию `DATE()`.

**ПРИМЕЧАНИЕ
Этот список неполный. Все функции, упомянутые в этой книге, поддерживаются SQLite. Другие реализации базы данных содержат другие функции. Полный список функций, поддерживаемых SQLite, доступен на веб-страницеSQLite.

![[Типы функций.jpg]]

Как видно на рис. 86, в SQL существуют функции трех разных типов.
- *Строковые функции* изменяют символьные и текстовые данные.
- *Функции даты и времени* изменяют данные времени и даты.
- *Агрегатные функции* выполняют математические операции.

**ПРИМЕЧАНИЕ
На первый взгляд может показаться, что эти три типа функций работают только с соответствующими им типами данных (символами, датами и числами). Однако вспомните первый пример с использованием функции COUNT(). Мы смогли использовать агрегатную функцию для арифметического подсчета символьных данных. В определенных случаях мы можем использовать эти функции с разными типами данных.

`SELECT`
	`COUNT(LastName) AS [NameCount]`
`FROM`
	`customers`
`WHERE`
	`LastName LIKE 'B%'`

Рассмотрим следующий пример. На панели Execute SQL (Выполнить SQL-запрос) начните вводить имя функции с одной открытой скобкой:
**UPPER(**
**The UPPER(X) function returns a copy of input string X in which all lowercase ASCII characters are converted to their uppercase equivalent.**


## Конкатенация строк

Конкатенация — объединение двух или более строк. Для слияния двух полей вместе используется символ ||. Например, следующий код выполняет объединение полей `FirstName` и `LastName`.

`SELECT`
	`FirstName || LastName`
`FROM`
	`customers`
`WHERE`
	`CustomerId = 1`

Оператор конкатенации || просто соединил оба поля вместе без пробелов. Для удобства чтения мы можем последовательно использовать две конкатенации и заключить пробел в одинарные кавычки. Тогда запрос будет выглядеть следующим образом:

`SELECT`
	`FirstName,`
	`LastName,`
	`FirstName || ' ' || LastName AS 'Full Name'`
`FROM`
	`customers`
`WHERE`
	`Country = 'USA'`
`

**ПРИМЕЧАНИЕ
Функция конкатенации || не похожа на остальные функции, которые мы будем рассматривать в этой главе. В других реализациях SQL существует функция CONCAT() или используется символ +. Синтаксис может отличаться в зависимости от того, какую РСУБД вы используете, но эффект будет одинаковым.


Рассмотрим следующий пример, где для создания в одной строке имени и адреса клиента используется множественная конкатенация.

`SELECT`
	`FirstName || ' ' || LastName || ', ' || Address || ', ' ||`
	`City || ', ' || State || ' ' ||`
	`PostalCode AS [MailingAddress]`
`FROM`
	`customers`
`WHERE`
	`Country = 'USA'`
`

## Обрезка строки

С помощью функций мы также можем вырезать из текста определенное количество символов. Из приведенного выше примера видно, что почтовые индексы США в таблице customers не единообразны. Некоторые из них содержат дефис и дополнительный четырехзначный номер, который почтовая служба США называет кодом ZIP +4. В одном из почтовых индексов отсутствует четвертая цифра почтового кода ZIP +4.

Мы используем функцию LENGTH() в таком поле, как `PostalCode` (таблица customers), и видим, что длина каждого кода может быть вычислена.

`SELECT`
	`PostalCode,`
	`length(PostalCode) AS [Postal Code Length]`
`FROM`
	`customers`
`WHERE`
	`Country = 'USA'`
`
Функция UPPER(X) возвращает копию входной строки X, в которой все символы ASCII в нижнем регистре переведены в верхний регистр. Функция LOWER() переводит все символы аргумента в нижний регистр.
Рассмотрим пример использования этих функций:

`SELECT`
	`FirstName AS [First Name Unmodified],`
	`upper(FirstName) AS [FirstName in UPPERCASE],`
	`lower(FirstName) AS [FirstName in lowercase],`
	`upper(FirstName) || ' ' || upper(LastName) AS [Full Name in UPPERCASE]`
`FROM`
	`customers`
`
В данном запросе в качестве аргумента функций UPPER() и LOWER() выступает поле FirstName. Также для обозначения результата мы использовали псевдоним Full Name, чтобы показать, что вы можете объединить два поля после выполнения функций.


## Функции даты и времени

Функции даты и времени позволяют управлять данными, хранящимися в различных форматах даты и времени. В базе данных sTunes информация о дате хранится в формате DATETIME: YYYY-MM-DD HH:MM:SS. Хотя формат позволяет вводить временной код, он не используется в нашей базе данных — все временные коды пусты и отображают 00:00:00. Поэтому, чтобы убрать временной код и оставить только информацию о дате, мы использовали функцию DATE() (см. главу 5). Поскольку в разных базах данных информация о дате может храниться по-разному, важно знать, как преобразовать один формат в другой. С датами мы можем сделать гораздо больше, чем просто изменить их формат. Например, чтобы вычислить возраст сотрудников, мы можем посчитать разницу между любой заданной и текущей датой, поскольку в таблице **employees** имеется поле **BirthDate** (Дата рождения).

Чтобы рассчитать возраст сотрудников, рассмотрим функцию `STRFTIME()`, также известную как функция времени в строковом формате. Она позволяет отформатировать информацию о времени и дате в виде текстовой строки. Для корректной работы функции `STRFTIME()` требуется как минимум информация двух видов. Необходимо указать желаемый формат (его называют спецификацией преобразования) и строку времени для форматирования. Строку времени можно ввести вручную или использовать поле **DATETIME**. В качестве аргумента строка времени также может использовать функцию `NOW`. Третий аргумент, модификатор, необязательный и может применяться для дискретного сдвига даты вперед или назад и выполнения некоторых других функций.

![[Функции даты.jpg]]


**ПРИМЕЧАНИЕ 
Функцию NOW иногда называют недетерминированной функцией. Это означает, что результирующие данные, возвращаемые этой функцией, будут разными при каждом ее вызове, поскольку дата и/или время будут разными при каждом вызове. Функция STRFTIME() и большинство других функций, описанных в этой книге, — детерминированные. То есть они дают один и тот же результат каждый раз, когда используются с одними и теми же аргументами. Функцию NOW необходимо постоянно обновлять, чтобы она оставалась точной и результат соответствовал времени вашего
компьютера.

**ПРИМЕЧАНИЕ
Функция STRFTIME() способна выполнять различные преобразования времени и дат. Если вы пока не совсем понимаете значения всех аргументов и выполняемых преобразований, не беспокойтесь. Главное то, что функция STRFTIME() принимает данные в формате времени и даты и использует ключевые слова для возврата определенных пользователем фрагментов даты.

![[Аргументы функций strftime.jpg]]

![[строка времени.jpg]]

![[модификатор времени.jpg]]


Давайте рассмотрим работу функции STRFTIME() на примере вычисления возраста сотрудников. Первое, что необходимо сделать, это указать необходимый формат. Поскольку **BirthDate** (Дата рождения) имеет тип данных DATETIME, а время в нашей базе данных не указано, для простоты опустим временные коды. Чтобы узнать возраст сотрудников, вычислим разницу во времени между датой рождения каждого сотрудника и текущей датой. Текущую дату можно получить, используя функцию **NOW**.

`SELECT`
	`LastName,`
	`FirstName,`
	`strftime('%Y-%m-%d', BirthDate) AS [BirthDate no Timecode],`
	`strftime('%Y-%m-%d', 'now') - strftime('%Y-%m-%d', BirthDate) AS [Age]`
`FROM`
	`employees`
`ORDER BY`
	`Age`
`
Мы можем использовать функцию `STRFTIME()` так же, как мы использовали функцию DATE() для удаления временных кодов. Затем, чтобы узнать возраст сотрудников, необходимо получить разницу между двумя функциями `strftime`.


## Агрегатные функции

*Агрегатные функции* воздействуют на значения столбца, чтобы получить единое результирующее значение с помощью различных математических операций. В начале этой главы, чтобы вычислить количество клиентов с фамилией, начинающейся с буквы B, мы использовали функцию COUNT(). Существует множество практических способов использования агрегатных функций. Так, используем функцию SUM() в таблице invoices для вычисления итоговой суммы всех счетов:

`SELECT`
	`sum(total) as 'Total Sales'`
`FROM`
	`invoices`

Существует множество агрегатных функций [11], но здесь мы рассмотрим пять основных функций в SQL: `SUM(), AVG(), MIN(), MAX() и COUNT()`.

![[Агрегатные функции.jpg]]

**ПРИМЕЧАНИЕ
По умолчанию функция COUNT() возвращает только ненулевые значения. Однако если необходимо подсчитать все записи, даже записи с ошибками или нулевыми значениями, рекомендуется использовать символ звездочки * или поле первичного ключа. Символ звездочки * обозначает «вернуть все записи». Поэтому, используя ее с агрегатной функцией COUNT(), мы получим количество всех записей в таблице invoices.

`SELECT`
	`sum(total) AS TotalSales,`
	`avg(total) AS AverageSales,`
	`max(total) AS MaximusSale,`
	`min(total) AS MinimumSale,`
	`count(*) AS SalesCount`
`FROM`
	`invoices`


## Вложенные функции на примере ROUND()

Вложенная функция — это та, которая содержится в другой функции. Одна из целей использования вложенных функций — модифицировать формат внутренней функции. Если мы проанализируем предыдущий пример, в котором мы использовали функцию AVG(), то увидим, что Average Sales (средний объем продаж) содержит слишком много десятичных знаков. Такой формат обычно не используется для денежных единиц. Функция ROUND(), хотя и не агрегатная, очень полезна при выполнении каких-либо математических операций или если требуется привести в порядок результаты. Для этой цели функцию AVG() можно поместить в функцию ROUND() (это и есть вложение) и указать количество десятичных знаков, до которого мы хотим округлить результат.

`ROUND(X,Y)` - Функция ROUND() округляет число X до указанного числа десятичных знаков Y. Если аргумент Y отсутствует, это означает, что он равен 0.

`SELECT`
	`avg(total) as [Average Sale],`
	`round(avg(total), 2) as [Rounded Average Sales]`
`FROM`
	`invoices`


## Использование агрегатных функций и условия GROUP BY

Полезной особенностью агрегатных функций считается их способность вычислять промежуточные значения, или агрегаты, для различных групп данных. Для таблицы invoices в базе данных sTunes мы можем легко получить среднюю сумму счета с помощью функции `AVG()`. Предположим, компании sTunes необходимо рассчитать среднюю сумму счета для каждого города, где его выставили.

Чтобы решить эту задачу, давайте проанализируем запрос. Нам задали вопрос: какова средняя сумма счетов по городам?

**НАПОМИНАНИЕ
Мы уже упоминали, что полезно разбивать запрос на компоненты, а также поразмыслить, какая таблица содержит нужную информацию и как ее отобразить. Ответ на эти два вопроса поможет вам устранить недочеты, связанные с запросом, который возвращает некорректную информацию.

В предыдущем (некорректном) запросе мы запросили у браузера SQL два вида информации из таблицы invoices. Сначала — перечислить все города в поле **BillingCity**. Затем — вычислить среднее значение поля Total. Результат выполнения первого запроса — многострочный ответ, а результат второго — однострочный ответ. Другими словами, мы указываем браузеру отображать одновременно как агрегатные, так и неагрегатные поля. Мы не получили необходимую информацию, так как неправильно сформулировали вопрос.

Исправить эту проблему можно, добавив в запрос условие `GROUP BY` следующим образом:

`SELECT`
	`BillingCity,`
	`round(avg(total), 2)`
`FROM`
	`invoices`
`GROUP BY`
	`BillingCity`
`ORDER BY`
	`BillingCity`



## Использование условий WHERE и HAVING со сгруппированными запросами

Добавление критериев в сгруппированный запрос работает так же, как и с другими, уже знакомыми нам запросами. Использование условия WHERE позволяет нам добавлять новые критерии. В примере ниже критерии добавляются для неагрегатного поля **BillingCity**.

`SELECT`
	`BillingCity,`
	`avg(total)`
`FROM`
	`invoices`
`WHERE`
	`BillingCity LIKE 'L%'`
`GROUP BY`
	`BillingCity`
`ORDER BY`
	`BillingCity`


**ВНИМАНИЕ
Следующий оператор SQL содержит ошибку. Но важно видеть, что критерии,
созданные в условии WHERE, не работают с агрегатными данными.

`SELECT`
	`BillingCity, AVG(Total)`
`FROM`
	`Invoices`
`WHERE`
	`AVG(Total) > 5 
`GROUP BY`
	`BillingCity 
`ORDER BY`
	`BillingCity`

При выполнении запроса возникнет следующее сообщение об ошибке: 
**Misuse of aggregate: AVG():**
(Неправильное использование агрегата: AVG())

Это сообщение об ошибке информирует нас, что для создания условия на основе агрегатной функции (по крайней мере, в данном случае) мы не можем использовать условие WHERE. В данном случае условие `WHERE` может указывать только, какую информацию извлекать из полей, указанных в условии `SELECT`. Если необходима дополнительная фильтрация на основе агрегатных функций, необходимо включить вторичную фильтрацию, известную как условие `HAVING`.

Условие `HAVING` всегда следует после условия `GROUP BY`. Измененный запрос теперь выглядит следующим образом:

`SELECT`
	`BillingCity,`
	`avg(total)`
`FROM`
	`invoices`
`GROUP BY`
	`BillingCity`
`HAVING`
	`avg(total) > 5`
`ORDER BY`
	`BillingCity`

**ПРИМЕЧАНИЕ
Условие HAVING позволяет фильтровать результат группировки, сделанной с помощью команды GROUP BY. Условие HAVING фильтрует агрегированные данные. Если вы попытаетесь использовать HAVING без условия GROUP BY, то получите сообщение об ошибке.


## Условия WHERE и HAVING

Если кратко, то разница между условиями `WHERE` и `HAVING` заключается в том, что `WHERE` предназначено для фильтрации неагрегатных данных, а `HAVING` — для фильтрации результатов, содержащих агрегаты. Если более подробно, то два типа фильтрации возникают, когда в запрос включены как условие `WHERE`, так и условие `HAVING`. Условие `WHERE` указывает запросу, какую информацию следует исключить из таблицы, а затем, после фильтрации данных и применения к полям агрегатных функций, условие `HAVING` действует как дополнительный фильтр для агрегатных данных. Давайте повторим предыдущий запрос, но на этот раз выберем только города, начинающиеся с буквы B, а затем из этого списка от-
фильтруем счета, среднее значение которых больше пяти (рис. 110).

`SELECT`
	`BillingCity,`
	`avg(total)`
`FROM`
	`invoices`
`WHERE`
	`BillingCity LIKE 'B%'`
`GROUP BY`
	`BillingCity`
`HAVING`
	`avg(total) > 5`
`ORDER BY`
	`BillingCity`

В запросе мы выполнили ту же задачу, но на этот раз добавили условие `WHERE` для фильтрации результатов только по городам, начинающимся с буквы B. Данный этап фильтрации выполняется до обработки условий `HAVING` и `ORDER BY`. Так как нам необходимо выполнить фильтрацию, прежде чем мы сможем группировать, то порядок условий фильтрации важен, а условие `WHERE` всегда предшествует `HAVING`.


## Группировка по нескольким столбцам

В условиях `GROUP BY` можно одновременно указывать столько столбцов, сколько вам требуется. Предположим, необходимо получить более подробную разбивку средних значений счетов. Мы можем написать запрос так, чтобы агрегированные данные были сначала сгруппированы по странам, а затем по городам. В приведенном ниже примере мы добавим в условие `GROUP BY` еще одно поле, BillingCountry. Давайте посмотрим, как работает запрос.

`SELECT`
	`BillingCountry,`
	`BillingCity,`
	`avg(total)`
`FROM`
	`invoices`
`GROUP BY`
	`BillingCountry, BillingCity`
`ORDER BY`
	`BillingCountry`

Группировка по нескольким столбцам может быть очень полезна, когда необходимо получить более детальную информацию.
