
==**Подзапрос**== — это просто один запрос, вложенный в другой. Подзапрос обычно добавляется в условия SELECT, FROM или WHERE. Использование подзапросов полезно, когда запрос, который мы хотим создать, требует нескольких дополнительных шагов или вычислений для создания ожидаемого набора данных.


## Использование агрегатных функций в подзапросах

Рассмотрим простой оператор SELECT, который мы использовали в предыдущей главе для возврата среднего значения суммы счета из таблицы invoices:

`SELECT`
	`round(avg(total), 2) AS [Average Total]`
`FROM`
	`invoices`

Мы видим, что в примере запроса средняя сумма счета из таблицы invoices составляет $5,65. Предположим, компания sTunes попросила нас собрать данные обо всех счетах, сумма которых меньше этого среднего значения. Прежде всего, необходимо использовать оператор SELECT, который выводит отдельные поля счета (например, InvoiceDate, BillingAddress, BillingCity и, конечно же, Total). Затем отфильтруем полученные результаты, сравнив их с агрегатной функцией. Используем условие WHERE, чтобы сравнить поле Total с полем AVG(Total). В предыдущей главе вы узнали, что попытка использования условия WHERE Total<AVG(Total) в условии WHERE для прямого сравнения приводит к ошибке misuse of aggregate function (неправильное использование агрегатной функции). Итак, нам надо взять указанный выше запрос и вставить его в другой запрос, который сортирует счета по итоговой сумме. И, к счастью, есть простой способ сделать это.

Начнем с базового оператора SELECT, а затем, используя круглые скобки (), вставим весь приведенный выше запрос в условие WHERE, заставляя его функционировать как подзапрос.

`SELECT`
	`InvoiceDate,`
	`BillingAddress,`
	`BillingCity,`
	`total`
`FROM`
	`invoices`
`WHERE total <`
	`(select`
		`avg(total)`
	`from`
		`invoices)`
`ORDER BY`
	`total DESC`


![[подзапрос.jpg]]

На рис. 113 показано, что оператор SELECT и другие операторы во внешнем запросе написаны прописными, а все операторы и функции во внутреннем запросе — строчными буквами. Не существует универсального правила, каким образом следует писать операторы или функции. Я лично считаю, что указанный способ написания операторов и функций внешних запросов и подзапросов упрощает восприятие, поскольку помогает визуально различать внешние и внутренние операторы запроса.


## Использование подзапроса в операторе SELECT

Если в операторе `SELECT` требуется добавить дополнительное действие (например, агрегатное вычисление), то для его выполнения нам понадобится подзапрос. В предыдущей главе, посвященной функциям, показано, что для отображения средних значений в счетах для разных городов мы использовали условие `GROUP BY`. Что будет, если для компании sTunes нам надо узнать показатели продаж в каждом отдельном городе и сравнить их со средними мировыми продажами? Один из способов ответить на это — написать запрос, который будет отображать средний объем продаж в каждом городе рядом со среднемировым показателем.

Запрос для отображения среднего объема продаж `BillingCity` идентичен запросу, который мы использовали в предыдущей главе, за одним исключением. Для расчета глобального среднего показателя мы включаем подзапрос в условие `SELECT`. Таким образом, мы можем сравнить два значения.

`SELECT`
	`BillingCity,`
	`avg(total) AS [City Average],`
	`(select avg(total)`
`from`
	`invoices) AS [Global Average]`
`FROM`
	`invoices`
`GROUP BY`
	`BillingCity`
`ORDER BY`
	`BillingCity`



## Использование подзапроса с условием WHERE

Иногда надо получить более подробный запрос в качестве подзапроса. Внешний запрос может содержать условие **WHERE**, которое, в свою очередь, содержит подзапрос с собственным условием **WHERE**. Хороший пример того, когда в подзапросе необходимо использовать условие **WHERE**, если требуется сравнить все поля с отдельным значением. Предположим, нас попросили найти самые большие продажи за весь период сбора данных (2009–2012 гг.) и проверить, имеются ли какие-либо итоговые суммы счетов за последний отчетный год (2013 г.), превышающие это значение. Чтобы ответить, сначала необходимо узнать самые большие продажи до 2013 года. Для этого воспользуемся функцией MAX().

`SELECT`
	`max(total)`
`FROM`
	`invoices`
`WHERE`
	`InvoiceDate < '2013-01-01'`

Теперь, когда нам известно это значение, мы заключим запрос в круглые скобки (), а затем добавим внешний запрос и вставим необходимые дополнительные поля.

`SELECT`
	`InvoiceDate,`
	`BillingCity,`
	`total`
`FROM` 
	`invoices`
`WHERE`
	`InvoiceDate >= '2013-01-01' AND total >`
	`(select`
		`max(total)`
	`from`
		`invoices`
	`where`
		`InvoiceDate < '2013-01-01')`

Из запроса видно, что максимальный счет был выставлен 13 ноября 2013 года.


## Подзапросы без агрегатных функций

Подзапрос не всегда содержит агрегатную функцию. Следующий запрос отображает дату конкретной транзакции.

`SELECT`
	`InvoiceDate`
`FROM`
	`invoices`
`WHERE`
	`InvoiceId = 251`

Если необходимо узнать, получены ли какие-либо другие счета после указанного выше счета, мы добавим подзапрос, заключенный в круглые скобки, а затем добавим внешний запрос.

`SELECT`
	`InvoiceDate,`
	`BillingAddress,`
	`BillingCity`,
	`InvoicesId`
`FROM`
	`invoices`
`WHERE`
	`InvoiceDate >`
`(select`
	`InvoiceDate`
`from`
	`invoices`
`where`
	`InvoiceId = 251)`



## Подзапросы и условие DISTINCT

Для удобства работы с избыточной информацией стоит отфильтровать данные, чтобы они отображали только уникальные значения. В этом случае полезно условие `DISTINCT`. Лучше понять подзапросы и использование условия `DISTINCT` нам помогут таблицы `tracks` и `invoice_items`.

Таблица `invoice_items` показывает, какие треки какому счету соответствуют. Если мы создадим запрос, отображающий поля `InvoiceId` и `TrackId`, упорядоченные по` TrackId`, мы увидим, что определенные номера треков были заказаны несколько раз в разных счетах.

`SELECT`
	`InvoiceId,`
	`TrackId`
`FROM`
	`invoice_items`
`ORDER BY`
	`TrackId`

Так, треки № 2 и № 8 появляются в нескольких счетах, что означает, что они были заказаны несколько раз (рис. 121). Однако для трека № 7 счет отсутствует, поэтому мы можем сделать вывод, что никто не приобретал его. Руководство sTunes хочет знать о треках, которые не продаются. Нам необходимо найти таблицу, связывающую поля `TrackId` с `InvoiceId`. Для перечисления всех треков (по композитору и названию), которые не отображаются в таблице `invoice_items`, мы можем использовать подзапросы.

Если мы снова запустим тот же запрос, только на этот раз с ключевым словом DISTINCT, мы получим список только тех треков, которые появляются в счетах, без дубликатов.

`SELECT`
	`DISTINCT TrackId`
`FROM`
	`invoice_items`
`ORDER BY`
	`TrackId`

Из примера видно, что некоторые номера `TrackId` (например, № 7) не появляются ни в одном счете, но списки треков, которые появляются в нескольких счетах, сокращены до одного. Теперь нам необходимо написать запрос, перечисляющий все треки из таблицы `tracks`, которые не входят (`NOT IN`) в созданный первым запросом список.

`SELECT`
	`TrackId,`
	`Composer,`
	`name`
`FROM`
	`tracks`
`WHERE`
	`TrackId NOT IN`
		`(select distinct`
			`TrackId`
		`from`
			`invoice_items)`

Итак, у нас есть список песен, которых не было ни в одном счете (рис. 123). Анализируя полученные результаты, мы видим, что трек № 7 находится в самой верхней части списка непродаваемых треков. Теперь отдел продаж sTunes имеет четкое представление о том, какие песни непопулярны.

![[distinct result.jpg]]

Примеры подзапросов из этой главы не являются исчерпывающими. Существует еще множество вариантов использования подзапросов, и все они имеют общие особенности. Подзапросы могут выполнять сложные многоступенчатые вычисления с помощью всего одного запроса. Они позволяют вычислить конкретное условие, а затем сравнить новый набор данных с тем же условием.

**ПРИМЕЧАНИЕ**
***Подзапросы* — это альтернативный способ взаимодействия таблиц, имеющих общие ключевые поля. Но если нам нужно много работать с обеими таблицами, то вместо подзапросов эффективнее создать join-соединение. Например, гораздо эффективнее создать соединение между полем `TrackId` и таблицей `tracks` (вместо использования подзапросов), чтобы отображать всю информацию рядом.**

