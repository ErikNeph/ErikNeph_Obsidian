---
date of creation: 2024-06-05T10:56:00
tags:
  - MySQL
  - PHP
  - Database
  - Education
  - ProgrammingLanguage
  - СУБД
  - IT
  - WebDeveloping
  - Web
  - РСУБД
---
---
# Новое в PHP 8 и MySQL 8



К концу второго десятилетия XXI века и PHP и MySQL выпустили свои восьмые версии и теперь могут считаться высокоразвитыми продуктами по стандартам программных технологий.

По данным сайта w3techs.com (https://tinyurl.com/w3tpl), к началу 2021 года PHP в той или иной форме использовался более чем на 79 % веб-сайтов и тем самым на 70 % опережал своего ближайшего конкурента ASP.NET. Ресурс explore-group.com (https://tinyurl.com/egctmpd) сообщил, что в 2019 году MySQL оставалась самой популярной базой данных, используемой в интернете, — она установлена на 52 % веб-сайтов. Хотя доля MySQL на рынке немного снизилась в последние годы, она по-прежнему на 16 % опережает своего ближайшего конкурента PostgreSQL, который используется на 36 % веб-сайтов. По всей видимости, так будет и в обозримом будущем, тем более что почти идентичная MariaDB также претендует на определенную долю рынка.

С выходом последней, восьмой версии двух технологий наряду с JavaScript эти основы современных веб-разработок, похоже, продолжат играть важную роль еще долгие годы. Итак, рассмотрим, что нового появилось в последних версиях PHP и MySQL.


### Об этой главе
---

Последние версии обеих технологий появились во время подготовки данного издания книги, и эта короткая глава представляет собой краткий обзор обновлений. Она не только содержит информацию, полезную для разработчиков PHP и MySQL, начинающих и среднего уровня, но и дает возможность подробно описать некоторые более продвинутые улучшения, внесенные в эти две технологии.

Если что-либо из рассмотренного далее относится к вопросам, которые вы еще не изучали в этой книге или где-либо еще, не волнуйтесь, в качестве инструментов разработки вам это пока не нужно. Но вы поймете, что было добавлено или изменено в тех вопросах, что вам встречались ранее, и будете иметь представление о том, как использовать новинки.

В последующих изданиях этой книги те вопросы, которые окажутся наиболее полезными для начинающих разработчиков, будут включены в основную часть учебного пособия.


## PHP
---

В восьмую версию PHP были внесены масштабные изменения, что стало важным достижением, так как новые функции появились в таких разделах, как тип, система, обработка синтаксических ошибок, строки, объектно-ориентированное программирование и многое другое. С новыми функциями PHP стал более мощным и простым в использовании, чем когда-либо, при этом были сведены к минимуму изменения, которые могут нарушить существующее оснащение. Например, в таких разделах, как именованные параметры, компиляция Just In Time (JIT), атрибуты и свойства конструктора, были внесены значительные улучшения и изменения в синтаксис, улучшена обработка ошибок, добавлены изменения и улучшения в операторы, чтобы помочь уменьшить вероятность пропустить ошибки.

>[!info]
>На момент написания этой главы стек AMPPS, который вам было рекомендовано установить в [[Установка сервера, предназначенного для разработки]], поставляется с MySQL 8.0.18, но его версия в PHP по-прежнему 7.3.11. Ожидается, что восьмая версия PHP будет включена в стек AMPPS, и я рекомендую вам разрешить AMPPS установить ее самостоятельно, особенно если вы новичок. Но если она все еще будет недоступна в AMPPS, а вы хотите сразу же начать использовать PHP 8, то всегда можете скачать новую версию непосредственно с сайта http://php.net/, следуя приведенным там инструкциям по его установке и использованию.


### Именованные параметры
---

В дополнение к традиционным параметрам позиции, в которых порядок передачи аргументов всегда должен быть одинаковым, PHP 8 позволяет использовать именованные параметры в вызовах функций, например, так:

```php
str_contains(needle: 'ian', haystack: 'Antidisestablishmentarianism');
```

Это делает имена параметров функции или метода частью общедоступного API и позволяет передавать входные данные в функцию на основе имен их аргументов, а не на основе порядка аргументов, что существенно повышает ясность кода. Таким образом, поскольку параметры передаются по имени, их порядок больше не имеет значения, что должно привести к уменьшению количества труднонаходимых ошибок. Кстати, функция **`str_contains`**, о которой будет рассказано позже, также является нововведением в PHP 8.


### Атрибуты
---

В PHP 8 атрибуты, такие как свойства и переменные, сопоставляются именам классов PHP, что позволяет включать метаданные в классы, методы и переменные. Раньше вам пришлось бы использовать комментарии `DocBloc` для их вывода.

Атрибуты позволяют предоставлять одной системе или программе сведения о другой системе, такой как подключаемый модуль или система событий. Они представляют собой простые классы, аннотированные атрибутом **`#[Attribute]`**, который может быть прикреплен к классам, свойствам, методам, функциям, константам класса или параметрам функций или методов. Во время выполнения атрибуты ничего не делают и не влияют на код. Однако они доступны для API отражения (рефлексии), что позволяет другому коду изучать атрибут и предпринимать дополнительные действия.

В обзоре на сайте https://tinyurl.com/php8attr вы найдете хорошее объяснение атрибутов, которые отчасти выходят за рамки темы этой книги.

Находящиеся в одной строке атрибуты интерпретируются как комментарии в старых версиях PHP и, следовательно, безопасно игнорируются.


### Свойства конструктора
---

В PHP 8 вы можете объявлять свойства класса прямо из конструктора класса, что позволяет сэкономить большое количество кодовых шаблонов. Возьмем, к примеру, этот код:

```php
class newRecord {
  public string $username;
  public string $email;
  
  public function __construct(
    string $username,
    string $email,
) {
    $this->username = $username;
    $this->email = $email;
  }
}
```

С помощью свойств конструктора вы можете свести все это к следующему:
```php
class newRecord
{
  public function __construct(
    public string $username,
    public string $email,
){}
}
```

Это обратно несовместимая функция, поэтому используйте ее только в тех случаях, когда точно знаете, что PHP 8 установлен.


### Компиляция Just In Time
---

Когда эта функция включена, Just In Time (JIT) компилирует и кэширует собственные функции (в отличие от так называемого кэша операций **`OPcache`**, что экономит время обработки файлов), чтобы повысить производительность приложений с высокой нагрузкой на процессор.

Вы можете включить JIT в файле php.ini следующим образом:
```.ini
opcache.enable = 1
opcache.jit_buffer_size = 100M
opcache.jit = tracing
```

Имейте в виду, что JIT является относительно новым для PHP и в настоящее время отладка и профилирование усложнены за счет добавленного слоя. Кроме того, проблемы с JIT наблюдались вплоть до дня, предшествовавшего его выпуску, поэтому следует остерегаться того, что в течение короткого времени в системе могут оставаться необнаруженные и неустраненные ошибки. Поэтому по умолчанию JIT-компиляция отключена, и вам, вероятно, следует на всякий случай отключить ее на время отладки.


### Типы соединений
---

В PHP 8 декларирование типов может быть расширено с помощью типов соединений для объявления более чем одного типа, который также поддерживает `false` в качестве специального типа для логического значения `false`, например, так:

```php
function parse_value(string|int|float): string|null {}
```


### Оператор нулевого значения Null-safe
---

В случае **`?->`** оператор **null-safe** закоротит оставшуюся часть раздела, если встретит нулевое значение, и немедленно вернет значение null, не вызывая ошибки:

```php
return $user->getAddress()?->getCountry()?->isoCode;
```

Раньше вам пришлось бы использовать несколько последовательных вызовов **`isset()`** для каждого раздела, поочередно проверяя каждый из них на наличие значения **`null`**.


### Выражение **`match`**
---

Выражение **`match`** похоже на блок **`switch`**, но оно обеспечивает сравнения, безопасные для типов, поддерживает возвращаемое значение, не требует оператора **`break`** для выхода, а также поддерживает множественные совпадающие значения. Таким образом, довольно громоздкий блок **`switch`**

```php
<?php
  switch ($country)
  {
    case "UK":
    case "USA":
    case "Australia":
    default:
      $lang = "English";
      break;
    case "Spain":
      $lang = "Spanish";
      break;
    case "Germany":
    case "Austria":
      $lang = "German";
      break;
  }
?>
```

может быть заменен следующим, гораздо более простым выражением **`match`**:

```php
<?php
  $lang = match($country)
  {
    "UK" => "English",
    "USA" => "English",
    "Australia" => "English",
    "Spain" => "Spanish",
    "Germany" => "German",
    default => "English"
  };
?>
```

Что касается сравнений, безопасных для типов, оператор **`switch`** запутается в следующем коде, потому что будет оценивать '**0e0**' как экспоненциальное значение для нуля и повторять '**null**', тогда как должен повторять '**a**'. Однако в match такой проблемы не возникнет.

```php
$a = '0e0';

switch ($a) {
case 0 : echo 'null'; break; 
case '0e0': echo 'a'; break;
}
```


## Новые функциональные возможности
---

PHP 8 предоставляет ряд новых функций, которые обеспечивают более широкую функциональность и улучшения языка, охватывая такие области, как обработка строк, отладка и обработка ошибок.


### Функция **`str_contains`**
---

Функция **`str`** позволяет узнать, содержится ли строка в другой строке. Эта функция лучше, чем **`strpos`**, потому что она возвращает позицию одной строки внутри другой или выдает значение false, если строка не найдена. Но существует потенциальная проблема: если строка найдена в нулевой позиции и возвращается значение 0, оно будет равно false, если не использовать оператор строгого сравнения (**`===`**) вместо **`==`**. Поэтому при использовании **`strpos`** вам нужно писать весьма нечеткий код, например, такой:

```php
<?php
  if (strpos("Once upon a time", "Once") !== false)
    echo "Found";
?>
```

Принимая во внимание то, что код, содержащий **`str_contains`**, например приведенный далее, гораздо более понятен при быстром сканировании и написании кода, он с меньшей вероятностью приведет к непонятным ошибкам:

```php
<?php
  if (str_contains('Once upon a time', 'Once'))
    echo "Found";
?>
```

Функция **`str_contains`** чувствительна к регистру, поэтому, если вам нужно выполнить проверку без учета регистра, с помощью функции следует запустить как **`$needle`**, так и **`$haystack`**, чтобы сначала удалить регистр, например **`strtolower`**, как показано далее:

```php
<?php
  if (str_contains(strtolower("Once upon a time"),
		           strtolower("once")))
    echo "Found";
?>
```

>[!example]
>Вместо того чтобы придумывать собственные полизаполнения, которые могут случайно внести ошибки в ваш код или оказаться несовместимыми с полизаполнениями других людей, можете использовать готовый набор полизаполнений Symfony для PHP 8, доступный бесплатно на GitHub (https://github.com/symfony/polyfill-php80).
>
>В следующей функции полизаполнения для PHP 7+ есть проверка на то, что $needle является пустой строкой. Она нужна, так как PHP 8 считает, что пустая строка существует в любой позиции внутри любой строки, даже пустой, поэтому такое поведение должно быть согласовано с функцией замены:
>```php
>if (!function_exists('str_contains'))
>{
>  function str_contains(string $haystack, string $needle): bool
>  {
>    return !needle === '' || strpos($haystack, $needle) !== false;
>  }
>}
>```

Если вы хотите использовать **`str_contains`** и при этом обеспечить обратную совместимость своего кода со старыми версиями PHP, можете применить полизаполнение (код, предоставляющий функцию, которая, как ожидается, будет доступна в вашем коде), чтобы создать собственную версию функции **`str_contains`**, если ее еще нет.


### Функция **`str_starts_with`**
---

Функция **`str_starts_with`** — это более точное средство проверки того, начинается ли одна строка с другой. Раньше вы, вероятно, использовали функцию **`strpos`** и проверяли, возвращает ли она нулевое значение. Мы уже видели, что в определенных ситуациях можно перепутать `0` и `false` — функция **`str_starts_with`** существенно уменьшает эту вероятность. Ее можно использовать следующим образом:

```php
if (str_starts_with('In the beginning', 'In'))
  echo 'Found';
```

Как и в случае с **`str_contains`**, проверка выполняется с учетом регистра, поэтому применяйте функцию наподобие **`strtolower`**, чтобы выполнить проверку без учета регистра. Полизаполнение PHP 7+ для этой функции может быть следующим:

```php
if (!function_exists('str_starts_with'))
{
  function str_starts_with(string $haystack, string $needle): bool
  {
    return $needle === '' || strpos($haystack, $needle) === 0;
  }
}
```

Поскольку PHP 8 считает, что пустая строка существует в каждой позиции строки, это полизаполнение всегда возвращает true, если $needle является пустой строкой.


### Функция **`str_ends_with`**
---

Эта функция обеспечивает более точный и простой способ проверки того, заканчивается ли одна строка другой. Раньше вы, вероятно, использовали функцию **`substr`**, передавая ей отрицательную длину **$needle**, но **`str_ends_with`** значительно упрощает эту задачу. Она применяется следующим образом:

```php
if (str_ends_with('In the end', 'end'))
  echo 'Found';
```

Как и в случае с другими новыми функциями строк, проверка выполняется с учетом регистра, поэтому следует использовать такую функцию, как **`strtolower`**, для обеих строк, чтобы выполнить проверку без учета регистра. Полизаполнение в PHP 7+ для этой функции может выглядеть следующим образом:

```php
if (!function_exists('str_ends_with'))
{
  function str_ends_with(string $haystack, string $needle): bool
  {
    return $needle === '' ||
    $needle === substr($haystack, -strlen($needle));
  }
}
```

Если второй аргумент, переданный в **`substr`**, отрицательный, как в данном случае, то строка сопоставляется в обратном порядке, отступая на такое количество символов от своего конца. И снова это полизаполнение всегда возвращает `true`, если `$needle` — нулевая строка. Также обратите внимание: используется оператор строгого сравнения **`===`**. Так можно убедится, что будет выполнено точное сравнение двух строк.


### Функция **`fdiv`**
---

Новая функция **`fdiv`** похожа на уже существующие функции **`fmod`** (возвращает остаток с плавающей запятой после деления) и **`intdiv`** (возвращает целочисленный коэффициент деления), но она позволяет выполнять деление на 0 без выдачи ошибки деления на ноль, а возвращает либо **`NF`**, либо -**`INF`**, либо **`NAN`** в зависимости от конкретной ситуации.

Например, **`intdiv(1, 0)`** выдаст ошибку деления на ноль, как и `1 % 0` или просто `1 / 0`. Но вы можете смело использовать **`fdiv(1, 0)`**, и результат будет с плавающей запятой со значением `INF`, в то время как **`fdiv(-1, 0)`** вернет `–INF`.

Далее приведено полизаполнение для PHP 7+, которое вы можете использовать, чтобы сделать свой код обратно совместимым:

```php
if (!function_exists('fdiv'))
{
  function fdiv(float $dividend, float $divisor): float
  {
    return @($dividend / $divisor);
  }
}
```


### Функция **`get_resource_id`**
---

В PHP 8 добавлена новая функция **`get_resource_id`**, похожая на приведение **`(int) $resource`**, чтобы упростить получение идентификатора ресурса, но тип возвращаемого значения проходит проверку на то, что он является ресурсом, а возвращаемое значение — целое число, поэтому они безопасны для типов.


### Функция **`get_debug_type`**
---

Функция **`get_debug_type`** предоставляет более согласованные значения, чем существующая функция **`get_type`**, и ее лучше всего использовать для получения подробной информации о неожиданной переменной в сообщениях об исключениях или журналах. Больше информации — на сайте https://wiki.php.net/rfc/get_debug_type.


### Функция **`preg_last_error_msg`**
---

Функции **`preg_`** в PHP не выдают исключений, поэтому в случае ошибки вы должны получить любое сообщение с помощью **`preg_last_error`**, чтобы получить код ошибки. Но если вы хотите, чтобы это было понятное сообщение об ошибке, а не просто код без объяснения, в PHP 8 теперь можете набрать **`preg_last_error_msg`**. Если ошибки не было, вернется сообщение **No error** («Ошибки нет»).

Поскольку эта книга рассчитана на разработчиков уровня от начального до среднего, я лишь поверхностно описал основные великолепные новые возможности PHP 8, которые вы можете начать использовать прямо сейчас. Если вы хотите узнать абсолютно все об этом важнейшем обновлении, можете получить полную информацию на официальном сайте https://www.php.net/releases/8.0.


## MySQL 8
---

Система MySQL 8 была выпущена в 2018 году, и предыдущее издание этой книги не смогло осветить функции, включенные в обновление. Поэтому сейчас, когда в конце 2020 года вышло ее последнее обновление (до версии 8.0.22), нам представилась отличная возможность рассмотреть все то, чем дополнены более ранние версии MySQL 8, например улучшенную поддержку Юникода, улучшенную обработку JSON и документов, географическое сопровождение и функции окон.

В этом разделе вы получите общее представление о восьми областях, которые были усовершенствованы, обновлены или добавлены в последней, 8-й версии.

>[!info]
>MySQL 8 является преемником версии 5.7, потому что 6-я версия так никогда и не была по-настоящему принята сообществом разработчиков, а когда Sun Microsystems приобрела MySQL, ее разработка была остановлена. Что еще более важно, до версии 8 самым большим изменением была версия 5.6–5.7, поэтому, по информации Sun, «из-за множества новых важных функций, которые внедрили в этой версии MySQL, мы решили начать новую серию. Поскольку серийные номера 6 и 7 фактически использовались ранее в MySQL, мы перешли к версии 8.0».


### Обновления в SQL
---

В MySQL 8 теперь есть функции окон, известные также как аналитические функции. Они похожи на сгруппированные агрегатные функции, которые сводят вычисления по наборам строк в одну строку. Однако оконная, или аналитическая, функция выполняет агрегацию для каждой строки в наборе результатов и является неагрегатной. Поскольку эти функции не самые важные для пользования MySQL и должны считаться продвинутыми расширениями, я не рассматриваю их в данной книге.

Вот новые функции: **`RANK`**, **`DENSE_RANK`**, **`PERCENT_RANK`**, **`CUME_DIST`**, **`NTILE`**, **`ROW_NUMBER`**, **`FIRST_VALUE`**, **`LAST_VALUE`**, **`NTH_VALUE`**, **`LEAD`** и **`LAG`**, и если вам нужно больше узнать о них, сообщаю: они полностью задокументированы на официальном сайте MySQL https://tinyurl.com/mysql8winfuncs.

MySQL 8 содержит также рекурсивные общие табличные выражения, расширенные альтернативы **`NOWAIT`** и **`SKIP LOCKED`** в предложении блокировки SQL, дочерние индексы, функцию группировки **`GROUPING`** и подсказки оптимизатора. Все это и многое другое можно посмотреть на сайте MySQL https://tinyurl.com/mysql8statements.


### [[JSON]] (JavaScript Object Notation)
---

Появился ряд новых функций для работы с JSON, была улучшена сортировка и группировка значений JSON. Помимо добавления расширенного синтаксиса для диапазонов в выражениях путей и улучшения сортировки появились новые функции таблиц, агрегации, слияния и др.

Учитывая эти улучшения в MySQL и использование JSON, можно утверждать, что теперь можно задействовать MySQL вместо баз данных NoSQL.

Использование JSON в MySQL выходит за рамки темы данной книги, но если эта область вам интересна, можете ознакомиться с официальной документацией всех новых функций: https://tinyurl.com/mysql8json.


### Географическое сопровождение
---

MySQL 8 предоставляет также GIS — географическое сопровождение, включая поддержку метаданных для SRS (система пространственной привязки), типы данных SRS, индексы и функции. Это означает, что MySQL теперь может, например, вычислить расстояние между двумя точками на поверхности Земли, используя их широту и долготу в любой из поддерживаемых систем пространственной привязки.

Более подробную информацию о том, как получить доступ к MySQL GIS, вы найдете на официальном веб-сайте https://tinyurl.com/mysql8gis.


### Надежность
---

MySQL и так уже была чрезвычайно надежна, но в 8-й версии она усовершенствована за счет хранения метаданных в операционном механизме хранения InnoDB, так что *пользовательские*, *привилегированные* и *словарные* таблицы теперь находятся в InnoDB.

В MySQL 8 есть только один словарь данных, тогда как в версии 5.7 и более ранних было два словаря данных — для сервера и для уровня InnoDB, которые могут рассинхронизироваться.

Начиная с 8-й версии, пользователю гарантируется, что любая задача DDL, например CREATE TABLE, будет либо выполнена полностью, либо не выполнена вообще, что предотвращает возможную рассинхронизацию основного сервера и сервера-копии.


### Скорость и производительность
---

Информационная схема в MySQL была ускорена в 100 раз за счет хранения таблиц в виде простых визуализаций в таблицах словаря данных в InnoDB. Кроме того, в таблицы схем производительности были добавлены более 100 индексов для дальнейшего повышения производительности, которая значительно улучшилась также за счет более быстрых чтения и записи, рабочих нагрузок, связанных со вводом/выводом, и рабочих нагрузок с высокой конкурентностью. Вдобавок теперь вы можете сопоставлять пользовательские потоки с процессорами для дальнейшей оптимизации производительности.

При больших вводных факторных рабочих нагрузках MySQL 8 масштабируется в четыре раза лучше по сравнению с версией 5.7 и обеспечивает еще более значительное увеличение рабочих нагрузок при чтении/записи.

В MySQL вы можете использовать каждое устройство хранения данных с максимальной эффективностью; при рабочих нагрузках с высокой конкурентностью производительность повышается (когда транзакции выстраиваются в очередь для получения блокировки).

В целом разработчики MySQL 8 утверждают, что новая версия работает в два раза быстрее прежних. Вы можете почитать их доводы и советы о том, как добиться такого увеличения производительности, на официальном сайте https://tinyurl.com/mysql8performance.


### Администрирование
---

В MySQL 8 вы можете переключать индекс с видимого на невидимый. Невидимый индекс не учитывается оптимизатором при создании плана запроса, но все равно будет поддерживаться в фоновом режиме, поэтому его легко можно сделать снова видимым, что позволит решать, является ли индекс сбрасываемым.

Кроме того, теперь пользователи обладают полным контролем над табличными пространствами отмены и могут сохранять глобальные динамические переменные сервера, которые были бы потеряны при его перезагрузке. Помимо этого, есть команда ПЕРЕЗАГРУЗКА SQL, позволяющая удаленно управлять сервером MySQL через SQL-соединение, а также появилась новая команда **`RENAME COLUMN`**, улучшенная по сравнению с предыдущим синтаксисом **`ALTER TABLE...CHANGE`**.

С более подробной информацией можете ознакомиться на официальном сайте https://tinyurl.com/mysql8serveradmin.


### Безопасность
---

Разумеется, при разработке 8-й версии вопросы безопасности не остались в стороне, поскольку в ней появилось много новых улучшений.

Начнем с того, что подключаемый модуль аутентификации по умолчанию был заменен с **`mysql_native_password`** на **`caching_sha2_password`**, а OpenSSL выбран в качестве библиотеки TLS/SSL по умолчанию как в выпусках Enterprise, так и в Community и динамически связан.

В MySQL 8 зашифрованы журналы отмены и повтора, а роли SQL реализованы таким образом, что вы можете предоставлять роли пользователям и привилегии ролям. Также можно использовать обязательные роли при создании новых пользователей. Теперь существует политика смены паролей, которая настраивается как на глобальном, так и на пользовательском уровне, с безопасным хранением истории паролей.

В MySQL 8 была добавлена отсрочка в процесс аутентификации, основанная на последовательных неудачных попытках входа в систему, чтобы замедлить попытки атаки методом подбора. Запуск и максимальную продолжительность отсрочки можно настраивать.

Получить более подробную информацию о MySQL и безопасности вы можете на официальном сайте https://tinyurl.com/mysql8security.


## Вопросы
---

- [ ] 1. Что теперь позволяет PHP 8 делать при объявлении свойств класса?
- [x] 2. Что такое оператор нулевого значения null-safe и для чего он нужен?
- [x] 3. Как можно использовать выражение соответствия в PHP 8 и почему оно может быть лучше, чем альтернативный вариант?
- [x] 4. Какую новую простую в использовании функцию вы теперь можете использовать в PHP 8, чтобы определить, существует ли одна строка внутри другой?
- [x] 5. Какой новый способ вычисления деления с плавающей точкой без возникновения ошибки деления на ноль является наилучшим в PHP 8?
- [ ] 6. Что такое полизаполнитель?
- [x] 7. Какой новый простой способ в PHP 8 позволяет увидеть на простом английском языке самую последнюю ошибку, сгенерированную вызовом одной из функций `preg_`?
- [ ] 8. Что теперь по умолчанию использует MySQL 8 в качестве механизма хранения транзакций?
- [x] 9. Что в MySQL 8 можно использовать вместо команды `ALTER` `TABLE...CHANGE` `TABLE` для изменения имени столбца?
- [ ] 10. Что является подключаемым модулем аутентификации по умолчанию
  в MySQL 8?

