---
date of creation: 2024-06-05T19:19:00
tags:
  - MySQL
  - PHP
  - Developing
  - Web
  - WebDeveloping
  - IT
  - РСУБД
  - СУБД
  - Database
  - Access
  - Connect
aliases:
  - Связывание PHP c MySQL
---
---
# Доступ к MySQL с использованием PHP
---


При полноценном изучении предыдущих глав вы должны были приобрести навыки работы как с MySQL, так и с PHP. Из этой главы вы узнаете, как объединить эти два компонента путем использования встроенных в PHP функций доступа к MySQL.


## Запросы к базе данных MySQL с помощью PHP
---

==Смысл использования PHP в качестве интерфейса к MySQL заключается в форматировании результатов SQL-запросов и придании им внешнего вида, предназначенного для вывода на веб-страницу.== Обладая возможностью входа в установленную систему MySQL с помощью своего имени пользователя и пароля, вы можете сделать то же самое и из PHP.

Однако вместо использования командной строки MySQL для ввода команд и просмотра выходной информации нужно будет создать строки запроса, а затем передать их MySQL. Ответ MySQL поступит в виде структуры данных, которую PHP сможет распознать, а не в виде того отформатированного экранного вывода, который вы наблюдали в процессе работы с командной строкой. Затем с помощью команд PHP можно будет извлекать данные и приводить их к формату веб-страницы.


### Процесс
---

Процесс использования MySQL с помощью PHP заключается в следующем.

1. Подключение к MySQL и выбор базы данных, которая будет использоваться.
2. Подготовка строки запроса.
3. Выполнение запроса.
4. Извлечение результатов и вывод их на веб-страницу.
5. Повторение шагов со 2-го по 4-й до тех пор, пока не будут извлечены все необходимые данные.
6. Отключение от MySQL.

Далее процесс будет рассмотрен поэтапно, но сначала важно настроить все элементы входа в систему на безопасную работу, для того чтобы шпионы, заинтересовавшиеся вашей системой, натыкались на заслон при попытке получения доступа к вашей базе данных.


### Создание файла регистрации
---

Большинство сайтов, разработанных на PHP, содержат множество программных файлов, которым понадобится доступ к MySQL, и им нужны будут сведения, касающиеся входа в систему и пароля. Поэтому имеет смысл создать отдельный файл для их хранения, а затем включать его туда, где он необходим. Такой файл, который я назвал `login.php`, показан в **примере 11.1.**

**Пример 11.1.** Файл `login.php`
```php
<?php  // login.php
  $host = 'localhost';
  $data = 'publications';
  $user = 'root';
  $password = 'mysql';
  $chrs = 'utf8mb4';
  $attr = "mysql:host=$host;dbname=$data;charset=$chrs";
  $opts = [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES => false,
  ];
?>
```

Наберите текст этого примера, заменяя значения **root** и пароль от **mysql** теми, которыми вы пользуетесь для входа в свою базу данных MySQL (а также при необходимости имя хоста и базы данных), и сохраните текст в файле, поместив его в разработочный каталог, созданный согласно рекомендациям, которые были даны в [[Установка сервера, предназначенного для разработки]]. Вскоре этот файл нам пригодится.

Имя хоста **localhost** будет работать до тех пор, пока вы используете базу данных MySQL в своей локальной системе, точно так же будет работать и база данных **`publications`**, если вы вводили в компьютер код всех встречавшихся ранее примеров.

Для файла `login.php`, показанного в **примере 11.1**, особую роль играют охватывающие теги **`<?php и ?>`**, поскольку они дают понять, что все строки, находящиеся между ними, должны интерпретироваться *только* как код PHP. Если их не поставить, то при вызове файла непосредственно с вашего сайта он будет отображен в виде текста, раскрывая все ваши секреты. А когда теги на месте, на сайте будет видна пустая страница. Этот файл будет без каких-либо проблем включаться в другие ваши PHP-файлы.

>[!info]
>В предыдущих изданиях книги мы использовали прямой доступ к MySQL, что было совсем небезопасно, и позже перешли к применению mysqli — это гораздо безопаснее. Но, как говорится, время не стоит на месте, и теперь существует самый безопасный и простой способ доступа к базе данных MySQL из PHP под названием PDO, который мы по умолчанию используем в этом издании книги в качестве облегченного и совместимого интерфейса для доступа к базам данных в PHP. PDO расшифровывается как PHP Data Objects — объекты данных PHP и представляет собой уровень доступа к данным, использующий унифицированный API. Каждый драйвер базы данных, реализующий интерфейс PDO, может предоставлять специфичные для базы данных возможности в виде обычных функций расширения.

Переменная **`$host`** сообщит PHP, какой компьютер следует использовать при подключении к базе данных. Ее присутствие обусловлено тем, что вы можете получить доступ к любой базе данных MySQL на любом компьютере, подключенном к той машине, на которой вы установили PHP, и она может потенциально включать в себя любой хост на просторах Всемирной паутины. Но примеры, приводимые в данной главе, будут работать только на локальном сервере. Поэтому здесь не будет указываться домен вроде **mysql.myserver.com**, а может просто использоваться слово **localhost** (или IP-адрес 127.0.0.1).

В роли рабочей базы данных, **`$data`**, будет выступать база данных publications, которую мы уже создали, изучая [[Введение в MySQL]] (или одна из тех баз данных, которую вам предоставил администратор вашего сервера, в таком случае нужно будет также внести соответствующие изменения в файл `login.php`).

**`$chrs`** означает набор символов, и в данном случае мы используем **utf8mb4**, в то время как **`$attr`** и **`$opts`** предусматривают дополнительные параметры, необходимые для доступа к базе данных.

>[!info]
>Другим преимуществом хранения всех сведений, необходимых для входа в систему, в одном месте станет возможность изменения пароля с нужной вам периодичностью, для чего придется обновлять только один файл, независимо от количества PHP-файлов, получающих доступ к MySQL.


### Подключение к базе данных MySQL
---

После сохранения файла `login.php` можно будет с помощью инструкции **`require_once`** включать его в любые PHP-файлы, которым нужен доступ к базе данных. Выбор пал именно на эту инструкцию, а не на инструкцию **`include`**, поскольку если файл не будет найден, он сгенерирует фатальную ошибку. И уж поверьте мне, если не будет найден файл, содержащий сведения для подключения к вашей базе данных, это действительно будет фатальной ошибкой.

Использование **`require_once`**, а не **`require`** ==означает, что файл будет считан только в том случае, если он не был включен до этого в какой-нибудь другой файл, что исключит совершенно бесполезные повторные обращения к диску.== Код, используемый для подключения, показан в **примере 11.2.**

**Пример 11.2.** Подключение к серверу MySQL с помощью PDO
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts); }
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }
?>
```

В данном примере при вызове нового экземпляра метода PDO с передачей ему всех значений, извлеченных из файла `login.php`, создается новый объект с именем **`$pdo`**. Проверка на возникновение ошибки осуществляется путем ссылки на парную команду **`try…catch`**.

Объект **`PDO`** используется в следующих примерах доступа к базе данных MySQL.

>[!info]
>Также никогда не нужно выводить содержимое любого сообщения об ошибке, полученного от MySQL. Вместо того чтобы помочь своим пользователям, вы можете предоставить хакерам такую конфиденциальную информацию, как данные о входе в систему. Лучше просто снабдите пользователя информацией о способе преодоления трудностей на основе того отчета, который содержится в сообщении об ошибке.


### Создание и выполнение запроса
---

Отправка запроса к MySQL из PHP сводится к простому включению соответствующего кода SQL в вызов метода **`query`**, принадлежащего объекту подключения. Как это делается, показано в **примере 11.3.**

**`Пример 11.3.`** Отправка запроса к базе данных с помощью **`PDO`**
```php
<?php
  $query = "SELECT * FROM classics";
  $result = $pdo->query($query);
?>
```

Как видите, MYSQL-запрос выглядит практически так же, как и непосредственно набираемая вручную инструкция в командной строке, за исключением того, что здесь отсутствует замыкающая точка с запятой, поскольку при обращении к MYSQL из PHP она не нужна.

Сначала переменной **`$query`** присваивается значение, содержащее код предстоящего запроса, а затем она передается методу query объекта **`$pdo`**, который возвращает результат, помещаемый в объект **`$result`**. Если в объекте **`$result`** содержится значение `FALSE`, значит, возникла проблема, подробности которой будут содержаться в свойстве `error` объекта подключения, а вызываемая функция **`die`** покажет их на экране.

Теперь все данные, возвращаемые MySQL, хранятся в легко поддающемся опросу формате в объекте **`$result`**.


### Извлечение результата
---

После возвращения объекта **`$result`** его можно использовать для поэлементного извлечения нужных вам данных с помощью имеющегося у этого объекта метода **`fetch`**. В **примере 11.4** предыдущие примеры объединены и расширены в программу, которую для получения этих результатов можно запустить самостоятельно (как показано на **рис. 11.1**). Наберите этот сценарий и сохраните его под именем `query.php` или же загрузите его из репозитория с примерами, https://github.com/RobinNixon/lpmj6.

**Пример 11.4.** Построчное извлечение результатов
```php
<?php // query.php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query  = "SELECT * FROM classics";
  $result = $pdo->query($query);
  
  while ($row = $result->fetch())
  {
    echo 'Author:   ' . htmlspecialchars($row['author'])   . "<br>";
    echo 'Title:    ' . htmlspecialchars($row['title'])    . "<br>";
    echo 'Category: ' . htmlspecialchars($row['category']) . "<br>";
    echo 'Year:     ' . htmlspecialchars($row['year'])     . "<br>";
    echo 'ISBN:     ' . htmlspecialchars($row['isbn'])     . "<br><br>";
  }
?>
```

![[Рис. 11.1. Данные, выводимые программой query.php.jpg]]
   >   **Рис. 11.1.** Данные, выводимые программой query.php

Для извлечения значения, хранящегося в каждой строке, при каждом прохождении цикла вызывается объект **`$pdo`** метода **`fetch`**, а для вывода результата на экран используются инструкции echo. Не стоит волноваться, если вы увидите, что результаты выводятся в другом порядке. Это происходит потому, что мы не использовали команду **`ORDER BY`** для указания порядка, в котором они должны возвращаться, так что порядок не будет задан.

При выводе в браузер данных, источником которых был (или мог быть) пользовательский ввод, всегда есть риск наличия в них вставок из вредоносного кода HTML, даже если вы уверены, что эти данные прошли процесс обезвреживания. Такой код может потенциально использоваться для осуществления атак по принципу межсайтового выполнения сценариев (XSS-атак). Простым способом устранения такой возможности является вставка всех выводимых на экран данных такого характера в вызов функции **`htmlspecialchars`**, заменяющей все опасные символы безопасными HTML-элементами. Именно этот прием был применен в предыдущем примере и будет использоваться во многих последующих примерах книги. Трудно не согласиться с тем, что весь этот многократный поиск и т. д. выглядит слишком громоздко и что должен быть более эффективный способ достижения того же результата. И такой способ построчного извлечения данных действительно есть.

>[!info]
>В [[Освоение MySQL]] шла речь о первой, второй и третьей нормальных формах, а теперь можно заметить, что таблица **`classics`** не удовлетворяет правилам этих форм, потому что сведения как об авторах, так и о книгах включены в одну и ту же таблицу. Причина состоит в том, что эта таблица была создана еще до того, как мы приступили к изучению нормализации. Но ее повторное использование для иллюстрации доступа к MySQL из PHP избавляет нас от необходимости ввода нового набора тестовых данных, поэтому в данном случае мы продолжим работу с этой таблицей.


### Извлечение строки с указанием стиля
---

Метод выборки **`fetch`** может возвращать данные в разных стилях, включая следующие:

- **`PDO::FETCH_ASSOC`** — возвращает следующую строку в виде массива, индексированного по имени столбца;
- **`PDO::FETCH_BOTH`** (по умолчанию) — возвращает следующую строку в виде массива, индексированного по имени и номеру столбца;
- **`PDO::FETCH_LAZY`** — возвращает следующую строку как анонимный объект с именами в качестве свойств;
- **`PDO::FETCH_OBJ`** — возвращает следующую строку как анонимный объект с именем столбца в качестве свойства;
- **`PDO::FETCH_NUM`** — возвращает массив, индексированный по номеру столбца.

Полный список стилей PDO fetch вы найдете в онлайн-справочнике https://tinyurl.com/pdofetch.

Поэтому слегка видоизмененный **пример 11.5** показывает более четкое назначение метода выборки **`fetch`** для данного случая. Возможно, вы захотите сохранить этот исправленный файл под именем fetchrow.php.

**Пример 11.5.** Построчное извлечение результатов
```php
<?php
  require_once 'login.php';

  try {
    $pdo = new PDO($attr, $user, $pass, $opts);
  } catch (PDOException $e) {

    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query = "SELECT * FROM classics";
  $result = $pdo->query($query);

  while ($row = $result->fetch(PDO::FETCH_BOTH))
  {
    echo 'Author: ' . htmlspecialchars($row['author']) . "<br>";
    echo 'Title: ' . htmlspecialchars($row['title']) . "<br>";
    echo 'Category: ' . htmlspecialchars($row['category']) . "<br>";
    echo 'Year: ' . htmlspecialchars($row['year']) . "<br>";
    echo 'ISBN: ' . htmlspecialchars($row['isbn']) . "<br>";
  }
?>
```

В этом измененном коде к объекту **`$result`** происходит всего лишь одна пятая обращений (по сравнению с предыдущим примером) и при каждом проходе цикла производится только один поиск внутри объекта, поскольку посредством использования метода **`fetch`** каждая строка извлекается целиком. То есть отдельная строка данных возвращается в виде массива, значения которого затем присваиваются массиву **`$row`**.

В этом сценарии используется ассоциативный массив. Ассоциативные массивы обычно полезнее числовых, поскольку к каждому столбцу можно обращаться по имени, например **`$row['author']`**, не утруждая себя воспоминаниями, каким идет нужный столбец по счету.


### Отключение
---

Со временем, после того как выполнение сценария завершится, PHP должен возвратить память, выделенную объектам, следовательно, при использовании небольших сценариев о самостоятельном высвобождении памяти вам обычно беспокоиться не следует. Однако если вы ходите завершить соединение PDO вручную, вам нужно просто установить для него значение *`null`* следующим образом:
```php
$pdo = null;
```


## Практический пример
---

Теперь настало время создать наш первый пример использования PHP для вставки данных в таблицу MySQL и удаления их оттуда. Я рекомендую набрать **`пример 11.6`** и сохранить его в вашем разработочном каталоге в файле под именем sqltest.php. В результате работы кода из этого примера экран приобретает вид, показанный на **`рис. 11.2.`**

>[!info]
>В **примере 11.6** создается стандартная HTML-форма. Более подробно такие формы рассматриваются в [[Обработка форм]], а здесь обработка формы используется только для демонстрации взаимодействия с базой данных.

![[Рис. 11.2. Вид экрана, получаемый в результате работы кода из примера 11.6..jpg]]
> **Рис. 11.2.** Вид экрана, получаемый в результате работы кода из **примера             11.6**, сохраненного в файле sqltest.php

**Пример 11.6.** Вставка и удаление данных с помощью программы sqltest.php
```php
<?php // sqltest.php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  if (isset($_POST['delete']) && isset($_POST['isbn']))
  {
    $isbn   = get_post($pdo, 'isbn');
    $query  = "DELETE FROM classics WHERE isbn=$isbn";
    $result = $pdo->query($query);
  }

  if (isset($_POST['author'])   &&
      isset($_POST['title'])    &&
      isset($_POST['category']) &&
      isset($_POST['year'])     &&
      isset($_POST['isbn']))
  {
    $author   = get_post($pdo, 'author');
    $title    = get_post($pdo, 'title');
    $category = get_post($pdo, 'category');
    $year     = get_post($pdo, 'year');
    $isbn     = get_post($pdo, 'isbn');
    
    $query    = "INSERT INTO classics VALUES" .
      "($author, $title, $category, $year, $isbn)";
    $result = $pdo->query($query);
  }

  echo <<<_END
  <form action="sqltest.php" method="post"><pre>
    Author <input type="text" name="author">
     Title <input type="text" name="title">
  Category <input type="text" name="category">
      Year <input type="text" name="year">
      ISBN <input type="text" name="isbn">
           <input type="submit" value="ADD RECORD">
  </pre></form>
_END;

  $query  = "SELECT * FROM classics";
  $result = $pdo->query($query);

  while ($row = $result->fetch())
  {
    $r0 = htmlspecialchars($row['author']);
    $r1 = htmlspecialchars($row['title']);
    $r2 = htmlspecialchars($row['category']);
    $r3 = htmlspecialchars($row['year']);
    $r4 = htmlspecialchars($row['isbn']);
    
    echo <<<_END
  <pre>
    Author $r0
     Title $r1
  Category $r2
      Year $r3
      ISBN $r4
  </pre>
  <form action='sqltest.php' method='post'>
  <input type='hidden' name='delete' value='yes'>
  <input type='hidden' name='isbn' value='$r4'>
  <input type='submit' value='DELETE RECORD'></form>
_END;
  }

  function get_post($pdo, $var)
  {
    return $pdo->quote($_POST[$var]);
  }
?>
```

Эта программа со своими почти 80 строками кода может испугать, но не стоит переживать — многие из этих строк уже были изучены в **примере 11.4**, а в работе этого кода нет ничего сложного.

Сначала выполняется проверка всех введенных данных, а затем в соответствии с предоставленным вводом осуществляется либо вставка новых данных в таблицу **`classics`** базы данных **`publications`**, либо удаление строки из этой таблицы. Независимо от того, что именно было введено, программа вслед за этим выводит все строки таблицы в браузер. Посмотрим, как все это работает.

Первая часть нового кода начинается с использования функции **`isset`**, чтобы проверить, были ли отправлены программе значения для всех полей. На основании такого подтверждения каждая из строк, находящихся внутри инструкции **`if`**, вызывает функцию **`get_post`**, которая появляется в самом конце программы. Эта функция делает небольшую, но очень важную работу: извлекает введенные данные из браузера.

>[!info]
>Из соображений ясности и краткости, а также в целях максимально возможного упрощения объяснений из многих последующих примеров убраны весьма нужные фрагменты кода, отвечающие за соблюдение мер безопасности, поскольку они бы сделали примеры длиннее и отвлекали бы от четкого объяснения функций, заложенных в этих примерах. Поэтому важно не пропустить изучение следующего далее в этой главе раздела «Предотвращение попыток взлома», где рассматриваются дополнительные меры по защите ваших баз данных, которые можно предпринять в отношении кода, чтобы сделать его безопасным.


### Массив **`$_POST`**
---

В одной из предыдущих глав я уже упоминал о том, что браузер отправляет пользовательский ввод в виде **`GET-`** или **`POST`**-запроса. Обычно предпочтение отдается **`POST`**-запросу, так как он предотвращает размещение неэстетичных данных в адресной строке браузера, поэтому именно он здесь и используется. Веб-сервер объединяет все введенное пользователем (даже если в форме заполнено под сотню полей) и помещает его в массив **`$_POST`**.

`$_POST` относится к ассоциативным массивам, рассмотренным в [[Массивы в PHP]]. Данные формы будут помещаться в ассоциативный массив с именем `$_POST `или `$_GET` в зависимости от того, какой метод используется для отправки формы — `POST` или `GET`. Оба этих массива могут быть прочитаны абсолютно одинаковым способом.

У каждого поля есть элемент в массиве, имеющий точно такое же имя. Поэтому если в форме есть поле **`isbn`**, в массиве `$_POST` будет элемент с ключом `isbn`. PHP-программа может прочитать это поле, ссылаясь на него либо в виде **`$_POST['isbn']`**, либо в виде **`$_POST["isbn"]`** (в данном случае одинарные и двойные кавычки обладают одинаковым действием).

Если синтаксис работы с массивом **`$_POST`** кажется вам слишком сложным, можно спокойно воспользоваться приемом, показанным в **примере 11.6**: скопировать введенные пользователем данные в другие переменные, после чего о массиве **`$_POST`** можно будет забыть. Для PHP-программ это вполне нормальный подход: они получают все поля из массива **`$_POST`** в самом начале программы и больше к нему не обращаются.

>[!info]
>Записывать элемент в массив **`$_POST`** нет никакого смысла. Он предназначен только для передачи информации из браузера в программу, и перед его изменением лучше скопировать данные в свои собственные переменные.

Возвращаясь к функции **`get_post`**, следует отметить, что она пропускает каждый получаемый ею элемент через метод **`quote`** объекта **PDO**, чтобы удалить любые цитаты, которые злоумышленник может вставить, пытаясь взломать или изменить вашу базу данных, и добавляет кавычки вокруг каждой строки следующим образом:
```php
function get_post($pdo, $var)
{
  return $pdo->quote($_POST[$var]);
}
```


### Удаление записи
---

Перед проверкой отправки новых данных программа проверяет, есть ли значение у переменной **`$_POST['delete']`**. Если у нее есть значение, значит, пользователь нажал кнопку **`DELETE RECORD`** (Удалить запись). В этом случае должно быть отправлено и значение **`$isbn`**.

Как уже говорилось, номер `ISBN` является уникальным идентификатором каждой записи. HTML-форма добавляет `ISBN` к строке запроса **`DELETE FROM`**, создаваемой в переменной **`$query`**, которая затем передается методу query объекта **`$conn`**, чтобы этот запрос попал к MySQL.

Если значение для **`$_POST['delete']`** не установлено (и поэтому нет записи для удаления), проверяются **`$_POST[' author']`** и другие отправляемые значения. Если всем им присвоены значения, переменной **`$query`** присваивается текст команды **`INSERT INTO`**, за которым перечисляются пять вставляемых значений. Затем эта строка передается методу **`query`**.

Если какой-либо запрос завершится неудачно, команды **`try...catch`** выдадут сообщение об ошибке. Вам не захочется показывать эти ориентированные на программистов сообщения об ошибках на рабочем сайте, так что нужно будет заменить свой оператор **`CATCH`** на тот, в котором вы сами аккуратно обработаете ошибку и решите, какое сообщение об ошибке (если таковое имеется) предоставить вашим пользователям.


### Отображение формы
---

Перед выводом на экран небольшой формы (показанной на **рис. 11.2**) программа обезвреживает копии элементов, которые будут выводиться из массива **`$row`**, передавая эти копии функции **`htmlspecialchars`** с целью замены всех потенциально опасных HTML-символов безопасными HTML-элементами, а затем помещает получившиеся данные в переменные от **`$r0`** и до **`$r4`**.

Затем следует та часть кода, которая отображает данные, используя структуру echo **`<<<_END..._END`**, выводящую на экран все, что находится между тегами **`_END`**, которая должна быть вам знакома по предыдущим главам.

>[!info] ЗАМЕЧАНИЕ!
>Вместо команды `echo` программа может завершить работу с интерпретатором PHP, используя тег **`?>`**, выдать код HTML, а затем опять вернуться к работе с интерпретатором PHP, используя тег **`<?php`**. Какой из стилей применять — дело вкуса программиста, но я всегда рекомендую оставаться в рамках PHP-кода в силу следующих причин:
>
>- при отладке (а также при разборе кода другими пользователями) это дает абсолютную уверенность в том, что все содержимое файла .php является кодом PHP. Поэтому не возникает нужды отлавливать временные выходы в код HTML;
>- когда значение переменной PHP нужно вставить непосредственно в код HTML, можно просто набрать ее имя внутри этого кода. А при выходе в HTML нужно будет временно вернуться к обработке PHP, вывести переменную, а затем снова вернуться в HTML.

Раздел HTML-формы направляет все, что сделано в форме, в адрес файла sqltest.php. Это означает, что при отправке формы содержимое ее полей будет передано файлу sqltest.php, в котором и хранится сама программа. Форма настроена также на отправку полей в **`POST`**-, а не в **`GET`**-запросе. Причина в том, что **`GET`**-запросы являются дополнением к отправляемому URL-адресу и могут иметь в вашем браузере неприглядный вид. Эти запросы также позволяют пользователям без особого труда вносить изменения в отправляемую информацию и предпринимать попытки взлома вашего сервера (хотя того же самого можно добиться с помощью встроенных в браузер инструментов разработчика). Кроме этого, отказ от использования **`GET`**-запросов уберегает от появления в регистрационных файлах сервера слишком большого объема информации, поэтому при малейшей возможности нужно использовать для отправки данных **`POST`**-запросы, которые к тому же имеют преимущество, позволяющее скрыть отправляемые данные от просмотра.

При выводе полей формы HTML отображает кнопку отправки с именем **`ADD RECORD`** (Добавить запись), и форма закрывается. Обратите внимание на теги **`<pre>`** и **`</pre>`**, позволяющие воспользоваться моноширинным шрифтом и выровнять по линейке все элементы ввода данных. Внутри тегов **`<pre>`** в выводимые данные попадают также символы возврата каретки, стоящие в конце каждой строки.


### Запросы к базе данных
---

Далее код программы возвращается в привычное для нас русло **примера 11.4**, где в адрес MySQL отправляется запрос на выдачу всех записей в таблице **`classics`**:
```php
$query = "SELECT * FROM classics";
$result = $pdo->query($query);
```

Далее вводится цикл **`while`** для отображения содержимого каждой строки. Затем программа заполняет массив **`$row`** строкой результатов, для чего вызывается метод **`fetch`** объекта **`$result`**.

После того как данные попали в массив **`$row`**, они могут быть без особых усилий выведены на экран с помощью последующей heredoc-инструкции **`echo`**, где я решил использовать тег **`<pre>`**, чтобы выровнять на экране каждую запись, придав всему изображению привлекательный вид.

После отображения каждой записи следует вторая форма, которая также отправляет все свои данные файлу sqltest.php (то есть самой программе), но теперь в форме есть два скрытых поля: **`delete`** и **`isbn`**. Поле **`delete`** устанавливается в `yes`, а полю `isbn` присваивается значение, сохраненное в элементе массива **`$row[isbn]`**, в котором содержится ISBN для этой записи.

Далее отображается кнопка отправки с надписью Delete Record (Удалить запись), и форма закрывается. Затем фигурная скобка закрывает тело цикла **`while`**, который продолжает работу до тех пор, пока не будут отображены все записи.

В самом конце программы дано определение функции **`get_post`**, которую мы уже рассматривали. Вот так выглядит наша первая PHP-программа, предназначенная для управления базой данных MySQL. А теперь проверим, на что она способна.

После набора программы (и исправления всех опечаток) попробуйте ввести в поля ввода следующие сведения о книге *Moby Dick*, которые предназначены для добавления новой записи к базе данных:
```output
Herman Melville Moby Dick
Fiction 1851
9780199535729
```


### Запуск программы
---

Когда эти данные будут отправлены с помощью кнопки **ADD RECORD** (Добавить запись), прокрутите веб-страницу до самого конца, чтобы посмотреть только что добавленную информацию. Ее предполагаемый вид показан на **рис. 11.3**, но поскольку мы не упорядочили результаты с помощью **`ORDER BY`**, расположение, в котором они отобразятся, не определено.

![[Рис. 11.3. Результат добавления сведений о книге Moby Dick в базу данных.jpg]]
>**Рис. 11.3.** Результат добавления сведений о книге Moby Dick в базу                                  данных


Теперь посмотрим, как работает удаление записи, специально создав для этого ненужную запись. Попробуйте ввести во все пять полей только одну цифру 1 и нажмите кнопку **ADD RECORD** (Добавить запись). Если теперь прокрутить страницу вниз, станет видна новая запись, состоящая из одних единиц. Конечно, такая запись в таблице не нужна, поэтому теперь нажмите кнопку **DELETE RECORD** (Удалить запись) и снова прокрутите страницу вниз, чтобы убедиться в том, что запись была удалена.

>[!info]
>Теперь, если все получилось, вы можете добавлять и удалять записи по своему усмотрению. Попробуйте сделать все это несколько раз, но основные записи (включая и новую запись о книге Moby Dick) оставьте нетронутыми, поскольку они нам еще пригодятся. Можно также попробовать добавить запись, состоящую из одних единиц, два раза и посмотреть, как при второй попытке будет выведено сообщение об ошибке, в котором говорится о том, что в таблице уже есть запись со значением ISBN, равным единице.



## Практическая работа с MySQL
---
Теперь вы готовы к изучению некоторых практических приемов, которые можно использовать в PHP для доступа к базам данных MySQL, куда включены задачи создания и удаления таблиц, вставки, обновления и удаления данных, а также защиты вашей базы данных и сайта от злоумышленников. Учтите, что в следующих примерах предполагается, что вы создали программу login.php, рассмотренную ранее в этой главе.


### Создание таблицы
---

Предположим, что зоопарк поручил вам создать базу данных со сведениями обо всех содержащихся в нем представителях семейства кошачьих. Вам сказали, что в зоопарке девять представителей кошачьих: *лев*, *тигр*, *ягуар*, *леопард*, *пума*, *гепард*, *рысь*, *каракал* и *домашний кот*. Вам необходима отдельная графа для вида кошачьих. У каждого животного есть кличка, и для нее нужна еще одна графа. Необходимо также отслеживать возраст животных, и для этого требуется еще одна графа.

Разумеется, позже могут понадобиться дополнительные графы, например, для учета рациона питания, сделанных прививок и других сведений, но пока, чтобы приступить к работе, достаточно и этих граф. Каждому животному нужен также уникальный идентификатор, поэтому решено было создать для него графу **`id`**.

В **примере 11.7** показан код, который можно использовать для создания таблицы MySQL, хранящей все эти сведения. Операция присваивания, относящаяся к главному запросу, выделена полужирным шрифтом.

**Пример 11.7.** Создание таблицы **cats**
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query = "CREATE TABLE cats (
    id SMALLINT NOT NULL AUTO_INCREMENT,
    family VARCHAR(32) NOT NULL,
    name VARCHAR(32) NOT NULL,
    age TINYINT NOT NULL,
    PRIMARY KEY (id)
  )";

  $result = $pdo->query($query);
?>
```

Как видите, MySQL-запрос очень похож на тот запрос, который приходилось набирать непосредственно в командной строке, за исключением того, что в нем нет завершающей точки с запятой.


### Описание таблицы
---

Если вы не вошли в командную строку MySQL, то можно воспользоваться весьма полезным фрагментом кода, позволяющим проверить в браузере факт успешного создания таблицы. Этот код просто выдает запрос **`DESCRIBE cats`**, а затем выводит HTML-таблицу, имеющую четыре заголовка: **`Column`** (Графа), **`Type`** (Тип), **`Null`** (Нуль) и **`Key`** (Ключ), ниже которых отображаются все имеющиеся в таблице графы.

Чтобы использовать код **примера 11.8** с другими таблицами, нужно просто заменить в запросе имя `cats` именем новой таблицы.

**Пример 11.8**. Описание таблицы `cats`
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query  = "DESCRIBE cats";
  $result = $pdo->query($query);

  echo "<table><tr><th>Column</th><th>Type</th><th>Null</th><th>Key</th></tr>";

  while ($row = $result->fetch(PDO::FETCH_NUM))
  {
    echo "<tr>";
    for ($k = 0 ; $k < 4 ; ++$k)
      echo "<td>" . htmlspecialchars($row[$k]) . "</td>";
    echo "</tr>";
  }

  echo "</table>";
?>
```

Посмотрите, как стиль выборки **`PDO FETCH_NUM`** используется для возврата числового массива, чтобы легко отобразить содержимое возвращаемых данных без использования имен. Информация, выводимая программой, должна иметь следующий вид:

```html
Column  Type        Null Key 
id      smallint(6) NO   PRI
family  varchar(32) NO
name    varchar(32) NO
age     tinyint(4)  NO
```


### Удаление таблица
---

Удалить таблицу очень легко, и это весьма опасное действие нужно выполнять с большой осторожностью. В **примере 11.9** показан необходимый для этого код. Но я не советую его применять до тех пор, пока не будут проработаны все остальные примеры (вплоть до раздела «Выполнение дополнительных запросов»), поскольку в результате его выполнения будет удалена таблица **`cats`** и вам придется создавать ее заново с помощью кода, показанного в **примере 11.7.**

**Пример 11.9.** Удаление таблицы `cats`
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query  = "DROP TABLE cats";
  $result = $pdo->query($query);
?>
```


### Добавление данных
---

Добавим к таблице некоторые данные, воспользовавшись кодом, показанным в **примере 11.10.**

**Пример 11.10.** Добавление данных к таблице `cats`
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query  = "INSERT INTO cats VALUES(NULL, 'Lion', 'Leo', 4)";
  $result = $pdo->query($query);
  $query = "INSERT INTO cats VALUES(NULL, 'Cougar', 'Growler', 2)";
  $result = $pdo->query($query);
  $query = "INSERT INTO cats VALUES(NULL, 'Cheetah', 'Charly', 3)";
  $result = $pdo->query($query);
?>
```

Если изменить значение переменной $query, как показано далее, можно добавить еще два элемента данных и еще раз вызвать программу из вашего браузера:

```php
$query = "INSERT INTO cats VALUES(NULL, 'Cougar', 'Growler', 2)";
$query = "INSERT INTO cats VALUES(NULL, 'Cheetah', 'Charly', 3)";
```

Кстати, вы заметили, что в качестве первого параметра было передано значение **`NULL`**? Это сделано потому, что столбец **`id`** имеет тип **`AUTO_INCREMENT`** и MySQL решит, что нужно присвоить следующее доступное в используемой последовательности значение, поэтому мы просто передаем значение **`NULL`**, которое будет проигнорировано.

Разумеется, наиболее эффективный способ заполнения MySQL данными заключается в создании массива и вставке данных с использованием только одного запроса.

>[!info]
>На данный момент главное внимание уделяется демонстрации способов непосредственной вставки данных в MySQL (и предоставлению соответствующих мер безопасности). Но далее в книге мы перейдем к изучению более подходящего практического метода с использованием указателей мест заполнения (см. далее раздел «Указатели мест заполнения»), который практически исключает возможность ввода пользователями вредоносного кода в вашу базу данных. Поэтому при чтении данного раздела имейте в виду, что в нем просто рассматриваются основы работы MySQL-вставки, а в дальнейшем будут изучены способы усовершенствования этих базовых приемов.


### Извлечение данных
---

Теперь, когда в таблицу `cats` введены некоторые данные, в **примере 11.11** показано, как можно убедиться в том, что они были благополучно вставлены в эту таблицу.

**Пример 11.11.** Извлечение строк из таблицы `cats`
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query  = "SELECT * FROM cats";
  $result = $pdo->query($query);

  echo "<table><tr> <th>Id</th> <th>Family</th><th>Name</th><th>Age</th></tr>";

  while ($row = $result->fetch(PDO::FETCH_NUM))
  {
  	echo "<tr>";
    for ($k = 0 ; $k < 4 ; ++$k)
      echo "<td>" . htmlspecialchars($row[$k]) . "</td>";
  	echo "</tr>";
  }

  echo "</table>";
?>
```

Этот код выдает простой MySQL-запрос **`SELECT * FROM cats`**, а затем отображает все возвращенные строки, запрашивая их в виде массивов с числовым доступом в стиле **`PDO::FETCH_NUM`**. Выходная информация должна иметь следующий вид:
```html
ID  Family  Name    Age
1   Lion    Leo     4
2   Cougar  Growler 2
3   Cheetah Charly  3
```

Здесь можно убедиться в том, что столбец **`id`** получает правильное автоприращение.


### Обновление данных
---

Изменение внесенных в таблицу данных также выполняется очень просто. Вы заметили, что кличка гепарда (**`cheetah`**) записана как **`Charly`**? Исправим ее на **`Charlie`**, как показано в **примере 11.12**.

**Пример 11.12.** Переименование гепарда `Charly` в `Charlie`
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query  = "UPDATE cats SET name='Charlie' WHERE name='Charly'";
  $result = $pdo->query($query);
?>
```

Если теперь еще раз запустить код из **примера 11.11**, то будет выведена следующая информация:
```html
Id Family  Name    Age
1  Lion    Leo     4 
2  Cougar  Growler 2 
3  Cheetah Charlie 3
```


### Удаление данных
---

Пума по имени **`Growler`** была перевезена в другой зоопарк, поэтому сведения о ней нужно удалить из базы данных. Удаление данных из таблицы показано в **примере 11.13.**

**Пример 11.13.** Удаление сведений о пуме **`Growler`** из таблицы **`cats`**
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query  = "DELETE FROM cats WHERE name='Growler'";
  $result = $pdo->query($query);
?>
```

Здесь используется стандартный запрос **`DELETE FROM`**, и когда будет запущен код из **примера 11.11**, в отображаемой информации вы сможете увидеть, что строка была удалена:

```html
Id Family  Name    Age 
1  Lion    Leo     4 
3  Cheetah Charlie 3
```


### Свойство **`AUTO_INCREMENT`**
---

При использовании свойства **`AUTO_INCREMENT`** вы не можете знать, какое значение было дано графе строки, которая предшествовала вставляемой строке. Но если нужно узнать об этом, можно позже обратиться к MySQL с помощью свойства **`mysql_insert_id`** объекта подключения. Потребность в этом возникает довольно часто: например, при обработке покупки можно вставить в таблицу **`Customers`** нового покупателя, а затем сослаться на только что созданный **`CustId`** при вставке покупки в таблицу покупок. **Пример 11.10** может быть переписан и превращен в **пример 11.14**, отображающий это значение после каждой вставки.

>[!info]
>Вместо выбора наибольшего по значению идентификатора в столбце **`id`** и увеличения его значения на единицу рекомендуется использовать свойство **`AUTO_INCREMENT`**, поскольку одновременно выполняемые запросы могут после извлечения наибольшего значения изменить значения в данном столбце еще до того, как будет сохранено новое вычисленное значение.

**Пример 11.14.** Добавление данных к таблице `cats` и отчет о вставленном **`ID`**
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }
  
  $query  = "INSERT INTO cats VALUES(NULL, 'Lynx', 'Stumpy', 5)";
  $result = $pdo->query($query);

  echo "The Insert ID was: " . $pdo->lastInsertId();
?>
```

Теперь содержимое таблицы приобретет следующий вид (обратите внимание на то, что ранее использовавшееся значение **`ID`**, равное **`2`**, повторно *не* используется, поскольку в некоторых случаях это может вызвать определенные сложности):
```html
Id Family Name Age
1  Lion    Leo 4 
3  Cheetah Charlie 3 
4  Lynx    Stumpy 5
```


### Идентификаторы вставленных строк
---

Зачастую данные вставляются сразу в несколько таблиц: за книгой следует ее автор, за покупателем — его покупка и т. д. При вставке данных в графы с автоприращением нужно будет запомнить вставленный **`ID`**, возвращенный для его сохранения в связанной таблице.

Предположим, что для привлечения дополнительных средств над представителями кошачьих могут брать шефство какие-нибудь организации, и когда животное сохраняется в таблице кошек, нам нужно создать ключ для привязки его к организации, взявшей над ним шефство. Код для этого похож на код **примера 11.14**, за исключением того, что возвращенный **`ID`**, который был вставлен в таблицу, сохраняется в переменной **`$insertID`**, а затем используется в качестве составной части следующего запроса:

```php
$query = "INSERT INTO cats VALUES(NULL, 'Lynx', 'Stumpy', 5)";
$result = $pdo->query($query);
$insertID = $pdo->lastInsertId();

$query = "INSERT INTO owners VALUES($insertID, 'Ann', 'Smith')";
$result = $pdo->query($query);
```

Теперь животное связано со своим шефом посредством уникального кошачьего идентификатора, который был автоматически создан благодаря свойству **`AUTO_INCREMENT`**. Этот пример, особенно последние две строки, представляет собой теоретический код, показывающий, как использовать идентификатор вставки в качестве ключа, если бы мы создавали таблицу с названием **`owners`**.


### Выполнение дополнительных запросов
---

Итак, хватит тренироваться на кошках. Чтобы исследовать более сложные запросы, нужно вернуться к использованию таблиц **`customers`** и **`classics`**, которые вы должны были создать в процессе работы с главой 8. В таблице **`customers`** должны быть сведения о двух покупателях, а в таблице **`classics`** — сведения о нескольких книгах. В них также совместно используется столбец с номером ISBN, названный **`isbn`**, который можно применять для выполнения дополнительных запросов.

==Например, для отображения всех покупателей вместе с названиями и авторами купленных ими книг можно воспользоваться кодом, показанным в **примере 11.15.**==

**Пример 11.15.** Выполнение вторичного запроса
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $query  = "SELECT * FROM customers";
  $result = $pdo->query($query);

  while ($row = $result->fetch())
  {
    $custname = htmlspecialchars($row['name']);
    $custisbn = htmlspecialchars($row['isbn']);

    echo "$custname purchased ISBN $custisbn: <br>";

    $subquery  = "SELECT * FROM classics WHERE isbn='$custisbn'";
    $subresult = $pdo->query($subquery);
    $subrow    = $subresult->fetch();
    
    $custbook  = htmlspecialchars($subrow['title']);
    $custauth  = htmlspecialchars($subrow['author']);

    echo "&nbsp;&nbsp; '$custbook' by $custauth<br><br>";
  }
?>
```

В этой программе используется первичный запрос к таблице customers, чтобы найти всех покупателей. Затем на основе номера ISBN книг, приобретенных каждым покупателем, делается новый запрос к таблице **`classics`**, чтобы найти название и автора каждой из книг. При выполнении этого кода будет выведена следующая информация:

```html
Joe Bloggs purchased ISBN 9780099533474:
 'The Old Curiosity Shop' by Charles Dickens
Jack Wilson purchased ISBN 9780517123201:
 'The Origin of Species' by Charles Darwin
Mary Smith purchased ISBN 9780582506206:
 'Pride and Prejudice' by Jane Austen
```

>[!info]
>Хотя это и не имеет отношения к иллюстрации использования дополнительных запросов, но в данном случае можно вернуть точно такую же информацию, используя запрос с видом объединения **`NATURAL JOIN`** ([[Введение в MySQL]]):
>```mysql
>SELECT name,isbn,title,author FROM customers;
>  NATURAL JOIN classics;
>```


## Предотвращение попыток взлома
---

Наверное, опасность передачи MySQL не прошедшей проверку вводимой пользователем информации все же недооценивается. Представьте, к примеру, что для идентификации пользователя применяется следующий простой фрагмент кода:
```php
$user = $_POST['user'];
$pass = $_POST['pass'];
$query = "SELECT * FROM users WHERE user='$user' AND pass='$pass'";
```

На первый взгляд этот код может показаться вполне приемлемым. Если пользователь вводит значения `fredsmith` и `mypass`, которые присваиваются переменным `$user` и `$pass` соответственно, то строка запроса, которая передается MySQL, приобретает следующий вид:
```mysql
SELECT * FROM users WHERE user='fredsmith' AND pass='mypass'
```

Все это выглядит вполне пристойно, но что будет, если кто-нибудь введет для переменной **`$user`** следующую строку (а для переменной **`$pass`** вообще ничего не станет вводить):
```mysql
admin' #
```

осмотрим на строку, которая будет отправлена MySQL:
```mysql
SELECT * FROM users WHERE user='admin' #' AND pass=''
```

Вы поняли, в чем тут проблема (ниже выделено полужирным шрифтом)? Произошла атака *[[SQL-инъекции]]*. В MySQL с символа **`#`** начинается комментарий. Поэтому пользователь войдет в систему под именем admin (предположим, что в системе есть пользователь *admin*), и ему не нужно будет вводить пароль. В следующей строке исполняемая часть запроса выделена полужирным шрифтом, а все остальные символы будут проигнорированы.
```php
$user = $_POST['user'];
$pass = $_POST['pass'];
$query = "DELETE FROM users WHERE user='$user' AND pass='$pass'";
```

На первый взгляд с ним опять вроде бы все в порядке, но что получится, если кто-нибудь введет для переменной **`$user`** следующее значение:
```mysql
anything' OR 1=1 #
```

MySQL интерпретирует это следующим образом (также выделено полужирным шрифтом):
```mysql
DELETE FROM users WHERE user='anything' OR 1=1 #' AND pass=''
```

Благодаря тому что любое утверждение, за которым следует **`OR 1=1`**, всегда будет истинным, **`TRUE`**, условие этого SQL-запроса всегда будет **`TRUE`**, поэтому, поскольку остальная часть утверждения игнорируется из-за символа **`#`**, вы лишитесь всей *пользовательской* базы данных. Так что же нужно делать в случае подобной атаки?


### Возможные меры противодействия
---

Не стоит полагаться на встроенное в PHP свойство «волшебных кавычек» (magic quotes), которое автоматически отключает любые символы одинарных и двойных кавычек путем установки перед ними символа «обратный слеш» (`\`). Почему? Да потому, что это свойство может быть отключено. Многие программисты именно так и делают, чтобы вставить собственный код, обеспечивающий безопасность. Поэтому нет никаких гарантий того, что на вашем рабочем сервере это свойство не было отключено. Фактически в PHP 5.3.0 его использование не приветствовалось, а из PHP 5.4.0 оно вообще было удалено.

Вместо этого, как мы показывали ранее, для всех обращений к MySQL вы можете всегда использовать метод **`quote`**. В **примере 11.16** показана функция, которую можно использовать, чтобы удалить любые «волшебные кавычки», добавленные во введенную пользователем строку, а затем соответствующим образом обезвредить все имеющиеся в ней опасные компоненты.

**Пример 11.16.** Способ обезвреживания данных, введенных пользователем, приемлемый для MySQL
```php
<?php
  function mysql_fix_string($pdo, $string)
{
  if (get_magic_quotes_gpc()) $string = stripslashes($string);
  return $pdo->quote($string);
}
?>
```

Функция **`get_magic_quotes_gpc`** возвращает **`TRUE`**, если свойство «волшебных кавычек» находится в активном состоянии. Если это так, любые добавленные к строке слеши подлежат удалению, в противном случае метод **`quote`** может отключить некоторые символы дважды, сделав строки непригодными для дальнейшего использования. В **примере 11.17** показано, как можно вставить функцию **`mysql_fix_string`** в ваш код.

**Пример 11.17.** Способ безопасного доступа к MySQL при использовании данных, введенных пользователем
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $user  = mysql_fix_string($pdo, $_POST['user']);
  $pass  = mysql_fix_string($pdo, $_POST['pass']);
  $query = "SELECT * FROM users WHERE user=$user AND pass=$pass";

  // Etc...

  function mysql_fix_string($pdo, $string)
  {
    if (get_magic_quotes_gpc()) $string = stripslashes($string);
    return $pdo->quote($string);
  }
?>
```

>[!info]
>Помните, что, поскольку метод **`quote`** автоматически добавляет кавычки вокруг строк, вам не нужно применять их в любом запросе, использующем эти очищенные строки. Получается, вместо
>```MySQL
>
>$query = "SELECT * FROM users WHERE user='$user' AND pass='$pass'";
>```
>
>вам нужно вводить
>
>```mysql
>
$query = "SELECT * FROM users WHERE user=$user AND pass=$pass";>
>```
>
>Актуальность этих мер предосторожности снижается, поскольку есть более простой и безопасный способ доступа к MySQL, исключающий необходимость использования подобного рода функций и заключающийся в применении указателей мест заполнения, которые мы рассмотрим далее.


### Указатели мест заполнения
---

Все рассмотренные до сих пор способы работают с MySQL, но требуют применения особых мер безопасности, поскольку строки постоянно нужно обезвреживать. ==Но теперь, после изучения основ, приступим к более рациональному и рекомендуемому способу работы с MySQL, существенно превосходящему по степени защищенности прежние методы работы==. Как только вы усвоите материал этого раздела, нужно будет отказаться от непосредственной вставки данных в MySQL (хотя было важно показать, как это делается) и постоянно использовать исключительно указатели мест заполнения.

Так что же собой представляют эти указатели? Это позиции внутри подготовленных инструкций, в которых данные переносятся непосредственно в базу данных, что исключает возможность интерпретации переданных пользователем (или кем-то другим) данных в качестве MySQL-инструкций (и возможность потенциального взлома в результате такой интерпретации).

Эта технология требует от вас сначала определить запрос для выполнения в MySQL, в котором в местах, ссылающихся на данные, используются простые вопросительные знаки.

Обычно в MySQL предварительно определенные запросы имеют вид, показанный в **примере 11.18.**

**Пример 11.18.** Использование указателей мест заполнения
```mysql
PREPARE statement FROM "INSERT INTO classics VALUES(?,?,?,?,?)";
SET @author = "Emily Brontё",
	@title = "Wuthering Heights",
	@category = "Classic Fiction",
	@year = "1847",
	@isbn = "9780553212587";

EXECUTE statement USING @author,@title,@category,@year,@isbn;
DEALLOCATE PREPARE statement;
```

Чтобы не усложнять передачу запросов MySQL, расширение **`PDO`** упрощает обработку указателей мест заполнения, предоставляя готовый метод под названием prepare, вызываемый следующим образом:

```php
$stmt = $pdo->prepare('INSERT INTO classics VALUES(?,?,?,?,?)');
```

Объект **`$stmt`** (сокращение от слова «инструкция» — *statement*), возвращаемый этим методом, используется затем для отправки на сервер данных, замещающих вопросительные знаки. В первую очередь он используется для последовательной привязки к каждому вопросительному знаку (к параметрам указателей мест заполнения) PHP-переменных:

```php
$stmt->bindParam(1, $author, PDO::PARAM_STR, 128);
$stmt->bindParam(2, $title, PDO::PARAM_STR, 128);
$stmt->bindParam(3, $category, PDO::PARAM_STR, 16 );
$stmt->bindParam(4, $year, PDO::PARAM_INT );
$stmt->bindParam(5, $isbn, PDO::PARAM_STR, 13 );
```

Первым аргументом метода **`bindParam`** является число, представляющее собой позицию вставляемого значения в строке запроса (другими словами, на какой заменитель вопросительного знака идет ссылка). За ним идет переменная, которая будет предоставлять данные для этого заменителя, а затем тип данных, которые должна содержать эта переменная, и если это строка, далее стоит другое значение, указывающее ее максимальную длину.

Теперь, когда переменные привязаны к предварительно определенным инструкциям, необходимо заполнить их данными, чтобы можно было передать их MySQL, следующим образом:

```php
$author = 'Emily Brontё';
$title = 'Wuthering Heights';
$category = 'Classic Fiction';
$year = '1847';
$isbn = '9780553212587';
```

Теперь у сценария PHP есть все, что нужно, чтобы выполнить предварительно определенный запрос, поэтому мы выдаем следующую команду, вызывающую метод **`execute`** ранее созданного объекта **`$stmt`**, передавая значения, которые необходимо вставить, в виде массива:

```php
$stmt->execute([$author, $title, $category, $year, $isbn]);
```

Перед тем как продолжить, имеет смысл провести очередную проверку на успешное выполнение команды, что можно сделать, используя метод **`rowCount`** для **`$stmt`**:

```php
printf("%d Row inserted.\n", $stmt->rowCount());
```

В данном случае выводимая информация должна свидетельствовать о вставке одной строки.

Когда все будет собрано вместе, получится результат, показанный в **примере 11.19.**

**Пример 11.19.** Использование указателей мест заполнения с PHP
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $stmt = $pdo->prepare('INSERT INTO classics VALUES(?,?,?,?,?)');
  $stmt->bindParam(1, $author,   PDO::PARAM_STR, 128);
  $stmt->bindParam(2, $title,    PDO::PARAM_STR, 128);
  $stmt->bindParam(3, $category, PDO::PARAM_STR, 16 );
  $stmt->bindParam(4, $year,     PDO::PARAM_INT     );
  $stmt->bindParam(5, $isbn,     PDO::PARAM_STR, 13 );
  
  $author   = 'Emily Brontë';
  $title    = 'Wuthering Heights';
  $category = 'Classic Fiction';
  $year     = '1847';
  $isbn     = '9780553212587';

  $stmt->execute([$author, $title, $category, $year, $isbn]);
  printf("%d Row inserted.\n", $stmt->rowCount());
?>
```

При каждом использовании предварительно определяемых запросов вместо изначально готовых запросов вы будете закрывать потенциальную брешь в системе безопасности, поэтому стоит потратить время на изучение способов их использования.


### Предотвращение внедрения JavaScript в HTML
---

Нужно позаботиться о защите еще от одного вида внедрения, который связан не с безопасностью ваших собственных сайтов, а с конфиденциальностью и защитой пользовательских данных. Речь идет о *межсайтовом выполнении сценариев* (Cross Site Scripting), называемом также *XSS-атакой*.

Эта разновидность внедрения происходит в том случае, когда вы разрешаете пользователю вводить, а затем отображать на вашем сайте HTML-, или, что случается чаще, JavaScript-код. Одним из мест, где это часто происходит, является форма для комментариев. Чаще всего злоумышленник пытается написать код, ворующий у пользователей вашего сайта cookie, позволяющие ему узнать пары «имя пользователя — пароль», если они обрабатываются недостаточно безопасно, или другую информацию, позволяющую захватить сеанс работы (в котором пользовательская учетная запись захвачена злоумышленником, получившим теперь возможность пользоваться ею!). Или же злоумышленник может предпринять атаку с целью загрузки на пользовательский компьютер троянского коня.

Чтобы предотвратить это внедрение, нужно лишь вызвать функцию **`htmlentities`**, выявляющую все коды разметки HTML и заменяющую их формой, которая отображает символы, но не позволяет браузеру действовать в соответствии с их предназначением. Рассмотрим, к примеру, следующий код HTML:

```javascript
<script src='http://x.com/hack.js'></script>
<script>hack();</script>
```

Этот код загружает программу на JavaScript, а затем выполняет вредоносные функции. Но если сначала этот код будет пропущен через функцию **`htmlentities`**, то он превратится в такую абсолютно безвредную строку:

```js
&lt;script src='http://x.com/hack.js'&gt; &lt;/script&gt; &lt;script&gt;hack();&lt;/script&gt;
```

Поэтому если вы когда-нибудь соберетесь отобразить какие-нибудь данные, введенные пользователем, то нужно немедленно или сразу же после первого сохранения в базе данных обезвредить их с помощью функции **`htmlentities`**. Для этого я рекомендую вам создать новую функцию наподобие первой функции, показанной в **примере 11.20**, которая способна обезвредить попытки как SQL-, так и XSS-внедрения.

```php
<?php
  function mysql_entities_fix_string($pdo, $string)
  {
    return htmlentities(mysql_fix_string($pdo, $string));
  }    

  function mysql_fix_string($pdo, $string)
  {
    if (get_magic_quotes_gpc()) $string = stripslashes($string);
    return $pdo->quote($string);
  }
?>
```

Функция **`mysql_entities_fix_string`** сначала вызывает функцию **`mysql_fix_string`**, а затем, прежде чем вернуть полностью обезвреженную строку, пропускает результат через функцию **`htmlentities`**. Для использования любой из этих функций у вас уже должен быть активный объект подключения к базе данных MySQL.

**В примере 11.21** показана новая, «более защищенная» версия **примера 11.17**. Это всего лишь пример кода, и вам потребуется добавить код, чтобы получить доступ к возвращаемым результатам там, где вы увидите строку комментария //Etc....

**Пример 11.21.** Способ безопасного доступа к MySQL
и предотвращения XSS-атак
```php
<?php
  require_once 'login.php';

  try
  {
    $pdo = new PDO($attr, $user, $pass, $opts);
  }
  catch (PDOException $e)
  {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
  }

  $user  = mysql_entities_fix_string($pdo, $_POST['user']);
  $pass  = mysql_entities_fix_string($pdo, $_POST['pass']);
  $query = "SELECT * FROM users WHERE user=$user AND pass=$pass";

  //Etc…

  function mysql_entities_fix_string($pdo, $string)
  {
    return htmlentities(mysql_fix_string($pdo, $string));
  }    

  function mysql_fix_string($pdo, $string)
  {
    if (get_magic_quotes_gpc()) $string = stripslashes($string);
    return $pdo->quote($string);
  }
?>
```


## Вопросы
---

- [x] 1. Как подключиться к базе данных MySQL с помощью **`PDO`**?
- [x] 2. Как, используя **`PDO`**, отправить запрос к MySQL?
- [ ] 3. Какой стиль метода `fetch` можно использовать для возврата строки в виде массива, индексированного по номеру столбца?
- [x] 4. Как можно вручную закрыть соединение **`PDO`**?
- [x] 5. При добавлении строки в таблицу со столбцом **`AUTO_INCREMENT`** какое значение должно быть передано этому столбцу?
- [ ] 6. Какой метод `PDO` можно использовать, чтобы корректно избежать пользовательского ввода и тем самым предотвратить внедрение кода?
- [ ] 7. Как лучше всего обеспечить безопасность базы данных при получении доступа к ней?

