---
date of creation: 2024-06-02T10:21:00
tags:
  - MySQL
  - SQL
  - Database
  - IT
  - Programming
  - ProgrammingLanguage
  - СУБД
  - Education
  - РСУБД
---
---
# Введение в MySQL
==Более чем 10 миллионов установленных на компьютерах копий MySQL позволяют, наверное, считать ее наиболее популярной системой управления базами данных для веб-серверов.== Она была разработана в середине 1990-х годов и теперь превратилась в полноценную технологию, входящую в состав многих современных наиболее посещаемых интернет-ресурсов.

Одна из причин такого успеха — то, что она, как и PHP, является продуктом свободного пользования. Кроме того, это очень мощная и исключительно быстрая система. Система [[MySQL]] обладает также хорошей масштабируемостью, то есть база данных может увеличиваться в объеме вместе с вашим сайтом; последние сравнительные показатели обновляются в режиме онлайн — https://tinyurl.com/mysqlbm.

==Больше подробностей об SQL== - [[SQL (Structured Query Language язык структурированных запросов).]]


## Основные характеристики MySQL
[[База данных]] — это структурированная коллекция записей или данных, хранящихся в компьютерной системе и организованных так, что можно осуществлять быстрый поиск и извлечение нужной информации.

В названии MySQL составляющая SQL означает *Structured Query Language* язык структурированных запросов. Если характеризовать его в общих чертах, то это язык, основанный на словах английского языка и используемый также в других системах управления базами данных, например Oracle и Microsoft SQL Server. Он разработан для предоставления возможности создания простых запросов к базе данных посредством команд следующего вида:

```sql
SELECT title FROM publications WHERE author = 'Charles Dickens';
```

В базе данных MySQL имеются одна или несколько *таблиц*, каждая из которых состоит из *записей*, или *строк*. Внутри *строк* находятся разные *столбцы*, или *поля*, в которых и содержатся данные. В **табл. 8.1** показана учебная база данных, в которой присутствует информация о пяти книгах, структурированная по авторам, названиям, категориям и годам изданий.

**Таблица 8.1.** Пример простой базы данных
![[Таблица 8.1. Пример простой базы данных.jpg]]

Каждая строка таблицы подобна строке в таблице MySQL, столбец в таблице соответствует столбцу в MySQL, и каждый элемент в строке подобен полю MySQL.

Чтобы однозначно идентифицировать эту базу данных, в последующих примерах я буду ссылаться на нее как на базу данных **`publications`** (издания). Как вы уже заметили, все эти издания относятся к классической литературе, поэтому таблицу в базе данных, содержащую сведения о них, я буду называть **`classics`**.


## Сводка понятий, используемых в базах данных
Основными понятиями, с которыми следует ознакомиться на данном этапе, являются:

- *база данных* — контейнер для всей коллекции данных MySQL;
- *таблица* — вложенный в базу данных контейнер, в котором хранятся сами данные;
- *строка* — отдельная запись, в которой могут содержаться несколько полей;
- *столбец* — имя поля внутри строки.

Следует заметить, что я не пытаюсь воспроизвести точную терминологию, используемую в реляционных базах данных, а хочу лишь дать простые, обычные определения, помогающие быстро усвоить основные понятия и приступить к работе с базой данных.


## Доступ к MySQL из командной строки
Работать с MySQL можно тремя основными способами: используя командную строку, применяя веб-интерфейс наподобие *phpMyAdmin* и задействуя такой язык программирования, как PHP. Третий из перечисленных способов будет рассмотрен в [[Доступ к MySQL с использованием PHP]], а сейчас изучим первые два способа.


### Начало работы с интерфейсом командной строки
---
В следующих разделах даны соответствующие инструкции для Windows, macOS и Linux.


#### Для пользователей Windows
---
Если у вас в соответствии с инструкциями, изложенными в [[Установка сервера, предназначенного для разработки]], обычным способом установлена среда AMPPS, то доступ к исполняемой программе MySQL можно получить из следующего каталога:
```cmd
C:\Program Files\Ampps\mysql\bin
```


>[!info]
>Если AMPPS установлена в любое другое место, то вместо этого нужно воспользоваться тем каталогом, в котором она находится, например, для 32-битных установок AMPPS следующим:
>```cmd
>C:\Program Files (x86)\Ampps\mysql\bin

По умолчанию начальным для MySQL будет пользователь по имени root, у которого будет исходный пароль **`mysql`**.

Чтобы войти в интерфейс командной строки MySQL, следует выбрать команду Пуск>Выполнить и в окне запуска ввести команду **`CMD`**, после чего нажать клавишу Enter. В результате будет вызвано командное окно Windows. Находясь в этом окне, нужно ввести следующую команду (внося в нее соответствующие коррективы):

```cmd
cd C:\"Program Files\Ampps\mysql\bin" mysql -u root -pmysql
```

Первая команда меняет текущий каталог на каталог MySQL, а вторая предписывает MySQL зарегистрировать вас как пользователя **`root`** с паролем **`mysql`**. Теперь вы должны оказаться в среде MySQL и сможете приступить к вводу команд.

Если вы используете Windows PowerShell, а не командную строку, он не будет загружать команды из текущего местоположения, поскольку вы должны четко указать, откуда загружать программу, и в этом случае вам нужно ввести следующее (обратите внимание на знак **`./`** перед командой **`mysql`**):

```PowerShell
cd C:\"Program Files\Ampps\mysql\bin"
./mysql -u root -pmysql
```

Чтобы убедиться в том, что все работает должным образом, введите следующую команду, результат выполнения которой должен быть похож на показанный на **рис. 8.1**:

```MySQL
SHOW databases;
```

Теперь можете перейти к подразделу «Использование интерфейса командной строки».


#### Для пользователей macOS
---
Чтобы иметь возможность выполнять то, о чем говорится в этой главе, нужно в соответствии с инструкциями, изложенными в [[Установка сервера, предназначенного для разработки]], установить среду [[AMPPS]]. Следует также иметь работающий веб-сервер с запущенным сервером MySQL.

Для входа в интерфейс командной строки MySQL необходимо запустить программу Terminal (доступную в меню Utilities программы Finder). Затем вызвать программу MySQL, которая должна быть установлена в каталоге `/Applications/ampps/mysql/bin`.

По умолчанию исходным пользователем для MySQL будет пользователь по имени root, и пароль у него будет mysql. Поэтому для запуска программы наберите следующую команду:

```Terminal
/Applications/ampps/mysql/bin/mysql -u root -pmysql
```

Эта команда предпишет MySQL зарегистрировать вас как пользователя root с использованием пароля mysql. Чтобы проверить, что все в порядке, наберите следующую команду (результаты ее выполнения показаны на рис. 8.2):

```MySQL
SHOW databases;
```

Если будет получено сообщение об ошибке, не позволяющей подключиться к локальному серверу MySQL (**Can't connect to local MySQL server through socket**), то, вероятно, сначала вам придется запустить сервер MySQL в соответствии с описанием, приведенным в [[Установка сервера, предназначенного для разработки]].

Теперь вы готовы перейти к подразделу «Использование интерфейса командной строки» далее в этой главе.


#### Для пользователей Linux
---
На машинах, работающих под управлением UNIX-подобных операционных систем, к которым относится и Linux, PHP и MySQL, вероятно, будут заранее установлены и запущены, позволяя вводить текст примеров следующего раздела (если же этого не случилось, нужно выполнить процедуры, которые рассматривались в [[Установка сервера, предназначенного для разработки]], когда шел разговор об установке AMPPS). Сначала нужно войти в систему MySQL, введя следующую команду:

```bash
mysql -u root -p
```

Эта команда предписывает MySQL зарегистрировать вас под именем root и запросить пароль. Если у вас есть пароль, то нужно его ввести, если пароль отсутствует — просто нажать клавишу Enter.

После входа в систему нужно проверить работоспособность программы, набрав следующую команду, примерный результат выполнения которой показан на рис. 8.3:

```MySQL
SHOW databases;
```

Если по каким-то причинам эта команда не сработает, обратитесь, пожалуйста, к [[Установка сервера, предназначенного для разработки]], чтобы убедиться в том, что MySQL установлена должным образом.


#### MySQL на удаленном сервере
---
При получении доступа к MySQL на удаленном сервере, который, скорее всего, будет работать под управлением операционной системы семейства типа Linux/ FreeBSD/UNIX, нужно выйти на удаленную машину с помощью безопасного протокола SSH (использования небезопасного протокола Telnet нужно избегать всеми силами). После подключения к удаленной машине можно встретиться с незначительными вариациями в порядке работы, зависящими от настроек сервера, которые выполнены системным администратором, особенно если этот сервер предназначен для коллективного пользования. Поэтому следует убедиться в доступности MySQL и в том, что у вас есть имя пользователя и пароль. Получив эти сведения, можно набрать следующую команду, в которой вместо **`имя_пользователя`** нужно вставить предоставленное имя пользователя:

```bash
mysql -u имя_пользователя -p
```

После появления приглашения необходимо ввести пароль. Затем можно попробовать ввести следующую команду, примерный результат выполнения которой показан на рис. 8.3:

```mysql
SHOW databases;
```

В перечне баз данных могут присутствовать и другие ранее созданные базы, среди которых базы **test** может и не оказаться.

Следует также понимать, что все находится под полным контролем системного администратора и вы можете столкнуться с некоторыми неожиданными настройками. Например, может оказаться, что вам следует ставить перед именами всех создаваемых вами баз данных уникальную идентификационную строку, обеспечивающую их бесконфликтную работу с базами данных, созданными другими пользователями.

При возникновении любых проблем нужно переговорить с системным администратором, который должен с ними разобраться. У него нужно запросить имя пользователя и пароль, а также можно попросить дать вам возможность создавать новые базы данных или как минимум попросить создать для вас хотя бы одну готовую к работе базу данных. Тогда в этой базе можно будет создать все необходимые таблицы.


## Использование интерфейса командной строки

Для всего, что изложено далее в тексте главы, нет никакой разницы, из какой именно системы — Windows, macOS или Linux — вы получаете непосредственный доступ к MySQL, поскольку все используемые команды (и сообщения об ошибках, которые могут быть получены) абсолютно одинаковы.


### Точка с запятой
---

Начнем с самого простого. Набирая команду, вы, наверное, заметили точку с запятой (**`;`**) в конце **`SHOW databases;`**? Этот символ используется в MySQL для завершения команд или отделения их друг от друга. Если забыть поставить этот символ, MySQL выдаст приглашение и будет ожидать от вас его ввода. Запрашиваемая точка с запятой стала частью синтаксиса, позволяющего вводить многострочные команды, разбивая их на несколько строк. Она также позволяет вводить сразу несколько команд, после каждой из которых стоит точка с запятой. После нажатия вами клавиши Enter интерпретатор получит все эти команды в едином пакете и выполнит их в порядке следования.

>[!info]
>Вместо результата введенной команды довольно часто появляется приглашение MySQL. Это означает, что вы забыли поставить завершающую точку с запятой. В таком случае нужно просто ввести точку с запятой, нажать клавишу Enter, и вы получите желаемый результат.

На экране могут появляться шесть разных приглашений MySQL (**табл. 8.2**), позволяющих определить, на каком именно этапе многострочного ввода вы находитесь.

**Таблица 8.2.** Шесть приглашений к вводу команды MySQL
![[Таблица 8.2. Шесть приглашений к вводу команды MySQL.jpg]]


### Отмена команды
---

Если, набрав часть команды, вы решили, что ее вообще не следует выполнять, то можно ввести символы **`\с`** и нажать клавишу **Enter**. Порядок использования этой команды показан в **примере 8.1**.

**Пример 8.1.** Отмена ввода строки
```MySQL
бессмысленная для mysql строка \с
```

При наборе этой строки MySQL проигнорирует все ранее введенные символы и выдаст новое приглашение. Без **`\с`** программа выведет сообщение об ошибке. Но этой парой символов нужно пользоваться с оглядкой: если у вас уже есть открытая строка или комментарий, то прежде чем применить **`\c`**, вам придется их закрыть, иначе MySQL примет **`\c`** за часть строки. В **примере 8.2** показано, как в таком случае следует задействовать **`\c`**.

**Пример 8.2.** Отмена ввода из строки
```mysql
это "бессмысленная для mysql строка" \с
```

Следует также заметить, что комбинация **`\с`** после точки с запятой не отменит предыдущую команду, поскольку это уже будет новая инструкция.


### Команды MySQL
---

Нам уже приходилось встречаться с командой **`SHOW`**, которая выводит список таблиц, баз данных и многих других элементов. В **`табл. 8.3`** приведен перечень наиболее востребованных команд.

**Таблица 8.3.** Наиболее востребованные команды MySQL
![[Таблица 8.3. Наиболее востребованные команнды MySQL.jpg | 700x700]]

Многие из этих команд будут рассмотрены по мере изучения этой главы, но сначала следует запомнить два важных положения, касающихся команд MySQL.

- Команды и ключевые слова SQL нечувствительны к регистру. Все три команды — **`CREATE`**, **`create`** и **`CrEaTe`** — абсолютно идентичны по смыслу. Но чтобы было понятнее, для команд можно использовать буквы верхнего регистра.
- Имена таблиц нечувствительны к регистру в Windows, но чувствительны к регистру в Linux и macOS. Поэтому из соображений переносимости нужно всегда выбирать буквы одного из регистров и пользоваться только ими. Для имен таблиц рекомендуется использовать буквы нижнего регистра или комбинацию из букв верхнего и нижнего регистра.


### Создание базы данных
---

Если вы работаете на удаленном сервере, у вас только одна учетная запись пользователя и вы имеете допуск только к одной созданной для вас базе данных, то можете перейти к изучению пункта «Создание таблицы» далее. А если это не так, то продолжим, введя следующую команду для создания новой базы данных по имени **`publications`**:

```MySQL
CREATE DATABASE publications;
```

При успешном выполнении команды будет выведено сообщение, пока не имеющее для нас особого смысла, — **`Query OK, 1 row affected (0.38 sec)`** (Запрос выполнен, обработана 1 строка за 0,38 с), но вскоре все станет на свои места. После создания базы данных с ней нужно будет работать, поэтому даем следующую команду:

```MySQL
USE publications;
```

Теперь должно быть выведено сообщение об изменении текущей базы данных (**`Database changed`**), и после этого база будет готова к продолжению работы со следующими примерами.


### Организация доступа пользователей
---

Теперь, когда вы уже убедились в том, насколько просто пользоваться MySQL, и создали свою первую базу данных, настало время посмотреть на то, как происходит организация доступа пользователей, поскольку, вполне вероятно, вам не захочется предоставлять PHP-сценариям привилегированный доступ (`root`) к MySQL, что грозит большими неприятностями в том случае, если кому-то вздумается взломать ваш сайт.

Для создания нового пользователя выдается команда предоставления прав `CREATE USER`, которая принимает следующую форму (не вздумайте все это набирать, поскольку это еще не команда):

```sql
CREATE USER 'имя_пользователя'@'имя_хоста' IDENTIFIED BY 'пароль';
GRANT PRIVILEGES ON database.object TO 'имя_пользователя'@'имя_хоста';
```

Эта форма не должна вызвать каких-либо затруднений, быть может, за исключением фрагмента **база_данных.объект**. Это ссылка на саму базу данных и на содержащиеся в ней объекты, например на таблицы (**табл. 8.4**).

![[Таблица 8.4. Примерные параметры для команды GRANT.jpg]]

Итак, создадим пользователя, который получит доступ только к новой базе данных `publications` и ко всем ее объектам, и введем для этого следующую команду (заменив в ней имя пользователя `jim` и пароль `password` выбранными вами именем и паролем):

```Mysql
CREATE USER 'jim'@'localhost' IDENTIFIED BY 'password';
GRANT ALL ON publications.* TO 'jim'@'localhost';
```

Эта команда предоставляет пользователю `jim@localhost` полный доступ к базе данных publications при использовании пароля password. Работоспособность этой установки можно проверить, если ввести команду quit для выхода из системы, а затем перезапустить MySQL, воспользовавшись прежним способом запуска. Но вместо того чтобы входить в систему как root, войдите в систему под любым созданным вами именем пользователя, например `jim`. В **табл. 8.5** показаны команды, соответствующие используемой вами операционной системе, но если на вашей системе MySQL-клиент установлен в другой каталог, то в команду следует внести соответствующие коррективы.

![[Таблица 8.5. Запуска MySQL и в вход под именем jim@localhost.jpg]]

Теперь, как только появится приглашение, нужно лишь ввести свой пароль, и вход в систему будет открыт. Кстати, если захотите, можете поместить пароль сразу же после ключа `-p` (не используя никаких пробелов). Тем самым вы избежите его ввода после появления приглашения. Но такой подход не приветствуется, поскольку если в вашей системе зарегистрировались и другие пользователи, они могут подсмотреть вводимую вами команду и получить доступ к вашему паролю.

>[!info]
>Вы можете предоставлять только те права, которыми уже обладаете, и должны иметь право на ввод команд `GRANT`. Этим и ограничивается выбор предоставляемых вам прав, если только вам не предоставлены абсолютно все права. Если вас интересуют подробности использования команды `GRANT` и команды `REVOKE`, которые позволяют отозвать уже предоставленные права, обратитесь к документации по адресу https://tinyurl.com/ `mysqlgrant`. Вам также следует знать, что если при создании нового пользователя не будет указана инструкция `IDENTIFIED BY`, у пользователя не будет пароля, из-за чего возникнет неблагоприятная с точки зрения безопасности ситуация, которой лучше избегать.


### Создание таблицы
---

В данный момент вы должны находиться в системе MySQL, обладать всеми (ALL) правами, выделенными для базы данных `publications` (или той базы данных, которая была для вас создана), и быть готовыми к созданию своей первой таблицы. Поэтому нужно включить базу данных в работу, набрав следующую команду (и заменив `publications` именем своей базы данных, если оно у нее другое):

```mysql
USE publications;
```

Теперь наберите построчно команды, которые приведены в **примере 8.3.**

**Пример 8.3.** Создание таблицы под названием `classics`
```mysql
CREATE TABLE classics (
  author VARCHAR(128),
  title VARCHAR(128),
  type VARCHAR(16),
  year CHAR(4)) ENGINE InnoDB;
```

>[!info]
>Последние два слова в этой команде требуют небольшого разъяснения. Обработка запросов внутри MySQL может осуществляться множеством различных способов, которые поддерживаются различными исполнительными механизмами. Начиная с версии 5.6, исходным механизмом работы с хранилищем MySQL является `InnoDB`, используемый нами из-за имеющейся в нем поддержки поисков в режиме FULLTEXT. Если у вас относительно новая версия MySQL, часть команды `ENGINE InnoDB` при создании таблицы можно опустить, но я ее сохранил для того, чтобы подчеркнуть, какой именно исполнительный механизм используется.
>
>Если у вас запущена версия MySQL ниже 5.6, то механизм `InnoDB` не станет поддерживать индексы FULLTEXT и вам придется вместо `InnoDB` указать в команде `MyISAM`, чтобы показать, что нужно воспользоваться именно этим исполнительным механизмом (см. далее раздел «Создание индекса FULLTEXT»).
>
>`InnoDB` в целом более эффективен и является рекомендуемым вариантом применения. Если у вас в соответствии с подробными инструкциями, изложенными в [[Установка сервера, предназначенного для разработки]], установлен пакет программных средств AMPPS, вы будете пользоваться версией MySQL не ниже 5.6.35.

>[!Info]
>Предыдущую команду можно ввести одной строкой:
>
>```mysql
CREATE TABLE classics (author VARCHAR(128), title VARCHAR(128), type VARCHAR(16), year CHAR(4)) ENGINE InnoDB;`
>```
>но команды MySQL могут быть длинными и сложными, поэтому я рекомендую набирать их в формате, показанном в **примере 8.3**, до тех пор пока вы не привыкнете к набору длинных строк.

осле ввода команды MySQL должна выдать ответ: `Query OK, 0 rows affected`, а также показать время, затраченное на выполнение команды. Если вместо этого появится сообщение об ошибке, внимательно проверьте синтаксис команды. Должны быть на месте все скобки и запятые, а может быть, допущена какая-нибудь опечатка.

Чтобы проверить факт создания новой таблицы, наберите команду:
```Mysql
DESCRIBE classics;
```

Если все в порядке, то вы увидите последовательность команд и ответов, показанных в **примере 8.4**, в которой особое внимание следует обратить на отображение формата таблицы.

**Пример 8.4.** Сеанс работы с MySQL: создание и проверка формата новой таблицы
```mysql
mysql> USE publications; Database changed
mysql> CREATE TABLE classics (
->    author VARCHAR(128),
->    title VARCHAR(128),
->    type VARCHAR(16),
->    year CHAR(4)) ENGINE InnoDB
Query OK, 0 rows affected (0.03 sec)

mysql> DESCRIBE classics;
+--------+--------------+------+-----+---------+-------+
| Field  | Type         | Null | Key | Default | Extra |
+--------+--------------+------+-----+---------+-------+
| author | varchar(128) | YES  |     | NULL    |       |
| title  | varchar(128) | YES  |     | NULL    |       |
| type   | varchar(16)  | YES  |     | NULL    |       |
| year   | char(4)      | YES  |     | NULL    |       |
+--------+--------------+------+-----+---------+-------+
4 rows in set (0.24 sec)
```

Команда DESCRIBE является неоценимым средством отладки, когда нужно убедиться в успешном создании таблицы MySQL. Этой командой можно воспользоваться также для того, чтобы просмотреть имена полей или столбцов таблицы и типы данных в каждом из них. Рассмотрим подробнее все заголовки:

- **`Field`** — имя каждого из полей или столбцов таблицы;
- **`Type`** — тип данных, сохраняемых в поле;
- **`Null`** — заголовок, который показывает, может ли поле содержать значение **`NULL`**;
- **`Key`** — примененный тип ключа, если таковой имеется (*ключи*, или *индексы*, в MySQL позволяют ускорить просмотр и поиск данных);
- **`Default`** — исходное значение, присваиваемое полю, если при создании новой строки не указано никакого значения;
- **`Extra`** — дополнительная информация, например, о настройке поля на автоматическое приращение его значения.


## Типы данных
---

В примере 8.3 можно было заметить, что для трех полей таблицы объявлены типы данных **`VARCHAR`**, а для одного — тип данных **`CHAR`**. Термин **`VARCHAR`** означает *VARiable length CHARacter string* — строка символов переменной длины, а команда воспринимает числовое значение, указывающее MySQL максимальную длину, разрешенную для строки, хранящейся в этом поле.

Оба типа данных (и **`CHAR`**, и **`VARCHAR`**) принимают строки текста, ограничивая их длину размером поля. Разница между ними состоит в том, что каждая строка в поле **`CHAR`** имеет указанный размер. Если поместить в него строку меньшего размера, она будет дополнена пробелами. В поле **`VARCHAR`** дополнения текста не происходит; его размер может изменяться таким образом, чтобы в него помещался вставленный текст. Но при использовании поля **`VARCHAR`** требуется идти на небольшие издержки, чтобы отслеживать размер каждого значения. ==Поэтому **`CHAR`** больше подходит для тех случаев, когда данные во всех записях имеют одинаковый размер, а **`VARCHAR`** эффективнее применять, когда размеры могут сильно отличаться друг от друга и возрастать.== Но за это приходится расплачиваться тем, что доступ к данным типа **`VARCHAR`** осуществляется несколько медленнее, чем к данным типа **`CHAR`**.

Еще одной особенностью символьных и текстовых столбцов, играющей важную роль для сегодняшнего глобального интернета, является набор символов. Вполне очевидно, что для английского и русского языков используются разные наборы символов. При создании символьных или текстовых столбцов им можно присвоить тот или иной набор символов.

Тип данных **`VARCHAR`** очень удобен в нашем примере, поскольку позволяет разместить имена авторов и названия различной длины, помогая MySQL планировать размер базы данных и эффективнее осуществлять просмотр и поиск данных. Но есть у него и недостаток: если присвоить строковое значение длиннее позволенного, оно будет усечено до максимальной длины, объявленной в определении таблицы.

Но у поля **`year`** (год) вполне предсказуемые значения, поэтому вместо **`VARCHAR`** для него используется более подходящий тип данных — **`CHAR(4)`**. Параметр 4 позволяет выделить под него 4 байта данных, поддерживающих все года от –999 до 9999; байт содержит 8 бит и может иметь значения от 00000000 до 11111111, что в десятичном представлении означает от 0 до 255.

Можно было бы, конечно, сохранять год и в значении, состоящем из двух цифр, но если данные не утратят своей актуальности и в следующем столетии или показатель лет каким-то образом опять вернется к нулевому значению, то эту проблему нужно решать в первоочередном порядке, поскольку она очень похожа на «проблему 2000 года», из-за которой даты начиная с 1 января 2000 года на многих крупных компьютерных системах могли быть отнесены к 1900 году.

>[!info]
>Тип данных **`YEAR`** не выбран для хранения года в таблице **`classics`** 
>потому,что он поддерживает только 0000 год и диапазон лет с 1901-го по 2155-й. MySQL из соображений эффективности хранит значение года в одном байте, а это значит, что храниться могут только 256 значений, в то время как книги в таблице classics изданы задолго до 1901 года.


### Тип данных `CHAR`
---

В **табл. 8.6** перечислены типы символьных данных `CHAR`. Оба типа предлагают указать параметр, устанавливающий максимальную (или точную) длину строки, которая может быть помещена в поле. Из таблицы следует, что у каждого типа есть присущее ему максимальное значение длины. Для данных типа `VARCHAR` длиной от 0 до 255 байт требуется еще один байт в хранилище, а для данных длиной более 256 байт требуется еще два байта.

**Таблица 8.6.** Типы данных `CHAR`, используемые в MySQL
![[Таблица 8.6. Типы данных CHAR, используемые в MySQL.jpg]]


### Тип данных `BINARY`
---

Тип данных `BINARY` (**табл. 8.7**) ==применяется для хранения строк байтов, не имеющих связанного с ними набора символов.== Например, тип данных `BINARY` можно использовать для хранения изображения в формате GIF.

**Таблица 8.7.** Типы данных `BINARY`, используемые в MySQL
![[Таблица 8.7. Типы данных BINARY, использумые в MySQL.jpg]]


### Типы данных `TEXT`
---

Символьные данные могут быть также сохранены в одном из наборов полей `TEXT`. Различия между этими полями и полями `VARCHAR` невелики:

- до выхода версии 5.0.3 MySQL удалял из полей `VARCHAR` все начальные и замыкающие пробелы;
- в полях типа `TEXT` не может быть исходных значений;
- в столбце `TEXT` MySQL индексирует только первые `n` символов (`n` задается при создании индекса).

==Это означает, что `VARCHAR` является более приемлемым и быстрее обрабатываемым типом данных, если нужно вести поиск по всему содержимому поля.== ==Если поиск никогда не будет вестись более чем в конкретном количестве начальных символов хранящегося в поле значения, то, наверное, нужно остановить свой выбор на типе данных `TEXT`==
(**табл. 8.8**).

**Таблица 8.8.** Типы данных `TEXT`, используемые в MySQL
![[Таблица 8.8. Типы данных TEXT, используеиые в MySQL.jpg]]

==Использование типов данных, имеющих меньший максимальный размер, также повышает эффективность работы, поэтому следует использовать наиболее подходящий известный тип с наименьшим максимальным размером, способный вместить сохраняемую в поле строку.==


### Тип данных `BLOB`
---

Термин **`BLOB`** означает *Binary Large Object* — ==большой двоичный объект, и поэтому, как и можно было предположить, тип данных BLOB больше всего подходит для хранения двоичных данных, превышающих по объему 65 536 байт.== Другим основным отличием `BLOB` от типа данных `BINARY` является то, что для столбцов типа `BLOB` нельзя задавать исходные значения. Типы данных `BLOB` перечислены в **табл. 8.9**.

**Таблица 8.9.** Типы данных `BLOB`, используемые в MySQL
![[Таблица 8.9. Типы данных BLOB, используемые в MySQL.jpg]]


### Числовые типы данных
---

В MySQL поддерживаются различные числовые типы данных — от одиночного байта до чисел с плавающей точкой с удвоенной точностью. Хотя для числового поля можно использовать до 8 байт, лучше все же выбрать поле с самым скромным типом данных, в котором способно уместиться наибольшее из ожидаемых вами значений. Тогда ваша база данных будет небольшой по объему и быстрой по доступу.

В **табл. 8.10** перечислены числовые типы данных, поддерживаемые MySQL, и диапазоны значений, которые могут содержаться в их полях. Если вы не знакомы с терминологией, поясню, что число со *знаком* имеет диапазон возможных значений от отрицательного до нуля и от нуля до положительного значения, а число *без знака* может быть в диапазоне от нуля до положительного значения. Оба они могут иметь одинаковую величину, нужно лишь представить число со знаком, сдвинутым наполовину влево, с одной половиной в отрицательном, а с другой — в положительном диапазоне. Следует заметить, что значения с плавающей точкой (любой точности) могут быть только числами со знаком.

Чтобы указать, какой именно тип данных используется, со знаком или без знака, применяется спецификатор `UNSIGNED`. В следующем примере создается таблица по имени `tablename`, содержащая поле `fieldname` с типом данных `UNSIGNED INTEGER`:
```mysql
CREATE TABLE tablename (fieldname INT UNSIGNED);
```

При создании числового поля можно также передать в качестве параметра необязательное число:
```mysql
CREATE TABLE tablename (fieldname INT(4));
```

**Таблица 8.10.** Числовые типы данных, используемые в MySQL
![[Таблица 8.10. Числовые типы данных, используемые в MySQL.jpg]]

Но при этом следует помнить, что, в отличие от типов данных `BINARY` и `CHAR`, этот параметр не показывает количество байтов, выделяемых под хранение. Может быть, это противоречит интуитивному восприятию, но на самом деле это число обозначает отображаемую ширину данных в поле при его извлечении. Оно часто используется вместе со спецификатором `ZEROFILL`:
```mysql
CREATE TABLE tablename (fieldname INT(4) ZEROFILL);
```

Этот спецификатор указывает на то, что все числа шириной меньше четырех символов дополняются одним или несколькими нулями, для того чтобы ширина отображаемого поля составляла четыре символа. Если поле уже занимает четыре и более символа, дополнение не производится.


### Типы данных `DATE` и `TIME`
---

**В табл. 8.11** показана еще одна важная категория типов данных, поддерживаемая MySQL, которая относится к дате и времени.

**Таблица 8.11.** Типы данных `DATE` и `TIME`, используемые в MySQL
![[Таблица 8.11. Типы данных DATE и TIME, используемые в MySQL.jpg]]

Значения, имеющие типы данных `DATETIME` и `TIMESTAMP`, отображаются одинаково. Основное различие в том, что у `TIMESTAMP` слишком узкий диапазон (от 1970 до 2037 года), а в `DATETIME` может храниться практически любая нужная дата, если только вы не интересуетесь античной историей или научной фантастикой.

==Но `TIMESTAMP` также полезен, потому что, используя его, можно позволить MySQL установить для вас нужное значение.== Если при добавлении строки не задавать значение для поля с этим типом данных, то в него автоматически будет вставлено текущее время. Можно также заставить MySQL обновлять столбец с типом данных `TIMESTAMP` при каждом изменении строки.


### Атрибут `AUTO_INCREMENT`
---

Иногда нужно обеспечить уникальность каждой строки, имеющейся в базе данных. В вашей программе это можно сделать за счет тщательной проверки вводимых данных и обеспечения их различия хотя бы в одном из значений в любых двух строках. Но такой подход не защищен от ошибок и работает только в конкретных обстоятельствах. Например, в таблице фамилия одного и того же автора может появляться несколько раз. Точно так же, скорее всего, будет повторяться год издания и т. д. В таком случае гарантировать отсутствие продублированных строк будет довольно трудно.

В общем виде эта проблема решается за счет специально выделенного для этой цели дополнительного столбца. Вскоре мы рассмотрим использование ISBN (International Standard Book Number — международный стандартный книжный номер) издания, но сначала нужно представить вам тип данных с автоприращением — `AUTO_INCREMENT`.

В соответствии с названием столбца, которому назначен этот тип данных, его содержимому будет устанавливаться значение на единицу большее, чем значение записи в этом же столбце в предыдущей вставленной строке. В **примере 8.5** показано, как нужно добавлять новый столбец по имени id к таблице classics и придавать ему свойства автоприращения.

**Пример 8.5.** Добавление столбца `id` с автоприращением
```mysql
ALTER TABLE classics ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT KEY;
```

Здесь представлена команда `ALTER`, очень похожая на команду `CREATE`. ==Команда `ALTER` работает с уже существующей таблицей и может добавлять, изменять или удалять столбцы.== В нашем примере добавляется столбец с именем id, имеющий следующие характеристики.

- **`INT UNSIGNED`** — делает столбец способным принять целое число, достаточно большое для того, чтобы в таблице могло храниться более 4 млрд записей.
- **`NOT NULL`** — обеспечивает наличие значения в каждой записи столбца. Многие программисты используют его в поле `NULL`, чтобы показать отсутствие в нем какого-либо значения. Но тогда могут появляться дубликаты, противоречащие самому смыслу существования этого столбца. Поэтому появление в нем значения `NULL` запрещено.
- **`AUTO_INCREMENT`** — заставляет MySQL установить для этого столбца уникальное значение в каждой строке, как было описано ранее. Фактически мы не управляем значением, которое будет появляться в каждой строке этого столбца, но это и не нужно: все, о чем мы беспокоимся, — гарантия уникальности этого значения.
- **`KEY`** — столбец с автоприращением полезно использовать в качестве ключа, поскольку вы будете стремиться искать строки на основе значений этого столбца. Пояснения будут даны в разделе «Индексы» далее.

Теперь каждая запись будет иметь уникальное число в столбце `id`, для первой записи это начальное число 1, а счет других записей будет вестись по нарастающей. Как только будет вставлена новая строка, в ее столбец `id` будет автоматически записано следующее по порядку число.

Этот столбец можно не добавлять после создания таблицы, а сразу включить в нее, слегка изменив формат команды `CREATE`. В данном случае команда из **примера 8.3** должна быть заменена командой из **примера 8.6.** Обратите особое внимание на ее последнюю строку.

**Пример 8.6.** Добавление столбца `id` с автоприращением при создании таблицы
```mysql
mysql> CREATE TABLE classics (
    ->   author VARCHAR(128),
    ->   title VARCHAR(128),
    ->   type VARCHAR(16),
    ->   year CHAR(4),
    ->   id INT UNSIGNED NOT NULL AUTO_INCREMENT KEY) ENGINE InnoDB;
```

Если хочется проверить, был ли добавлен столбец, нужно посмотреть имеющиеся в таблице столбцы и типы данных, воспользовавшись следующей командой: `DESCRIBE classics`;

Теперь, когда мы закончили изучение этого типа данных, столбец `id` нам больше не нужен, поэтому если вы его создали, воспользовавшись командой из **примера 8.5**, его нужно удалить, введя команду из **примера 8.7.**

**Пример 8.7.** Удаление столбца `id`
```mysql
ALTER TABLE classics DROP id;
```


### Добавление данных к таблице
---

Для добавления данных к таблице предназначена команда **`INSERT`**. Рассмотрим ее в действии, заполнив таблицу `classics` данными из **табл. 8.1**, многократно используя одну и ту же форму команды `INSERT` (**пример 8.8**).

**Пример 8.8.** Заполнение таблицы `classics`
```mysql
INSERT INTO classics(author, title, type, year)
  VALUES('Mark Twain','The Adventures of Tom Sawyer','Fiction','1876');
INSERT INTO classics(author, title, type, year)
  VALUES('Jane Austen','Pride and Prejudice','Fiction','1811');
INSERT INTO classics(author, title, type, year)
  VALUES('Charles Darwin','The Origin of Species','NonFiction','1856');
INSERT INTO classics(author, title, type, year)
  VALUES('Charles Dickens','The Old Curiosity Shop','Fiction','1841');
INSERT INTO classics(author, title, type, year)
  VALUES('William Shakespeare','Romeo and Juliet','Play','1594');
```

После каждой второй строки вы должны увидеть сообщение об успешной обработке запроса — `Query OK`. Как только будут введены все строки, наберите следующую команду, которая отобразит содержимое таблицы:

```mysql
SELECT * FROM classics;
```

Результат должен быть похож на тот, что показан на рис. 8.4.

Сейчас не стоит обращать внимания на команду `SELECT`, ее очередь наступит в разделе «Запросы к базе данных MySQL» далее в этой главе. Достаточно сказать, что в таком виде она отображает все только что введенные данные.

Также не стоит волноваться, если вы увидите возвращаемые результаты в другом порядке, — это нормально, потому что на данный момент порядок не определен. Позже в этой главе мы узнаем, как использовать `ORDER BY`, чтобы выбрать порядок возврата результатов, но сейчас они могут отображаться в любом порядке.

![[Рис. 8.4. Заполнение таблицы classics и просмотр ее содержимого.jpg]]
>    **Рис. 8.4.** Заполнение таблицы classics и просмотр ее содержимого

Теперь вернемся назад и посмотрим, как используется команда `INSERT`. Ее первая часть, `INSERT INTO classics`, сообщает MySQL, куда нужно вставлять следующие за ней данные. Затем в круглых скобках перечисляются четыре имени столбцов: `author`, `title`, `type` и `year`, которые отделяются друг от друга запятыми. Таким образом MySQL сообщается, что именно в эти четыре поля будут вставляться данные.

Во второй строке каждой команды `INSERT` содержится ключевое слово `VALUES`, за которым следуют четыре строковых значения, взятых в кавычки и отделенных друг от друга запятыми. Они обеспечивают MySQL теми четырьмя значениями, которые будут вставлены в четыре ранее указанных столбца. (Как и во всех остальных примерах, разбиение команды на строки было моим собственным решением, придерживаться которого не обязательно.)

Каждый элемент данных будет вставлен по порядку в соответствующие столбцы. Если порядок перечисления столбцов и данных будет случайно перепутан, данные попадут не в те столбцы. А количество указанных столбцов должно соответствовать количеству элементов данных. (Есть более безопасные способы использования `INSERT`, которые вскоре будут рассмотрены).


### Переименование таблиц
---

Переименование таблицы, как и любые другие изменения ее структуры или метаданных, осуществляется посредством команды `ALTER`. Поэтому чтобы, к примеру, изменить имя таблицы `classics` на `pre1900`, воспользуйтесь следующей командой:
```mysql
ALTER TABLE classics RENAME pre1900;
```

Если применить эту команду, то потом, чтобы без изменений работали все последующие примеры этой главы, вам придется вернуть таблице ее прежнее имя, для чего нужно будет ввести следующую команду:
```mysql
ALTER TABLE pre1900 RENAME classics;
```


### Изменение типа данных столбца
---

Для изменения типа данных столбца также используется команда `ALTER`, но в этом случае вместе с ней применяется ключевое слово `MODIFY`. Поэтому для изменения типа данных столбца year с `CHAR(4)` на `SMALLINT` (для которого потребуется только 2 байта памяти, что способствует экономии дискового пространства) нужно ввести следующую команду:
```mysql
ALTER TABLE classics MODIFY year SMALLINT;
```

После этого, если для MySQL есть смысл конвертировать тип данных, система автоматически изменит данные, сохраняя их значение. В этом случае она заменит каждое строковое значение сопоставимым с ним целым числом, пока строку можно будет распознать как отображение целого числа.


### Добавление нового столбца
---

Предположим, что таблица создана и заполнена большим объемом данных и тут выяснилось, что нужен еще один столбец. Не стоит расстраиваться. Посмотрите, как можно добавить к таблице новый столбец `pages`, который будет использоваться для хранения количества страниц, имеющихся в книге:
```mysql
ALTER TABLE classics ADD pages SMALLINT UNSIGNED;
```

Эта команда добавляет новый столбец с именем `pages`, в котором используется тип данных `UNSIGNED SMALLINT`, подходящий для хранения значений вплоть до 65 535. Этого наверняка более чем достаточно для любой когда-либо изданной книги!

И если запросить у MySQL описание обновленной таблицы, воспользовавшись показанной далее командой DESCRIBE, то можно будет увидеть внесенные в нее изменения (**рис. 8.5**).

```mysql
DESCRIBE classics;
```
![[Рис. 8.5. Добавление нового столбца pages и просмотра таблицы.jpg]]
   >   **Рис. 8.5.** Добавление нового столбца pages и просмотр таблицы



### Переименования столбца
---

Посмотрев еще раз на **рис. 8.5**, можно заметить, что наличие в таблице столбца `type` приводит к путанице, поскольку такое же имя используется MySQL для идентификации типа данных. Но это не проблема — изменим имя этого столбца на `category`:
```mysql
ALTER TABLE classics CHANGE type category VARCHAR(16);
```

Обратите внимание на добавление `VARCHAR(16)` в конце этой команды. Это связано с тем, что ключевое слово `CHANGE` требует указания типа данных даже в том случае, если вы не собираетесь его изменять, и `VARCHAR(16)` — тот самый тип данных, который был указан при создании столбца `type`.


### Удаление столбца
---

Поразмыслив, можно прийти к выводу, что столбец `pages`, в котором хранится количество страниц, не представляет для этой базы данных особой ценности, поэтому его можно удалить, используя ключевое слово `DROP`.
```mysql
ALTER TABLE classics DROP pages;
```

>[!danger]
>Учтите, что ключевое слово DROP нужно применять с особой осторожностью, поскольку его действие носит необратимый характер и по недоразумению можно удалить целые таблицы (и даже базы данных)!


### Удаление таблицы
---

Удалить таблицу очень просто. Но поскольку я не хочу заставлять вас заново вводить все данные в таблицу `classics`, мы ее удалять не станем. Вместо этого просто создадим новую таблицу, проверим факт ее существования, а затем удалим ее, набрав команду, приведенную в 
**примере 8.9.** Результат выполнения всех четырех команд показан на
**рис. 8.6**.

**Пример 8.9.** Создание, просмотр и удаление таблицы
```mysql
CREATE TABLE disposable(trash INT);
DESCRIBE disposable;
DROP TABLE disposable;
SHOW tables;
```
![[Рис. 8.6. Создание, просмотр и удаление таблицы.jpg]]
          **Рис. 8.6.** Создание, просмотр и удаление таблицы


## Индексы
---

В данный момент у нас есть действующая таблица `classics`, в которой можно будет без труда, пользуясь средствами MySQL, отыскать нужную информацию. Но все так просто лишь до тех пор, пока она не разрастется до пары сотен строк. Тогда с каждой добавленной строкой доступ к базе данных будет становиться все медленнее и медленнее, поскольку MySQL при обработке запроса придется вести поиск в каждой строке. Это похоже на поиск нужной информации в каждой книге, имеющейся в библиотеке.

Разумеется, вам не придется вести поиск в библиотеках подобным образом, поскольку в них есть либо обычная картотека, либо, что более вероятно, собственная база данных. То же самое относится и к MySQL, поскольку ценой небольших затрат оперативной памяти и дискового пространства можно создать «картотеку» для таблицы, которая будет использоваться MySQL для выполнения мгновенного поиска.


### Создание индекса
---

==Возможности быстрого поиска можно добиться путем добавления индекса либо при создании таблицы, либо в любое время впоследствии.== Но сделать это не так-то просто. Существуют, к примеру, различные типы индексов, такие как `INDEX`, `PRIMARY KEY` или `FULLTEXT`. Кроме того, нужно решить, каким столбцам нужен индекс, а для этого нужно спрогнозировать, по каким данным каждого из столбцов будет осуществляться поиск. Индексы можно также усложнять, комбинируя в одном индексе данные из нескольких столбцов. И даже когда вы все это поймете, у вас будет возможность сократить размер индекса за счет ограничения объема данных каждого индексируемого столбца.

Если представить себе поисковые операции применительно к таблице 
`classics`, становится ясно, что поиск может осуществляться во всех столбцах. Но если бы не был удален столбец `pages`, созданный в пункте «Добавление нового столбца» выше, то он, наверное, не понадобился бы для индекса, поскольку большинство людей вряд ли стали бы искать книги по количеству страниц. Давайте все же продолжим и добавим индекс к каждому столбцу, воспользовавшись командами, приведенными в 
**примере 8.10**.

**Пример 8.10.** Добавление индексов к таблице `classics`
```mysql
ALTER TABLE classics ADD INDEX(author(20));
ALTER TABLE classics ADD INDEX(title(20));
ALTER TABLE classics ADD INDEX(category(4));
ALTER TABLE classics ADD INDEX(year);
DESCRIBE classics;
```
Вывод таблицы после внесение изменений.
![[Вывод таблицы.jpg]]

Первые две команды создают индексы для столбцов авторов и названий — `author` и `title`, ограничивая каждый индекс только первыми 20 символами.

Например, когда MySQL индексирует название:
```mysql
The Adventures of Tom Sawyer
```

на самом деле в индексе будут сохранены только первые 20 символов:
```mysql
The Adventures of To
```

Это делается для сокращения размера индекса и для оптимизации скорости доступа к базе данных. Я выбрал 20 символов, поскольку их должно быть достаточно для обеспечения уникальности большинства строк, встречающихся в данных столбцах. Если MySQL обнаружит два индекса с одинаковым содержимым, ей нужно будет понапрасну потратить время на обращение к самой таблице и на проверку проиндексированного столбца, для того чтобы определить, какая именно строка действительно соответствует условиям поиска.

Что касается столбца категории — `category`, то на данный момент, чтобы идентифицировать уникальность строки, достаточно только первого символа (**`F`** для **`Fiction`**, **`N`** для **`Nonfiction`** и **`P`** для **`Play`**), но я выбрал индекс из четырех символов, чтобы дать возможность в будущем вводить такие категории, у которых первые три символа могут быть одинаковыми. Если позже набор категорий усложнится еще больше, этот столбец можно будет переиндексировать. И наконец, я не стал задавать ограничения на индекс столбца года издания — **`year`**, поскольку он имеет четко определенную длину в четыре символа.

Результат ввода этих команд (и команды **`DESCRIBE`**, позволяющей убедиться в том, что они работают) можно увидеть на **рис. 8.7**, который показывает наличие ключа **`MUL`** для каждого столбца. Это означает, что в этом столбце может многократно присутствовать одно и то же значение, что, собственно, нам и нужно, поскольку имена авторов могут встречаться многократно, одни и те же названия книг могут использоваться множеством авторов, и т. д.

![[Рис. 8.7. Добавление индексов к таблице classics.jpg]]
   >   **Рис. 8.7.** Добавление индексов к таблице **`classics`**
   

### Использование команды `CREATE INDEX`
---

Индекс можно добавить не только командой `ALTER TABLE`, но и командой `CREATE INDEX`. Эти две команды являются равнозначными, за исключением того, что `CREATE INDEX` не может использоваться для создания индекса типа первичного ключа — `PRIMARY KEY` (см. далее пункт «Первичные ключи»). Формат этой команды показан во второй строке **примера 8.11**.

**Пример 8.11.** Эти две команды эквивалентны
```mysql
ALTER TABLE classics ADD INDEX(author(20));
CREATE INDEX author ON classics (author(20));
```


### Добавление индексов при создании таблиц
---

Чтобы добавить индекс, не нужно выжидать какое-то время после создания таблицы. Это может отнять много времени, поскольку добавление индекса к большой таблице — длительный процесс. Поэтому рассмотрим команду, создающую таблицу `classics` с уже имеющимися индексами.

**Пример 8.12** является переработкой **примера 8.3**, в котором одновременно с таблицами создаются индексы. Учтите, что для включения всех изменений, выполненных в данной главе, в этой версии используется новое имя столбца `category` вместо прежнего имени `type`, а для столбца `year` указан тип данных `SMALLINT`, а не `CHAR(4)`. При желании попробовать эту команду в работе без предварительного удаления текущей таблицы `classics` замените слово `classics` в первой строке каким-нибудь другим словом, например `classics1`, а после завершения работы удалите таблицу `classics1`.

**Пример 8.12.** Создание таблицы `classics` с индексами
```mysql
CREATE TABLE classics (
  author VARCHAR(128),
  title VARCHAR(128),
  category VARCHAR(16),
  year SMALLINT,
  INDEX(author(20)),
  INDEX(title(20)),
  INDEX(category(4)),
  INDEX(year)) ENGINE InnoDB;
```


### Первичные ключи
---

В данный момент у нас создана таблица `classics` и за счет добавления индексов обеспечен быстрый поиск, но кое-что все же упущено. Можно вести поиск по всем имеющимся в таблице изданиям, но нет единого уникального ключа для каждого издания, обеспечивающего мгновенный доступ к строке. Важность наличия ключа с уникальным значением для каждой строки проявится, когда мы станем комбинировать данные из разных таблиц.

В пункте «Атрибут `AUTO_INCREMENT`» подраздела «Типы данных» предыдущего раздела, где рассматривался создаваемый столбец `id` с автоприращением, было сказано, что он может быть использован в качестве первичного ключа для этой таблицы. Но я захотел возложить эту задачу на более подходящий столбец: признанный во всем мире номер ISBN.

Поэтому продолжим работу с таблицей и создадим новый столбец для этого ключа. Теперь, помня о том, что номер ISBN состоит из 13 символов, можно решить, что с этой задачей справится следующая команда:
```mysql
ALTER TABLE classics ADD isbn CHAR(13) PRIMARY KEY;
```

Но это не так. Если запустить эту команду на выполнение, будет получено сообщение об ошибке, похожей на дубликат записи для ключа `1: Duplicate entry`. Причина в том, что таблица уже заполнена данными, а эта команда пытается добавить столбец со значением `NULL` к каждой строке, что запрещено, поскольку все столбцы, использующие первичный ключ, должны иметь уникальное значение. Если бы таблица была пуста, то эта команда была бы выполнена без проблем, как и при добавлении первичного ключа сразу же после создания таблицы.

В сложившейся ситуации нужно немного схитрить: создать новый столбец без индекса, заполнить его данными, а затем добавить индекс ретроспективно, воспользовавшись командой из **примера 8.13**. К счастью, в этом наборе данных каждый год имеет уникальное значение, поэтому для идентификации каждой обновляемой строки можно воспользоваться столбцом year. Учтите, что в этом примере применяется команда `UPDATE` и ключевое слово `WHERE`, которые более подробно будут рассмотрены в подразделе «Создание запросов к базе данных MySQL» далее.

**Пример 8.13.** Заполнение столбца `isbn` данными и использование
первичного ключа
```mysql
ALTER TABLE classics ADD isbn CHAR(13);
UPDATE classics SET isbn='9781598184891' WHERE year='1876';
UPDATE classics SET isbn='9780582506206' WHERE year='1811';
UPDATE classics SET isbn='9780517123201' WHERE year='1856';
UPDATE classics SET isbn='9780099533474' WHERE year='1841';
UPDATE classics SET isbn='9780192814968' WHERE year='1594';
ALTER TABLE classics ADD PRIMARY KEY(isbn);
DESCRIBE classics;
```

После ввода этих команд будет получен результат, похожий на копию экрана, показанную на **рис. 8.8**. Обратите внимание на то, что в синтаксисе команды `ALTER TABLE` ключевое слово `INDEX` заменено ключевыми словами `PRIMARY KEY` (сравните **примеры 8.10 и 8.13**).

Чтобы создать первичный ключ при создании таблицы `classics`, можно воспользоваться командой, показанной в **примере 8.14**. И в этом случае, если вы хотите испробовать эту команду в работе, нужно заменить имя `classics` в строке 1 каким-нибудь другим, а затем удалить проверочную таблицу.

![[Рис. 8.8. Ретроспективное добавление первичного ключа к таблице classics.jpg]]
> **Рис. 8.8.** Ретроспективное добавление первичного ключа к таблице `classics`

**Пример 8.14.** Создание таблицы `classics` с первичным ключом
```mysql
CREATE TABLE classics (
  author VARCHAR(128),
  title VARCHAR(128),
  category VARCHAR(16),
  year SMALLINT,
  isbn CHAR(13),
  INDEX(author(20)),
  INDEX(title(20)),
  INDEX(category(4)),
  INDEX(year),
  PRIMARY KEY (isbn)) ENGINE InnoDB;
```


### Создание индекса `FULLTEXT`
---

==В отличие от обычного индекса имеющийся в MySQL индекс `FULLTEXT` позволяет осуществлять сверхбыстрый поиск целых столбцов текста.== Он сохраняет каждое слово каждой строки данных в специальном индексе, в котором можно вести поиск, используя «естественный язык» наподобие того, что применяется в поисковом механизме.

>[!info]
>Вообще-то утверждение о том, что система MySQL хранит все слова в индексе `FULLTEXT`, не вполне соответствует действительности, поскольку в ней имеется встроенный список более чем из 500 слов, которые она предпочитает игнорировать в силу их широкой распространенности и практической бесполезности при любом поиске. Этот список, называемый стоповыми словами — stopwords, включает слова the, as, is, of и т. д. Список помогает MySQL работать при `FULLTEXT`-поиске намного быстрее и не раздувать размеры базы данных.

Рассмотрим некоторые особенности индексов `FULLTEXT`, о которых нужно знать.

- С выходом MySQL 5.6 появилась возможность использования индексов FULLTEXT с таблицами InnoDB, но прежде эти индексы могли применяться только с таблицами типа MyISAM. Если нужно привести таблицу к типу MyISAM, можно применить команду MySQL: 
  `ALTER TABLE tablename ENGINE = MyISAM;`
- Индексы `FULLTEXT` могут создаваться только для столбцов с типами данных `CHAR`, `VARCHAR` и `TEXT`.
- Определение индекса `FULLTEXT` может быть дано в инструкции `CREATE` `TABLE` при создании таблицы или добавлено позже с использованием инструкции `ALTER TABLE` (или `CREATE INDEX`).
- *Намного* быстрее будет загрузить большие наборы данных в таблицу, не имеющую индекса `FULLTEXT`, а затем создать индекс.

Чтобы создать индекс `FULLTEXT`, примените его к одной или нескольким записям, как в **примере 8.15**, в котором индекс `FULLTEXT` добавляется к двум столбцам `author` и `title`, принадлежащим таблице `classics` (этот индекс является дополнением к тем, что уже были созданы, и не влияет на их работу).

**Пример 8.15.** Добавление индекса `FULLTEXT` к таблице `classics`
```mysql
ALTER TABLE classics ADD FULLTEXT(author,title);
```

Теперь в этой паре столбцов можно вести поиск с использованием индекса `FULLTEXT`. Такая возможность могла бы проявиться в полную силу, если бы вы могли теперь ввести весь текст этих книг в базу данных (учитывая, что они не защищены авторскими правами), тогда они были бы полностью доступны для поиска. Поисковые операции с использованием индекса FULLTEXT рассмотрены далее в пункте «MATCH...AGAINST» подраздела «Создание запросов к базе данных MySQL».

>[!info]
>Если система MySQL станет при доступе к вашей базе данных работать медленнее, чем вы от нее ожидали, то проблема чаще всего заключается в ваших индексах. Либо у вас нет индекса там, где он нужен, либо индексы составлены неоптимальным образом. Зачастую данная проблема решается за счет тонкой настройки индексов таблиц. Производительность не входит в тематику этой книги, но в [[Освоение MySQL]] я дам несколько подсказок, чтобы вы знали, что именно нужно искать.


## Создание запросов к базе данных MySQL
---

Итак, мы создали базу данных MySQL и таблицы, заполнили их данными и добавили к ним индексы, чтобы ускорить поиск. Теперь настало время посмотреть, как именно ведется этот поиск и какие для этого имеются команды и спецификаторы.


### `SELECT`
---

На **рис. 8.4** уже было показано, что команда **`SELECT`** используется для извлечения данных из таблицы. В том разделе я воспользовался ее наипростейшей формой для выбора всех данных и их отображения, что вам вряд ли когда-нибудь пригодится, разве что для просмотра самых маленьких таблиц, поскольку все данные будут прокручиваться на экране и скрываться в нечитаемой области. В качестве альтернативного варианта, на компьютерах под управлением Unix/ Linux, MySQL можно заставить выполнить постраничный вывод данных на величину экрана, запустив следующую команду:

`pager less;`

Эта команда направит весь вывод на экран через канал программы **less**. Чтобы восстановить стандартный вывод и выключить разбиение на страницы, можно запустить следующую команду:

`nopager;`

А теперь рассмотрим команду **`SELECT`** более подробно.

Ее основной синтаксис имеет следующий вид:

```mysql
SELECT что_нибудь FROM имя_таблицы;
```

Этим **что-нибудь**, как вы уже видели, может быть символ звездочки (`*`), означающий «каждый столбец», вместо него можно указать какие-нибудь конкретные столбцы. В **примере 8.16** показано, как выбрать только автора и название (`author` и `title`) и только название и ISBN. Результат выполнения этих команд показан на **рис. 8.9**.

![[Рис. 8.9. Вывод, полученный в результате выполнения двух разных инструкций SELECT.jpg]]
**Рис. 8.9**. Вывод, полученный в результате выполнения двух разных                             инструкций `SELECT`

**Пример 8.16.** Две разные инструкции
```mysql
SELECT author,title FROM classics;
SELECT title,isbn FROM classics;
```


### `SELECT COUNT`
---

Другой заменой параметра **что-нибудь** является функция `COUNT`, которая может быть использована множеством способов. В **примере 8.17** она отображает количество строк в таблице за счет передачи ей в качестве параметра символа звездочки (`*`), означающего «все строки». В соответствии с вашими ожиданиями будет возвращено число 5, поскольку в таблицу внесены сведения о пяти книгах.

**Пример 8.17.** Подсчет количества строк
```mysql
mysql> SELECT COUNT(*) FROM classics;
+----------+
| COUNT(*) |
+----------+
|        5 |
+----------+
1 row in set (0.06 sec)
```


### `SELECT DISTINCT`
---

Спецификатор `DISTINCT` (и его напарник `DISTINCTROW`) позволяет исключать множество записей, имеющих одинаковые данные. Предположим, к примеру, что вам нужно получить список всех авторов, фигурирующих в таблице.

Если просто выбрать столбец `author` из таблицы, содержащей несколько книг одного и того же автора, то будет отображен длинный список с одинаковыми именами авторов, повторяющимися снова и снова. Но за счет добавления ключевого слова `DISTINCT` можно показать каждого автора всего лишь один раз.

Проверим этот спецификатор, добавив еще одну строку, в которой повторяется один из уже имеющихся авторов (**пример 8.18**).

**Пример 8.18.** Дублирование данных
```mysql
INSERT INTO classics(author, title, category, year, isbn)
  VALUES('Charles Dickens','Little Dorrit','Fiction','1857', '9780141439969');
```

Теперь, когда Чарльз Диккенс появляется в таблице дважды, мы можем сравнить результаты использования команды `SELECT` со спецификатором `DISTINCT` и без него. В **примере 8.19** и на **рис. 8.10** показано, что при вводе простой команды `SELECT` Диккенс будет показан дважды, а команда со спецификатором `DISTINCT` выводит его только один раз.

![[Рис. 8.10. Выбор данных с использованием DISTINCT и без него.jpg]]
   >**Рис. 8.10.** Выбор данных с использованием DISTINCT и без него

### `DELETE`
---

Когда нужно удалить строку из таблицы, применяется команда `DELETE`. Ее синтаксис похож на синтаксис команды `SELECT`, он позволяет сузить диапазон удаляемой информации до конкретной строки или строк путем использования таких спецификаторов, как `WHERE` и `LIMIT`.

Теперь, если вы вводили команду, показанную в **примере 8.18**, и изучали работу спецификатора `DISTINCT`, нужно удалить Little Dorrit путем ввода команды, показанной в **примере 8.20**.

**Пример 8.20.** Удаление новой записи
```mysql
DELETE FROM classics WHERE title='Little Dorrit';
```

В этом примере команда `DELETE` выдается для всех строк, в столбце `title` которых содержится точное строковое значение Little Dorrit.

Ключевое слово `WHERE` обладает большими возможностями, и очень важно, чтобы оно было набрано правильно. Ошибка может навести команду не на те строки (или вообще ни к чему не привести в том случае, если условию `WHERE` не будет найдено ни одного соответствия). Поэтому теперь нужно уделить немного внимания этому условию, играющему очень важную роль в языке SQL.


### `WHERE`
---

Ключевое слово WHERE позволяет сузить диапазон действия запроса, возвращая только те данные, в отношении которых конкретное выражение возвращает истинное значение. За счет использования оператора равенства `=` код в **примере 8.20** возвращает только те строки, в которых значение столбца title в точности соответствует строке Little Dorrit. В **примере 8.21** показаны еще два фрагмента, в которых WHERE используется с оператором `=`.

**Пример 8.21.** Использование ключевого слова `WHERE`
```mysql
SELECT author,title FROM classics WHERE author="Mark Twain";
SELECT author,title FROM classics WHERE isbn="9781598184891";
```

Применительно к нашей таблице эти две команды отобразят один и тот же результат. Но мы можем без особого труда добавить еще несколько книг Марка Твена, и тогда команда в первой строке отобразит все названия книг, принадлежащих его перу, а команда во второй строке — прежний результат (потому что, как мы знаем, ISBN имеет уникальное значение) — **The Adventures of Tom Sawyer**. Иными словами, поисковые операции, использующие уникальный ключ, более предсказуемы, и новые доказательства этого вы увидите позже, при рассмотрении роли уникальных и первичных ключей.

При проведении поисковых операций можно также осуществлять проверку на соответствие шаблону, для чего применяется спецификатор **`LIKE`**, позволяющий вести поиск в разных частях строк. Этот спецификатор должен использоваться с символом **`%`** до или после некоторого текста. Если его поместить до текста, это будет означать «что-нибудь до», а если после текста — «что-нибудь после». В **примере 8.22** показаны три разных запроса, один из которых предназначен для начала строки, другой — для конца, а третий — для любого места в строке. Результат выполнения этих команд приведен на **рис. 8.11.**

**Пример 8.22.** Использование спецификатора `LIKE`
```mysql
SELECT author,title FROM classics WHERE author LIKE "Charles%";
SELECT author,title FROM classics WHERE title LIKE "%Species";
SELECT author,title FROM classics WHERE title LIKE "%and%";
```
![[Рис. 8.11. Использование ключевого слова WHERE со спецификатором LIKE.jpg]]
  **Рис. 8.11.** Использование ключевого слова `WHERE` со спецификатором `LIKE`

Первая команда выведет книги, принадлежащие перу как Чарльза Дарвина, так и Чарльза Диккенса, потому что спецификатор `LIKE` был настроен на возвращение всего соответствующего строке `Charles`, за которой следует любой другой текст.

Затем будет возвращена информация о книге The Origin of Species, потому что есть только одна строка, столбец которой заканчивается строковым значением `Species`. И на последний запрос будет возвращена информация о книгах Pride and Prejudice и Romeo and Juliet, потому что обе записи соответствуют запросу строкового значения and в любом месте столбца.

Символ `%` будет также соответствовать пустому месту в той позиции, которую он занимает. Иными словами, он может соответствовать пустой строке.


### `LIMIT`
---

Спецификатор `LIMIT` позволяет выбрать количество выводимых в запросе строк и место, с которого таблица начнет их возвращать. Когда передается один параметр, он указывает MySQL начать действие спецификатора с верхней части результатов и вернуть только то количество строк, которое задано этим параметром. Если передать спецификатору два параметра, то первый укажет смещение относительно начала результатов, которое MySQL должна учесть при их отображении, а второй укажет, сколько строк нужно вывести.

Можно представить, что первый параметр сообщает: «Нужно пропустить это количество результатов, ведя счет сверху».

В **пример 8.23** включены три команды. Первая возвращает первые три строки из таблицы. Вторая возвращает две строки, начиная с позиции 1 (пропуская первую строку). А последняя возвращает одну строку, начинающуюся с позиции 3 (пропуская первые три строки). Результаты выполнения всех трех команд показаны на **рис. 8.12.**

**Пример 8.23.** Ограничение количества возвращаемых результатов
```mysql
SELECT author,title FROM classics LIMIT 3;
SELECT author,title FROM classics LIMIT 1,2;
SELECT author,title FROM classics LIMIT 3,1;
```

>[!info]
>Ключевое слово LIMIT требует особого внимания, поскольку смещение начинается с нулевой позиции, а количество возвращаемых строк — с единицы. Поэтому спецификатор LIMIT 1,3 означает возвращение трех строк, начиная со второй строки. Первый аргумент можно рассматривать как указание на то, сколько строк нужно пропустить, следовательно, говоря простым языком, инструкция должна звучать так: «Возвратить 3 строки, пропустив первые строки в количестве 1».

![[Рис. 8.12. Ограничение диапазона выводимых строк с помощью спецификатора LIMIT.jpg]]
>Рис. 8.12. Ограничение диапазона выводимых строк с помощью                               спецификатора `LIMIT`


### `MATCH...AGAINST`
---

Конструкция `MATCH`…`AGAINST` может быть применена к столбцу, для которого был создан индекс `FULLTEXT` (см. выше пункт «Создание индекса `FULLTEXT`»). Используя эту конструкцию, можно вести поиск, применяя в качестве критерия элементы обычного языка как при работе с поисковыми механизмами интернета. В отличие от конструкций `WHERE`…`=` или `WHERE`…``LIKE``, конструкция `MATCH`… `AGAINST` позволяет вводить в поисковый запрос несколько слов и проверять на их наличие все слова в столбцах, имеющих индекс `FULLTEXT`. Индексы `FULLTEXT` нечувствительны к регистру букв, поэтому неважно, какой именно регистр используется в ваших запросах.

Предположим, что вы добавили индекс `FULLTEXT` к столбцам `author` и `title` и ввели три запроса, показанные в **примере 8.24**. Первый из них требует вернуть любые строки, в которых содержится слово and. Если вы используете механизм хранения `MyISAM`, то поскольку в нем and является стоповым словом, MySQL его проигнорирует и запрос всегда будет возвращать пустой набор независимо от того, что хранится в столбце. Если же вы используете InnoDB, and является разрешенным словом. Второй запрос требует вернуть любые строки, содержащие в любом месте и в любом порядке оба слова: `curiosity` и `shop`. Третий запрос инициирует тот же вид поиска для слов `tom` и `sawyer`. Результаты выполнения этих запросов показаны на **рис. 8.13.**

**Пример 8.24.** Использование конструкции `MATCH`…`AGAINST` с индексами `FULLTEXT`
```mysql
SELECT author,title FROM classics
  WHERE MATCH(author,title) AGAINST('and');

SELECT author,title FROM classics
  WHERE MATCH(author,title) AGAINST('curiosity shop');

SELECT author,title FROM classics
  WHERE MATCH(author,title) AGAINST('tom sawyer');
```
![[Рис. 8.13. Использование конструкции MATCH...AGAINST в индексе FULLTEXT.jpg]]


### `MATCH...AGAINST` в булевом режиме
---

При желании придать своим запросам с конструкцией `MATCH...AGAINST` более широкие возможности нужно воспользоваться булевым режимом. Это изменение выражается в том, что стандартный запрос по индексу `FULLTEXT` ведет поиск любой комбинации искомых слов, не требуя наличия всех этих слов в тексте. Наличие отдельного слова в столбце приводит к тому, что поисковая операция возвращает строку.

Булев режим позволяет также ставить впереди искомых слов знак **`+`** или **`–`**, чтобы показать, что они должны быть включены или исключены. Если обычный булев режим требует «искать присутствие любого из этих слов», то знак «плюс» означает, что «это слово обязательно должно присутствовать, иначе строку возвращать не нужно». Знак «минус» означает, что «этого слова быть не должно, а если оно присутствует, то строку возвращать не нужно».

В **примере 8.25** показаны два запроса, использующие булев режим. Первый запрос требует вернуть все строки, в которых содержится слово `Charles` и нет слова `species`. Во втором запросе используются двойные кавычки, чтобы потребовать вернуть все строки, включающие в себя фразу `origin of`. На **рис. 8.14** показаны результаты выполнения этих запросов.

**Пример 8.25.** Использование `MATCH...AGAINST` в булевом режиме
```mysql
SELECT author,title FROM classics
  WHERE MATCH(author,title)
  AGAINST('+charles -species' IN BOOLEAN MODE);

SELECT author,title FROM classics
  WHERE MATCH(author,title)
  AGAINST('"origin of"' IN BOOLEAN MODE);
```
![[Рис. 8.14. Использование конструкции MATCH...AGAINST в булевом режиме.jpg]]
> Рис. 8.14. Использование конструкции `MATCH...AGAINST` в булевом режиме

Как, наверное, и ожидалось, первый запрос вернет только запись о книге The Old Curiosity Shop Чарльза Диккенса. Запись о книге Чарльза Дарвина игнорируется, поскольку из результата должна быть исключена любая строка, содержащая слово `species`.

>[!info]
>Во втором запросе есть кое-что интересное: частью искомой строки является стоповое слово of, но оно все же используется в поиске, поскольку двойные кавычки отменяют учет стоповых слов.


### `UPDATE...SET`
---

==Эта конструкция позволяет обновлять содержимое поля==. Если нужно изменить содержимое одного или нескольких полей, сначала следует сузить область действия запроса до того поля или полей, которые будут подвергаться изменениям, практически тем же способом, который применялся в команде `SELECT`. В **примере 8.26** показаны два разных способа использования **`UPDATE...SET`**. Копия экрана с результатами работы этих команд приведена на **рис. 8.15.**

**Пример 8.26.** Использование `UPDATE...SET`
```mysql
UPDATE classics SET author='Mark Twain (Samuel Langhorne Clemens)'
  WHERE author='Mark Twain';

UPDATE classics SET category='Classic Fiction'
  WHERE category='Fiction';
```
![[Рис. 8.15. Обновление столбцов в таблице classics.jpg]]
   >   **Рис. 8.15.** Обновление столбцов в таблице `classics`
   
В первом запросе, действие которого затрагивает только одну строку, к литературному псевдониму Mark Twain добавляется настоящее имя писателя — `Samuel Langhorne Clemens`, заключенное в скобки. А вот второй запрос воздействует на три столбца, поскольку он заменяет все появления слова `Fiction` в столбце category термином `Classic Fiction`.

При выполнении обновления можно также воспользоваться такими уже приведенными здесь спецификаторами, как `LIMIT`, а также рассматриваемыми далее ключевыми словами **`ORDER BY`** и **`GROUP BY`**.


### `ORDER BY`
---

Спецификатор **`ORDER BY`** ==позволяет отсортировать возвращаемые результаты по одному или нескольким столбцам в возрастающем или в убывающем порядке.== В **примере 8.27** показаны два таких запроса, результаты работы которых можно увидеть на **рис. 8.16.**

**Пример 8.27.** Использование `ORDER BY`
```mysql
SELECT author,title FROM classics ORDER BY author;
SELECT author,title FROM classics ORDER BY title DESC;
```

Первый запрос возвращает издания, отсортированные по авторам в возрастающем алфавитном порядке (этот режим используется по умолчанию), а второй возвращает их отсортированными по названию в убывающем порядке.

Если нужно отсортировать все столбцы по авторам, а затем в убывающем порядке по году издания (чтобы сначала стояли самые последние), нужно ввести следующий запрос:

```mysql
SELECT author,title,year FROM classics ORDER BY author,year DESC;
```
![[Рис. 8.16. Сортировка результатов запроса.jpg]]
   >   **Рис. 8.16.** Сортировка результатов запроса

Здесь показано, что каждый спецификатор сортировки по возрастанию и по убыванию применяется к отдельному столбцу. Ключевое слово **`DESC`** применяется только к столбцу, который указан перед ним, — `year`. Поскольку для столбца `author` разрешено использовать порядок сортировки, применяемый по умолчанию, этот столбец сортируется в возрастающем порядке. Можно также указать порядок сортировки этого столбца по возрастанию и в явном виде, в результате будут получены аналогичные результаты:

```mysql
SELECT author,title,year FROM classics ORDER BY author ASC,year DESC;
```


### `GROUP BY`
---

Точно так же, как и при использовании **`ORDER BY`**, можно сгруппировать результаты, возвращаемые запросом, с помощью спецификатора **`GROUP BY`**, который больше всего подходит для извлечения информации о группе данных. Например, если нужно узнать, сколько изданий каждой категории присутствует в таблице `classics`, можно ввести запрос:

```mysql
SELECT category,COUNT(author) FROM classics GROUP BY category;
```

который вернет следующую информацию:
```mysql
+-----------------+---------------+
| category        | COUNT(author) |
+-----------------+---------------+
| Classic Fiction |             3 |
| Play            |             1 |
| NonFiction      |             1 |
+-----------------+---------------+
3 rows in set (0.03 sec)
```


## Объединение таблиц
---

Управление несколькими таблицами, содержащими различные виды информации в одной базе данных, считается вполне обычным делом. Рассмотрим, к примеру, таблицу клиентов — `customers`, для которой нужно обеспечить возможность использования перекрестных ссылок с приобретенными этими же клиентами книгами из таблицы `classics`. Чтобы создать эту новую таблицу и поместить в нее информацию о трех клиентах и их покупках, введите команды из **примера 8.28**. Результаты показаны на **рис. 8.17**.

**Пример 8.28.** Создание и заполнение таблицы `customers`
```mysql
CREATE TABLE customers (
  name VARCHAR(128),
  isbn VARCHAR(13),
  PRIMARY KEY (isbn)) ENGINE InnoDB;

INSERT INTO customers(name,isbn)
  VALUES('Joe Bloggs','9780099533474');
INSERT INTO customers(name,isbn)
  VALUES('Mary Smith','9780582506206');
INSERT INTO customers(name,isbn)
  VALUES('Jack Wilson','9780517123201');

SELECT * FROM customers;
```
![[Рис. 8.17. Создание таблицы customers.jpg]]
>            **Рис. 8.17.** Создание таблицы `customers`

Разумеется, в настоящей таблице, содержащей сведения о покупателях, будут присутствовать также адреса, номера телефонов, адреса электронной почты и т. д., но на данном этапе изучения они для нас не представляют интереса. При создании новой таблицы следует обратить внимание на то, что у нее есть кое-что общее с таблицей `classics`: столбец под названием `isbn`. Поскольку его предназначение в обеих таблицах совпадает (ISBN всегда является ссылкой на одну и ту же книгу), этот столбец можно использовать для связывания двух таблиц вместе в едином запросе как в **примере 8.29.**

>[!info]
>Существует также быстрый способ для вставки сразу нескольких строк данных как в **примере 8.28**, позволяющий заменить три отдельных запроса **`INSERT INTO`** одним, в котором перечисляются вставляемые данные, отделенные друг от друга запятыми:
>
>```mysql
>INSERT INTO customers(name,isbn) VALUES
>('Joe Bloggs','9780099533474'),
('Mary Smith','9780582506206'),
('Jack Wilson','9780517123201');
>```

**Пример 8.29.** Объединение двух таблиц в одном запросе
```mysql
SELECT name,author,title FROM customers,classics
  WHERE customers.isbn=classics.isbn;
```

В результате будет выведена следующая информация:
```mysql
+-------------+-----------------+-----------------------+
| name        | author          | title                 |
+-------------+-----------------+-----------------------+
| Joe Bloggs  | Charles Dickens | The Old Curosity Shop |
| Jack Wilson | Charles Darwin  | The Origin of Species |
| Mary Smith  | Jane Austen     | Pride and Prejudice   |
+-------------+-----------------+-----------------------+
3 rows in set (0.00 sec)
```


### `NATURAL JOIN`
---

Используя конструкцию **`NATURAL JOIN`**, можно сократить количество вводимого текста и сделать запросы немного более понятными. В этом виде объединения участвуют две таблицы, в которых автоматически объединяются столбцы с одинаковыми именами. Для получения тех же результатов, что и в **примере 8.29**, можно ввести следующий запрос:
```mysql
SELECT name,author,title FROM customers NATURAL JOIN classics;

+-------------+-----------------+-----------------------+
| name        | author          | title                 |
+-------------+-----------------+-----------------------+
| Joe Bloggs  | Charles Dickens | The Old Curosity Shop |
| Jack Wilson | Charles Darwin  | The Origin of Species |
| Mary Smith  | Jane Austen     | Pride and Prejudice   |
+-------------+-----------------+-----------------------+
3 rows in set (0.00 sec)
```


### `JOIN...ON`
---

Если нужно указать столбец, по которому следует объединить две таблицы, используется конструкция **`JOIN...ON`**. Благодаря ей можно получить те же результаты, что и в **примере 8.29**:
```mysql
SELECT name,author,title FROM customers
  JOIN classics ON customers.isbn=classics.isbn;
```


### Использование ключевого слова `AS`
---

==Можно сократить количество вводимого текста и улучшить читаемость запроса за счет создания псевдонимов с помощью ключевого слова== **`AS`**. После имени таблицы нужно просто поставить **`AS`**, а затем используемый псевдоним. Следующий код идентичен по своей работе коду, приведенному в **примере 8.29**:
```mysql
SELECT name,author,title from
  customers AS cust, classics AS class WHERE cust.isbn=class.isbn;
```

Результат выполнения этой операции имеет следующий вид:
```mysql
+-------------+-----------------+-----------------------+
| name        | author          | title                 |
+-------------+-----------------+-----------------------+
| Joe Bloggs  | Charles Dickens | The Old Curosity Shop |
| Jack Wilson | Charles Darwin  | The Origin of Species |
| Mary Smith  | Jane Austen     | Pride and Prejudice   |
+-------------+-----------------+-----------------------+
3 rows in set (0.00 sec)
```

Ключевое слово `AS` можно также использовать для переименования столбца (независимо от того, объединяются таблицы или нет), например:
```mysql
SELECT name AS customer FROM customers ORDER BY customer;
```

В качестве результата будут выведены следующие данные:
```mysql
+-------------+
|  customer   |
+-------------+ 
| Jack Wilson | 
| Joe Bloggs  | 
| Mary Smith  |
+-------------+
3 rows in set (0.00 sec)
```

==Псевдонимы особенно полезны в длинных запросах, содержащих множественные ссылки на одни и те же имена таблиц.==


### Использование логических операторов
---

Для дальнейшего сужения пространства выбора в запросах MySQL, использующих ключевое слово `WHERE`, можно также задействовать логические операторы `AND`, `OR` и `NOT`. В **примере 8.30** показаны варианты применения каждого из них, но их можно использовать в любых сочетаниях.

**Пример 8.30.** Использование логических операторов
```mysql
SELECT author,title FROM classics WHERE
  author LIKE "Charles%" AND author LIKE "%Darwin";
SELECT author,title FROM classics WHERE
  author LIKE "%Mark Twain%" OR author LIKE "%Samuel Langhorne Clemens%"; SELECT author,title FROM classics WHERE
  author LIKE "Charles%" AND author NOT LIKE "%Darwin";
```

Первый запрос выбран потому, что Чарльз Дарвин может фигурировать в некоторых строках под своим полным именем — Чарльз Роберт Дарвин. А запрос возвращает сведения о книгах, для которых значение столбца `author` начинается с Charles и заканчивается Darwin. Второй запрос ищет книги, принадлежащие перу Марка Твена, используя для этого либо литературный псевдоним — Mark Twain, либо настоящее имя писателя — Samuel Langhorne Clemens. Третий запрос возвращает книги с авторами, чье имя Charles, а фамилия не Darwin.


## Функции MySQL
---

Стремление применять функции MySQL при таком обилии достаточно мощных функций PHP может вызвать недоумение. Ответ предельно прост: функции MySQL работают с данными непосредственно в самой базе. А при использовании PHP приходится сначала извлекать строку данных из MySQL, выполнять обработку, а затем выдавать первоначально задуманный запрос к базе данных.

Применение встроенных функций MySQL не только существенно сокращает время обработки сложных запросов, но и упрощает сами запросы. При желании подробные сведения обо всех доступных строковых функциях и функциях даты и времени можно найти в документации по следующим адресам: http://tinyurl.com/mysqlstrings и http://tinyurl.com/mysqldatefuncs.


## Работа с MySQL через phpMyAdmin
---

Для работы с MySQL, безусловно, важно изучить все представленные здесь основные команды и особенности их работы, но после того, как они уже изучены, для управления базами данных и таблицами будет намного проще и быстрее использовать программу phpMyAdmin.

Для этого, при условии, что пакет программ AMPPS установлен в соответствии с инструкциями [[Установка сервера, предназначенного для разработки]], наберите следующую команду, чтобы открыть программу (**рис. 8.18**):
```browser
http://localhost/phpmyadmin
```

![[Рис. 8.18. Главный экран phpMyAdmin.jpg]]
> 		       **Рис. 8.18.** Главный экран phpMyAdmin

На левой панели основного экрана phpMyAdmin можно выбрать щелчком любые таблицы, с которыми нужно поработать (хотя сначала, если такие таблицы отсутствуют, их нужно создать). Для создания новой базы данных можно также щелкнуть на пункте меню New (Новая).

Находясь в окне этой программы, можно совершать все основные операции, например создавать новые базы данных, добавлять таблицы, создавать индексы и т. д. Дополнительные сведения о программе phpMyAdmin можно найти в документации по адресу https://docs.phpmyadmin.net/.

Если вы совместно со мной прорабатывали все примеры, приведенные в данной главе, то я вас поздравляю с тем, что вы смогли одолеть весьма долгое путешествие, пройдя весь путь от изучения способа создания базы MySQL через выдачу сложных запросов с задействованием сразу нескольких таблиц до использования булевых операторов и применения различных квалификаторов MySQL.

В [[Освоение MySQL]] мы приступим к рассмотрению подходов к разработке рациональных баз данных, более совершенных SQL-технологий, а также функций и транзакций MySQL.


## ==Вопросы==
---

1. Для чего нужна точка с запятой в запросах MySQL?
2. Какие команды используются для просмотра доступных баз данных или
   таблиц?
3. Как на локальном хосте создается новый пользователь MySQL с именем
   `newuser` и паролем `newpass`, которому открыт доступ ко всему содержимому базы данных `newdatabase`?
4. Как просмотреть структуру таблицы?
5. Для чего нужен индекс в MySQL?
6. Какие преимущества дает индекс `FULLTEXT`?
7. Что такое стоповое слово?
8. Оба спецификатора, и `SELECT DISTINCT` и `GROUP BY`, приводят к отображению только одной строки для каждого значения в столбце, даже если такое значение имеют несколько строк. Каково основное различие между `SELECT DISTINCT` и `GROUP BY`?
9. Как можно с помощью инструкции SELECT...WHERE вернуть только те
   строки, в которых в каком-нибудь месте столбца author таблицы classics, используемой в этой главе, содержится слово Langhorne?
10. Что должно быть определено в двух таблицах, чтобы появилась возможность их объединения?
 