---
title: Принципы тестирования
date of creation: 2026-01-03T20:44:00
tags:
  - Test
  - Tests
  - Developing
  - Developing/Tests
  - Backend/Tests
  - IT/Tests
  - IT/Testing
  - SystemDesign
  - Principle
  - IT/Principles
read status: false
completion status: false
aliases:
  - 7 принципов тестирования
  - 7 Принципов тестирования
---
# Принципы тестирования
---
Итак, принципов тестирования всего 7 — как цветов радуги, чудес света, смертных грехов, дней недели и много чего еще. Выбирайте любой образ, который поможет лучше это запомнить. Как и большинство принципов, они редко напрямую используются на практике, но при этом любое тестирование предполагает их соблюдение. Для начала перечислим их:

1. Тестирование не может доказать отсутствие багов(только их наличие);
2. Исчерпывающее тестирование невозможно по определению;
3. Раннее тестирование позволяет сэкономить ресурсы;
4. Парадокс пестицидов;
5. Кластеризация багов;
6. Тестирование зависит от контекста;
7. Заблуждение об отсутствии багов;

Хотите стать хорошим тестировщиком? Так вот, этот список надо не просто зазубрить, а вникнуть в каждый пункт, понять его. Возможно, смысл одних очевиден (или только кажется таковым), а насчет других у вас отсутствуют какие-либо догадки. Рассмотрим каждый подробно.


## Тестирование не может доказать отсутствие багов, только их наличие.
---

_Месяца два назад в интернет-магазине заказала кофту с милым принтом. Она не пришла, в сроке доставке было написано 10-40 дней. Написала продавцу. Он не соглашается отдавать мне деньги, указывая на то, что я его обманываю. Просит прислать фотку, доказывающую, что кофты нет. Я просто чего-то не понимаю, да? Сейчас отправила ему фотку пустого стола. Отпишусь, когда ответит._

Можно ли доказать отсутствие чего-либо? Надо ли вообще его доказывать? Может, это оппонент должен доказать наличие чего-либо, являющегося предметом спора? Однако, тестирование процесс сугубо практический и, не отвлекаясь на глубокие мысли, попробуем разобраться в первом его принципе.

Представим, что в ходе тестирования мы провели какую-либо проверку и получили тот результат, который и ждали. Например, кликнули по иконке корзины на сайте интернет-магазина и открылась страница корзины. Значит ли это, что любой пользователь в любой ситуации повторит наше действие и получит тот же результат? Ответ: «Нет». Ведь пользователь это может делать в другом браузере, или в другой версии того же браузера, что и мы. Или у него может быть другая операционная система (или версия), другая конфигурация компьютера. В конце концов, может произойти что-то непредвиденное — «скакнет» электричество, на секунду оборвется интернет-связь, и в итоге корзина не откроется. 

Таким образом, отсутствие багов во время проверки не может гарантировать отсутствия багов при подобных действиях в другое время. Из этого делаем вывод,что тестирование не может доказать отсутствие багов.
## Исчерпывающее тестирование невозможно
---

Я в своем познании настолько преисполнился…

В конце описания первого принципа мы как раз вплотную подошли ко второму. Почему бы не взять и не провести нужные проверки во всех условиях, чтобы ни у кого не возникало проблем? Исчерпывающее тестирование — это как раз и есть тестирование, содержащее множество всех возможных проверок. Но и здесь стоит сделать существенное уточнение: Нет, не так. ВСЕХ ВОЗМОЖНЫХ проверок. Да, так лучше. Возьмем простой пример: у нас на сайте есть поле, в которое можно вводить только цифры и имеющее ограничение в 2 символа. Множество позитивных проверок составит ввод в поле значений от 0 до 99 плюс, возможно, еще некоторое количество проверок. Откуда этот плюс? Ну мы ведь не конкретизировали, отличается ли 1 от 01. Для ровного счета решим, что проверок будет 100 — от 0 до 99. Но мы упомянули, что это множество позитивных проверок, т.е. проверяющих, что поле делает то, что должно делать. Еще нужно убедиться, что поле не делает то, что оно делать не должно (то есть провести негативные проверки), верно? Раз сказано, что вводить можно только цифры, значит, все остальное вводить нельзя и при попытке ввести что-либо кроме цифры поле останется пустым. И привычных нам русских и английских букв не хватит. 

Мы ведь говорили о ВСЕХ ВОЗМОЖНЫХ проверках, следовательно, надо попробовать ввести в поле все буквы всех языков мира (поддерживаемые для ввода). Плюс знаки препинания, да. Дополнительно к этому еще все возможные для ввода спецсимволы, среди которых собака @, тильда ~ и т.д. и т.п.

Когда мы закончим с этим, мы выясним, что первый символ в поле точно не может быть ничем, кроме цифры. Но что, если в качестве второго символа поле может принять не цифру, а что-то другое? Нужно провести еще столько же проверок, вводя первым символом в поле цифру. От конкретной цифры тоже может что-то зависеть, например, «2а» нельзя ввести, а вот «3а» уже можно.


## Раннее тестирование
---

Пожалуй, самый осязаемый, самый материальный принцип. Как вы позже узнаете, процесс тестирования программного обеспечения включает в себя не только работу с уже готовым или скорее полу-готовым продуктом. По сути своей, тестирование сопровождает процесс разработки где-то с момента зарождения идеи. Когда на каждую мысль «Вот так будет очень хорошо!» появляется критическая оценка «А правда ли будет?» — это уже можно назвать тестированием. Ну так, в глобальном, даже философском смысле. Тестировать же можно в принципе что угодно. Хотел прокатиться на ногах по замерзшей луже, а в итоге поскользнулся и упал — явное несовпадение ожидаемого результата с фактическим.

Но, возвращаясь к тестированию ПО, чем раньше была найдена ошибка (она же баг, она же дефект и т.д.), тем больше ресурсов будет сэкономлено. Ну или меньше потрачено, разницы нет. Под ресурсами мы понимаем, в первую очередь, время и деньги. Время — это тоже деньги, как известно. Да и вообще любые потери любой компании в конечном итоге можно измерить деньгами.

Предположим, команда собралась и обсудила фичу, которая планируется к разработке. По результатам обсуждения был написан документ, включающий описание этой самой фичи. Документ оказался проблемным, но никто его не вычитывал. Команда разработки создала и внедрила фичу на основании документа. Фича вышла в релиз. Выяснилось, что из-за новой фичи не работает половина старых. Куча гневных отзывов, сокращение количества пользователей (ушли к конкурентам). Потери компании колоссальны. Самое время уволить команду тестирования, если она вообще была


## Парадокс пестицидов
---

Для того чтобы насекомые-вредители не ели урожай, растения обрабатывают химикатами (в том числе пестицидами). Речь как об огромных полях, на которые распыляют вещества с самолетов, так и о грядках на даче, которые опрыскивают, обмакивая веник в ведро с разведенным ядом. После первого применения большая часть насекомых умрет. Более того, состав останется на растениях и, если вдруг на освободившуюся кормовую базу нагрянут новые паразиты, жертвами яда падут и они. Но все же небольшая часть останется в живых. Почему? Ну, например, из-за индивидуальных особенностей конкретно вот этих самых особей. Им, скорее всего, будет очень плохо. Возможно, их жизнь даже будет более короткой и мучительной, чем у не отравленных собратьев. Но все же они успеют дать потомство, которое окажется чуть более невосприимчивым к яду. И так еще одно поколение, и еще одно. Прапрапра[много раз «пра»] внуки первых выживших будут поедать опрысканные растения также, как и неопрысканные. Возможно, без яда им уже будет не так вкусно, но это неточно. По итогу данный конкретный химикат перестанет действовать, а количество вредителей вернется к первоначальному уровню. Парадоксально, но применение пестицидов породило устойчивых к ним жуков. Эту проблему решают путем создания нового яда.

К чему это лирическое отступление об особенностях борьбы за урожай? Ну, разумеется, из-за аналогии «жуки — баги», как же обойти стороной такой грандиозный стереотип. И еще из-за того, что поведение ошибок в данном случае на редкость аналогично живым собратьям — они тоже подстраиваются под проверки, призванные их выявить (и уничтожить). Проверки становятся неэффективны, подобно пестицидам. Само собой, механизм совершенно другой и ничего общего с описанным в первом абзаце не имеет, но внешне похоже. И средство борьбы тоже очень похожее — при тестировании разных версий следует избегать одних и тех же тестовых данных, то есть применять, по сути, новый яд.


### P.S.
---

Красиво звучит, а что на практике? А на практике возможна ситуация, когда программист, исправляя неоднократно найденный баг, изменит код таким образом, что баг на тех же самых данных перестанет повторяться, а на других продолжит. Предположим, в калькуляторе вместо умножения происходит сложение. Тестировщик всегда проверяет умножение, вводя 5х5 и получая 10 вместо 25. Тогда разработчик напишет код примерно такого содержания: если А=5 и В=5, то АхВ=25, во всех остальных случаях АхВ=А+В. В очередной раз введя 5х5, тестировщик наконец увидит 25 и подтвердит исправление бага. А если бы каждый раз вводил разное…

Разумеется, ни один вменяемый разработчик никогда не поступит подобным образом. Но на этом тривиальном примере очевидна нелогичность решения. В большой сложной системе может быть непонятно, что новый код не исправляет реальную проблему, а лишь делает ее менее заметной.


## Кластеризация багов
---

> Смотри-ка, альпинист с горы полетел! Второй, третий! Ого, да у них походу там гнездо!

Закон Парето, столь любимый маркетологами и разного рода инфоцыганами, справедлив и для дефектов ПО. Это тот, который про 20% одного дает 80% другого. В нашем случае одним является функционал, а другим — баги. Ошибки при проверках имеют свойство складываться вместе, образовывая кластер. Или кучковаться в одном кластере разрабатываемого ПО — суть не меняется. 

Почему так получается? Причин может быть много, одно тянет за собой другое, а каждый случай индивидуален. Например, за «проблемный» модуль продукта отвечает программист, который ранее с подобными задачами не сталкивался. Учится по ходу дела и допускает много ошибок при выполнении задач. Или у заказчика нет четкого понимания как эта часть программы должна работать, он пытается менять решения на ходу, что сильно сказывается на уже сделанных частях. Или модуль плохо описан в документации, из-за чего возникает множество разночтений при выполнении. 

Докопаться до первопричины, устранить сразу множество имеющихся багов или хотя бы предотвратить появление будущих — это очень здорово. Но редко когда удается это сделать. Если разработчик только набирается опыта, он не наберется его моментально. На заказчика не снизойдет ясное видение готового продукта. А документация не изменится в одночасье. 

**Для нас, как тестировщиков, важен один вывод из пятого принципа: нашел баг — поищи другой поблизости**.


### P.S.
---

Немного о другом, но все же важном на практике моменте. Согласно принципам программирования, похожие элементы не создаются каждый по отдельности. Вместо этого общая часть кода пишется в одном месте и используется уже в коде однотипных элементов в виде ссылки, а разнящиеся части дописываются после нее. Таким образом, если баг вызван ошибкой в общей части кода, сломаются все использующие общий код элементы. И, будучи найденным в одном элементе, этот баг может быть пропущен в другом. Об этом тоже надо помнить и сразу оценивать, что еще мог зацепить найденный баг.

**Дисклеймер:** знающие хоть что-то о программировании люди, простите нас за такие формулировки. В данном случае было важно объяснить принцип тем, кто вообще не представляет себе как оно устроено.