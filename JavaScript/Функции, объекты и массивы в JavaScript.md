---
date of creation: 2024-06-11T21:43:00
tags:
  - JavaScript
  - JS
  - IT/Programming_language
  - WebDeveloping/JS
  - Web/JS
  - Arrays
  - Programming/JS
  - ProgrammingLanguage/JS
  - OOP/JS
  - objects/JS
  - Functions/JS
aliases:
  - Объекты и массивы в JavaScript
  - Функции и ООП в JavaScript
---
---
# Функции, объекты и массивы в JavaScript


В JavaScript предоставляется практически такой же доступ к функциям и объектам, как и в PHP. Язык JavaScript фактически основан на объектах, поскольку, как вы уже поняли, у него есть доступ к DOM — модели, которая реализует доступ к каждому элементу HTML-документа, позволяя работать с ним как с объектом. Способы применения функций и объектов, а также используемый для этого синтаксис очень похожи на все то, что мы видели в PHP, поэтому при изучении этого материала, а также при углубленном рассмотрении массивов JavaScript вы будете чувствовать себя вполне уверенно.


## Функции JavaScript
---

В JavaScript наряду с доступом к десяткам встроенных функций (или методов), среди которых и метод **`write`**, который, как мы уже видели, использовался в вызовах **`document.write`**, можно создавать и собственные функции. Как только появляется какой-нибудь непростой фрагмент кода с перспективами на многократное использование, он становится кандидатом на оформление в виде функции.


### Определение функции
---

В общем виде синтаксис функции выглядит следующим образом:

```js
function имя_функции([параметр [, ...]])
{
  инструкции
}
```

Из первой строки синтаксиса следует, что:

- определение начинается со слова **`function`**;
- следующее за этим словом имя должно начинаться с буквы или символа подчеркивания, за которым следует любое количество букв, цифр, символов доллара или подчеркивания;
- необходимо использовать скобки;
- дополнительно может применяться один или несколько параметров, разделенных запятыми (о чем свидетельствуют квадратные скобки, не являющиеся частью синтаксиса функции).

Имена функций чувствительны к регистру букв, поэтому строки **`getInput`**, **`GETINPUT`** и **`getinput`** ссылаются на разные функции.

В JavaScript для имен функций действует общепринятое соглашение: первая буква каждого слова в имени, за исключением первой буквы всего имени, должна быть прописной. Поэтому в приведенных примерах имен предпочтение следует отдать имени **`getinput`**, имеющему формат, используемый большинством программистов. Это соглашение часто называют *bumpyCaps*, *bumpy-Case* (неровности из прописных букв), а чаще всего — *camelCase* (горбатый регистр).

Инструкции, которые будут выполняться после вызова функции, начинаются с открывающей фигурной скобки, а составляющая ей пару закрывающая фигурная скобка должна завершать перечень этих инструкций. Среди инструкций обязана присутствовать одна или несколько инструкций **`return`**, которые заставляют функцию прекратить выполнение и вернуть управление вызвавшему ее коду. Если к инструкции **`return`** прилагается какое-нибудь значение, то вызывающий код может его извлечь.


#### Массив аргументов
---

Составной частью каждой функции является массив аргументов — **`arguments`**. Благодаря ему можно определить количество переменных, переданных функции, и понять, что они собой представляют. Рассмотрим, например, функцию **`displayltems`**. Один из способов ее создания показан в **примере 16.1.**

>**Пример 16.1.** Определение функции
```html
<script>
  displayItems("Собака", "Кошка", "Пони", "Хомяк", "Черепаха")

  function displayItems(v1, v2, v3, v4, v5)
  {
    document.write(v1 + "<br>")
    document.write(v2 + "<br>")
    document.write(v3 + "<br>")
    document.write(v4 + "<br>")
    document.write(v5 + "<br>")
  }
</script>
```

После вызова этого сценария на экране браузера отобразится следующая информация:

```output
Собака
Кошка
Пони
Хомяк
Черепаха
```

А что делать, если функции нужно будет передать больше пяти аргументов? К тому же применение вместо цикла многократного вызова метода **`document. write`** считается слишком расточительным приемом программирования. К счастью, массив **`arguments`** позволяет приспособиться к обработке любого количества аргументов. В **примере 16.2** показана возможность использования этого массива для придания предыдущему примеру более рациональной формы.

>**Пример 16.2.** Модификация функции для использования массива аргументов
```html
<script>
  let c = "Сом"

  displayItems("Бананы", 32.3, c)

  function displayItems()
  {
    for (j = 0 ; j < displayItems.arguments.length ; ++j)
      document.write(displayItems.arguments[j] + "<br>")
  }
</script>
```

Обратите внимание на использование свойства **`length`**, которое уже встречалось в [[Выражения и управление процессом выполнения сценариев в JavaScript]], а также на то, что с помощью переменной **`j`**, являющейся индексным смещением внутри массива, осуществляется ссылка на элементы **`displayltems.arguments`**. Поскольку тело цикла **`for`** состоит всего из одной инструкции, я решил не заключать его в фигурные скобки, чтобы не загромождать код функции. Не забудьте, что цикл должен остановиться, когда значение переменной **`j`** будет на единицу меньше значения **`length`**, а не равно ему.

Теперь благодаря данной технологии у вас есть функция, способная принимать любое количество аргументов и делать с каждым аргументом все, что вам захочется.


### Возвращение значения

^1d80b1

---

Функции используются не только для отображения информации. Чаще всего они применяются для выполнения вычислений или обработки данных с возвращением полученного результата. Функция **`fixNames`**, показанная в **`примере 16.3`**, задействует массив **`arguments`** (рассмотренный в предыдущем пункте) для приема переданной ей последовательности строк и возвращения всех этих строк в виде одной строки. Слово **`fix`** (исправление) в ее имени означает, что она переводит каждый символ в аргументах в нижний регистр, делая исключение для первой буквы каждого аргумента, которую она превращает в прописную.

>**Пример 16.3.** Приведение в порядок полного названия
```html
<script>
  document.write(fixNames("the", "DALLAS", "CowBoys"))

  function fixNames()
  {
    var s = ""

    for (j = 0 ; j < fixNames.arguments.length ; ++j)
      s += fixNames.arguments[j].charAt(0).toUpperCase() +
           fixNames.arguments[j].substr(1).toLowerCase() + " "

    return s.substr(0, s.length-1)
  }
</script>
```

К примеру, если вызвать эту функцию с параметрами **`the`**, **`DALLAS`** и **`CowBoys`**, то она вернет строку **`The Dallas Cowboys`**. Проанализируем работу этой функции. Сначала она инициализирует временную (и локальную) переменную **`s`**, присваивая ей значение пустой строки. Затем с помощью цикла **`for`** осуществляется последовательный перебор каждого переданного параметра с выделением его первой буквы с помощью метода **`charAt`** и переводом ее в верхний регистр с помощью метода **`toUpperCase`**. Все методы, показанные в этом примере, встроены в JavaScript и доступны по умолчанию.

После этого для извлечения оставшейся части каждой строки используется метод **`substr`**, а для перевода букв этой части строки в нижний регистр — метод **`toLowerCase`**.

Если здесь применить полную версию вызова метода **`substr`**, то в ней вторым аргументом нужно указать, из какого количества символов будет состоять извлекаемая подстрока:

```js
substr(1, (arguments[j].length) – 1 )
```

Иными словами, в этом вызове метода **`substr`** говорится следующее: «Начни с символа, который находится в позиции 1 (это второй символ), и верни оставшуюся часть строки (равную длине строки — **`length`** за вычетом одного символа)». Но что особенно приятно, метод **`substr`** заранее предполагает, что если второй аргумент опущен, то вам нужна вся оставшаяся часть строки. После того как весь аргумент будет переделан для получения нужного результата, к нему добавляется пробел и результат присоединяется к значению временной переменной **`s`**.

На завершающей стадии к содержимому переменной **`s`** опять применяется метод **`substr`**. Поскольку последний пробел нам не нужен, мы используем метод **`substr`**, чтобы вернуть всю строку, за исключением ее последнего символа.

Этот пример особенно интересен тем, что в нем показано использование в одном выражении сразу нескольких свойств и методов, например:

```js
fixNames.arguments[j].substr(1).toLowerCase()
```

Чтобы понять суть этой инструкции, ее нужно мысленно разделить на части, используя в качестве разделителей точки. JavaScript вычисляет эти элементы инструкции слева направо.

1. Берется имя функции: **`fixNames`**.
2. Из массива аргументов этой функции извлекается элемент **`j`**.
3. К извлеченному элементу применяется метод **`substr`** с параметром 1. Благодаря этому следующей части выражения будет передан весь извлеченный элемент, за исключением первого символа.
4. К той строке, которая только что была передана, применяется метод **`toLowerCase`**.

Такие построения часто называют *составлением цепочки методов*. Если, к примеру, приведенному здесь выражению передать строку **`mixedCASE`**, то она пройдет через следующие преобразования:

```output
mixedCase
ixedCase
ixedcase
```

Иными словами, **`fixNames.arguments[j]`** выдает **`mixedCASE`**, затем **`substr(1)`** получает **`mixedCASE`** и выдает **`ixedCASE`**, и наконец, **`toLowerCase()`** получает **`ixedCASE`** и выдает **`ixedcase`**.

И последнее напоминание: созданная внутри функции переменная **`s`** имеет локальную область видимости и не может быть доступна за ее пределами. Возвращая **`s`** с помощью инструкции **`return`**, мы делаем ее значение доступным вызывавшему функцию коду, который может его сохранить или использовать любым другим способом.

Но с завершением работы функции сама переменная **`s`** исчезает. Хотя мы можем заставить функцию работать и с глобальными переменными (что иногда просто необходимо), все-таки лучше просто вернуть те значения, которые нужно сохранить, и дать возможность JavaScript избавиться от всех остальных переменных, которые использовались функцией.


### Возвращение массива
---

В **примере 16.3** функция возвращает только один параметр. А что делать, если нужно вернуть сразу несколько параметров? Решить задачу поможет возвращение массива, показанное в **примере 16.4**.

>**Пример 16.4.** Возвращение массива значений
```html
<script>
  words = fixNames("the", "DALLAS", "CowBoys")

  for (j = 0 ; j < words.length ; ++j)
    document.write(words[j] + "<br>")
	
  function fixNames()
  {
    var s = new Array()

    for (j = 0 ; j < fixNames.arguments.length ; ++j)
      s[j] = fixNames.arguments[j].charAt(0).toUpperCase() +
             fixNames.arguments[j].substr(1).toLowerCase()

    return s
  }
</script>
```

Здесь переменная **`words`** автоматически определяется в виде массива и заполняется результатами, возвращенными вызовом функции **`fixNames`**. Затем цикл **`for`** осуществляет последовательный перебор элементов массива, отображая каждый элемент.

Что касается функции **`fixNames`**, то она практически идентична использованной в **примере 16.3**, за исключением того, что переменная **`s`** теперь является массивом, возвращаемым с помощью инструкции **`return`**.

Эта функция позволяет извлекать отдельные параметры из возвращенных ею элементов, например, как в следующем коде (который выводит строку **`The Cowboys`**):

```js
words = fixNames("the", "DALLAS", "CowBoys")
document.write(words[0] + " " + words[2])
```


## Объекты JavaScript
---

По сравнению с переменными, которые в каждый конкретный момент могут содержать только одно значение, объекты JavaScript — это значительный шаг вперед, поскольку в них может содержаться несколько значений и даже функций. Объект группирует вместе данные и функции для работы с ними.


### Объявление класса
---

При создании сценария, в котором используются объекты, необходимо спроектировать структуру из данных и кода, называемую *классом*. Каждый новый объект, основанный на конкретном классе, называется *экземпляром класса*. Вам уже известно, что данные, связанные с объектом, называются его *свойствами*, а функции, которые им используются, называются *методами*.

Посмотрим, как объявляется класс для объекта по имени **`User`**, который будет содержать сведения о текущем пользователе. Для создания класса нужно просто создать функцию с именем этого класса.

Эта функция может воспринимать аргументы (позже будет показано, как она вызывается) и создавать свойства и методы для объектов класса. Такая функция называется *конструктором*.

В **примере 16.5** показан конструктор для класса **`User`**, имеющий три свойства: имя — **`forename`**, пользовательское имя — **`username`** и пароль — **`password`**. В классе также определяется метод демонстрации сведений о пользователе — **`showUser`**.

>**Пример 16.5.** Объявление класса **`User`** и его метода
```html
<script>
  function User(forename, username, password)
  {
    this.forename = forename
    this.username = username
    this.password = password

    this.showUser = function()
    {
      document.write("Forename: " + this.forename + "<br>")
      document.write("Username: " + this.username + "<br>")
      document.write("Password: " + this.password + "<br>")
    }
  }
</script>
```

От ранее рассмотренных эту функцию отличают несколько особенностей.

- При каждом вызове функции ею создается новый объект. То есть, к примеру, можно вызвать одну и ту же функцию многократно с разными аргументами, чтобы создать объекты для пользователей с разными значениями свойства имени **`forename`**.
- Она ссылается на объект с именем **`this`**, который является ссылкой на создаваемый экземпляр. В примере показано, что объектом имя **`this`** используется для установки своих собственных свойств, которые для разных экземпляров **`User`** будут иметь разные значения.
- Внутри этой функции создается новая функция с именем **`showUser`**. Здесь показан новый, усложненный синтаксис. Его задача — привязать **`showUser`** к классу **`User`**. Таким образом, **`showUser`** становится методом класса **`User`**.

Здесь используется соглашение о выборе имен, согласно которому все свойства получают имена, состоящие из букв в нижнем регистре, а в имени метода в соответствии с упомянутым в данной главе горбатым регистром есть по крайней мере одна прописная буква.

В **примере 16.5** соблюдается рекомендуемый способ создания конструктора класса, который состоит в том, что методы включаются в функции конструктора. Но в **примере 16.6** показано, что можно также ссылаться на те функции, которые определены за границами конструктора.

>**Пример 16.6.** Раздельное объявление класса и метода
```html
<script>
  function User(forename, username, password)
  {
    this.forename = forename
    this.username = username
    this.password = password
    this.showUser = showUser
  }

  function showUser()
  {
    document.write("Forename: " + this.forename + "<br>")
    document.write("Username: " + this.username + "<br>")
    document.write("Password: " + this.password + "<br>")
  }
</script>
```

Эта форма объявления класса показана с расчетом на то, что вам наверняка придется сталкиваться с использованием кода, созданного другими программистами.


### Создание объекта
---

Для создания экземпляра класса **`User`** можно воспользоваться следующей инструкцией:

```js
details = new User("Wolfgang", "w.a.mozart", "composer")
```

Или же можно создать пустой объект:

```js
details = new User()
```

а затем наполнить его содержимым:

```js
details.forename = "Wolfgang"
details.username = "w.a.mozart"
details.password = "composer"
```

К объекту также можно добавлять новые свойства:

```js
details.greeting = "Привет"
```

Проверить работу только что добавленного свойства можно с помощью следующей инструкции:

```js
document.write(details.greeting)
```


### Доступ к объектам
---

Для доступа к объекту можно сослаться на его свойства, как показано в следующих не связанных друг с другом примерах инструкций:

```js
name = details.forename
if (details.username == "Admin") loginAsAdmin()
```

А для доступа к методу **`showUser`**, принадлежащему объекту класса **`User`**, нужно воспользоваться следующим синтаксисом, в котором применяется уже созданный и заполненный данными объект **`details`**:

```js
details.showUser()
```

В соответствии с ранее предоставленными объекту данными этот код отобразит следующую информацию:

```output
Имя: Wolfgang
Пользовательское имя: w.a.mozart
Пароль: composer
```


### Ключевое слово **`prototype`**
---

==Использование ключевого слова **`prototype`** позволяет добиться существенной экономии оперативной памяти.== Каждый экземпляр класса **`User`** будет содержать три свойства и один метод. Поэтому если в памяти содержится тысяча таких объектов, метод **`showUser`** также будет растиражирован тысячу раз. Но поскольку в каждом экземпляре присутствует один и тот же метод, можно предписать **новому** объекту ссылаться на единственный экземпляр этого метода и не создавать его копию. Итак, вместо использования в конструкторе класса строки кода:

```js
this.showUser = function()
```

можно воспользоваться следующей строкой:

```js
User.prototype.showUser = function()
```

Код обновленного конструктора показан в **примере 16.7.**

>**Пример 16.7.** Объявление класса с использованием для метода ключевого слова **`prototype`**
```html
<script>
  function User(forename, username, password)
  {
    this.forename = forename
    this.username = username
    this.password = password

    User.prototype.showUser = function()
    {
      document.write("Forename: " + this.forename + "<br>")
      document.write("Username: " + this.username + "<br>")
      document.write("Password: " + this.password + "<br>")
    }
  }
</script>
```

Этот код работает благодаря тому, что у всех функций имеется свойство с именем **`prototype`**, разработанное для хранения свойств и методов, не тиражируемых в каждом объекте, создаваемом на основе класса. Вместо этого они передаются объектам данного класса по ссылке.

Это означает, что свойства или методы **`prototype`** могут быть добавлены в любое время и они будут унаследованы всеми объектами (даже теми, которые уже были созданы), что можно проиллюстрировать следующими инструкциями:

```js
User.prototype.greeting = "Привет" document.write(details.greeting)
```

Первая инструкция добавляет к классу **`User`** прототипное свойство prototype. greeting, имеющее значение Привет. Во второй строке уже созданный объект details вполне корректно отображает это новое свойство.

Можно также добавлять к классу методы или вносить в них изменения, как показано в следующих инструкциях:

```js
User.prototype.showUser = function()
{
  document.write("Имя " + this.forename +
				" Пользователь " + this.username +
				" Пароль " + this.password)
}

details.showUser()
```

Эти строки можно поместить в свой сценарий, в инструкцию условия (например, в **`if`**), чтобы они запускались только в том случае, когда действия пользователя наталкивают на принятие решения о применении другого метода **`showUser`**. После запуска этих строк кода даже для уже созданного объекта **`details`** при всех последующих вызовах метода **`details.showUser`** будет запускаться новая версия, а старое определение **`showUser`** будет стерто.


### Статические методы и свойства
---

При изучении объектов PHP вы узнали, что у классов могут быть [[Cтатические свойства и методы]], а также свойства и методы, связанные с конкретным экземпляром класса. JavaScript также поддерживает статические свойства и методы, которые легко и просто могут сохраняться в принадлежащие классу прототипы и извлекаться из них. Следующие инструкции устанавливают в класс User и считывают из него статическую строку:

```js
User.prototype.greeting = "Привет"
document.write(User.prototype.greeting)
```


### Расширение объектов JavaScript
---

Ключевое слово **`prototype`** позволяет даже добавлять функциональные возможности встроенным объектам. Предположим, что нужно добавить возможность замены всех пробелов в строке неразрываемыми пробелами, чтобы избежать переноса ее части на новую строку. Это можно сделать добавлением к имеющемуся в JavaScript определению исходного объекта **`String`** прототипного метода:

```js
String.prototype.nbsp = function()
{
  return this.replace(/ /g, '&nbsp;')
}
```

В коде этого метода для поиска всех одиночных пробелов и замены их строкой **`&nbsp`**; используется метод **`replace`** и регулярное выражение.

>[!info]
>Если вы еще не знакомы с регулярными выражениями, следует пояснить, что они являются очень удобными средствами извлечения информации из строк или манипулирования строками и весьма подробно рассматриваются в [[Проверка данных и обработка ошибок в JavaScript и PHP]]. А пока вы можете скопировать и вставить предыдущие примеры, и они будут работать согласно описаниям, иллюстрируя возможности расширения JavaScript-объектов **`String`**.

Если после запуска этого кода будет введена следующая команда:

```js
document.write("Шустрая бурая лиса".nbspO)
```

то в результате ее работы будет выведена следующая строка: **`Шустрая&nbsp;бурая&nbsp;лиса`**. Посмотрите также на метод, приведенный далее. Его можно добавить для удаления всех пробелов, с которых начинается и которыми заканчивается строка (в нем опять используется регулярное выражение):

```js
String.prototype.trim = function()
{
  return this.replace(/^\s+|\s+$/g, '')
}
```

Если выдать следующую инструкцию, то на выходе будет получена строка **`Пожалуйста, избавьте меня от лишних пробелов`** (то есть из нее будут удалены все начальные и замыкающие пробелы):

```js
document.write(" Пожалуйста, избавьте меня от лишних пробелов ".trim())
```

Если разбить выражение на составные части, то два символа **`/`** помечают начало и конец выражения, а завершающий символ **`g`** задает глобальный поиск. Внутри выражения его часть **`^\s+`** задает поиск одного или нескольких пробельных символов применительно к началу строки, в которой ведется поиск, а его часть **`\s+$`** задает поиск одного или нескольких пробельных символов применительно к концу строки, в которой ведется поиск. Расположенный в середине символ **`|`** служит разделителем альтернативных вариантов регулярного выражения.

В результате при совпадении любого из этих выражений соответствующая часть заменяется пустой строкой, возвращая тем самым усеченную версию строки без лидирующих и замыкающих пустых пространств.

>[!danger]
>Среди программистов возникают споры, насколько хороша или плоха практика расширения объектов. Одни говорят, что при последующем расширении объекта, при котором добавленная вами функциональная возможность предлагается вполне официально, ее реализация может отличаться от вашей или же совершать нечто абсолютно иное по сравнению с вашим расширением, что в последующем может создать конфликтную ситуацию. Другие же, включая Брендана Эйха, автора JavaScript, говорят: практика создания расширений вполне приемлема. Я склонен согласиться с последними, но в коде, предназначенном для промышленного применения, лучше выбирать такие имена расширений, использование которых в официальных реализациях будет наименее вероятным. К примеру, расширение trim можно переименовать в mytrim, и поддерживающий его код может с большей долей безопасности быть написан следующим образом:
>```js
>String.prototype.mytrim = function()
>{
>    return this.replace(/^\s+|\s+$/g, '')
>}
>```



## Массивы в JavaScript
---

Работа с массивами в JavaScript очень напоминает работу с ними в PHP, хотя синтаксис имеет несколько иной вид. Тем не менее с учетом уже приобретенных знаний о массивах освоить материал этого раздела будет относительно несложно.


### Числовые массивы
---

Чтобы создать новый массив, нужно воспользоваться следующим синтаксисом:

```js
arrayname = new Array()
```

или же его более краткой формой:

```js
arrayname = []
```


### Присваивание значений элементам массива
---

В PHP можно было добавить к массиву новый элемент простым присваиванием ему значения, без указания смещения элемента относительно начала массива:

```php
$arrayname[] = "Элемент 1";
$arrayname[] = "Элемент 2";
```

В JavaScript для этих же целей используется метод **`push`**:

```js
arrayname.push("Элемент 1")
arrayname.push("Элемент 2")
```

Он позволяет добавлять к массиву элементы, не отслеживая их количество. Когда потребуется узнать, сколько элементов содержится в массиве, можно будет воспользоваться свойством **`length`**:

```js
document.write(arrayname.length)
```

Если нужно будет проконтролировать размещение элементов, расставляя их по конкретным местам, можно воспользоваться другим синтаксисом:

```js
arrayname[0] = "Элемент 1"
arrayname[1] = "Элемент 2"
```

В **`примере 16.8`** показан простой сценарий, в котором создается массив, в него загружается несколько элементов, после чего эти элементы отображаются на экране.

> **Пример 16.8.** Создание, построение и вывод массива на экран
```html
<script>
  numbers = []
  numbers.push("One")
  numbers.push("Two")
  numbers.push("Three")

  for (j = 0 ; j < numbers.length ; ++j)
    document.write("Element " + j + " = " + numbers[j] + "<br>")
</script>
```

Этот сценарий выводит следующую информацию:

```output
Элемент 0 = Один
Элемент 1 = Два
Элемент 2 = Три
```


### Присваивание с использованием ключевого слова **`Array`**
---

С помощью ключевого слова **`Array`** можно также создать массив с несколькими исходными элементами:

```js
numbers = Аrrау("Один", "Два", "Три")
```

После этого ничто не помешает добавить к данному массиву дополнительные элементы.

Теперь в вашем распоряжении есть несколько способов добавления элементов к массиву и один способ ссылки на них, но JavaScript предлагает куда более обширный арсенал способов, к **рассмотрению** которых мы скоро перейдем. Но сначала рассмотрим еще один тип массива.


### Ассоциативные массивы
---

К *ассоциативным* относятся такие массивы, в которых ссылки на элементы осуществляются по именам, а не по целочисленному смещению. Но в JavaScript подобные структуры не поддерживаются. Нам придется добиваться нужных результатов путем создания объекта с аналогично работающими свойствами.

Чтобы создать ассоциативный массив, нужно определить блок элементов, заключенный в фигурные скобки **`{}`**. Для каждого элемента слева от двоеточия (**`:`**) указывается его ключ, а справа — содержимое. В **примере 16.9** показано, как можно создать ассоциативный массив для хранения данных о товаре в разделе мячей интернет-магазина спортивного инвентаря.

>**Пример 16.9.** Создание и отображение ассоциативного массива
```html
<script>
  balls = {"гольф":     "Мячи для гольфа, 6",
           "теннис":    "Мячи для тенниса, 3",
           "футбол":    "Мячи для футбола, 1",
           "пинг-понг": "Мячи для пинг-понга, 12 шт."}

  for (ball in balls)
    document.write(ball + " = " + balls[ball] + "<br>")
</script>
```

Для проверки факта создания и заполнения массива я воспользовался еще одной разновидностью цикла **`for`**, в которой применяется ключевое слово **`in`**. В этом цикле создается новая переменная, которая задействуется только внутри массива (в данном примере — **`ball`**), и вызывается последовательный перебор всех элементов массива, указанных справа от ключевого слова **`in`** (в данном примере — **`balls`**). Цикл обрабатывает каждый элемент массива **`balls`**, помещая значение ключа в переменную **`ball`**.

Используя значение ключа, сохраненное в переменной **`ball`**, можно также получить значение текущего элемента массива **`balls`**. Результат вызова сценария этого примера в браузере будет иметь следующий вид:

```output
гольф = Мячи для гольфа, 6
теннис = Мячи для тенниса, 3
футбол = Футбольный мяч, 1
пинг-понг = Мячи для пинг-понга, 12 шт.
```

Чтобы получить значение конкретного элемента ассоциативного массива, нужно в явном виде указать его ключ (в данном случае будет выведено значение Футбольный мяч, 1):

```js
document.write(balls['футбол'])
```


### Многомерные массивы
---

В JavaScript для создания многомерного массива нужно просто поместить массивы внутрь других массивов. Например, чтобы создать массив, содержащий сведения о двумерной шахматной доске (8 × 8 клеток), можно воспользоваться кодом **примера 16.10.**

>**Пример 16.10.** Создание многомерного числового массива
```html
<script>
  checkerboard = Array(
    Array(' ', 'o', ' ', 'o', ' ', 'o', ' ', 'o'),
    Array('o', ' ', 'o', ' ', 'o', ' ', 'o', ' '),
    Array(' ', 'o', ' ', 'o', ' ', 'o', ' ', 'o'),
    Array(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '),
    Array(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '),
    Array('O', ' ', 'O', ' ', 'O', ' ', 'O', ' '),
    Array(' ', 'O', ' ', 'O', ' ', 'O', ' ', 'O'),
    Array('O', ' ', 'O', ' ', 'O', ' ', 'O', ' '))

  document.write("<pre>")

  for (j = 0 ; j < 8 ; ++j)
  {
    for (k = 0 ; k < 8 ; ++k)
      document.write(checkerboard[j][k] + " ")

    document.write("<br>")
  }

  document.write("</pre>")
</script>
```

В данном примере буквами нижнего регистра обозначены черные, а буквами верхнего регистра — белые фигуры. Два цикла **`for`**, один из которых является вложенным, осуществляют последовательный перебор элементов массива и отображают его содержимое.

Внешний цикл содержит две инструкции, поэтому они заключены в фигурные скобки. Внутренний цикл обрабатывает каждую клетку в горизонтали, выводя символ, находящийся в позиции **`[j][k]`**, за которым следует пробел (чтобы придать выводимой информации квадратную конфигурацию). В этом цикле содержится всего одна инструкция, поэтому заключать ее в фигурные скобки не имеет смысла. Теги **`<pre>`** и **`</pre>`** обеспечивают корректный вывод информации:

Можно также получить непосредственный доступ к любому элементу данного массива, применив для этого квадратные скобки:

```js
document.write(checkerboard[7][2])
```

Эта инструкция выводит букву **`O`** 0верхнего регистра, то есть содержимое восьмой сверху и третьей справа клетки, — ==напоминаю, что индексация элементов в массиве начинается с нуля, а не с единицы.==


## Методы массивов
---

Реализовать возможности, предоставленные массивами, помогают имеющиеся в JavaScript готовые к использованию методы для работы с ними и с содержащимися в них данными. Рассмотрим подборку, состоящую из наиболее востребованных методов.


### Метод **`some`**
---

Когда нужно узнать, соответствует ли хотя бы один элемент определенному критерию, можно воспользоваться методом **`some`**, ==который позволит протестировать все элементы и автоматически остановится, возвратив требуемое значение при первом же найденном соответствии.== Это избавит вас от необходимости написания собственного кода для выполнения подобного поиска:

```js
function isBiggerThan10(element, index, array)
{
  return element > 10
}

result = [2, 5, 8, 1, 4].some(isBiggerThan10);   // Результатом будет false
result = [12, 5, 7, 1, 4].some(isBiggerThan10);  // Результатом будет true
```


### Метод **`indexOf`**
---

==Для определения факта нахождения элемента в массиве можно воспользоваться в отношении массива методом== **`indexOf`**, с помощью которого будет возвращено смещение обнаруженного элемента (начиная с нуля), или значение –1, если элемент не будет найден. Например, при выполнении следующего кода переменной **`offset`** будет присвоено значение 2:

```js
animals = ['кот', 'собака', 'корова', 'лошадь', 'слон']
offset = animals.indexOf('корова')
```


### Метод **`concat`**
---

Метод **`concat`** ==объединяет два массива или ряд значений в массив==. Например, следующий код выведет `Банан,Виноград,Морковь,Капуста`:

```js
fruit = ["Банан", "Виноград"]
veg = ["Морковь", "Капуста"]

document.write(fruit.concat(veg))
```

В качестве аргументов можно указать несколько массивов, тогда метод **`concat`** добавит все их элементы в порядке указания массивов.

А вот еще один способ использования метода **`concat`**, где с массивом **`pets`** объединяются простые значения и на экран выводится строка `Кошка,Собака,Рыба,Кролик,Хомяк`:

```js
pets = ["Кошка", "Собака", "Рыба"]
more_pets = pets.concat("Кролик", "Хомяк")

document.write(more_pets)
```


### Метод **`forEach`**
---

Используемый в JavaScript метод **`forEach`** является еще одним способом получения функциональных возможностей, аналогичных тем, которые предоставляются ключевым словом PHP **`foreach`**. Воспользоваться этим методом можно, передав ему имя функции, которая будет вызвана для каждого элемента массива. Как это делается, показано в **примере 16.11.**

>**Пример 16.11.** Использование метода **`forEach`**
```html
<script>
  pets = ["Кошка", "Собака", "Кролик", "Хомяк"]
  pets.forEach(output)

  function output(element, index, array)
  {
    document.write("Element at index " + index + " has the value " +
      element + "<br>")
  }
</script>
```

В данном случае функция, передаваемая методу **`forEach`**, называется **`output`**. Она воспринимает три параметра: элемент, его индекс и массив. Как они используются, зависит от потребностей вашей функции. В данном примере они просто отображают значения индекса и элемента с помощью метода **`document.write`**.

После того как массив будет заполнен, можно вызвать рассматриваемый метод:

```js
pets.forEach(output)
```

На выходе будет получена следующая информация:

```output
Элемент с индексом 0 содержит значение Кошка
Элемент с индексом 1 содержит значение Собака
Элемент с индексом 2 содержит значение Кролик
Элемент с индексом 3 содержит значение Хомяк
```


### Метод **`join`**
---

Метод **`join`** ==позволяет превратить все значения массива в строки, а затем объединить их в одну большую строку, расставляя между значениями необязательные разделители.== В **примере 16.12** показаны три способа использования этого метода.

>**Пример 16.12.** Использование метода **`join`**
```html
<script>
  pets = ["Кошка", "Собака", "Кролик", "Хомяк"]

  document.write(pets.join()      + "<br>")
  document.write(pets.join(' ')   + "<br>")
  document.write(pets.join(' : ') + "<br>")
</script>
```

Если не указывать параметр, метод **`join`** использует в качестве разделителя элементов запятую, в противном случае между элементами вставляется переданная методу **`join`** строка. Код **примера 16.12** выводит следующую информацию:

```output
Кошка,Собака,Кролик,Хомяк
Кошка Собака Кролик Хомяк
Кошка : Собака : Кролик : Хомяк
```


### Методы **`push`** и **`pop`**
---

Применение метода **`push`** для вставки значения в массив уже было рассмотрено. Противоположным ему по действию является метод **`pop`**. Он удаляет последний вставленный элемент из массива и возвращает значение этого элемента. Порядок его использования показан в **примере 16.13**.

>**Пример 16.13.** Использование методов **`push`** и **`pop`**
```html
<script>
  sports = ["Футбол", "Теннис", "Бейсбол"]
  document.write("Изначально = "      + sports +  "<br>")

  sports.push("Хокей");
  document.write("После вставки = " + sports +  "<br>")

  removed = sports.pop()
  document.write("После удаления = "  + sports +  "<br>")
  document.write("Удаленный элемент = "    + removed + "<br>")
</script>
```

Три основные инструкции этого сценария выделены полужирным шрифтом. Сначала в сценарии создается массив по имени **`sports`**, содержащий три элемента, затем в него вставляется четвертый элемент, после чего сценарий удаляет этот элемент. В процессе этих действий с помощью метода **`document.write`** отображаются разные значения массива. Сценарий выводит следующую информацию:

```html
Изначально = Футбол,Теннис,Бейсбол
После вставки = Футбол,Теннис,Бейсбол,Хоккей
После удаления = Футбол,Теннис,Бейсбол
Удаленный элемент = Хоккей
```

Методы **`push`** и **`pop`** применяются в тех случаях, когда нужно отвлечься от каких-нибудь действий на другие, а затем вернуться к прежним действиям. Предположим, к примеру, что вам нужно отложить некоторые действия на потом и заняться чем-нибудь более важным на данный момент. Такое часто случается в реальной жизни, когда просматриваются списки предстоящих дел, поэтому давайте воспроизведем это в программном коде в списке из шести дел применительно к задачам 2 и 5, которым отдается приоритет, как показано в **примере 16.14.**

>**Пример 16.14.** Использование методов **`push`** и **`pop`** внутри цикла и за его пределами
```html
<script>
  numbers = []

  for (j=1 ; j<6 ; ++j)
  {
    if (j == 2 || j == 5)
    {
      document.write("Выполнение намеченной задачи #" + j + "<br>")
    }
    else
    {
      document.write("Откладывание намеченной задачи #" + j + " на потом<br>")
      numbers.push(j)
    }
  }

  document.write("<br>Завершенние выполнение приоритетных задач.")
  document.write("<br>Начало выполнения отложенных задач в порядке, обратном                        их следованию<br><br>")

  document.write("Выполнение намеченной задачи #" + numbers.pop() + "<br>")
  document.write("Выполнение намеченной задачи #" + numbers.pop() + "<br>")
  document.write("Выполнение намеченной задачи #" + numbers.pop() + "<br>")
</script>
```

Код этого примера выведет следующую информацию:

```output
Откладывание намеченной задачи #1 на потом
Выполнение намеченной задачи # 2
Откладывание намеченной задачи #3 на потом
Откладывание намеченной задачи #4 на потом
Выполнение намеченной задачи # 5

Завершено выполнение приоритетных задач.
Начало выполнения отложенных задач в порядке, обратном их следованию.

Выполнение намеченной задачи #4
Выполнение намеченной задачи #3
Выполнение намеченной задачи #1
```


### Использование метода **`reverse`**
---

Метод **`reverse`** ==осуществляет простую перестановку элементов массива в обратном порядке.== Его действие показано в **примере 16.15.**

>**Пример 16.15.** Использование метода **`reverse`**
```html
<script>
  sports = ["Футбол", "Теннис", "Бейсбол", "Хоккей"]
  sports.reverse()
  document.write(sports)
</script>
```

Исходный массив подвергается изменению, и сценарий выводит следующую информацию:

```output
Хоккей,Бейсбол,Теннис,Футбол
```


### Метод **`sort`**
---

Метод **`sort`** ==позволяет расставить все элементы массива в алфавитном порядке в зависимости от применяемых параметров.== В **примере 16.16** показаны четыре типа сортировки.

>**Пример 16.16.** Использование метода **`sort`**
```html
<script>
  // Сортировка по алфавиту
  sports = ["Футбол", "Теннис", "Бейсбол", "Хоккей"]
  sports.sort()
  document.write(sports + "<br>")

  // Сортировка по алфавиту в обратном порядке
  sports = ["Футбол", "Теннис", "Бейсбол", "Хоккей"]
  sports.sort().reverse()
  document.write(sports + "<br>")

  // Сортировка чисел по возрастанию
  numbers = [7, 23, 6, 74]
  numbers.sort(function(a,b){return a – b})
  document.write(numbers + "<br>")

  // Сортировка чисел по убыванию numbers = [7, 23, 6, 74]
  numbers.sort(function(a,b){return b – a})
  document.write(numbers + "<br>")
</script>
```

В первом из четырех блоков этого примера применяется *сортировка по алфавиту*, во втором — возвращение к исходному виду, а затем метод **`reverse`**, чтобы получить *сортировку по алфавиту в обратном порядке*.

Третий и четвертый блоки усложнены использованием функции для сравнения взаимоотношений между **`а`** и **`b`**. У нее отсутствует имя, поскольку она используется только при сортировке. Функция по имени **`function`**, которая применяется для создания безымянных функций, уже встречалась при определении метода класса (метода **`showUser`**).

Здесь **`function`** создает безымянную функцию, отвечающую запросам метода **`sort`**. Если функция возвращает значение больше нуля, сортировка предполагает, что **`b`** ставится перед **`а`**. Если функция возвращает значение меньше нуля, сортировка предполагает, что **`а`** ставится перед **`b`**. Сортировка запускает эту функцию применительно ко всем значениям массива для определения порядка их следования. (Разумеется, если **`a`** и **`b`** имеют одинаковое значение, функция возвращает нуль, и порядок их следования совершенно неважен.)

За счет манипуляции возвращаемыми значениями (**`а – b`** или **`b – а`**) в третьем и четвертом блоках **примера 16.16** осуществляется выбор между сортировкой чисел по возрастанию и по убыванию.

На этом я заканчиваю введение в JavaScript. Теперь у вас должно сложиться представление о трех основных технологиях, рассматриваемых в данной книге. В следующей главе будут рассмотрены некоторые современные технические приемы, основанные на применении всех этих технологий, в частности проверка соответствия шаблонам и проверка допустимости введенных значений.


## Вопросы
---

- [x] 1. Обладают ли имена функций и переменных в JavaScript чувствительностью к регистру используемых в них букв?
- [?] 2. Как создать функцию, которая воспринимает и обрабатывает неограниченное количество параметров?
- [?] 3. Назовите способ возвращения из функции сразу нескольких значений.
- [x] 4. Какое ключевое слово для ссылки на текущий объект используется при определении класса?
- [x] 5. Должны ли все методы класса определяться внутри определения самого класса?
- [x] 6. Какое ключевое слово применяется для создания объекта?
- [x] 7. Как обеспечить доступность свойства или метода всем объектам класса без его тиражирования внутри объекта?
- [x] 8. Как создать многомерный массив?
- [x] 9. Какой синтаксис используется для создания ассоциативного массива?
- [x] 10. Создайте инструкцию для сортировки массива чисел в убывающем порядке.



---