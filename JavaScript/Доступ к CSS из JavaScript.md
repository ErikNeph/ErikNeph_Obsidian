---
date of creation: 2024-06-27T20:42:00
tags:
  - JS
  - JS/CSS
  - JavaScript
  - Developing
  - Developing/JS_and_CSS
  - IT
  - IT/JavaScript
  - Design/CSS
Read status: false
aliases:
  - CSS и JavaScript в связке
---
---
# Доступ к CSS из JavaScript
2024-06-27



После того как вы поняли, что такое объектная модель документа — Document Object Model (DOM) и каскадные таблицы стилей — CSS, из этой главы вы узнаете, как к ним можно получать доступ непосредственно из кода JavaScript, что позволит вам создавать высоко динамичные и быстро реагирующие на действия пользователей сайты.

Мы также рассмотрим использование прерываний, что позволит создавать анимацию или предоставлять любой код, который должен продолжать работу на веб-странице (например, часы). Кроме того, я объясню, как в DOM добавляются новые элементы или удаляются существующие элементы, чтобы вам не приходилось заранее создавать элементы в HTML на тот случай, если коду JavaScript может чуть позже понадобиться получить к ним доступ.


## Еще одно обращение к функции **`getElementByld`**
---

В качестве помощи в работе с примерами, приводимыми в остальной части книги, я намереваюсь представить вам улучшенную версию функции **`getElementByld`**, чтобы вы могли работать с элементами DOM и стилями CSS быстро и эффективно, не испытывая потребности включения таких сред, как jQuery.

Но чтобы избежать конфликтов со средами программирования, использующими символ **`$`**, я буду просто применять в качестве имени функции заглавную букву **`O`**, поскольку это первая буква слова Object (объект), а именно объект будет возвращаться при вызове этой функции (тот самый объект, представленный идентификатором ID, переданным функции).



### Функция **`O`**
---

Основа функции O имеет следующий вид:

```js
function O(i)
{
  return document.getElementById(i)
}
```

Только этот код уже сокращает количество набираемого текста при вызове функции на 22 символа, но я намерен немного расширить функцию, позволяя передавать ей либо ID, либо объект, как показано в полной версии функции, представленной в **примере 21.1.**

>**Пример 21.1.** Функция **`O`**
```js
function O(i)
{
  return typeof i == 'object' ? i : document.getElementById(i)
}
```

Если функции передается объект, она просто возвращает его обратно. В противном случае она предполагает, что ей был передан ID, и возвращает объект, на который этот ID ссылается.

Но с какой стати мне захотелось добавить эту первую инструкцию, которая просто возвращает переданный ей объект?



### Функция **`S`**
---

Ответ на данный вопрос станет ясным, когда вы посмотрите на вспомогательную функцию, названную **`S`** и показанную в **примере 21.2**, которую я вам предоставляю для упрощения доступа к стилевым свойствам (или CSS) объекта.

>**Пример 21.2.** Функция **`S`**
```js
function S(i)
{
  return O(i).style
}
```

Для этой функции имя **`S`** выбрано потому, что это первая буква слова **`Style`**, а функция выполняет задачу возвращения свойства стиля (или подчиненного объекта) того элемента, на который она ссылается. Поскольку встроенная функция **`O`** принимает либо ID, либо объект, вы можете передавать функции **`S`** как ID, так и объект.

Рассмотрим, что получится, когда мы возьмем **`<div>`**-элемент с ID **`myobj`** и установим для цвета его текста значение green (зеленый):

```html
<div id='myobj'>Some text</div>
<script>
  O('myobj').style.color = 'green'
</script>
```

Предыдущий код справится с этой задачей, но значительно проще будет вызвать новую функцию **`S`**:
```js
S('myobj').color = 'green'
```

Теперь рассмотрим случай, при котором объект, возвращенный в результате вызова функции **`O`**, сохранен, к примеру, в объекте по имени **`fred`**:
```js
fred = O('myobj')
```

Благодаря тому способу, который используется в работе функции **`S`**, мы можем для изменения цвета на зеленый вызвать и этот объект:
```js
S(fred).color = 'green'
```

Это означает, что при желании получить доступ к объекту непосредственно или через его ID вы можете сделать это, передавая его либо функции **`O`**, либо функции **`S`**, в зависимости от того, что вам нужно. Нужно лишь помнить, что при передаче объекта (а не ID) ни в коем случае не следует брать его имя в кавычки.



### Функция **`C`**
---

==Вам уже предоставлены две простые функции, упрощающие доступ к любому элементу на веб-странице и любому свойству стиля элемента.== Но иногда вам понадобится одновременный доступ более чем к одному элементу. Это можно сделать путем присваивания имени класса CSS каждому такому элементу, как показано в следующем примере, где для каждого элемента применяется класс **`myclass`**:

```html
<div class='myclass'>Содержимое div-контейнера </div>
<p class='myclass'>Содержимое абзаца</р>
```

Если нужен доступ ко всем элементам страницы, использующим конкретный класс, можно обратиться к функции **`C`** (чье имя происходит от первой буквы в слове **`Class`**), показанной в **примере 21.3.** Она вернет массив, состоящий из всех объектов, которые соответствуют предоставленному имени класса.

>**Пример 21.3.** Функция **`C`**
```js
function C(i)
{
  return document.getElementsByClassName(i)
}
```

Для использования эту функцию следует просто вызвать, как показано далее, сохраняя возвращенный массив, чтобы иметь возможность получить доступ отдельно к каждому нужному элементу или (что чаще всего и бывает) ко всем элементам с помощью цикла:

```js
myarray = C('myclass')
```

Теперь вы можете делать с возвращенными объектами все, что нужно, например можете установить для их свойства **`textDecoration`** значение подчеркивания **`'underline'`**:

```js
for (i = 0 ; i < myarray.length ; ++i)
  S(myarray[i]).textDecoration = 'underline'
```

Этот код осуществляет последовательный перебор объектов в **`myarray[]`**, а затем использует функцию **`S`** для ссылки на свойство стиля каждого объекта, задавая для свойства **`textDecoration`** значение **`'underline'`**.

>[!info]
>Очень маловероятно, что вы будете использовать функции **`O`**, **`S`** и **`C`** в коде разработки, потому что у вас, скорее всего, будет собственная или сторонняя платформа для обеспечения этой функциональности, а также многое другое. Но они служат для того, чтобы примеры в этой книге были короткими и хорошо понятными, а также являются простым примером способа улучшить JavaScript.
Включение функций



### Включение функций
---

Функции `O` и `S` используются во всей оставшейся части главы, поскольку делают код короче и понятнее. Поэтому я сохранил их в файле **`OSC.js`** (наряду с функцией `C`, поскольку я полагаю, что она принесет вам большую пользу) в папке Chapter 21 в сопутствующем архиве примеров, который вы можете загрузить из хранилища примеров этой книги.

Они могут быть включены в веб-страницу с помощью следующей инструкции. Ее предпочтительнее поместить в блок **`<head>`** где-нибудь перед любым сценарием, работа которого зависит от вызова этих функций:

```html
<script src='OSC.js'></script>
```

Содержимое файла `OSC.js `показано в **`примере 21.4`**, где все убрано всего лишь в три строки.

>**Пример 21.4.** Файл **`OSC.js`**
```js
function O(i) {return typeof i == 'object' ? i :document.getElementById(i) }
function S(i) { return O(i).style }
function C(i) { return document.getElementsByClassName(i) }
```





## Обращение к свойствам CSS из JavaScript
---

Свойство **`textDecoration`**, ==использовавшееся в ранее показанном примере, представляет свойство CSS, имя которого в обычном виде содержит дефис:== **`text-decoration`**. ==Но поскольку в JavaScript дефис зарезервирован для применения в качестве математического оператора, при доступе к свойству CSS, в имени которого используется дефис, этот дефис нужно опустить и перевести в верхний регистр символ, следовавший непосредственно за ним.==

Еще одним примером может послужить свойство **`font-size`** , на которое в JavaScript при помещении после оператора точки ссылаются как на **`fontSize`**:

```js
myobject.fontSize = '16pt'
```

Вместо этого можно предоставить более развернутый код и воспользоваться функцией **`setAttribute`**, которая поддерживает (и фактически требует) стандартное имя свойства CSS:

```js
myobject.setAttribute('style', 'font-size:16pt')
```




### Некоторые общие свойства
---

С помощью JavaScript вы можете изменить любое свойство любого элемента, имеющегося в веб-документе, примерно так же, как это делается с помощью CSS. Я уже показывал вам, как получить доступ к свойствам CSS, используя либо краткую форму JavaScript, либо функцию **`setAttribute`** (чтобы применить абсолютно такие же имена свойств, как и в CSS). Поэтому я не стану обременять вас детализацией всех этих сотен свойств. Вместо этого я покажу, как получить доступ к некоторым свойствам CSS, чтобы дать обзорное представление о возможностях их применения.

Сначала рассмотрим изменение нескольких свойств CSS из JavaScript, используя код **примера 21.5**, который в первую очередь загружает в себя три ранее упомянутые функции, затем создает **`<div>`**-элемент и, наконец, запускает инструкции JavaScript, находящиеся внутри блока **`<script>`** кода HTML с целью изменения некоторых атрибутов элемента **`<div>`** (**рис. 21.1**).

>**Пример 21.5.** Обращение к свойствам CSS из JavaScript
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Обращение к свойствам</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    <div id='object'>Div-объект</div>

    <script>
      S('object').border     = 'solid 1px red'
      S('object').width      = '100px'
      S('object').height     = '100px'
      S('object').background = '#eee'
      S('object').color      = 'blue'
      S('object').fontSize   = '15pt'
      S('object').fontFamily = 'Helvetica'
      S('object').fontStyle  = 'italic'
    </script> 
  </body>
</html>
```

От такого изменения свойств нет никакой практической пользы, поскольку можно так же легко включить код CSS непосредственно в атрибуты элемента, но скоро мы будем изменять свойства в ответ на действия пользователя, вот тогда и проявится настоящая эффективность сочетания JavaScript и CSS.

![[Рис. 21.1. Изменение стилей из JavaScript.jpg]]
>   **Рис. 21.1.** Изменение стилей из JavaScript




### Другие свойства
---

JavaScript также открывает доступ к очень широкому диапазону других свойств, таких как ширина и высота окна браузера и любых появляющихся или присутствующих в браузере окон или фреймов, и к такой полезной информации, как родительское окно (если таковое имеется) и история URL-адресов, по которым осуществлялись визиты в текущем сеансе.

Все эти свойства доступны из объекта window через оператор «точка» (.) (например, **`window.name`**). В **табл. 21.1** перечислены все эти свойства с описаниями.

>**Таблица 21.1.** Свойства объекта **`window`**
![[Таблица 21.1. Свойства объекта window.jpg]]
![[Таблица 21.1.2 Свойства объекта window.jpg]]

У некоторых из этих свойств есть следующие особенности.

- Свойства **`defaultStatus`** и **`status`** могут быть установлены, только если пользователи изменили настройки своих браузеров и разрешили их применение (что маловероятно).
- Содержимое объекта **`history`** не может быть прочитано (поэтому нельзя посмотреть, какие адреса посещались вашими визитерами), но этот объект поддерживает свойство **`length`** , чтобы определить длину истории, а также методы **`back`**, **`forward`** и **`go`** для переходов на указанные страницы в истории.
- Когда нужно узнать, какое пространство доступно в текущем окне браузера, следует просто прочитать значения свойств **`window.innerHeight`** и **`window.innerWidth`**. Я часто использую эти значения для размещения появляющихся в окне браузера диалоговых окон оповещения и подтверждения по центру.
- Объект **`screen`** поддерживает свойства, доступные только для чтения, **`availHeight`**, **`availWidth`**, **`colorDepth`**, **`height`**, **`pixelDepth`** и **`width`**, поэтому отлично подходит для извлечения информации о дисплее пользователя.

>[!info]
>Многие из этих свойств могут быть просто бесценными при позиционировании на мобильных телефонах и планшетных устройствах, поскольку дадут точную информацию об экранном пространстве, с которым придется работать, о типе используемого браузера и т. д.

Этого объема информации вполне достаточно для начала работы и получения представления о многих новых и интересных приемах работы с JavaScript. Разумеется, существует намного больше доступных свойств и методов, которые могли бы быть рассмотрены в данной главе. Но теперь, когда вы знаете о том, как обращаться к свойствам и использовать их, вам нужен лишь информационный ресурс, на котором все они перечислены. Я рекомендую для начала обратиться к документации на сайте https://tinyurl.com/domexplained.





## Встроенный JavaScript
---

Использование тегов **`<script>`** не единственный способ выполнения инструкций JavaScript. Получить доступ к JavaScript можно также из тегов HTML, что и делается для повышения динамической интерактивности.

Например, для быстрого добавления эффекта при прохождении указателя мыши над объектом можно воспользоваться таким же кодом, который показан в теге **`<img>`** в **примере 21.6**. Там изначально отображается картинка с яблоком, которая при прохождении над ней указателя мыши заменяется картинкой с апельсином (а при выходе указателя за пределы картинки возвращается картинка с яблоком).

>**Пример 21.6.** Использование встроенного JavaScript
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Встроенный JavaScript</title>
  </head>
  <body>
    <img src='apple.png'
      onmouseover="this.src='orange.png'"
      onmouseout="this.src='apple.png'"> 
  </body>
</html>

```




### Ключевое слово **`this`**
---

В предыдущем примере вы можете увидеть применение ключевого слова **`this`**. Оно заставляет JavaScript работать с названным объектом, а именно с тегом **`<img>`**. Результат можно увидеть на **рис. 21.2**, где указатель мыши только что прошел над картинкой с яблоком.

>[!info]
>Когда ключевое слово **`this`** находится во встроенном вызове JavaScript, оно представляет вызываемый объект. А при использовании в методах класса оно представляет объект, к которому применяется метод.

![[Рис. 21.2. Пример встроенного кода JavaScript, обрабатывающего прохождение указателя мыши над объектом.jpg]]
>**Рис. 21.2.** Пример встроенного кода JavaScript, обрабатывающего                  прохождение указателя мыши над объектом




### Привязка событий к объектам в сценарии
---

Предыдущий код является эквивалентом предоставления тегу **`<img>`** идентификатора с последующей привязкой действий к событиям мыши этого тега как в **примере 21.7.**

>**Пример 21.7.** Невстроенный JavaScript
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Невстроенный JavaScript</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    <img id='object' src='apple.png'>

    <script>
      O('object').onmouseover = function() { this.src = 'orange.png' }
      O('object').onmouseout  = function() { this.src = 'apple.png'  }
    </script> 
  </body>
</html>

```

Этот код применяет ID объекта к тегу **`<img>`** в блоке HTML, а затем продолжает работать с ним отдельно в блоке JavaScript, прикрепив к каждому событию безымянную функцию.



### Прикрепление к другим событиям
---

Какой бы JavaScript ни использовался, встроенный или отдельный, существуют события, к которым вы можете прикрепить действия. И активизировать тем самым множество дополнительных функций, которые можете предоставить своим пользователям. В **табл. 21.2** перечислены эти события и указаны условия их наступления.

>**Таблица 21.2.** События и условия их наступления
>![[Таблица 21.2. События и условия их наступления.jpg]]
>![[Таблица 21.2.2 События и условия их наступления.jpg]]

**`*`** - Элемент с фокусом — тот, который был выбран или иным образом активизирован, например поле ввода.

>[!danger]
>События нужно прикреплять только к тем объектам, для которых в них имеется смысл. Например, объект, не являющийся формой, не будет реагировать на событие `onsubmit`.



### Добавление новых элементов
---

Работая с JavaScript, вы можете манипулировать не только элементами и объектами, которые были предоставлены документу его кодом HTML. Вы можете создавать объекты по своему желанию, вставляя их в DOM.

Предположим, к примеру, что вам нужен новый элемент **`<div>`**. Способ добавления его к веб-странице показан в **примере 21.8**.

>**Пример 21.8.** Вставка элемента в DOM
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Добавление элементов</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    В этом документе содержиться только этот текст.<br><br>

    <script>
      alert('Для добавления элемента нажмите кнопку ОК.')

      newdiv    = document.createElement('div')
      newdiv.id = 'NewDiv'
      document.body.append(newdiv)

      S(newdiv).border = 'solid 1px red'
      S(newdiv).width  = '100px'
      S(newdiv).height = '100px'
      newdiv.innerHTML = "Это новый объект, вставленный в DOM"
      
      setTimeout(function()
      {
        alert('Для удаление элемента нажмите кнопку ОК')
      
        newdiv.parentNode.removeChild(newdiv)
      }, 1000)
    </script>
  </body>
</html>
```

На **`рис. 21.3`** показано, как этот код используется для добавления к веб-документу нового **`<div>`**-элемента. Сначала новый элемент создается с помощью функции **`createElement`**, затем вызывается функция **`appendChild`** и элемент вставляется в DOM.

>![[Рис. 21.3. Вставка нового элемента в DOM.jpg]]
>   **Рис. 21.3.** Вставка нового элемента в DOM

После этого элементу присваиваются различные свойства, включая некоторый текст для его внутреннего HTML-кода. И затем, чтобы убедиться, что новый элемент будет мгновенно обнаружен, устанавливается тайм-аут, который сработает через одну секунду в будущем, задерживая выполнение оставшегося кода, чтобы дать DOM время для обновления и отображения, прежде чем снова появится предупреждение об удалении элемента. Подробнее о создании и использовании тайм-аутов написано в разделе «[[#Использование функции **`setTimeout`**|Использование функции setTimeout]]» далее в этой главе. Этот вновь созданный элемент будет точно таким же, как если бы он был включен в исходный HTML, и станет открывать доступ к аналогичным свойствам и методам.

>[!info]
>Иногда я использую технологию создания новых элементов, когда хочу создать окно, появляющееся в окне браузера, потому что она не зависит от наличия запасных **`<div>`**-элементов, доступных в DOM.




### Удаление элементов
---

Вы можете также удалить элементы из DOM, включая те, которые не были вставлены с помощью кода JavaScript. Это даже проще, чем добавить элемент. Если предположить, что удаляется объект **`element`**, то это делается следующим образом:
```js
element.parentNode.removeChild(element)
```

Этот код обращается к объекту **`parentNode`** элемента, поэтому он может удалить элемент из этого узла. Затем он вызывает метод этого родительского объекта **`removeChild`**, передавая ему удаляемый объект.









### Использование функции **`setTimeout`**
---

