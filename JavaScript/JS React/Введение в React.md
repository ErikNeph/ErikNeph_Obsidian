---
date of creation: 2024-07-14T06:24:00
tags:
  - React
  - JS/React
  - Framework
  - Framework/JS
  - Developing
  - Developing/JS
  - JS
read status: true
aliases:
  - React основа
---
---
# Введение в React


При использовании JavaScript, HTML и CSS для создания динамических вебсайтов наступает момент, когда код, необходимый для обработки интерфейса ваших веб-сайтов и приложений, может стать громоздким и чрезмерно подробным, что замедляет скорость разработки проекта и может стать причиной появления труднонаходимых ошибок.

Именно здесь на помощь приходят среды. Конечно, с 2006 года нам помогает также библиотека jQuery, соответственно она установлена на подавляющем большинстве производственных веб-сайтов. К тому же в наши дни значительно увеличились масштабы и гибкость JavaScript, и программистам можно намного меньше полагаться на такие среды, как jQuery. Кроме того, с течением времени технология постоянно совершенствуется, и теперь есть ряд других отличных вариантов, таких как [[Angular Framework|Angular]] и, как уже говорилось, ==мой фаворит — React==.

jQuery была разработана для упрощения обхода дерева HTML DOM и манипулирования им, а также для обработки событий, CSS-анимации и Ajax, но некоторые программисты, например команда разработчиков Google, посчитали, что она все еще недостаточно мощная, и в 2010 году придумали Angular JS, который в 2016 году превратился в Angular.

Angular в качестве основной архитектурной характеристики использует иерархию компонентов, а не область видимости или контроллеры (например, Angular). Мощная платформа Google AdWords работает на Angular, как и Forbes, Autodesk, Indiegogo, UPS и многие другие, и это действительно чрезвычайно мощная платформа.

А вот Facebook придерживался другого видения и придумал библиотеку React, известную также как React JS, в качестве основы для разработки одностраничных или мобильных приложений, основываясь на расширении [[JSX (JavaScript XML)]]. Библиотека React, разработанная в 2012 году, разделяет веб-страницу на отдельные компоненты, упрощая разработку интерфейса, необходимого для обслуживания всей рекламы Facebook и многого другого. В настоящее время она широко используется такими широко известными платформами, как Dropbox, Cloudflare, Airbnb, Netflix, BBC, PayPal и многими другими.

Очевидно, что при создании и проектировании и Angular, и React руководствовались надежными коммерческими решениями. Они были созданы для работы с веб-страницами с чрезвычайно высоким трафиком, когда считалось, что jQuery просто не обладает той мощью, которая нужна была разработчикам. Поэтому сегодня наряду со знанием основных технологий JavaScript, HTML, CSS, серверного языка, такого как PHP, и базы данных, такой как MySQL, программистам все еще может быть полезно хоть немного знать jQuery и разбираться либо в Angular, либо в React, если не в обеих сразу, а также, возможно, в других средах, у которых также есть последователи.

Однако я решил, что важнее познакомить вас с React, так как она проста в использовании, у нее не слишком сложны кривая обучения и общая реализация, а также потому, что [Google Trends](https://trends.google.com/trends/) показывает, что эта структура пользуется наибольшей популярностью среди всех трех, как показано на **рис. 24.1**. Кстати, пожалуйста, не путайте [[ReactPHP]] с React для JavaScript, поскольку это совершенно отдельный, не связанный с рассматриваемым проект.

>![[Рис. 24.1. Популярность jQuery, Angular и React в настоящее время по данным Google Trends.jpg]]
>**Рис. 24.1.** Популярность jQuery, Angular и React в настоящее время по данным Google Trends


## В чем же суть React?
---

==React позволяет разработчикам создавать большие веб-приложения, которые могут легко обрабатывать и изменять данные без перезагрузки веб-страницы.== Ее основными целями являются скорость, масштабируемость и простота в обработке уровня просмотра одностраничных веб-приложений и мобильных приложений. Она также позволяет создавать повторно используемые компоненты пользовательского интерфейса и управляет виртуальным DOM для повышения производительности. Некоторые люди говорят, что его можно использовать в качестве V в архитектуре [[MVC (Model, View, Controller)]] — модель, представление, контроллер), которая разделяет приложения на три компонента.

Вместо того чтобы придумывать различные способы описания транзакций для интерфейсов, разработчики могут просто описать интерфейсы в терминах конечного состояния так, что когда транзакции происходят в этом состоянии, React обновляет пользовательский интерфейс за вас. ==Конечными результатами являются более быстрая разработка с меньшим количеством ошибок, скорость, надежность и масштабируемость.== Поскольку React — это библиотека, а не среда, изучить ее можно быстро: нужно освоить всего несколько функций. После этого все будет зависеть от ваших навыков работы с JavaScript.

Итак, начнем изучение с того, как получить доступ к файлам React.

>[!info]
>На мой взгляд, jQuery великолепен, но я также считаю React очень простым в использовании. И полагаю, время покажет, прав ли я в своем предположении, что React может в конечном итоге заменить jQuery в качестве доминирующей платформы, особенно для работы с пользовательским интерфейсом, хотя бы потому, что она намного богаче. Но даже если этого не произойдет, изучив React, вы все равно получите в свое распоряжение невероятно мощный новый инструмент, который многие ведущие компании будут искать в вашем резюме. Но не стоит сбрасывать со счетов и Angular. Если бы в этой книге было место, я бы рассказал и о ней, потому что его определенно стоит понять для отладки и обслуживания существующего кода, даже если вы не используете его для разработок. Вы можете все узнать о ней на сайте https://angular.io (и это знание тоже будет отлично смотреться в вашем резюме).

\
## Получение доступа к файлам React
---

Так же как jQuery и Angular, React имеет открытый исходный код и полностью бесплатна для использования. Как и в случае с другими средами, в интернете существует множество сервисов, которые бесплатно предоставят вам последнюю (или любую) версию, поэтому использовать React может быть так же просто, как разместить пару дополнительных строк кода на вашей веб-странице.

Прежде чем изучать, что можно сделать с React и как ее использовать, приведем пример того, как включить его в веб-страницу, извлекая файлы с unpkg.com:

```html
<script
src="https://unpkg.com/react@17/umd/react.development.js">
</script>
<script src="https://unpkg.com/react-dom@17/umd/react-                dom.development.js">
</script>
```

Для удобства доступа и чтобы сделать код как можно более кратким, я загрузил последнюю версию (на момент написания этих строк 17-ю) несжатых файлов разработки в архив примеров для этой книги (https://github.com/RobinNixon/lpmj6), так что все примеры будут загружаться локально и выглядеть следующим образом:

```html
<script src="react.development.js"></script>
<script src="react-dom.development.js"></script>
```

Что делать после того, как React стала доступна для вашего кода? Хотя в этом нет необходимости, далее мы подключаем расширение Babel JSX, которое позволяет включать XML-текст непосредственно в JavaScript, что значительно облегчит вашу жизнь.


### Включение babel.js
---

Расширение Babel JSX добавляет возможность использовать XML (очень похожий на HTML) непосредственно в JavaScript, избавляя вас от необходимости каждый раз вызывать функцию. Кроме того, в браузерах с версиями ECMAScript ранее 6-й (официальный стандарт JavaScript) Babel обновляет их для обработки синтаксиса ES6, обеспечивая таким образом два больших преимущества за один раз.

И снова вы можете извлечь нужный файл с сервера unpkg.com, например, так:

```html
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
```

Вам потребуется только одна свернутая версия кода Babel на сервере разработки или на рабочем сервере. Для удобства я также загрузил последнюю версию в сопутствующий архив файлов примеров, поэтому примеры из этой книги загружаются локально и выглядят следующим образом:

```html
<script src="babel.min.js"></script>
```

Теперь, когда мы смогли получить доступ к файлам React, продолжим работать с ними.

>[!info]
>Цель этой главы — научить вас основам использования React, обеспечить четкое понимание того, как и почему он работает, и предоставить вам хороший старт для дальнейшего развития в React. На самом деле некоторые примеры, приводимые в этой главе, основаны на примерах (или похожи на них), которые вы найдете в официальной документации на сайте http://reactjs.org/. Так что если захотите изучить React более подробно, можете посетить сайт и приступить к работе.


## Наш первый проект в React
---

Вместо того чтобы полностью обучить вас React и JSX, прежде чем приступить к кодированию, мы подойдем с другой стороны и покажем, насколько все просто. Для этого сразу перейдем к нашему первому проекту в React, как показано в **примере 24.1**, результатом которого является отображение в браузере текста «Клянусь Дживсом, это работает!».

>**Пример 24.1.** Наш первый проект в React
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Using a class</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class One extends React.Component
      {
        render()
        {
          return <p>By Jeeves, it works!</p>
        }
      }
      
      ReactDOM.render(<One />, document.getElementById('div1'))
    </script>
  </head>
  <body>
    <div id="div1" style='font-family:monospace'></div>
  </body>
</html>
```

Это стандартный документ HTML5, который загружается в два сценария React и сценарий Babel перед открытием встроенного сценария. Вот на что нам в первую очередь нужно обратить внимание, потому что вместо того, чтобы не указывать тип тега **`script`** или использовать **`type=application/javascript`**, тегу присваивается **`type=text/babel`**. Это позволяет браузеру разрешить выполнять сценарий препроцессору Babel, при необходимости добавить в него функциональность ES6, заменить любой встреченный XML на вызовы функций JavaScript и только после этого запускать содержимое сценария в качестве JavaScript.

Наконец, внутри сценария вызывается функция **`render`** класса **`One`**, ей передается идентификатор единственного элемента **`<div>`** в теле документа, которому был присвоен идентификатор **`div1`**. Результатом является визуализация XML в **`div`**, что заставляет браузер автоматически обновлять и отображать содержимое, которое выглядит следующим образом:

```html
By Jeeves, it works!
```

Вы сразу же увидите, что включение XML в JavaScript значительно упрощает и ускоряет написание кода, а также делает его более понятным. Без расширения JSX вам пришлось бы делать все это с помощью последовательности вызовов функций JavaScript.

>[!info]
>React обрабатывает компоненты, начинающиеся со строчных букв, к примеру теги DOM. Поэтому, например, элемент **`<div />`** представляет тег HTML **`<div>`**, но **`< One />`** представляет собой компонент и требует присутствия `One` в области применения — в предыдущем примере нельзя использовать оne (со строчной буквы «о») и ожидать, что код заработает, так как компонент и любое обращение к нему должны начинаться с прописной буквы.


### Использование функции вместо класса
---

Если хотите, можете использовать функцию для своего кода вместо того, чтобы помещать его в класс с функцией визуализации (и это встречается все чаще), как показано в **примере 24.2.** Основные причины, по которым вы можете предпочесть этот вариант, — простота, удобство использования и более быстрая разработка.

>**Пример 24.2.** Использование функции вместо класса
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Using a function</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      function Two()
      {
        return <p>And this, by Jove!</p>
      }

      ReactDOM.render(<Two />, document.getElementById('div2'))
    </script>
  </head>
  <body>
    <div id="div2" style='font-family:monospace'></div>
  </body>
</html>
```

Результат будет отображаться в браузере следующим образом:

```html
И это работает!
```

>[!info]
>Начиная с этого момента, для краткости и простоты я буду показывать в примерах только содержимое сценария Babel и тело документа, как если бы они оба находились в теле (это работает точно так же), но примеры в сопутствующем архиве будут полными. Поэтому в дальнейшем они будут выглядеть следующим образом:
>```html
`<script` type="text/babel">
function Two()
{
  return `<p>`И это работает!`</p>`
}
ReactDOM.render(<Two />, document.getElementById('div2'))
`</script>`
`<div` id="div2">`</div>`




### Чистый и нечистый код: золотое правило
---

Когда вы пишете обычную функцию JavaScript, можно написать то, что React называет чистым или нечистым кодом. Чистый код функции не изменяет свои входные данные, что возвращает значение, вычисленное из его аргументов, как показано в примере далее:

```js
function mult(m1, m2)
{
  return m1 * m2
}
```

А следующая функция считается нечистой, поскольку она изменяет аргумент и абсолютно недопустима при использовании React:

```js
function assign(obj, val)
{
  obj.value = val
}
```

Если выразить это в виде золотого правила, то следует помнить, что все компоненты React должны действовать как чистые функции по отношению к своим свойствам, как объясняется в разделе «[[#Свойства и компоненты|Свойства и компоненты]]» далее в этой главе.


#### Совместное использование класса и функции
---

Конечно, вы можете применять функции и классы практически взаимозаменяемо (хотя между ними есть различия, которые я объясню в разделе [[#Различия между использованием класса и функции|«Различия между использованием класса и функции»]] далее в этой главе), как в примере 24.3.

>**Пример 24.3.** Совместное использование функции и класса
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Using a class and a function</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class One extends React.Component
      {
        render()
        {
          return <p>By Jeeves, it works!</p>
        }
      }
      
      function Two()
      {
        return <p>And this, by Jove!</p>
      }

      doRender(<One />, 'div1')
      doRender(<Two />, 'div2')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <div id="div1" style='font-family:monospace'></div>
    <div id="div2" style='font-family:monospace'></div>
  </body>
</html>
```

Здесь есть класс с названием **`One`** и функция **`Two`**, и они точно такие же, как и в предыдущих двух примерах. Однако есть и дополнительное отличие — создание новой функции под названием **`doRender`**, которая значительно сокращает синтаксис вызова, необходимого для визуализации блока XML. Результат выполнения этой функции отображается в браузере следующим образом:

```html
Клянусь Дживсом, это работает!
И это работает!
```

>[!info]
>В дополнение к отсутствию окружающего HTML-кода в следующих примерах я опущу код функции **`doRender`**, чтобы избежать ненужного многократного повторения. Поэтому когда в этих примерах вы увидите вызов функции **`doRender`**, помните, что это не встроенная функция React, а функция, включенная в полные примеры в сопутствующем архиве.


#### Свойства и компоненты
---

Отличным способом познакомить вас с тем, что React называет *свойствами* и *компонентами*, будет создать простую страницу приветствия, в которой имя передается сценарию, а затем отображается. Один из способов сделать это показан в **примере 24.4.** Компоненты позволяют разделить пользовательский интерфейс на отдельные повторно используемые части и работать с каждой из них изолированно. Они похожи на функции JavaScript и принимают произвольные входные данные, которые называются *свойствами*, возвращая элементы React, которые описывают, как элементы должны отображаться в браузере.

>**Пример 24.4.** Передача свойств в функцию
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Using props and components</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      function Welcome(props)
      {
        return <h1>Hello, {props.name}</h1>
      }

      doRender(<Welcome name='Robin' />, 'hello')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <div id="hello" style='font-family:monospace'></div>
  </body>
</html>
```

В этом примере функция **`Welcome`** получает аргумент **`props`**, который обозначает свойства, и в ее операторе возврата JSX есть раздел внутри фигурных скобок, который извлекает свойство **`name`** из объекта **`props`**:

```js
return <h1>Привет, {props.name}</h1>
```

Здесь **`props`** — это объект в React, и далее вы увидите один из способов заполнить его свойством.

Наконец, функции **`doRender`**, которая, как вы помните, является сокращенным вызовом, ведущим к функции **`ReactDOM.render`**, передается имя функции **`Welcome`**, после чего ее свойству **`name`** присваивается строковое значение 'Робин':

>[!info]
>Использование фигурных скобок — это способ встраивания выражений в JSX. Вы можете поместить практически любое выражение JavaScript внутрь этих фигурных скобок, и оно будет оценено (за исключением операторов **`for`** и **`if`**, которые не могут быть оценены).
>
>Соответственно, вместо props.name в этом примере можно было бы указать **`76 /13`** или **`«decode».substr(-4)`**, которое будет расценено как строка «code». Однако в данном случае имя свойства извлекается из объекта **`props`** и возвращается.

Затем React вызывает функцию **`Welcome`** (ее также называют компонентом), передавая ей **`{name:'Робин'}`** в свойствах. **`Welcome`** оценивает и возвращает результат **`<h1>Привет, Робин</h1>`**, который затем отображается в **`div`** под названием **`hello`** и отображается в браузере следующим образом:

```html
Привет, Робин
```

Чтобы сделать свой код более аккуратным, при желании вы можете сначала создать элемент, содержащий XML для передачи в **`doRender`**, например, так:

```js
const elem = <Welcome name='Робин' />
doRender(elem, 'hello')
```


#### Различия между использованием класса и функции
---

Наиболее очевидным различием между использованием класса и функции в React является ==синтаксис==. Функция представляет собой простой JavaScript, возможно, включающий JSX, который может принимать аргумент **`props`** и возвращать элемент компонента.

Однако класс расширяется из **`React.Component`** и требует метода **`render`** для возврата компонента. Но этот дополнительный код на самом деле имеет свои преимущества, поскольку класс позволяет вам применять **`setState`** в своем компоненте, что дает возможность, к примеру, использовать таймеры и другие функции с отслеживанием состояния. Функции в React называются *функциональными компонентами без состояния.* Кроме того, классы позволяют вам использовать то, что в React называется *хуками и методами жизненного цикла*. Подробнее обо всем этом будет рассказано в следующем разделе.

На сегодняшний день в React, по сути, вы можете сделать практически все, используя функции.


## Состояние и жизненный цикл React
---

Предположим, вы хотите, чтобы на вашей веб-странице отображались тикающие часы (для простоты возьмем обычные цифровые). Если вы используете код без состояния, выполнить это будет непросто, но если настроите свой код так, чтобы он сохранял свое состояние, то счетчик часов можно будет обновлять раз в секунду и так же часто будет отображаться время. Это тот случай, когда в React лучше использовать класс, а не функцию. Итак, создадим такие часы:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>A simple clock</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class Clock extends React.Component
      {
        constructor(props)
        {
          super(props)
          this.state = {date: new Date()}
        }

        componentDidMount()
        {
          this.timerID = setInterval(() => this.tick(), 1000)
        }

        componentWillUnmount()
        {
          clearInterval(this.timerID)
        }

        tick()
        {
          this.setState({date: new Date()})
        }

        render()
        {
          return <span> {this.state.date.toLocaleTimeString()} </span>
        }
      }

      doRender(<Clock />, 'the_time')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <p style='font-family:monospace'>The time is: <span                  id="the_time"></span></p>
  </body>
</html>
```

Этот код присваивает результат, возвращенный после вызова функцией **`Date`** свойства **`state`** объекта **`this`** конструктора, которым является **`props`**. Теперь содержимое JSX будет отображаться при каждом вызове функции класса **`render`**, и до тех пор, пока он отображается в одном и том же узле DOM, будет использоваться только один экземпляр класса.

>[!info]
>Вы видели вызов **`super`** в начале конструктора? Передавая ему **`props`**, теперь можно ссылаться на **`props`** с помощью ключевого слова **`this`** внутри конструктора, без которого вы не смогли бы совершить вызов.

Однако при существующем положении вещей время будет отображаться только один раз, после чего код перестанет выполняться. Поэтому теперь нам нужно настроить некий код, управляемый прерываниями, чтобы поддерживать свойство **`date`** в актуальном состоянии, и это делается добавлением метода *жизненного цикла* к классу путем установки таймера с помощью **`componentDidMount`**, как показано далее:

```js
componentDidMount()
{
  this.timerID = setInterval(() => this.tick(), 1000)
}
```

Мы не совсем дошли до конца, поскольку нам еще нужно написать функцию **`tick`**, но сначала поясним предыдущее: монтирование — это термин, который React использует для описания действий по добавлению узлов в DOM. Метод класса **`componentDidMount`** всегда вызывается, если компонент успешно смонтирован, поэтому он будет идеальным местом для установки прерывания. И действительно, в предыдущем коде **`this.timerID`** присваивается идентификатор, возвращаемый вызовом функции **`SetInterval`**, он передает ей метод **`this.tick`**, который будет вызываться каждые 1000 мс, или один раз в секунду.

Когда таймер установлен, мы должны обеспечить средства для его **`отключения`**, чтобы предотвратить ненужные циклы прерывания. В данном случае, когда DOM, созданный **`Clock`**, удаляется, то есть компонент размонтирован, метод и код, который мы используем для остановки прерываний, выглядит следующим образом:

```js
componentWillUnmount()
{
  clearInterval(this.timerID)
}
```

Здесь **`componentWillUnmount`** вызывается React при удалении DOM. Таким образом, именно здесь мы размещаем код для очистки интервала, хранящегося в **`this.timerID`**, а затем возвращаем все эти временные срезы обратно в систему, поскольку очистка интервала мгновенно останавливает вызов **`tick`**.

Последняя часть головоломки — это код, управляемый прерыванием, который вызывается каждые 1000 мс и которым является метод **`tick`**:

```js
tick()
{
  this.setState({date: new Date()})
}
```

Здесь функция React **`setState`** вызывается для обновления значения в свойстве **`state`** последнего результата вызова функции **`Date`** один раз в секунду.

Итак, рассмотрим весь этот код вместе, как показано в **примере 24.5.**

>**Пример 24.5.** Создание часов в React
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>A simple clock</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class Clock extends React.Component
      {
        constructor(props)
        {
          super(props)
          this.state = {date: new Date()}
        }

        componentDidMount()
        {
          this.timerID = setInterval(() => this.tick(), 1000)
        }

        componentWillUnmount()
        {
          clearInterval(this.timerID)
        }

        tick()
        {
          this.setState({date: new Date()})
        }

        render()
        {
          return <span> {this.state.date.toLocaleTimeString()}                 </span>
        }
      }

      doRender(<Clock />, 'the_time')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <p style='font-family:monospace'>The time is: <span                  id="the_time"></span></p>
  </body>
</html>
```

Теперь, когда класс **`Clock`** дополнен конструктором, инициатором и ограничителем прерываний, методом для обновления свойства **`state`** с использованием прерываний и функцией **`render`**, необходимо лишь вызвать **`doRender`**, чтобы все пошло своим чередом и работало как часы! Результат в браузере выглядит следующим образом:

```html
Время: 12:17:21
```

Часы автоматически обновляются на экране каждый раз при вызове функции **`setState`**; поскольку компоненты повторно отображаются этой функцией, вам не нужно беспокоиться об этом в своем коде.

>[!INFO]
>После начальной настройки состояния **`setState`** является единственным законным способом обновления состояния, потому что простое изменение состояния напрямую не приведет к повторной отправке компонента. Помните, что единственное место, которому вы можете присвоить **`this.state`**, находится в конструкторе. React может объединить несколько вызовов **`setState`** в одно обновление.


### Использование хуков (если вы пользуетесь [[NodeJS|Node.js]])
---

Если вы работаете с Node.js (см. http://nodejs.org/), то можете использовать хуки вместо того, чтобы целиком полагаться на классы. Node.js — это серверная среда с открытым исходным кодом, которая запускает JavaScript и React непосредственно на сервере. Правильное описание и документирование этой технологии заняло бы несколько глав, но если вы уже используете ее, я хочу, чтобы вы знали, что можете использовать и новые хуки React.

Хуки были включены в React 16.8 в качестве нового дополнения для поддержки доступа к состоянию без использования класса. Они просты в применении и становятся все более популярным дополнением к React. Если хотите изучить возможность их использования, можете получить дополнительную информацию в интернете: https://reactjs.org/docs/hooks-intro.html.


## События в React
---

В React имена событиям присваиваются с помощью **`camelCase`**, а JSX используется для передачи функции в качестве обработчика событий, а не строки. Кроме того, события React работают не совсем так, как собственные события JavaScript, поскольку вашим обработчикам передаются экземпляры кросс-браузерной оболочки вокруг собственного события браузера под названием **`syntheticEvent`**. Причина этого кроется в том, что React нормализует события, чтобы они имели согласованные свойства в разных браузерах. Однако если вам понадобится доступ к событию браузера, вы всегда можете использовать атрибут **`nativeEvent`**, чтобы получить его.

Для иллюстрации использования событий в React в **примере 24.6** приведен простой пример события **`onClick`**, которое удаляет или повторно отображает некоторый текст при нажатии на него.

>**Пример 24.6.** Настройка события
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Event handling</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class Toggle extends React.Component
      {
        constructor(props)
        {
          super(props)
          this.state       = {isVisible: true}
          this.handleClick = this.handleClick.bind(this)
        }

        handleClick()
        {
          this.setState(state => ({isVisible: !state.isVisible}))
        }

        render()
        {
          const show = this.state.isVisible

          return (
            <div>
              <button onClick={this.handleClick}>
                {show ? 'HIDE' : 'DISPLAY'}
              </button>
              <p>{show ? 'Here is some text' : ''}</p>
            </div>
          )
        }
      }

      doRender(<Toggle />, 'display')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <div id='display' style='font-family:monospace'></div>
  </body>
</html>
```

В конструкторе нового класса **`Toggle`** свойству **`isVisible`** присваивается значение **`true`** и устанавливается **`this.state`**:

```js
this.state = {isVisible: true}
```

Затем с помощью метода **`bind`** к нему присоединяется обработчик события **`handleClick`**:

```js
this.handleClick = this.handleClick.bind(this)
```

После завершения работы конструктора следующим будет действовать обработчик события **`handleClick`**. Он содержит однострочную команду для переключения состояния **`isVisible`** между **`true`** и **`false`**:

```js
this.setState(state => ({isVisible: !state.isVisible}))
```

В завершение мы воспользуемся вызовом метода **`render`**, который возвращает два элемента, расположенные внутри **`<div>`**. Причина этого заключается в том, что **`render`** может возвращать только один компонент или тег XML, поэтому два элемента объединяются в один, чтобы удовлетворить это требование.

Возвращаемые элементы представляют собой кнопку, которая отображает либо текст **`DISPLAY`**, если следующий текст в данный момент скрыт (то есть для **`isVisible`** установлено значение **`false`**), либо **`HIDE`**, если для **`isVisible`** установлено значение **`true`** и текст в данный момент виден. После этой кнопки отображается некоторый текст, если значение **`isVisible`** равно **`true`**, в противном случае ничего не отображается (фактически возвращается пустая строка, что, по сути, одно и то же).

Чтобы решить, какой текст кнопки отображать, а также показывать или не показывать текст, используется тернарный оператор, который вы будете вызывать, придерживаясь синтаксиса

```js
expression ? return this if true : or this if false.
```

Это делается с помощью односложного выражения переменной **`show`**, которая извлекает свое значение из **`this.state.isVisible`**. Если значение равно **`true`**, кнопка показывает **`HIDE`** и текст отображается, в противном случае кнопка показывает **`DISPLAY`** и текст не отображается. При загрузке в браузер результат выглядит следующим образом (**`[HIDE`**] и **`[DISPLAY]`** — кнопки):

```html
[HIDE]
Какой-нибудь текст
```

Когда кнопка нажата, она меняется только следующим образом:

```html
[DISPLAY]
```

>[!danger] ИСПОЛЬЗОВАНИЕ JSX В НЕСКОЛЬКИХ СТРОКАХ
>Хотя вы можете разделить свой JSX на множество строк для улучшения читабельности, как показано в предыдущем примере, единственное, чего вы не можете делать, — перемещать скобку после команды **`return`** вниз по строке или куда-либо еще. Она должна оставаться на своем месте после **`return`**, иначе будут выданы синтаксические ошибки. Однако закрывающая скобка может появиться там, где вы пожелаете.


### Встроенные условные утверждения JSX
---

В JSX есть способ возвращать XML только в том случае, если условие **`true`**, что позволяет осуществлять условный рендеринг. Это достигается благодаря тому, что **`true && expression`** оценивается как **`expression`**, а **`false && expression`** — как **`false`**. Поэтому, допустим, в **примере 24.7** две переменные настраиваются так, как будто они являются частью игры: **`this.highScore`** устанавливается на 90, а **`this.currentScore`** — на 100.

>**Пример 24.7.** Условное утверждение JSX
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>JSX conditional statement</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class Setup extends React.Component
      {
        constructor(props)
        {
          super(props)
          this.highScore    = 90
          this.currentScore = 100
        }

        render()
        {
          return (
            <div>
              {
                this.currentScore > this.highScore &&
                  <h1>New High Score</h1>
              }
            </div>
          )
        }
      }

      doRender(<Setup />, 'display')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <div id='display' style='font-family:monospace'></div>
  </body>
</html>
```

В данном случае если значение **`this.currentScore`** больше значения **`this. highScore`**, то возвращается элемент **`h1`**, в противном случае возвращается значение **`false`**. Результат работы кода в браузере выглядит следующим образом:

```html
Новый рекорд
```

Конечно, в реальной игре вы бы затем установили **`this.highScore`** на значение **`this.currentScore`** и, вероятно, сделали бы еще несколько вещей, прежде чем вернуться к игровому коду.

Таким образом, везде, где что-то должно отображаться, только если условие **`true`**, оператор **`&&`** — отличный способ добиться этого. И конечно, вы только что видели (в конце раздела [[#События в React|«События в React»]] ранее в этой главе), как можно создать блок **`if...then...else`** в JSX с использованием тернарного выражения (**`?:`**).


### Использование списков и ключей
---

Отображать списки с помощью React проще простого. В **примере 24.8** массив **`cats`** содержит список из четырех типов кошек. В следующей строке кода он извлекается с помощью функции **`map`**, которая выполняет итерацию по массиву, возвращая каждый элемент по очереди в переменную **`cat`**. В результате каждая итерация встраивается в пару тегов **`<li>...<li>`** и затем добавляется к строке **`listofCats`**.

>**Пример 24.8.** Отображение списка
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Using lists</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      const cats       = ['lion', 'tiger', 'cheetah', 'lynx']
      const listofCats = cats.map((cat) => <li>{cat}</li>)
      
      doRender(<ul>{listofCats}</ul>, 'display')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <div id='display' style='font-family:monospace'></div>
  </body>
</html>
```

В конце вызывается **`doRender`**, встраивающий **`listofCats`** в пару тегов **`<ul>...</ul>`**, результат которого отображается следующим образом:

```html
• лев
• тигр
• гепард
• рысь
```


#### Уникальные ключи
---

Если при выполнении **примера 24.8** у вас была открыта консоль JavaScript (обычно это делается нажатием `Ctrl+Shift+J` или `Option+Command+J` на Mac), вы могли заметить предупреждающее сообщение «Каждый дочерний элемент в списке должен иметь уникальное свойство “ключ”».

Хотя это и не обязательно, React работает лучше всего, когда вы предоставляете индивидуальный ключ для каждого элемента списка родственных элементов, что помогает ему находить ссылки на соответствующие узлы DOM и, когда вы вносите небольшие изменения, позволяет вносить незначительные коррективы в DOM вместо того, чтобы требовать повторной визуализации больших разделов. Предоставление именно такого ключа показано в **примере 24.9.**

>**Пример 24.9.** Использование индивидуальных ключей
```html
  <script type="text/babel">
    var uniqueId = 0
    const cats = ["лев", "тигр", "гепард", "рысь"]
    
    const listofCats = cats.map((cat) => <li key={uniqueId++}>           {uniqueId + ' ' + cat}</li>)
    
    doRender(<ul>{listofCats}</ul>, "display")
 </script>
```

В этом примере была создана переменная **`uniqueId`**, которая увеличивается при каждом ее использовании, так что, например, первый ключ станет равным 1. Отображаемый вывод будет таким же, как и в предыдущем примере, но если вы хотите увидеть сгенерированные ключи (просто ради интереса), можете изменить содержимое элемента **`li с {cat} на {uniqueId – 1 + ' ' + cat}`** — и увидите следующее (- 1 используется потому, что **`uniqueId`** уже был увеличен к моменту ссылки на него, так что нам нужно посмотреть, какое значение было до увеличения):

```html
• 0 лев
• 1 тигр
• 2 гепард
• 3 рысь
```

«Но какой в этом смысл?» — спросите вы. Что ж, рассмотрим следующую структуру списка:

```html
<ul> // Города Европы
  <li>Бирмингем</li>
  <li>Париж</li>
  <li>Милан</li>
  <li>Вена</li>
</ul>
<ul> // Города США
  <li>Цинциннати</li>
  <li>Париж</li>
  <li>Чикаго</li>
  <li>Бирмингем</li>
</ul>
```

Здесь показаны два набора списков, каждый из которых имеет по четыре уникальных родственных элемента, но между списками на одном уровне вложенности находятся два названия городов, Бирмингем и Париж. Когда React выполняет определенные действия согласования (возможно, после изменения порядка или модификации элемента), бывают случаи, когда вы можете добиться увеличения скорости и, возможно, избежать проблем, если элементы списка родственных элементов на одном уровне имеют одинаковые значения. Для этого можете задать индивидуальные ключи для всех родственных элементов, которые для React могут выглядеть следующим образом:

```html
<ul> // Города Европы
  <li key = "1">Бирмингем</li>
  <li key = "2">Париж</li>
  <li key = "3">Милан</li>
  <li key = "4">Вена</li>
</ul>
<ul> // Города США
  <li key = "5">Цинциннати</li>
  <li key = "6">Париж</li>
  <li key = "7">Чикаго</li>
  <li key = "8">Бирмингем</li>
</ul>
```

Теперь не будет шанса перепутать Париж в Европе с Парижем в США (или по крайней мере придется потрудиться, чтобы найти и, возможно, перенаправить правильный узел DOM), поскольку каждый элемент массива имеет уникальный идентификатор для React.

>[!info]
>Не стоит слишком беспокоиться о том, зачем вы создаете эти индивидуальные ключи. ==Просто помните: React работает лучше всего, когда они созданы, и хорошее эмпирическое правило заключается в том, что элементам внутри карты вызова понадобятся ключи.== Кроме того, вы можете повторно использовать ключи для разных наборов родственных элементов, которые никак не связаны между собой. Однако, возможно, вам не придется создавать собственные ключи, поскольку данные, с которыми вы работаете, вполне могут предоставить их вам, например номера ISBN книги. В крайнем случае можете просто использовать индекс элемента в качестве его ключа, но повторные заказы могут стать медленными и вы можете столкнуться с другими проблемами, поэтому создание собственных ключей обычно является наилучшим вариантом, чтобы контролировать то, что они содержат.


## Обработка форм
---

В React формы **`<input type='text'>`**, **`<textarea>`** и **`<select>`** ==функционируют сходным образом, так как внутреннее состояние React становится так называемым источником истины, поэтому эти компоненты называются== *управляемыми*.

Значение входного сигнала всегда определяется состоянием React при наличии *управляемого компонента*. Это означает, что вам придется написать немного больше кода в React, однако в итоге вы получите преимущество — сможете передавать значения другим элементам пользовательского интерфейса или получать к ним доступ из обработчиков событий.

Обычно без загрузки React или любой другой платформы или библиотеки элементы формы поддерживают свое собственное состояние, которое обновляется на основе ввода, полученного от пользователя. В React изменяемое состояние обычно хранится в свойстве компонентов **`state`** и должно обновляться только с помощью функции **`setState`**.


### Использование текстовых полей
---

Рассмотрим эти три типа ввода, начиная с простого текстового поля, например такого:

```html
<form>
  Имя: <input type='text' name='name'>
  <input type='submit'>
</form>
```

Этот код запрашивает ввод строки символов, которая затем отправляется при нажатии кнопки **Отправить** либо нажатии клавиши **Ввод** или **Возврат**. В **примере 24.10** мы изменим это на управляемый компонент React.

>**Пример 24.10.** Использование ввода текста
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Using text input</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class GetName extends React.Component
      {
        constructor(props)
        {
          super(props)
          this.state    = {value: ''}
          this.onChange = this.onChange.bind(this)
          this.onSubmit = this.onSubmit.bind(this)
        }

        onChange(event)
        {
          this.setState({value: event.target.value})
        }

        onSubmit(event)
        {
          alert('You submitted: ' + this.state.value)
          event.preventDefault()
        }

        render()
        {
          return (
            <form onSubmit={this.onSubmit}>
              <label>
                Name:
                <input type="text" value={this.state.value}
                                onChange={this.onChange} />
              </label>
              <input type="submit" />
            </form>
          )
        }
      }

      doRender(<GetName />, 'display')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <div id='display' style='font-family:monospace'></div>
  </body>
</html>
```

Рассмотрим этот процесс по частям. Сначала мы создадим новый класс **`GetName`**, который будет использоваться для создания формы, запрашивающей ввод имени. Данный класс содержит два обработчика событий — **`onChange`** и **`onSubmit`**. Это локальные обработчики, которые устанавливаются для переопределения стандартных обработчиков одноименных событий JavaScript с помощью вызовов **`bind`** в конструкторе, который также является местом, где значение в **`value`** инициализируется пустой строкой.

При вызове прерывания **`onChange`** новый обработчик **`onChange`** вызывает функцию **`setState`** для обновления значения при каждом изменении ввода, чтобы значение всегда обновлялось в соответствии с содержимым поля ввода.

Когда срабатывает событие **`onSubmit`**, оно обрабатывается новым обработчиком **`onSubmit`**, который в данном случае выдает всплывающее окно предупреждения, чтобы мы могли видеть, что оно сработало. Поскольку мы имеем дело с событием, а не с системой, затем следует предотвратить попадание события в систему с помощью вызова **`preventDefault`**.

Наконец, метод **`render`** содержит весь HTML-код, который должен быть выведен на экран в **`<div>`**. Конечно, для этого мы используем HTML, отформатированный как XML, поскольку именно этого ожидает Babel (а точнее, синтаксис JSX). В данном случае просто требуется дополнительное самозакрытие элементов ввода с помощью **`/>`**.

>[!info]
>Мы не переопределяли события **`onChange`** и **`onSubmit`** глобально, так как привязали события, выданные отображаемым кодом, только к локальным обработчикам событий в классе **`GetName`**. Поэтому можно безопасно использовать одинаковые имена для обработчиков событий, что помогает сделать назначение нашего кода более очевидным для других разработчиков. Но если у вас когда-нибудь возникнут какие-то сомнения, можете использовать для своих обработчиков другие имена, например **`actOnSubmit`** и т. д.

Итак, вы уже должны видеть, что **`this.state.value`** будет отражать состояние поля ввода, поскольку, как говорилось ранее, в случае управляемого компонента значение всегда определяется состоянием React.


### Использование текстовых областей
---

Одна из идей, лежащих в основе использования React, заключается в поддержании кросс-браузерного контроля над DOM для быстрого и простого доступа, а также оптимизации и упрощения процесса разработки. Применяя управляемые компоненты, мы всегда держим ситуацию под контролем и можем обеспечить одинаковый ввод данных всех типов.

В **примере 24.11** предыдущий пример был изменен — использован элемент **`<textarea>`** для ввода.

>**Пример 24.11.** Использование элемента **`textarea`**
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Using textarea</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class GetText extends React.Component
      {
        constructor(props)
        {
          super(props)
          this.state    = {value: ''}
          this.onChange = this.onChange.bind(this)
          this.onSubmit = this.onSubmit.bind(this)
        }

        onChange(event)
        {
          this.setState({value: event.target.value})
        }

        onSubmit(event)
        {
          alert('You submitted: ' + this.state.value)
          event.preventDefault()
        }

        render()
        {
          return (
            <form onSubmit={this.onSubmit}>
              <label>
                Enter some text:<br />
                <textarea rows='5' cols='40' value={this.state.value}
                                          onChange={this.onChange} />
              </label><br />
              <input type="submit" />
            </form>
          )
        }
      }

      doRender(<GetText />, 'display')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <div id='display' style='font-family:monospace'></div>
  </body>
</html>
```

Этот код очень похож на пример ввода текста с несколькими простыми изменениями: этот класс теперь называется **`GetText`**, ввод текста в методе **`render`** заменен на элемент **`<textarea>`**, для которого установлено значение 40 столбцов в ширину и 5 строк в высоту, и добавлена пара элементов **`<br>`** для форматирования. И это все — больше ничего не нужно было менять, чтобы мы могли полностью контролировать поле ввода **`<textarea>`**. Как и в предыдущем примере, значение **`this.state.value`** всегда будет отражать состояние поля ввода.

Конечно, этот тип ввода поддерживает использование клавиш **Ввод** или **Возврат** для ввода возврата каретки в поле, поэтому теперь ввод может быть представлен только нажатием на кнопку.


### Использование атрибута **`select`**
---

Прежде чем показывать, как использовать **`<select>`** в React, рассмотрим типичный фрагмент HTML-кода, в котором пользователю на выбор предлагаются несколько стран, причем по умолчанию выбирается США:

```html
<select>
  <option value="Australia">Австралия</option>
  <option value="Canada" >Канада</option>
  <option value="UK" >Великобритания</option>
  <option selected value="USA" >США</option>
</select>
```

В React это должно быть обработано немного по-другому, поскольку в элементе **`select`** используется атрибут **`value`** вместо атрибута **`selected`**, применяемого к подэлементу **`option`**, как в **примере 24.12**.

>**Пример 24.12.** Использование **`select`**
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Using select</title>

    <script src='react.development.js'    ></script>
    <script src='react-dom.development.js'></script>
    <script src="babel.min.js">            </script>

    <script type="text/babel">
      class GetCountry extends React.Component
      {
        constructor(props)
        {
          super(props)
          this.state    = {value: 'USA'}
          this.onChange = this.onChange.bind(this)
          this.onSubmit = this.onSubmit.bind(this)
        }

        onChange(event)
        {
          this.setState({value: event.target.value})
        }

        onSubmit(event)
        {
          alert('You selected: ' + this.state.value)
          event.preventDefault()
        }

        render()
        {
          return (
            <form onSubmit={this.onSubmit}>
              <label>
                Select a country:
                <select value={this.state.value}
                     onChange={this.onChange}>
                  <option value="Australia">Australia</option>
                  <option value="Canada"   >Canada</option>
                  <option value="UK"       >United Kingdom</option>
                  <option value="USA"      >United States</option>
                </select>
              </label>
              <input type="submit" />
            </form>
          )
        }
      }

      doRender(<GetCountry />, 'display')

      function doRender(elem, dest)
      {
        ReactDOM.render(elem, document.getElementById(dest))
      }
    </script>
  </head>
  <body>
    <div id='display' style='font-family:monospace'></div>
  </body>
</html>
```

И вы снова увидите, что в этом примере мало что изменилось, кроме нового имени класса **`GetCountry`**, которое по умолчанию присваивает **`this.state.value`** значение 'USA', и что типом ввода теперь стал **`<select>`**, но без атрибута selected. Как и в предыдущих двух примерах, значение **`this.state.value`** всегда отражает состояние входных данных.


## React Native
---

У React есть сопутствующий продукт под названием React Native. С его помощью вы можете создавать полноценные приложения как для телефонов и планшетов на базе iOS, так и для Android, просто используя расширенный язык JavaScript JSX, при этом не обязательно понимать Java или Kotlin (для Android) либо Object-C или Swift (для iOS).

Подробное описание и объяснение того, как все это сделать и запустить свои приложения на широком спектре мобильных устройств, выходит за рамки темы данной книги, но в этом разделе я покажу вам, где можно получить необходимое программное обеспечение и информацию.


### Создание приложений React Native
---
Для разработки приложений React Native вам сначала потребуется установить Android Studio (http://developer.android.com/studio) и Java JDK (https://tinyurl.com/getjavajdk).

На компьютере Mac дополнительно нужно установить Xcode из App Store. У пользователей Windows нет простых вариантов, кроме сложной виртуализации или «хакинтоша», для разработки приложений для iOS, поэтому лучше всего иметь доступ к подлинному Mac или хостинг-сервису.

Затем вам нужно будет прочитать документацию по Android Studio (https://developer.android.com/docs), чтобы понимать, как создать виртуальное устройство Android (AVD), и настроить различные переменные среды, такие как ANDROID_HOME, которые должны указывать на установленный JDK. Теперь нужно установить Node.JS с сайта http://nodejs.org/.

После установки Node ознакомьтесь с документацией (https://nodejs.org/en/docs/), если еще не знаете, как им пользоваться. Теперь вы готовы установить React Native, следуя рекомендациям, приведенным в документации по React Native (https://reactnative.dev/docs/environment-setup). После этого можете ознакомиться с учебным пособием на сайте http://reactnative.dev/docs/getting-started, обращая внимание на различия между созданием приложений в Windows и macOS.

Как только все это заработает (может потребоваться некоторое время, чтобы разобраться в том, что вы делаете, и чтобы все начало работать без сбоев), у вас появится фантастическое преимущество: вы можете (в основном) продолжать разрабатывать свои приложения для обеих основных мобильных платформ одновременно, просто используя код React JSX!


#### Дополнительная литература
---

В разработке React Native вам могут помочь несколько онлайн-руководств, которые, на мой взгляд, четко объясняют процесс (спасибо Пабасаре Джаявардхане из Medium, Кевину ван Гелдеру из академии Infinite Red, а также Microsoft). На момент написания книги все они были в режиме онлайн и работали (или могут находиться на archive.org, если что-то уже изменилось). Конечно, если вам нужно узнать больше, ваша любимая поисковая система найдет все, что нужно:

- React Native on Mac OS (https://tinyurl.com/reactnativemac);
- React Native on Windows (https://tinyurl.com/reactnativewindows);
- Microsoft’s Guide to React Native (https://microsoft.github.io/react-nativewindows/).

Хотя в URL-адресе последнего из этих трех источников упоминается только Windows, пособие включает и macOS.


#### Вывод React на новый уровень
---

Теперь, когда вы изучили основы настройки и использования React, можете сделать с ним гораздо больше, особенно если собираетесь создавать с его помощью приложения React Native, но это, к сожалению, выходит за рамки книги. Поэтому для продолжения путешествия по React я рекомендую вам посетить веб-страницу https://reactjs.org/docs/hello-world.html в качестве хорошей отправной точки, где вы сможете ознакомиться с некоторыми из обсуждаемых здесь вещей, прежде чем перейти к еще более мощным возможностям.

Итак, теперь, когда в нашем наборе инструментов есть React (по крайней мере, в достаточном объеме для того, чтобы начать работу), перейдем ко всем преимуществам [[Введение в HTML5|HTML5]].


---