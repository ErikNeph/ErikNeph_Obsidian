---
date of creation: 2024-06-12T19:22:00
tags:
  - JavaScript
  - JS
  - Developing/JS_and_PHP
  - WebDeveloping/JS_and_PHP
  - IT/JS_and_PHP
  - JS_and_PHP
  - Programming/JS_and_PHP
  - ProgrammingLanguage/JS_and_PHP
  - PHP
aliases:
  - Обработка ошибок в JavaScript и PHP
---
---
# Проверка данных и обработка ошибок в JavaScript и PHP



После приобретения основательных знаний по программированию на PHP и JavaScript настало время объединить эти две технологии воедино для создания максимально удобных для пользователей веб-форм.

PHP будет использоваться для создания форм, а JavaScript — для проверки приемлемости и полноты данных на стороне клиента, насколько это возможно до их отправки на сервер. После чего окончательная проверка приемлемости введенных данных будет выполняться программой PHP, которая при необходимости снова выведет форму, чтобы пользователь мог внести в нее изменения.

В процессе изложения данной главы будет рассмотрена проверка данных и применение регулярных выражений как в JavaScript, так и в PHP.


## Проверка данных, введенных пользователем, средствами JavaScript
---

Проверка данных средствами JavaScript должна рассматриваться в качестве помощи пользователям, а не сайтам, поскольку, как я уже неоднократно подчеркивал, нельзя доверять абсолютно ничему, что отправлено на ваш сервер, даже если предположить, что полученные данные проверены с помощью JavaScript. Дело в том, что взломщики могут без особых усилий создать имитацию ваших веб-форм и отправить любые нужные им данные.

Еще одна причина, не позволяющая полагаться на JavaScript при проверке введенных данных, заключается в том, что некоторые пользователи отключают JavaScript или используют браузеры, не поддерживающие этот язык.

Поэтому лучшее, что можно сделать при проверке данных средствами JavaScript, — это выполнить проверку информационного наполнения тех полей, которые не должны оставаться пустыми, обеспечить приведение адресов электронной почты в надлежащий формат и гарантировать то, что введенные значения находятся в пределах ожидаемых границ.


### Документ `validate.html` (часть первая)
---

Рассмотрим стандартную регистрационную форму, используемую большинством сайтов, на которых работать можно только зарегистрированным пользователям. В форме будут запрашиваться *имя*, *фамилия*, *пользовательское имя*, *пароль*, *возраст* и *адрес электронной почты*. В **примере 17.1** показан шаблон, который может применяться для этой формы.

>**Пример 17.1.** Форма с проверкой данных средствами JavaScript (часть первая)
```html
<!DOCTYPE html>
<html>
  <head>
    <title>An Example Form</title>
    <style>
      .signup {
        border:1px solid #999999;
        font:  normal 14px helvetica;
        color: #444444;
      }
    </style>

    <script>
      function validate(form)
      {
        fail  = validateForename(form.forename.value)
        fail += validateSurname(form.surname.value)
        fail += validateUsername(form.username.value)
        fail += validatePassword(form.password.value)
        fail += validateAge(form.age.value)
        fail += validateEmail(form.email.value)

        if   (fail == "")   return true
        else { alert(fail); return false }
      }

      //function validateForename(field)
      //{
      //  return (field == "") ? "No Forename was entered.\n" : ""
      //}
      //
      //function validateSurname(field)
      //{
      //  return (field == "") ? "No Surname was entered.\n" : ""
      //}

      //function validateUsername(field)
      //{
      //  if (field == "") return "No Username was entered.\n"
      //  else if (field.length < 5)
      //    return "Usernames must be at least 5 characters.\n"
      //  else if (/[^a-zA-Z0-9_-]/.test(field))
      //    return "Only a-z, A-Z, 0-9, - and _ allowed in Usernames.\n"
      //  return ""
      //}

      //function validatePassword(field)
      //{
      //  if (field == "") return "No Password was entered.\n"
      //  else if (field.length < 6)
      //    return "Passwords must be at least 6 characters.\n"
      //  else if (! /[a-z]/.test(field) ||
      //           ! /[A-Z]/.test(field) ||
      //           ! /[0-9]/.test(field))
      //    return "Passwords require one each of a-z, A-Z and 0-9.\n"
      //  return ""
      //}

      //function validateAge(field)
      //{
      //  if (isNaN(field)) return "No Age was entered.\\n"
      //  else if (field < 18 || field > 110)
      //    return "Age must be between 18 and 110.\n"
      //  return ""
      //}

      //function validateEmail(field)
      //{
      //  if (field == "") return "No Email was entered.\n"
      //    else if (!((field.indexOf(".") > 0) &&
      //               (field.indexOf("@") > 0)) ||
      //               /[^a-zA-Z0-9.@_-]/.test(field))
      //      return "The Email address is invalid.\n"
      //  return ""
      //}
    </script>
  </head>
  <body>
    <table class="signup" border="0" cellpadding="2" cellspacing="5" bgcolor="#eeeeee">
      <th colspan="2" align="center">Signup Form</th>
      <form method="post" action="adduser.php" onsubmit="return validate(this)">
        <tr><td>Forename</td>
          <td><input type="text" maxlength="32" name="forename"></td></tr>
        <tr><td>Surname</td>
          <td><input type="text" maxlength="32" name="surname"></td></tr>
        <tr><td>Username</td>
          <td><input type="text" maxlength="16" name="username"></td></tr>
        <tr><td>Password</td>
          <td><input type="text" maxlength="12" name="password"></td></tr>
        <tr><td>Age</td>
          <td><input type="text" maxlength="3"  name="age"></td></tr>
        <tr><td>Email</td>
          <td><input type="text" maxlength="64" name="email"></td></tr>
        <tr><td colspan="2" align="center"><input type="submit" value="Signup"></td></tr>
      </form>
    </table>
  </body>
</html>
```

В данном виде эта форма будет только отображаться, но не сможет заниматься самопроверкой, поскольку к ней еще не добавлены основные проверочные функции. Но несмотря на это, если набрать данный код, сохранить его в файле `validate.html`, а затем вызвать файл в браузере, мы получим результат, показанный на **рис. 17.1.**

![[Рис. 17.1. Форма, выведенная кодом из примера 17.1.jpg]]
   >        **Рис. 17.1.** Форма, выведенная кодом из** примера 17.1**

Рассмотрим, из чего состоит этот документ. В первых нескольких строках осуществляется настройка документа и используется небольшой фрагмент кода CSS, предназначенный для улучшения внешнего вида формы. Затем следует выделенная полужирным шрифтом часть документа, относящаяся к JavaScript.

В теги **`<script>`** и **`</script>`** заключена всего одна функция по имени **`validate`**, которая, в свою очередь, вызывает шесть других функций, проверяющих каждое из имеющихся в форме полей. Все они вскоре будут рассмотрены. А сейчас я ограничусь объяснением того, что они возвращают либо пустую строку, если поле проходит проверку, либо сообщение об ошибке, если оно эту проверку не проходит. При наличии любых ошибок сообщения о них выводятся в окне предупреждения, появляющемся благодаря последней строке сценария.

Если поле проходит проверку, то проводившая ее функция возвращает значение true, а если не проходит — **`false`**. Значения, возвращаемые функцией **`validate`**, учитываются при отправке данных формы: если она возвращает **`false`**, данные не отправляются. При этом пользователь получает возможность закрыть появившееся окно предупреждения и внести изменения в данные. Если будет возвращено значение **`true`**, значит, ошибок в полях формы не найдено и форму можно отправлять на сервер.

Во второй части этого примера показан код HTML для формы, где каждое поле и его имя помещены в отдельную строку таблицы. В этом HTML нет ничего сложного, за исключением инструкции **`onSubmit="return validate(this)"`**, помещенной в открывающий тег **`<form>`**. Использование атрибута **`onSubmit`** позволяет при отправке формы вызвать избранную вами функцию. Эта функция может выполнить проверку и вернуть значение либо **`true`**, либо **`false`**, для того чтобы известить о том, разрешена или нет отправка формы.

Параметр **`this`** указывает на текущий объект (то есть на данную форму). Он передается только что рассмотренной функции **`validate`**, которая получает этот параметр в виде объекта **`form`**.

Как видите, внутри HTML-формы JavaScript используется только для того, чтобы вызвать инструкцию **`return`**, помещенную в атрибут **`onSubmit`**. Браузеры, у которых JavaScript отключен или не поддерживается, просто проигнорируют атрибут **`onSubmit`** и беспрепятственно отобразят HTML.


### Документ `validate.html`(часть вторая)
---

Теперь обратимся к коду **примера 17.2**, содержащему набор из шести функций, осуществляющих проверку полей формы. Я предлагаю набрать весь код этой второй части и сохранить его в разделе **`<script>`**`...`**`</script>`** **примера 17.1,** который уже сохранен в файле `validate.html.`

>**Пример 17.2.** Форма, проверяемая средствами JavaScript (вторая часть)
```html
<!DOCTYPE html>
<html>
  <head>
    <title>An Example Form</title>
    <style>
      .signup {
        border:1px solid #999999;
        font:  normal 14px helvetica;
        color: #444444;
      }
    </style>

    <script>
      function validate(form)
      {
        fail  = validateForename(form.forename.value)
        fail += validateSurname(form.surname.value)
        fail += validateUsername(form.username.value)
        fail += validatePassword(form.password.value)
        fail += validateAge(form.age.value)
        fail += validateEmail(form.email.value)

        if   (fail == "")   return true
        else { alert(fail); return false }
      }

      function validateForename(field)
      {
        return (field == "") ? "No Forename was entered.\n" : ""
      }
      
      function validateSurname(field)
      {
        return (field == "") ? "No Surname was entered.\n" : ""
      }

      function validateUsername(field)
      {
        if (field == "") return "No Username was entered.\n"
        else if (field.length < 5)
          return "Usernames must be at least 5 characters.\n"
        else if (/[^a-zA-Z0-9_-]/.test(field))
          return "Only a-z, A-Z, 0-9, - and _ allowed in Usernames.\n"
        return ""
      }

      function validatePassword(field)
      {
        if (field == "") return "No Password was entered.\n"
        else if (field.length < 6)
          return "Passwords must be at least 6 characters.\n"
        else if (! /[a-z]/.test(field) ||
                 ! /[A-Z]/.test(field) ||
                 ! /[0-9]/.test(field))
          return "Passwords require one each of a-z, A-Z and 0-9.\n"
        return ""
      }

      function validateAge(field)
      {
        if (isNaN(field)) return "No Age was entered.\\n"
        else if (field < 18 || field > 110)
          return "Age must be between 18 and 110.\n"
        return ""
      }

      function validateEmail(field)
      {
        if (field == "") return "No Email was entered.\n"
          else if (!((field.indexOf(".") > 0) &&
                     (field.indexOf("@") > 0)) ||
                     /[^a-zA-Z0-9.@_-]/.test(field))
            return "The Email address is invalid.\n"
        return ""
      }
    </script>
  </head>
  <body>
    <table class="signup" border="0" cellpadding="2" cellspacing="5" bgcolor="#eeeeee">
      <th colspan="2" align="center">Signup Form</th>
      <form method="post" action="adduser.php" onsubmit="return validate(this)">
        <tr><td>Forename</td>
          <td><input type="text" maxlength="32" name="forename"></td></tr>
        <tr><td>Surname</td>
          <td><input type="text" maxlength="32" name="surname"></td></tr>
        <tr><td>Username</td>
          <td><input type="text" maxlength="16" name="username"></td></tr>
        <tr><td>Password</td>
          <td><input type="text" maxlength="12" name="password"></td></tr>
        <tr><td>Age</td>
          <td><input type="text" maxlength="3"  name="age"></td></tr>
        <tr><td>Email</td>
          <td><input type="text" maxlength="64" name="email"></td></tr>
        <tr><td colspan="2" align="center"><input type="submit" value="Signup"></td></tr>
      </form>
    </table>
  </body>
</html>
```

Чтобы понять, как работает проверка, рассмотрим по очереди все эти функции, начиная с **`validateForename`**.


#### Проверка имени
---

Предельно лаконичная функция **`validateForename`** воспринимает параметр **`field`**, являющийся значением имени (**`forename`**), переданным ей функцией **`validate`**. Если это значение является пустой строкой, возвращается сообщение об ошибке, если нет, то возвращается пустая строка, свидетельствующая о том, что ошибка не обнаружена.

Если пользователь введет в это поле пробелы, то они будут приняты функцией **`validateForename`**, хотя в качестве имени они не годятся. Этот просчет можно исправить, добавив еще одну инструкцию, удаляющую из поля пустые пространства перед его проверкой на незаполненность, затем воспользоваться регулярным выражением, чтобы убедиться в том, что в поле находится еще что-нибудь, кроме пробелов, или — как это сделано в данном случае — позволить пользователю допустить эту ошибку и «отловить» ее на сервере.


#### Проверка фамилии
---

Код функции **`validateSurname`** похож на код функции **`validateForename`**, он также возвращает сообщение об ошибке, если в качестве фамилии (**`surname`**) была предоставлена пустая строка. Я решил не накладывать ограничения на символы обоих полей, чтобы пользователь мог вводить символы, не входящие в английский алфавит, имеющие дополнительные знаки и т. д.


#### Проверка имени пользователя
---

Код функции **`validateUsername`** немного интереснее, поскольку выполняет более сложную работу. Он должен разрешить использование только тех символов, которые входят в набор **`a–z, A–Z, 0–9, _ и –`**, и гарантировать, что имена пользователей состоят не менее чем из пяти символов.

Код структуры **`if...else`** начинается с возвращения сообщения об ошибке в том случае, если поле не было заполнено. Если значение поля не является пустой строкой, но состоит менее чем из пяти символов, то возвращается другое сообщение об ошибке.

Затем вызывается JavaScript-функция **`test`**, которая сравнивает регулярное выражение (соответствующее любому символу, не входящему в перечень разрешенных) с содержимым поля (см. раздел «Регулярные выражения» данной главы). Встретив хотя бы один недопустимый символ, функция **`test`** возвращает **`true`**, в результате чего функция **`validateUsername`** возвращает сообщение об ошибке.


#### Проверка пароля
---

Такая же технология используется и в функции **`validatePassword`**. Сначала функция проверяет поле на пустоту, возвращая сообщение об ошибке при незаполненном поле. Затем сообщение об ошибке возвращается в том случае, если пароль короче шести символов.

Одно из требований, предъявляемых к паролям, заключается в том, что в них должно быть хотя бы по одному символу в нижнем и в верхнем регистре, а также хотя бы одна цифра, поэтому функция **`test`** вызывается три раза, по одному разу на каждую из этих проверок. Если при любом из таких вызовов будет возвращено значение **`false`**, это будет говорить о том, что одно из условий не выполнено, поэтому будет возвращено сообщение об ошибке. В противном случае будет возвращена пустая строка, свидетельствующая о том, что с паролем все в порядке.


#### Проверка возраста
---

Функция **`validateAge`** возвращает сообщение об ошибке, если значение поля не является числом (что определяется вызовом функции **`isNaN`**) либо введенный возраст меньше 18 или больше 110 лет. У ваших приложений могут быть иные требования к возрастной категории или вообще не быть никаких требований. При успешной проверке также будет возвращена пустая строка.


#### Проверка адреса электронной почты
---

И последняя, наиболее сложная проверка — адреса электронной почты — выполняется с помощью функции **`validateEmail`**. После проверки на существование каких-нибудь введенных данных и возвращения сообщения об ошибке при отсутствии таковых функция дважды вызывает JavaScript-функцию **`indexOf`**. При первом вызове проверяется наличие точки (**`.`**) где-нибудь в поле после первого символа, а при втором — присутствие символа **`@`**, также где-нибудь после первого символа.

Если будут пройдены эти две проверки, вызывается функция **`test`**, чтобы проверить поле на наличие недопустимых символов. Если любая из этих проверок не будет пройдена, то возвращается сообщение об ошибке. Допустимыми в адресе электронной почты считаются буквы в нижнем и верхнем регистрах, символы подчеркивания, тире, точки и символ **`@`**. Все они перечислены в регулярном выражении, передаваемом методу **`test`**. Если не будет найдено ни одной ошибки, возвращается пустая строка, свидетельствующая об успешно пройденной проверке. В последней строке примера сценарий и документ закрываются.

**На рис. 17.2** показан результат нажатия кнопки Зарегистрироваться без заполнения полей.

![[Рис. 17.2. Работа JavaScript-формы с проверкой данных.jpg]]
> 			  **Рис. 17.2.** Работа JavaScript-формы с проверкой данных


### Использование отдельного файла JavaScript
---

Конечно, благодаря универсальности своей конструкции и применимости ко многим типам потенциально востребуемых проверок эти шесть функций становятся идеальными кандидатами для выделения в отдельный файл. Этот файл, к примеру, можно назвать `validate_functions.js` и включить его сразу же после начального блока сценария в **пример 17.1**, используя следующую инструкцию:

```html
<script src="validate_functions.js"></script>
```


## Регулярные выражения
---

Более пристально рассмотрим шаблоны соответствия, созданные нами благодаря использованию *регулярных выражений*, которые поддерживаются как в JavaScript, так и в PHP. Они позволяют выстроить внутри одного выражения более мощные алгоритмы соответствия шаблонам.


### Соответствие, закладываемое в метасимволы
---

Любое регулярное выражение должно быть заключено в слеши (**`/`**). ==Конкретные символы, находящиеся внутри этих слешей, называются== *метасимволами* и имеют специальное предназначение. Например, звездочка (**`*`**) имеет аналогичное (но не вполне такое же) значение, как и звездочки, уже встречавшиеся вам в оболочке или в командной строке Windows. Звездочка означает следующее: ==«Текст, подвергаемый сравнению, может содержать любое количество указанного перед ней символа или не содержать его вообще».==

К примеру, вы ищете имя **Le Guin** и знаете, что оно может быть написано как с пробелом, так и без него. Из-за не вполне обычной разметки текста (кто-нибудь, например, мог вставить лишние пробелы, чтобы выровнять строки по правому краю) нужно вести поиск в следующей строке:

```txt
The difficulty of classifying Le Guin's works
```

Иначе говоря, шаблон должен соответствовать строке **LeGuin**, а также отдельно строкам **Le** и **Guin**, разделенным любым количеством пробелов. Решением может стать установка после пробела звездочки:

```regular
/Le *Guin/
```

В строке, кроме имени **Le Guin**, присутствует множество других символов, но этот шаблон все равно будет работать. Поскольку регулярное выражение соответствует какой-то части строки, проверочная функция вернет истинное значение. А если нужно узнать, что в строке не содержится ничего другого, кроме **Le Guin**? Как в этом убедиться, будет показано чуть позже.

Предположим, что известно о непременном наличии хотя бы одного пробела. В таком случае можно воспользоваться знаком «плюс» (**`+`**), поскольку этот метасимвол требует присутствия хотя бы одного из предшествующих ему символов:

```regular
/Le +Guin/
```


### Нестрогое символьное соответствие
---

Одним из самых полезных метасимволов является точка (**`.`**), поскольку она может соответствовать любому символу, за исключением символа новой строки. Предположим, что выполняется поиск HTML-тегов, которые начинаются с символа **`<`** и заканчиваются символом **`>`**. Проще всего найти тег с помощью следующего регулярного выражения:

```regular
/<.*>/
```

==Точка соответствует любому символу, а звездочка== (**`*`**) ==расширяет действие точки до соответствия нулевому или любому другому количеству символов, что означает: ==«Соответствует всему, что заключено между символами **`<`** и **`>`**, даже если там ничего нет».

Этот шаблон будет соответствовать строкам **`<>`**, **`<em>`**, **`<br>`** и т. д. Но если не требуется, чтобы он соответствовал отсутствию символов **`<>`**, нужно вместо символа **`*`** использовать символ **`+`**:

```regex
/<.+>/
```

Знак «плюс» расширяет действие точки до соответствия одному или нескольким символам, что означает: «Соответствует всему, что находится между символами **`<`** и **`>`**, пока между ними есть хотя бы один символ».

Этот шаблон будет соответствовать **`<em>`** и **`</em>`**, **`<h1>`** и **`</h1>`** и тегам с атрибутами, например:

```html
<a href="www.mozilla.org">
```

К сожалению, знак «плюс» расширит соответствие вплоть до последнего символа **`>`** в строке, поэтому соответствовать шаблону будет и такая строка:

```html
<h1><b>Введение</b></h1>
```

А в ней содержится больше одного тега! Чуть позже в этом разделе я покажу более подходящее решение.

>[!info]
>Если между угловыми скобками использовать только точку и не ставить за ней знаки **`+`** или **`*`**, то она будет соответствовать любому одиночному символу, а шаблон будет соответствовать таким тегам, как **`<b>`** и **`<i>`**, но не будет соответствовать тегам **`<em>`** или **`<textarea>`**.

Если нужно, чтобы соответствие относилось к символу «точка» (**`.`**) как таковому, его действие нужно отключить, поставив перед ним символ «обратный слеш» (**`\`**), поскольку в противном случае точка будет считаться метасимволом, соответствующим любому символу.

К примеру, если нужен шаблон, соответствующий числу с плавающей точкой 5.0, то в нем можно будет использовать следующее регулярное выражение:

```regex
/5\.0/
```

Обратный слеш может отключить действие любого метасимвола, в том числе и еще одного обратного слеша (если в тексте отыскивается соответствие именно обратному слешу). Но слеш может и запутать ситуацию — чуть позже будет показано, как обратные слеши иногда придают следующим за ними символам специальное предназначение.

Только что мы рассмотрели шаблон соответствия числу с плавающей точкой. Но вам наверняка понадобится проверить соответствие не только строке 5.0, но и строке 5., поскольку обе содержат значение одного и того же числа с плавающей точкой. Нужно будет также проверить соответствие строкам 5.00, 5.000 и т. д., ведь разрешено использовать любое количество нулей. Это можно сделать добавлением звездочки:

```regex
/5\.0*/
```


### Группировка с помощью скобок
---

Предположим, что нужно найти соответствие таким возрастающим степеням, как кило, мега, гига и тера. Иными словами, нужно найти соответствие следующим строкам:

```text
1,000
1,000,000
1,000,000,000
1,000,000,000,000
...
```

Здесь мог бы пригодиться знак «плюс», но нужно сгруппировать строку **`,000`** так, чтобы действие этого знака распространялось на нее целиком. Для этого служит следующее регулярное выражение:

```regex
/1(,000)+ /
```

Скобки означают: «При применении какого-нибудь метасимвола наподобие знака “плюс” все это нужно рассматривать как группу». Строки **`1,00,000`** и **`1,000,00`** не будут соответствовать шаблону, поскольку в тексте должен быть символ 1, за которым следует одна или несколько групп, состоящих из запятой и трех нулей.

Пробел после знака «плюс» показывает, что соответствие должно закончиться, как только встретится пробел. Без этого пробела строка **`1,000,00`** будет вычислена соответствующей шаблону, поскольку в расчет будет приниматься только ее первая часть **`1,000,`** а оставшаяся часть **`,00`** будет проигнорирована. Пробел нужен после остальных символов шаблона, чтобы обеспечить продолжение поиска соответствия шаблону до конца числа.


### Символьный класс
---

Иногда требуется установить нестрогое соответствие, но не настолько пространное, чтобы для этого использовать точку. Не строгость придает регулярным выражениям огромную мощность: можно регулировать строгость и не строгость в соответствии с вашими желаниями.

Одним из ключевых элементов поддержки не строгости соответствия является пара квадратных скобок (**`[]`**). Эта пара, как и точка, соответствует всего одному символу, но в эти скобки помещается перечень всех возможных соответствий. При появлении любого из символов этого перечня текст будет соответствовать шаблону. Например, если нужно, чтобы шаблону соответствовали оба написания — американское **gray** и английское **grey** — можно задать следующее регулярное выражение:

```regex
/gr[ae]y/
```

В сравниваемой части текста после **gr** может быть либо **а**, либо **е**. Но должна быть только одна из этих букв: все, что помещается внутри квадратных скобок, соответствует лишь одному символу. ==Группа символов внутри скобок называется ==*символьным классом*.


### Указание диапазона
---

Для указания диапазона внутри квадратных скобок можно использовать дефис (**`-`**). Одной из самых распространенных задач является проверка соответствия отдельной цифре, в которой можно использовать диапазон:

```regex
/[0-9]/
```

Цифры являются настолько распространенным элементом регулярных выражений, что для их представления используется отдельный символ **`\d`**. Его можно использовать для проверки соответствия цифре вместо регулярного выражения в квадратных скобках:

```regex
/\d/
```


### Инвертирование
---

Другим важным свойством квадратных скобок является *инвертирование* символьного класса. За счет помещения знака вставки (**`^`**) после открывающей квадратной скобки можно превратить весь символьный класс в его противоположность. После этого он будет означать: «Соответствует любому символу, за *исключением* следующих». ==Предположим, нужно найти экземпляры строк Yahoo, в которых отсутствует следующий за ними восклицательный знак==. (Официальное название компании содержит восклицательный знак!) Для этого можно использовать такое регулярное выражение:

```regex
/Yahoo[^!]/
```

**`^`**  - ==Если в вкратце то этот знак трактуется как СООТВЕТСТВУЕТ ВСЕМУ КРОМЕ!==
Символьный класс состоит из одного символа — восклицательного знака, но он инвертируется стоящим перед ним символом **`^`**. Вообще-то это не самое лучшее решение задачи. Например, это выражение не позволяет найти соответствие, если Yahoo находится в конце строки, поскольку тогда за этим словом не следует *что-нибудь*, а содержимому квадратных скобок должен соответствовать один символ. В более удачном решении используется упреждающее инвертирование (соответствие чему-нибудь, за чем нет ничего другого), но эта тема выходит за рамки данной книги, поэтому просьба ознакомиться с онлайн-документацией по адресу https://tinyurl.com/regexdocs.


### Более сложные примеры
---

После усвоения понятий символьных классов и инвертирования вы уже готовы к изучению более удачных решений задачи поиска соответствия тегу HTML. Рассматриваемое решение позволяет шаблону не пропустить закрывающую угловую скобку отдельного тега, но по-прежнему соответствовать таким тегам, как **`<em>`** и **`</em>`**, а также тегам с атрибутами, таким как

```html
<a href="www.mozilla.org">
```

Один из вариантов такого решения выглядит следующим образом:

```regex
/<[^>]+>/
```

Это регулярное выражение похоже на результат падения чашки на клавиатуру, после которого она «по-прежнему вполне исправна и работоспособна». Разобьем это выражение на части. На **рис. 17.3** показан последовательный анализ всех его элементов.

![[Рис. 17.3. Разбор типичного регулярного выражения.jpg]]
>			**Рис. 17.3.** Разбор типичного регулярного выражения

**Вот эти элементы:**

- [i]  ***/***   открывающий слеш, указывающий на то, что это регулярное выражение;

- [i] ***<***   открывающая угловая скобка тега HTML. Требует точного соответствия, поскольку не является метасимволом;

- [i] ***`[^>]`*** символьный класс. Сочетание знака вставки и закрывающей угловой скобки `^>` означает: «Соответствует всему, кроме закрывающей угловой скобки»;

- [i] ***+***    допускает любое количество символов, соответствующих предыдущему регулярному выражению **`[^>]`**, если есть хотя бы один соответствующий ему символ;

- [i] ***>***   закрывающая угловая скобка тега HTML. Требует точного соответствия; 

- [i]  **`\`**   закрывающий слеш, указывающий на конец регулярного выражения. 


>[!tip]
>Другое решение задачи поиска соответствия тегам HTML связано с использованием так называемых нежадных инструкций. По умолчанию инструкция поиска соответствия шаблону является жадной, возвращающей наиболее длинное из всех возможных соответствий. При нежадном (или ленивом) поиске соответствия ищется соответствующая строка, наиболее короткая из возможных. Применение нежадного поиска соответствия выходит за рамки темы данной книги, более подробную информацию об этом можно найти по адресу https://tinyurl.com/regexgreedy.

Теперь рассмотрим одно из выражений из **примера 17.1**, которое использовалось в функции **`validateUsername`**:

```regex
/[^a-zA-Z0-9_]/
```

**На рис. 17.4** показан весь набор элементов этого выражения.

![[Рис. 17.4. Разбор регулярного выражения, используемого в функции validateUsername.jpg]]
>**Рис. 17.4.** Разбор регулярного выражения, используемого в функции **`validateUsername`**

**Рассмотрим эти элементы более подробно:**

-   **`/`**       открывающий слеш, указывающий на то, что это регулярное выражение;
-   **`[`**       открывающая квадратная скобка, с которой начинается символьный класс;
-   **`^`**       символ инвертирования: инвертирует все, что находится в скобках;
-   **`a–z`**   представляет любую букву в нижнем регистре;
-   **`A–Z`**   представляет любую букву в верхнем регистре;
-   **`0–9`**   представляет любую цифру;
-   **`_`**       символ подчеркивания;
-   **`–`**       тире;
-   **`]`**       квадратная скобка, закрывающая символьный класс;
-   **`\`**         обратный слеш, указывающий на конец регулярного выражения.

Есть еще пара весьма важных метасимволов. Они «закрепляют» регулярное выражение, требуя его применения в определенном месте. Если знак вставки (**`^`**) присутствует в начале регулярного выражения, то соответствующее выражению строковое значение должно быть в начале строки текста, иначе оно не будет соответствовать шаблону. По аналогии с этим, если знак доллара (**`$`**) ставится в конце регулярного выражения, то соответствующее выражению строковое значение должно находиться в конце строки текста.

>[!info]
>Знак вставки (**`^`**) может запутать ситуацию, поскольку внутри квадратных скобок он означает «инвертировать символьный класс», а в начале регулярного выражения — «соответствовать началу строки». К сожалению, один и тот же символ служит для достижения совершенно разных целей, поэтому при его использовании следует быть особенно внимательными.

Закончим изучение основ регулярных выражений ответом на ранее заданный вопрос: предположим, вам нужно убедиться в том, что в строке нет больше ничего, кроме того, что соответствует регулярному выражению. Что делать в том случае, если нужна строка текста, в которой нет ничего, кроме Le Guin? Можно усовершенствовать ранее рассмотренное регулярное выражение, закрепив его сразу с двух сторон:

```regex
/^Le *Guin$/
```


### Сводная таблица метасимволов
---

В **табл. 17.1** показаны метасимволы, используемые в регулярных выражениях.

>**Таблица 17.1.** Метасимволы регулярных выражений
>![[Таблица 17.1. Метасимволы регулярных выражений.jpg| 699x999]]

После изучения этой таблицы и повторного исследования выражения **`/[^a-zA-Z0-9_]/`** можно понять, что оно легко и просто укорачивается до **`/[^\w]/`**, так как отдельный метасимвол **`\w`** (с буквой **`w`** в нижнем регистре) указывает на символы **`a–z, A–Z, 0–9 и _`**.

Можно проявить еще большую наблюдательность и заметить, что метасимвол **`\W`** (с буквой **`W`** в верхнем регистре) указывает на все символы, за исключением **`a–z, A–Z, 0–9 и _`**. Это позволяет избавиться также от метасимвола **`^`** и использовать для выражения только символы **`/[\W]/`** или пойти еще дальше и не ставить квадратные скобки, поскольку это одиночный символ.

Чтобы дать вам больше пищи для размышлений о том, что и как работает, в **табл. 17.2** показан ряд выражений и описаны ситуации, которым они соответствуют.

>**Таблица 17.2.** Примеры регулярных выражений
>![[Таблица 17.2. Примеры регулярных выражений.jpg]]


### Общие модификаторы
---

В регулярных выражениях можно применять следующие модификаторы.

- **`/g`** — допускает «глобальное» соответствие. Применяется с функцией замены, что позволяет выполнить замену во всех соответствующих местах, а не только в месте первого соответствия.
- **`/i`** — отключает в регулярном выражении чувствительность к регистру букв. Иными словами, вместо **`/[a-zA-Z]/`** можно указать **`/[a-z]/i`** или **`/[A-Z]/i`**.
- **`/m`** — допускает многострочный режим работы, в котором знак вставки (**`^`**) и знак доллара (**`$`**) соответствуют позициям перед любыми символами новой строки в сравниваемой строковой переменной и после них. Обычно при поиске соответствия в многострочной строковой переменной знак **`^`** соответствует только позиции в ее начале, а символ **`$`** — в ее конце.

Например, выражение **`/cats/g`** будет соответствовать обоим появлениям слова **cats** в предложении «*I like cats and cats like me*». Аналогично этому выражение **`/dogs/gi`** будет соответствовать обоим появлениям слова *dogs (Dogs и dogs)* в предложении «*Dogs like other dogs*», поскольку эти модификаторы допускают совместное использование.


### Использование регулярных выражений в JavaScript
---

В JavaScript регулярные выражения используются в основном в двух методах: **`test`** (который вы уже рассматривали) и **`replace`**. Метод **`test`** просто сообщает, соответствует ли его аргумент регулярному выражению, а метод **`replace`** воспринимает второй параметр — строку, которой заменяется текст, соответствующий регулярному выражению. Как и большинство методов, **`replace`** генерирует в качестве возвращаемого значения новую строку, входные данные при этом не изменяются.

Если сравнивать эти два метода, то следующая инструкция просто возвращает **`true`**, позволяя узнать, что слово **`cats`** появляется в строке хотя бы один раз:

```js
document.write(/cats/i.test("Cats are fun. I like cats."))
```

А следующая инструкция заменяет оба имеющихся слова **cats** словом **dogs**, выводя результат на экран. Поиск должен быть глобальным (**`/g`**), чтобы найти все экземпляры этого слова, и нечувствительным к регистру букв (**`/i`**), чтобы найти слова, начинающиеся с большой буквы (**Cats**):

```js
document.write("Cats are fun. I like cats.".replace(/cats/gi,"dogs"))
```

Если испытать эту инструкцию в работе, то проявятся ограничения функции замены: поскольку текст заменяется строго той строкой, которую предписано использовать, первое слово **Cats** заменяется словом **dogs**, а не словом **Dogs**.


### Использование регулярных выражений в PHP
---

В PHP наиболее часто используются следующие функции, в которых применяются регулярные выражения: **`preg_match`**, **`preg_match_all`** и **`preg_replace`**.

Чтобы проверить присутствие слова **`cats`** в любом месте строки, в любой комбинации букв в нижнем и верхнем регистрах, можно воспользоваться функцией **`preg_match`**:

```php
$n = preg_match("/cats/i", "Cats are fun. I like cats.");
```

Поскольку в PHP используется значение **`1`** для **`TRUE`** и значение **`0`** для **`FALSE`**, предыдущая инструкция присвоит переменной **`$n`** значение **`1`**. Первым аргументом функции служит регулярное выражение, а вторым — текст, проверяемый на соответствие. Но функция **`preg_match`** способна выполнять более сложную задачу, поскольку она воспринимает еще и третий аргумент, который показывает, какой именно текст соответствовал регулярному выражению:

```php
$n = preg_match("/cats/i", "Cats are fun. I like cats.", $match);
echo "Количество соответсвий $n: $match[0]";
```

Третий аргумент является массивом (здесь ему присвоено имя **`$match`**). Функция помещает текст, соответствующий регулярному выражению, в первый элемент массива, поэтому если соответствие будет найдено, соответствующий регулярному выражению текст может быть найден в элементе **`$match[0]`**. В данном примере выводимая на экран информация покажет, что соответствующий текст начинался с прописной буквы:

```output
Количество соответствий 1: Cats
```

Если нужно определить все соответствия, используется функция **`preg_match_all`**:

```php
$n = preg_match_all("/cats/i", "Cats are fun. I like cats.", $match);
echo "Количество соответствий $n: ";
for ($j=0 ; $j < $n ; ++$j)
  echo $match[0][$j]." ";
```

Как и в предыдущем случае, функции передан массив **`$match`** и элементу **`$match[0]`** присваиваются найденные соответствия, только теперь они представляют собой подмассив. Для отображения содержимого подмассива в этом примере осуществляется последовательный перебор его элементов с помощью цикла **`for`**.

Если нужно заменить часть строки, можно воспользоваться функцией **`preg_replace`**. В этом примере все встречающиеся слова **`cats`**, независимо от регистра букв, заменяются словами **`dogs`**:

```php
echo preg_replace("/cats/i", "dogs", "Cats are fun. I like cats.");
```

>[!info]
>Тема регулярных выражений слишком обширна, и о ней написана целая книга. Если вам нужна дополнительная информация, я рекомендую статью из «Википедии» (http://bit.ly/regex-wiki) либо веб-сайт по адресу https://www.regular-expressions.info/.


## Повторное отображение формы после проверки данных PHP-программой
---

Вернемся к проверке формы. На данный момент нами создан HTML-документ `validate.html`, который будет отправлен PHP-программе `adduser.php`, но это произойдет только в том случае, если поля пройдут проверку средствами JavaScript или если JavaScript отключен или недоступен.

Теперь настало время создать программу, сохраняемую в файле `adduser.php`. Эта программа получает отправленную форму и проводит собственную проверку, а затем, если проверка не будет пройдена, снова предоставляет форму визитеру. Код, который нужно будет набрать и сохранить (или загрузить с сайта, сопутствующего книге), показан в **примере 17.3.**

>**Пример 17.3.** Программа `adduser.php`
```php
<?php // adduser.php

  // Start with the PHP code

  $forename = $surname = $username = $password = $age = $email = "";

  if (isset($_POST['forename']))
    $forename = fix_string($_POST['forename']);
  if (isset($_POST['surname']))
    $surname  = fix_string($_POST['surname']);
  if (isset($_POST['username']))
    $username = fix_string($_POST['username']);
  if (isset($_POST['password']))
    $password = fix_string($_POST['password']);
  if (isset($_POST['age']))
    $age      = fix_string($_POST['age']);
  if (isset($_POST['email']))
    $email    = fix_string($_POST['email']);

  $fail  = validate_forename($forename);
  $fail .= validate_surname($surname);
  $fail .= validate_username($username);
  $fail .= validate_password($password);
  $fail .= validate_age($age);
  $fail .= validate_email($email);

  echo "<!DOCTYPE html>\n<html><head><title>An Example Form</title>";

  if ($fail == "")
  {
    echo "</head><body>Form data successfully validated:
      $forename, $surname, $username, $password, $age, $email.</body></html>";

    // This is where you would enter the posted fields into a database,
    // preferably using hash encryption for the password.

	exit;
  }

  echo <<<_END

    <!-- The HTML/JavaScript section -->

    <style>
      .signup {
        border: 1px solid #999999;
      font:   normal 14px helvetica; color:#444444;
      }
    </style>

    <script>
      function validate(form)
      {
        fail  = validateForename(form.forename.value)
        fail += validateSurname(form.surname.value)
        fail += validateUsername(form.username.value)
        fail += validatePassword(form.password.value)
        fail += validateAge(form.age.value)
        fail += validateEmail(form.email.value)
      
        if (fail == "")     return true
        else { alert(fail); return false }
      }

      function validateForename(field)
      {
        return (field == "") ? "No Forename was entered.\\n" : ""
      }

      function validateSurname(field)
      {
        return (field == "") ? "No Surname was entered.\\n" : ""
      }

      function validateUsername(field)
      {
        if (field == "") return "No Username was entered.\\n"
        else if (field.length < 5)
          return "Usernames must be at least 5 characters.\\n"
        else if (/[^a-zA-Z0-9_-]/.test(field))
          return "Only a-z, A-Z, 0-9, - and _ allowed in Usernames.\\n"
        return ""
      }

      function validatePassword(field)
      {
        if (field == "") return "No Password was entered.\\n"
        else if (field.length < 6)
          return "Passwords must be at least 6 characters.\\n"
        else if (!/[a-z]/.test(field) || ! /[A-Z]/.test(field) ||
                 !/[0-9]/.test(field))
          return "Passwords require one each of a-z, A-Z and 0-9.\\n"
        return ""
      }

      function validateAge(field)
      {
        if (isNaN(field)) return "No Age was entered.\\n"
        else if (field < 18 || field > 110)
          return "Age must be between 18 and 110.\\n"
        return ""
      }

      function validateEmail(field)
      {
        if (field == "") return "No Email was entered.\\n"
          else if (!((field.indexOf(".") > 0) &&
                     (field.indexOf("@") > 0)) ||
                    /[^a-zA-Z0-9.@_-]/.test(field))
            return "The Email address is invalid.\\n"
        return ""
      }
    </script>
  </head>
  <body>

    <table border="0" cellpadding="2" cellspacing="5" bgcolor="#eeeeee">
      <th colspan="2" align="center">Signup Form</th>

        <tr><td colspan="2">Sorry, the following errors were found<br>
          in your form: <p><font color=red size=1><i>$fail</i></font></p>
        </td></tr>

      <form method="post" action="adduser.php" onSubmit="return validate(this)">
        <tr><td>Forename</td>
          <td><input type="text" maxlength="32" name="forename" value="$forename">
        </td></tr><tr><td>Surname</td>
          <td><input type="text" maxlength="32" name="surname"  value="$surname">
        </td></tr><tr><td>Username</td>
          <td><input type="text" maxlength="16" name="username" value="$username">
        </td></tr><tr><td>Password</td>
          <td><input type="text" maxlength="12" name="password" value="$password">
        </td></tr><tr><td>Age</td>
          <td><input type="text" maxlength="3"  name="age"      value="$age">
        </td></tr><tr><td>Email</td>
          <td><input type="text" maxlength="64" name="email"    value="$email">
        </td></tr><tr><td colspan="2" align="center"><input type="submit"
          value="Signup"></td></tr>
      </form>
    </table>
  </body>
</html>

_END;

  // The PHP functions

  function validate_forename($field)
  {
  	return ($field == "") ? "No Forename was entered<br>": "";
  }
  
  function validate_surname($field)
  {
  	return($field == "") ? "No Surname was entered<br>" : "";
  }
  
  function validate_username($field)
  {
    if ($field == "") return "No Username was entered<br>";
    else if (strlen($field) < 5)
      return "Usernames must be at least 5 characters<br>";
    else if (preg_match("/[^a-zA-Z0-9_-]/", $field))
      return "Only letters, numbers, - and _ in usernames<br>";
    return "";		
  }
  
  function validate_password($field)
  {
    if ($field == "") return "No Password was entered<br>";
    else if (strlen($field) < 6)
      return "Passwords must be at least 6 characters<br>";
    else if (!preg_match("/[a-z]/", $field) ||
             !preg_match("/[A-Z]/", $field) ||
             !preg_match("/[0-9]/", $field))
      return "Passwords require 1 each of a-z, A-Z and 0-9<br>";
    return "";
  }
  
  function validate_age($field)
  {
    if ($field == "") return "No Age was entered<br>";
    else if ($field < 18 || $field > 110)
      return "Age must be between 18 and 110<br>";
    return "";
  }
  
  function validate_email($field)
  {
    if ($field == "") return "No Email was entered<br>";
      else if (!((strpos($field, ".") > 0) &&
                 (strpos($field, "@") > 0)) ||
                  preg_match("/[^a-zA-Z0-9.@_-]/", $field))
        return "The Email address is invalid<br>";
    return "";
  }
  
  function fix_string($string)
  {
    if (get_magic_quotes_gpc()) $string = stripslashes($string);
    return htmlentities ($string);
  }
?>
```

>[!info]
>В этом примере все вводимые данные перед применением обезвреживаются, даже пароли, которые из-за возможного содержания в них символов, используемых для форматирования HTML, будут превращены в HTMLпоследовательности. Например, **`&`** станет **`&amp`**;, а **`<`** превратится в **`&lt`**; и т. д. Если для сохранения зашифрованных паролей будет использоваться функция **`hash`**, это не создаст проблем в том случае, если при последующей проверке введенного пароля он будет обезвреживаться тем же способом и сравниваться будут такие же вводимые данные.

Результат отправки формы при отключенном JavaScript (и двумя неправильно заполненными полями) показан на **рис. 17.5.**

PHP-раздел этого кода и изменения, внесенные в HTML-раздел, выделены полужирным шрифтом, чтобы сделать заметнее все отличия кода этого примера от кода, который был показан в **примерах 17.1 и 17.2.**

Если вы внимательно изучили этот пример либо набрали или загрузили его из хранилища примеров книги, то вы увидели, что код PHP является практически клоном кода JavaScript. Для проверки каждого из полей в очень похожих функциях используются те же самые регулярные выражения.

Но здесь следует отметить две особенности. Во-первых, для обезвреживания содержимого каждого поля и предотвращения любых попыток внедрения кода применяется функция **`fix_string`**, которая находится в самом конце примера.

Во-вторых, вы должны были заметить, что код HTML из **примера 17.1**, повторенный в PHP-коде внутри структуры **`<<<_END..._END`**;, отображает форму со значениями, которые посетитель ввел при предыдущей попытке заполнения формы. Это сделано за счет простого добавления еще одного параметра **`value`** к каждому тегу **`<input>`** (например, **`value="$forename"`**). Проявление такой заботы о пользователе всячески приветствуется, поскольку при этом ему не приходится снова и снова заполнять все поля, а остается лишь отредактировать ранее введенные данные.

![[Рис. 17.5. Форма, отображаемая после того, как она не прошла проверку средствами PHP.jpg]]
> **Рис. 17.5.** Форма, отображаемая после того, как она не прошла проверку                             средствами PHP

>[!info]
>При разработке реального проекта вы вряд ли стали бы сначала создавать HTML-форму вроде той, что показана в **примере 17.1.** Скорее всего, вместо этого вы сразу перешли бы к созданию PHP-программы, показанной в **примере 17.3**, в которую включен весь код HTML. И разумеется, вам потребовались бы небольшие доработки для первого вызова этой программы, чтобы заблокировать отображение ошибок при еще не заполненных полях. К тому же следовало бы выделить шесть функций JavaScript в отдельный включаемый файл с `расширением.js` в соответствии с рекомендациями, изложенными в подразделе «Использование отдельного файла JavaScript» ранее в этой главе.

После рассмотрения способа объединения кода PHP, HTML и JavaScript в следующей главе будет представлена технология Ajax (Asynchronous JavaScript And XML — асинхронный JavaScript и XML) [[Использование технологии асинхронного обмена данными]], в которой используются фоновые JavaScript-вызовы, обращенные к серверу для получения плавного обновления фрагментов веб-страницы, при котором не требуется повторная отправка всего ее содержимого с веб-сервера.


## Вопросы
---

- [ ] 1. Каким методом JavaScript можно воспользоваться, чтобы послать данные формы на проверку перед их отправкой на сервер?
- [ ] 2. Какой метод JavaScript применяется для проверки соответствия строки регулярному выражению?
- [ ] 3. Используя определения синтаксиса регулярных выражений, напишите такое регулярное выражение, которое будет соответствовать любым символам, *не* использующимся в словах.
- [x] 4. Напишите регулярное выражение, которое будет соответствовать как слову **fox**, так и слову **fix**.
- [ ] 5. Напишите регулярное выражение, которое будет соответствовать любому отдельному слову, за которым следует любой символ, не использующийся в словах.
- [x] 6. Используя регулярное выражение, напишите функцию JavaScript, проверяющую наличие слова **fox** в строке **The quick brown fox**.
- [x] 7. Используя регулярное выражение, напишите функцию PHP, заменяющую все экземпляры слова **the** в строке **The cow jumps over the moon** словом **my**.
- [ ] 8. Какой атрибут HTML используется для предварительного заполнения полей формы значениями?


---