---
date of creation: 2024-06-27T20:42:00
tags:
  - JS
  - JS/CSS
  - JavaScript
  - Developing
  - Developing/JS_and_CSS
  - IT
  - IT/JavaScript
  - Design/CSS
Read status: true
aliases:
  - CSS и JavaScript в связке
---
---
# Доступ к CSS из JavaScript
2024-06-27



После того как вы поняли, что такое объектная модель документа — Document Object Model (DOM) и каскадные таблицы стилей — CSS, из этой главы вы узнаете, как к ним можно получать доступ непосредственно из кода JavaScript, что позволит вам создавать высоко динамичные и быстро реагирующие на действия пользователей сайты.

Мы также рассмотрим использование прерываний, что позволит создавать анимацию или предоставлять любой код, который должен продолжать работу на веб-странице (например, часы). Кроме того, я объясню, как в DOM добавляются новые элементы или удаляются существующие элементы, чтобы вам не приходилось заранее создавать элементы в HTML на тот случай, если коду JavaScript может чуть позже понадобиться получить к ним доступ.


## Еще одно обращение к функции **`getElementByld`**
---

В качестве помощи в работе с примерами, приводимыми в остальной части книги, я намереваюсь представить вам улучшенную версию функции **`getElementByld`**, чтобы вы могли работать с элементами DOM и стилями CSS быстро и эффективно, не испытывая потребности включения таких сред, как jQuery.

Но чтобы избежать конфликтов со средами программирования, использующими символ **`$`**, я буду просто применять в качестве имени функции заглавную букву **`O`**, поскольку это первая буква слова Object (объект), а именно объект будет возвращаться при вызове этой функции (тот самый объект, представленный идентификатором ID, переданным функции).



### Функция **`O`**
---

Основа функции O имеет следующий вид:

```js
function O(i)
{
  return document.getElementById(i)
}
```

Только этот код уже сокращает количество набираемого текста при вызове функции на 22 символа, но я намерен немного расширить функцию, позволяя передавать ей либо ID, либо объект, как показано в полной версии функции, представленной в **примере 21.1.**

>**Пример 21.1.** Функция **`O`**
```js
function O(i)
{
  return typeof i == 'object' ? i : document.getElementById(i)
}
```

Если функции передается объект, она просто возвращает его обратно. В противном случае она предполагает, что ей был передан ID, и возвращает объект, на который этот ID ссылается.

Но с какой стати мне захотелось добавить эту первую инструкцию, которая просто возвращает переданный ей объект?



### Функция **`S`**
---

Ответ на данный вопрос станет ясным, когда вы посмотрите на вспомогательную функцию, названную **`S`** и показанную в **примере 21.2**, которую я вам предоставляю для упрощения доступа к стилевым свойствам (или CSS) объекта.

>**Пример 21.2.** Функция **`S`**
```js
function S(i)
{
  return O(i).style
}
```

Для этой функции имя **`S`** выбрано потому, что это первая буква слова **`Style`**, а функция выполняет задачу возвращения свойства стиля (или подчиненного объекта) того элемента, на который она ссылается. Поскольку встроенная функция **`O`** принимает либо ID, либо объект, вы можете передавать функции **`S`** как ID, так и объект.

Рассмотрим, что получится, когда мы возьмем **`<div>`**-элемент с ID **`myobj`** и установим для цвета его текста значение green (зеленый):

```html
<div id='myobj'>Some text</div>
<script>
  O('myobj').style.color = 'green'
</script>
```

Предыдущий код справится с этой задачей, но значительно проще будет вызвать новую функцию **`S`**:
```js
S('myobj').color = 'green'
```

Теперь рассмотрим случай, при котором объект, возвращенный в результате вызова функции **`O`**, сохранен, к примеру, в объекте по имени **`fred`**:
```js
fred = O('myobj')
```

Благодаря тому способу, который используется в работе функции **`S`**, мы можем для изменения цвета на зеленый вызвать и этот объект:
```js
S(fred).color = 'green'
```

Это означает, что при желании получить доступ к объекту непосредственно или через его ID вы можете сделать это, передавая его либо функции **`O`**, либо функции **`S`**, в зависимости от того, что вам нужно. Нужно лишь помнить, что при передаче объекта (а не ID) ни в коем случае не следует брать его имя в кавычки.



### Функция **`C`**
---

==Вам уже предоставлены две простые функции, упрощающие доступ к любому элементу на веб-странице и любому свойству стиля элемента.== Но иногда вам понадобится одновременный доступ более чем к одному элементу. Это можно сделать путем присваивания имени класса CSS каждому такому элементу, как показано в следующем примере, где для каждого элемента применяется класс **`myclass`**:

```html
<div class='myclass'>Содержимое div-контейнера </div>
<p class='myclass'>Содержимое абзаца</р>
```

Если нужен доступ ко всем элементам страницы, использующим конкретный класс, можно обратиться к функции **`C`** (чье имя происходит от первой буквы в слове **`Class`**), показанной в **примере 21.3.** Она вернет массив, состоящий из всех объектов, которые соответствуют предоставленному имени класса.

>**Пример 21.3.** Функция **`C`**
```js
function C(i)
{
  return document.getElementsByClassName(i)
}
```

Для использования эту функцию следует просто вызвать, как показано далее, сохраняя возвращенный массив, чтобы иметь возможность получить доступ отдельно к каждому нужному элементу или (что чаще всего и бывает) ко всем элементам с помощью цикла:

```js
myarray = C('myclass')
```

Теперь вы можете делать с возвращенными объектами все, что нужно, например можете установить для их свойства **`textDecoration`** значение подчеркивания **`'underline'`**:

```js
for (i = 0 ; i < myarray.length ; ++i)
  S(myarray[i]).textDecoration = 'underline'
```

Этот код осуществляет последовательный перебор объектов в **`myarray[]`**, а затем использует функцию **`S`** для ссылки на свойство стиля каждого объекта, задавая для свойства **`textDecoration`** значение **`'underline'`**.

>[!info]
>Очень маловероятно, что вы будете использовать функции **`O`**, **`S`** и **`C`** в коде разработки, потому что у вас, скорее всего, будет собственная или сторонняя платформа для обеспечения этой функциональности, а также многое другое. Но они служат для того, чтобы примеры в этой книге были короткими и хорошо понятными, а также являются простым примером способа улучшить JavaScript.
Включение функций



### Включение функций
---

Функции `O` и `S` используются во всей оставшейся части главы, поскольку делают код короче и понятнее. Поэтому я сохранил их в файле **`OSC.js`** (наряду с функцией `C`, поскольку я полагаю, что она принесет вам большую пользу) в папке Chapter 21 в сопутствующем архиве примеров, который вы можете загрузить из хранилища примеров этой книги.

Они могут быть включены в веб-страницу с помощью следующей инструкции. Ее предпочтительнее поместить в блок **`<head>`** где-нибудь перед любым сценарием, работа которого зависит от вызова этих функций:

```html
<script src='OSC.js'></script>
```

Содержимое файла `OSC.js `показано в **`примере 21.4`**, где все убрано всего лишь в три строки.

>**Пример 21.4.** Файл **`OSC.js`**
```js
function O(i) {return typeof i == 'object' ? i :document.getElementById(i) }
function S(i) { return O(i).style }
function C(i) { return document.getElementsByClassName(i) }
```





## Обращение к свойствам CSS из JavaScript
---

Свойство **`textDecoration`**, ==использовавшееся в ранее показанном примере, представляет свойство CSS, имя которого в обычном виде содержит дефис:== **`text-decoration`**. ==Но поскольку в JavaScript дефис зарезервирован для применения в качестве математического оператора, при доступе к свойству CSS, в имени которого используется дефис, этот дефис нужно опустить и перевести в верхний регистр символ, следовавший непосредственно за ним.==

Еще одним примером может послужить свойство **`font-size`** , на которое в JavaScript при помещении после оператора точки ссылаются как на **`fontSize`**:

```js
myobject.fontSize = '16pt'
```

Вместо этого можно предоставить более развернутый код и воспользоваться функцией **`setAttribute`**, которая поддерживает (и фактически требует) стандартное имя свойства CSS:

```js
myobject.setAttribute('style', 'font-size:16pt')
```




### Некоторые общие свойства
---

С помощью JavaScript вы можете изменить любое свойство любого элемента, имеющегося в веб-документе, примерно так же, как это делается с помощью CSS. Я уже показывал вам, как получить доступ к свойствам CSS, используя либо краткую форму JavaScript, либо функцию **`setAttribute`** (чтобы применить абсолютно такие же имена свойств, как и в CSS). Поэтому я не стану обременять вас детализацией всех этих сотен свойств. Вместо этого я покажу, как получить доступ к некоторым свойствам CSS, чтобы дать обзорное представление о возможностях их применения.

Сначала рассмотрим изменение нескольких свойств CSS из JavaScript, используя код **примера 21.5**, который в первую очередь загружает в себя три ранее упомянутые функции, затем создает **`<div>`**-элемент и, наконец, запускает инструкции JavaScript, находящиеся внутри блока **`<script>`** кода HTML с целью изменения некоторых атрибутов элемента **`<div>`** (**рис. 21.1**).

>**Пример 21.5.** Обращение к свойствам CSS из JavaScript
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Обращение к свойствам</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    <div id='object'>Div-объект</div>

    <script>
      S('object').border     = 'solid 1px red'
      S('object').width      = '100px'
      S('object').height     = '100px'
      S('object').background = '#eee'
      S('object').color      = 'blue'
      S('object').fontSize   = '15pt'
      S('object').fontFamily = 'Helvetica'
      S('object').fontStyle  = 'italic'
    </script> 
  </body>
</html>
```

От такого изменения свойств нет никакой практической пользы, поскольку можно так же легко включить код CSS непосредственно в атрибуты элемента, но скоро мы будем изменять свойства в ответ на действия пользователя, вот тогда и проявится настоящая эффективность сочетания JavaScript и CSS.

![[Рис. 21.1. Изменение стилей из JavaScript.jpg]]
>   **Рис. 21.1.** Изменение стилей из JavaScript




### Другие свойства
---

JavaScript также открывает доступ к очень широкому диапазону других свойств, таких как ширина и высота окна браузера и любых появляющихся или присутствующих в браузере окон или фреймов, и к такой полезной информации, как родительское окно (если таковое имеется) и история URL-адресов, по которым осуществлялись визиты в текущем сеансе.

Все эти свойства доступны из объекта window через оператор «точка» (.) (например, **`window.name`**). В **табл. 21.1** перечислены все эти свойства с описаниями.

>**Таблица 21.1.** Свойства объекта **`window`**
![[Таблица 21.1. Свойства объекта window.jpg]]
![[Таблица 21.1.2 Свойства объекта window.jpg]]

У некоторых из этих свойств есть следующие особенности.

- Свойства **`defaultStatus`** и **`status`** могут быть установлены, только если пользователи изменили настройки своих браузеров и разрешили их применение (что маловероятно).
- Содержимое объекта **`history`** не может быть прочитано (поэтому нельзя посмотреть, какие адреса посещались вашими визитерами), но этот объект поддерживает свойство **`length`** , чтобы определить длину истории, а также методы **`back`**, **`forward`** и **`go`** для переходов на указанные страницы в истории.
- Когда нужно узнать, какое пространство доступно в текущем окне браузера, следует просто прочитать значения свойств **`window.innerHeight`** и **`window.innerWidth`**. Я часто использую эти значения для размещения появляющихся в окне браузера диалоговых окон оповещения и подтверждения по центру.
- Объект **`screen`** поддерживает свойства, доступные только для чтения, **`availHeight`**, **`availWidth`**, **`colorDepth`**, **`height`**, **`pixelDepth`** и **`width`**, поэтому отлично подходит для извлечения информации о дисплее пользователя.

>[!info]
>Многие из этих свойств могут быть просто бесценными при позиционировании на мобильных телефонах и планшетных устройствах, поскольку дадут точную информацию об экранном пространстве, с которым придется работать, о типе используемого браузера и т. д.

Этого объема информации вполне достаточно для начала работы и получения представления о многих новых и интересных приемах работы с JavaScript. Разумеется, существует намного больше доступных свойств и методов, которые могли бы быть рассмотрены в данной главе. Но теперь, когда вы знаете о том, как обращаться к свойствам и использовать их, вам нужен лишь информационный ресурс, на котором все они перечислены. Я рекомендую для начала обратиться к документации на сайте https://tinyurl.com/domexplained.





## Встроенный JavaScript
---

Использование тегов **`<script>`** не единственный способ выполнения инструкций JavaScript. Получить доступ к JavaScript можно также из тегов HTML, что и делается для повышения динамической интерактивности.

Например, для быстрого добавления эффекта при прохождении указателя мыши над объектом можно воспользоваться таким же кодом, который показан в теге **`<img>`** в **примере 21.6**. Там изначально отображается картинка с яблоком, которая при прохождении над ней указателя мыши заменяется картинкой с апельсином (а при выходе указателя за пределы картинки возвращается картинка с яблоком).

>**Пример 21.6.** Использование встроенного JavaScript
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Встроенный JavaScript</title>
  </head>
  <body>
    <img src='apple.png'
      onmouseover="this.src='orange.png'"
      onmouseout="this.src='apple.png'"> 
  </body>
</html>

```




### Ключевое слово **`this`**
---

В предыдущем примере вы можете увидеть применение ключевого слова **`this`**. Оно заставляет JavaScript работать с названным объектом, а именно с тегом **`<img>`**. Результат можно увидеть на **рис. 21.2**, где указатель мыши только что прошел над картинкой с яблоком.

>[!info]
>Когда ключевое слово **`this`** находится во встроенном вызове JavaScript, оно представляет вызываемый объект. А при использовании в методах класса оно представляет объект, к которому применяется метод.

![[Рис. 21.2. Пример встроенного кода JavaScript, обрабатывающего прохождение указателя мыши над объектом.jpg]]
>**Рис. 21.2.** Пример встроенного кода JavaScript, обрабатывающего                  прохождение указателя мыши над объектом




### Привязка событий к объектам в сценарии
---

Предыдущий код является эквивалентом предоставления тегу **`<img>`** идентификатора с последующей привязкой действий к событиям мыши этого тега как в **примере 21.7.**

>**Пример 21.7.** Невстроенный JavaScript
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Невстроенный JavaScript</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    <img id='object' src='apple.png'>

    <script>
      O('object').onmouseover = function() { this.src = 'orange.png' }
      O('object').onmouseout  = function() { this.src = 'apple.png'  }
    </script> 
  </body>
</html>

```

Этот код применяет ID объекта к тегу **`<img>`** в блоке HTML, а затем продолжает работать с ним отдельно в блоке JavaScript, прикрепив к каждому событию безымянную функцию.



### Прикрепление к другим событиям
---

Какой бы JavaScript ни использовался, встроенный или отдельный, существуют события, к которым вы можете прикрепить действия. И активизировать тем самым множество дополнительных функций, которые можете предоставить своим пользователям. В **табл. 21.2** перечислены эти события и указаны условия их наступления.

>**Таблица 21.2.** События и условия их наступления
>![[Таблица 21.2. События и условия их наступления.jpg]]
>![[Таблица 21.2.2 События и условия их наступления.jpg]]

**`*`** - Элемент с фокусом — тот, который был выбран или иным образом активизирован, например поле ввода.

>[!danger]
>События нужно прикреплять только к тем объектам, для которых в них имеется смысл. Например, объект, не являющийся формой, не будет реагировать на событие `onsubmit`.



### Добавление новых элементов
---

Работая с JavaScript, вы можете манипулировать не только элементами и объектами, которые были предоставлены документу его кодом HTML. Вы можете создавать объекты по своему желанию, вставляя их в DOM.

Предположим, к примеру, что вам нужен новый элемент **`<div>`**. Способ добавления его к веб-странице показан в **примере 21.8**.

>**Пример 21.8.** Вставка элемента в DOM
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Добавление элементов</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    В этом документе содержиться только этот текст.<br><br>

    <script>
      alert('Для добавления элемента нажмите кнопку ОК.')

      newdiv    = document.createElement('div')
      newdiv.id = 'NewDiv'
      document.body.append(newdiv)

      S(newdiv).border = 'solid 1px red'
      S(newdiv).width  = '100px'
      S(newdiv).height = '100px'
      newdiv.innerHTML = "Это новый объект, вставленный в DOM"
      
      setTimeout(function()
      {
        alert('Для удаление элемента нажмите кнопку ОК')
      
        newdiv.parentNode.removeChild(newdiv)
      }, 1000)
    </script>
  </body>
</html>
```

На **`рис. 21.3`** показано, как этот код используется для добавления к веб-документу нового **`<div>`**-элемента. Сначала новый элемент создается с помощью функции **`createElement`**, затем вызывается функция **`appendChild`** и элемент вставляется в DOM.

>![[Рис. 21.3. Вставка нового элемента в DOM.jpg]]
>   **Рис. 21.3.** Вставка нового элемента в DOM

После этого элементу присваиваются различные свойства, включая некоторый текст для его внутреннего HTML-кода. И затем, чтобы убедиться, что новый элемент будет мгновенно обнаружен, устанавливается тайм-аут, который сработает через одну секунду в будущем, задерживая выполнение оставшегося кода, чтобы дать DOM время для обновления и отображения, прежде чем снова появится предупреждение об удалении элемента. Подробнее о создании и использовании тайм-аутов написано в разделе «[[#Использование функции **`setTimeout`**|Использование функции setTimeout]]» далее в этой главе. Этот вновь созданный элемент будет точно таким же, как если бы он был включен в исходный HTML, и станет открывать доступ к аналогичным свойствам и методам.

>[!info]
>Иногда я использую технологию создания новых элементов, когда хочу создать окно, появляющееся в окне браузера, потому что она не зависит от наличия запасных **`<div>`**-элементов, доступных в DOM.




### Удаление элементов
---

Вы можете также удалить элементы из DOM, включая те, которые не были вставлены с помощью кода JavaScript. Это даже проще, чем добавить элемент. Если предположить, что удаляется объект **`element`**, то это делается следующим образом:
```js
element.parentNode.removeChild(element)
```

Этот код обращается к объекту **`parentNode`** элемента, поэтому он может удалить элемент из этого узла. Затем он вызывает метод этого родительского объекта **`removeChild`**, передавая ему удаляемый объект.




### Альтернативы добавлению и удалению элементов
---

Вставка элемента предназначена для добавления к веб-странице абсолютно нового объекта. Но если вы намерены только скрывать и показывать объекты в соответствии с наступлением события **`onmouseover`** или какого-нибудь другого события, не забудьте, что есть пара свойств CSS, которые могут использоваться для этой цели без принятия таких радикальных мер, как создание и удаление элементов DOM.

Например, когда нужно сделать элемент невидимым, но оставить его на месте (оставляя на своих местах все окружающие его элементы), можно просто установить для свойства **`visibility`** объекта значение **`'hidden'`**:

```js
myobject.visibility = 'hidden'
```

А для повторного отображения объекта можно воспользоваться следующим кодом:

```js
myobject.visibility = 'visible'
```

Можно также свернуть элемент, чтобы он занимал нулевую ширину и высоту (и чтобы все окружающие его объекты заняли освободившееся пространство):

```js
myobject.display = 'none'
```

Для последующего восстановления элемента в его исходных размерах можно написать такой код:

```js
myobject.display = 'block'
```

И конечно же, в вашем распоряжении всегда есть свойство **`innerHTML`**, с помощью которого можно изменить код HTML, примененный к элементу. Например:

```js
mylement.innerHTML = '<b>Замена HTML</b>'
```

Можно также воспользоваться упомянутой ранее функцией **`O`**:

```js
O('someid').innerHTML = 'Новое содержимое'
```

Можно заставить элемент показаться исчезнувшим:

```js
O('someid').innerHTML = ''
```

>[!info]
>Не забывайте обо всех других полезных свойствах CSS, к которым можно обратиться из JavaScript. Например, для переключения объекта из видимого в невидимое состояние и обратно можно воспользоваться свойством непрозрачности, а для изменения размеров объекта можно изменить значения свойств `width` и `height`. И конечно же, применяя для свойства `position` значения `absolute`, `static`, `fixed`, `sticky` или `relative`, вы можете даже поместить объект в любое место окна браузера (или снаружи).





## Использование прерываний
---

JavaScript предоставляет доступ к *прерываниям*, методу, с помощью которого можно попросить браузер вызвать ваш код после определенного периода времени или даже продолжать вызовы через указанные интервалы времени. Это дает вам средства обработки фоновых задач, таких как обмен данными с помощью Ajax, или даже такие средства, как анимация веб-элементов.

Существует два типа прерываний — **`setTimeout`** и **`setInterval`**, сопровождающиеся функциями **`clearTimeout`** и **`clearInterval`** для их выключения.




### Использование функции **`setTimeout`**
---

При вызове функции **`setTimeout`** ==передается код JavaScript или имя функции и значение в миллисекундах, отображающее продолжительность задержки запуска кода на выполнение==:

```js
setTimeout(dothis, 5000)
```

Ваша функция **`dothis`** может иметь следующий вид:

```js
function dothis()
{
  alert('Это ваш будильник!');
}

```

>[!info]
>Как ни удивительно, вы не можете просто указать **`alert()`** (с круглыми скобками) в качестве функции, вызываемой **`setTimeout`**, потому что функция будет тут же выполнена. Передавать имя функции, чтобы код был выполнен только по истечении указанного времени, можно только без круглых скобок, служащих для указания аргументов (например, **`alert`**).



#### Передача строки
---

Если исполняемой функции нужно передать аргумент, то функции **`setTimeout`** можно также передать строковое значение, которое не будет выполняться, пока не наступит нужное время. Например:

```js
setTimeout("alert('Hello!T\ 5000)
```

Фактически, если после каждой инструкции ставить точку с запятой, можно передать столько строк кода JavaScript, сколько нужно:

```js
setTimeout("document.write('Starting'); alert('Hello!')", 5000)
```



#### Повторение тайм-аутов
---

Для предоставления повторяющихся прерываний, создаваемых функцией **`setTimeout`**, некоторые программисты используют технологию вызова функции **`setTimeout`** из кода, вызываемого этой же функцией, как в следующем примере, который инициирует бесконечный цикл вывода окон предупреждений:

```js
setTimeout(dothis, 5000) function dothis()
{
  setTimeout(dothis, 5000) alert('Я вас раздражаю!')
}
```

Теперь окно предупреждения будет появляться каждые 5 секунд. Я не рекомендую вам запускать этот конкретный пример на выполнение (кроме как в целях тестирования), поскольку для остановки его работы вам, скорее всего, придется закрывать браузер!

>[!info]
>Еще один вариант предполагает использование рассматриваемой далее функции **`setInterval`**. Однако преимущество цепочки **`setTimeout`** состоит в том, что вызов функции **`setTimeout`** выполняется только после выполнения всего предыдущего кода, в то время как **`setInterval`** прерывает выполнение кода, что иногда может не дать желаемого результата.



#### Отмена тайм-аута
---

После установки тайм-аута вы можете отменить его, если предварительно сохранили значение, возвращенное при начальном вызове функции **`setTimeout`**:

```js
handle = setTimeout(dothis, 5000)
```

Теперь, когда у вас есть это значение в переменной **`handle`** (термин, используемый для обозначения того, что у вас есть *маркер* (**`handle`**), с помощью которого вы можете управлять функцией), вы можете отменить прерывание в любой момент, вплоть до истечения назначенного срока:

```js
clearTimeout(handle)
```

В результате этого прерывание полностью забывается и код, назначенный ему для выполнения, никогда не выполняется.




### Функция **`setInterval`**
---

==Самый простой способ установки регулярных прерываний заключается в использовании функции== **`setInterval`**. Она работает точно так же, как и описанная выше, за исключением того, что, проявив себя после интервала, заданного вами в миллисекундах, она сделает это снова, после того как этот же интервал снова пройдет, и так до бесконечности, пока вы ее не остановите.
В **примере 21.9** эта функция используется для вывода в браузере простых часов, показанных на **рис. 21.4**.

>**Пример 21.9.** Часы, созданные с помощью прерываний
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Использование setInterval</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    Текущее время: <span id='time'>00:00:00</span><br>

    <script>
      setInterval("showtime(O('time'))", 1000)

      function showtime(object)
      {
        var date = new Date()
        object.innerHTML = date.toTimeString().substr(0,8)
      }
    </script>
  </body>
</html>
```

>![[Рис. 21.4. Поддержка показаний правильного времени с помощью прерываний.jpg]]
>**Рис. 21.4.** Поддержка показаний правильного времени с помощью                                 прерываний

При каждом вызове функции **`ShowTime`** она присваивает объекту **`date`** текущее время и дату с помощью вызова функции **`Date`**:

```js
var date = new Date()
```

Затем свойству **`innerHTML`** объекта, переданного функции **`showtime`** (то есть **`object`**), присваивается значение текущего времени в часах, минутах и секундах, как определено вызовом функции **`toTimeString`**. В результате возвращается строка **`09:57:17 UTC+0530`**, которая затем усекается до первых восьми символов с помощью вызова функции **`substr`**:



#### Использование функции
---

Чтобы воспользоваться этой функцией, сначала нужно создать объект, свойство **`innerHTML`** которого будет применено для отображения времени как в следующем коде HTML:

```html
Текущее время: <span id='time'>00:00:00</span>
```

Значение 00:00:00 используется лишь для того, чтобы показать, где и как будет отображаться время. В нем нет необходимости, так как оно все равно будет заменено. Затем в блоке кода **`<script>`** вызовите функцию **`setInterval`**:

```js
setInterval("showtime(O('time'))", 1000)
```

Затем сценарий передает функции **`setInterval`** строку, содержащую следующую инструкцию, настроенную на выполнение один раз в секунду (каждые 1000 мс):

```js
showtime(O('time'))
```

В том редком случае, когда кто-нибудь отключил в своем браузере JavaScript (что некоторые делают из соображений безопасности), ваш JavaScript не запустится и пользователь просто увидит исходное значение 00:00:00.



#### Отмена интервала
---

Чтобы остановить повторяющийся интервал, при первой установке интервала путем вызова функции **`setInterval`** вы должны пометить для себя в переменной **`handle`** дескриптор этого интервала:

```js
handle = setInterval("showtime(O('time'))", 1000)
```

Теперь можно остановить часы в любое время, сделав следующий вызов:

```js
clearInterval(handle)
```

Можно также настроить таймер на остановку через определенный период времени:

```js
setTimeout("clearInterval(handle)", 10000)
```

Эта инструкция выдаст прерывание через 10 с (10 000 мс), которое очистит повторяющиеся интервалы.



#### Использование прерываний для анимации
---

Путем сочетания нескольких свойств CSS с повторяющимся прерыванием можно создавать всевозможные анимации и эффекты.

Код в **примере 21.10** перемещает прямоугольник по верхней части окна браузера, все время увеличивая его в размерах (**рис. 21.5**). Когда значение переменной **LEFT** сбрасывается в 0, анимация начинается снова.

>**Пример 21.10.** Простая анимация
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Простая анимация</title>
    <script src="OSC.js"></script>
    <style>
        #box {
            position: absolute;
            background: orange;
            border: 1px solid red;
        }
    </style>
</head>
<body>
    <div id="box"></div>
    <script>
        SIZE = LEFT = 0

        setInterval(animate, 30)

        function animate()
        {
            SIZE += 10
            LEFT += 3

            if (SIZE == 400) SIZE = 0
            if (LEFT == 600) LEFT = 0

            S("box").width = SIZE + "px"
            S("box").height = SIZE + "px"
            S("box").left = LEFT + "px"
        }
    </script>
</body>
</html>
```
>![[Рис. 21.5. Объект плавно движется слева, одновременно меняя свой размер.jpg]]
>**Рис. 21.5.** Объект плавно движется слева, одновременно меняя                            свой размер

В блоке **`<head>`** документа объекту **`box`** устанавливается цвет фона **`orange`** (оранжевый) со значением его границы (**`border`**) **`1px`** **`solid`** **`red`**, а его свойству позиционирования **`position`** задается значение **`absolute`**, и следующий далее код анимации может точно задавать ему позицию в соответствии с вашими желаниями.

Затем в функции **`animate`** происходит постоянное обновление глобальных переменных **`SIZE`** и **`LEFT`**, а их значения применяются к атрибутам стиля **`width`**, **`height`** и **`left`** объекта **`box`** (с добавлением после каждого значения строки **`'px'`** для указания, что значение в пикселах), таким образом анимируя объект с частотой один раз каждые 30 мс. Тем самым задается скорость 33,33 кадра в секунду (1000/30 мс).





## Вопросы
---

- [x] 1. Для чего предназначены функции O, S и C?
- [x] 2. Назовите два способа изменения CSS-атрибута объекта.
- [x] 3. Какие свойства предоставляют доступную в окне браузера ширину и высоту?
- [x] 4. Как можно задать какие-нибудь действия при прохождении указателя мыши над объектом, а затем при выходе за границы объекта?
- [?] 5. Какая функция JavaScript создает новые элементы, а какая — добавляет их к DOM?
- [x] 6. Как сделать элемент: а) невидимым; б) сжатым до нулевых размеров?
- [x] 7. Какая функция задает одиночное событие в будущем времени?
- [x] 8. Какая функция устанавливает повторяющиеся события через указанный интервал времени?
- [?] 9. Как можно освободить элемент от его места на веб-странице, чтобы он мог перемещаться?
- [x] 10. Какая должна быть установлена задержка между событиями (в миллисекундах) для получения скорости анимации 50 кадров в секунду?

---