---
date of creation: 2024-06-14T18:32:00
tags:
  - JS
  - JavaScript
  - IT/JS_and_PHP
  - AJAX/JS
  - WebDeveloping/JS
  - Programming/JS
  - Asynch
  - Asynchrony
  - WebAsynchrony
  - Web/JS
aliases:
  - Асинхронный обмен данных с JS
---
---
# Использование технологии асинхронного обмена данными



==Термин Ajax был придуман в 2005 году. Изначально он расшифровывался как «*асинхронный JavaScript* и XML» (Asynchronous JavaScript and XML), что, проще говоря, означало использование набора методов, встроенных в JavaScript, для обмена данными между браузером и сервером в фоновом режиме. В настоящее время этот термин в основном вышел из употребления, и теперь эту технологию называют просто *асинхронным обменом данными*.==

Превосходным примером применения этой технологии является Google Maps (**рис. 18.1**), где новый участок карты загружается с сервера по мере необходимости, для чего не требуется обновление всей страницы.

Использование асинхронного обмена данными не только приводит к существенному снижению объема данных, передаваемых в обе стороны, но и обеспечивает плавную динамичность веб-страниц, делая их поведение характерным для самостоятельных приложений. В результате значительно улучшается пользовательский интерфейс и ускоряется реакция на действия пользователя.


## Что такое асинхронный обмен данными
---

Используемый в наши дни асинхронный обмен данными берет свое начало в 1999 году с выпуска Internet Explorer 5, где был представлен новый **ActiveX**-объект **`XMLHttpRequest`**. Разработанная в корпорации Microsoft технология ActiveX предусматривает использование дополнительных программных модулей, устанавливаемых на ваш компьютер. Позже разработчики других браузеров поддержали этот почин, но вместо применения **ActiveX** они разработали функциональный модуль, ставший неотъемлемой частью интерпретатора JavaScript.

Но к тому времени уже появилась ранняя форма технологии, использующая на странице скрытые фреймы, которые взаимодействуют с сервером в фоновом режиме. Самыми первыми потребителями этой технологии были участники форумов, которые задействовали ее для опроса и отображения новых сообщений без перезагрузок страницы.

![[Рис. 18.1. Google Maps - превосходный пример использования технологии асинхронного обмена данными.jpg]]
>**Рис. 18.1.** Google Maps — превосходный пример использования технологии                       асинхронного обмена данными

Посмотрим, как реализовать асинхронный обмен данными, используя JavaScript.


## Использование **`XMLHttpRequest`**
---

В прошлом выполнение вызовов Ajax было настоящей головной болью, поскольку существовало множество различных реализаций в разных браузерах и особенно в различных версиях Internet Explorer от Microsoft. К счастью, в наши дни ситуация значительно улучшилась: есть простой объект **`XMLHttpRequest`**, с которым можно работать в едином унифицированном виде.

Так, например, для выполнения запроса GET используйте код наподобие следующего:

```js
let XHR = new XMLHttpRequest()
XHR.open("GET", "resource.info", true)
XHR.setRequestHeader("Content-type", "application/x-www-form-urlencoded") XHR.send()
```

А для выполнения запроса **`POST`** замените **`GET`** на `POST`, все просто.


### Ваша первая программа, использующая асинхронный обмен данными
---

Наберите и сохраните в файле `urlpost.html` код **примера 18.1**, но пока не загружайте его в свой браузер.

>**Пример 18.1.** `urlpost.html`
```html
<!DOCTYPE html>
<html> <!-- urlpost.html -->
  <head>
    <title>Пример асинхронного обмена данными</title>
  </head>
  <body style='text-align:center'>
    <h1>Загрузка веб-страницы в контейнер</h1>
    <div id='info'>Это предложение будет заменено</div>

    <script>
      let XHR = new XMLHttpRequest()

      XHR.open("POST", "/urlpost.php", true)  // http://127.0.0.1/anyfile/urlp..
      XHR.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
      XHR.send("url=news.com")

      XHR.onreadystatechange = function()
      {
        if (this.readyState == 4 && this.status == 200)
        {
          document.getElementById("info").innerHTML = this.responseText
        }
      }
    </script>
  </body>
</html>
```

Разберем этот документ и посмотрим, что он делает, начиная с первых восьми строк, в которых устанавливается, что это HTML-документ, и отображается его заголовок. В следующей строке создается тег **`<div>`** с **`ID info`**, в котором изначально содержится текст: *Это предложение будет заменено*. Позже сюда будет вставлен текст, возвращенный в результате вызова.

После этого создается новый объект `XMLHttpRequest` под названием **`XHR`**. С его помощью ресурс, который необходимо загрузить, открывается вызовом **`XHR.open`**. В данном случае, чтобы избежать проблем с перекрестным происхождением Ajax в современных браузерах, выбран IP-адрес локального хоста **`http://127.0.0.1`**, затем папка [[Использование технологии асинхронного обмена данными]] и программа PHP `urlpost.php`, к которой мы скоро перейдем.

>[!info]
>Если вы настроили сервер разработки, используя **AMPPS** (либо аналогичный WAMP, LAMP или MAMP), рассмотренный в [[Установка сервера, предназначенного для разработки]], загрузили файлы примеров с https://github.com/RobinNixon/lpmj6 и сохранили их в корневом каталоге документов веб-сервера (как описано в этой главе), папка [[Использование технологии асинхронного обмена данными]] будет находиться в месте, нужном, чтобы этот код работал правильно. Если какая-либо часть ваших настроек отличается или вы запускаете этот код на сервере разработки, используя домен по своему выбору, вам придется соответствующим образом изменить эти значения в этом коде.

После указания ресурса для загрузки вызывается **`XHR.setRequestHeader`**, передающий необходимые заголовки для отправки на сервер ресурса, а значение, которое должно быть размещено, отправляется в вызове **`XHR.send`**. В данном случае это главная страница по адресу `news.com`.


### Свойство **`readyState`**
---

Теперь мы наконец добрались до самых тонкостей асинхронного вызова, которые целиком базируются на использовании свойства **`readyState`**. ==Оно позволяет браузерам реагировать на пользовательский ввод и изменять содержимое экрана, при условии, что наша программа настраивает свойство **`onreadystatechange`** на то, чтобы при каждом изменении свойства **`readyState`** вызывалась выбранная нами функция.== В данном случае будет использоваться не отдельная функция, имеющая собственное имя, а безымянная (или анонимная) встроенная функция. Она относится к так называемым *функциям обратного вызова*, поскольку вызывается при каждом изменении свойства **`readyState`**.

Синтаксис объявления функции обратного вызова, в котором применяется встроенная безымянная функция, имеет следующий вид:

```js
XHR.onreadystatechange = function()
{
  if (this.readyState == 4 && this.status == 200)
  {
    // какие-нибудь действия
  }
}
```

Если нужно воспользоваться отдельной функцией, имеющей собственное имя, применяется несколько иной синтаксис:

```js
XHR.onreadystatechange = asyncCallback function asyncCallback()
{
  if (this.readyState == 4 && this.status == 200)
  {
    // какие-нибудь действия
  }
}
```

Как часто бывает, у свойства **`readyState`** могут быть пять значений, но только одно из них представляет для нас интерес — ==значение== **`4`**, ==которое свидетельствует о завершении вызова==. Поэтому при каждом вызове новой функции она возвращает управление без каких-либо действий до тех пор, пока свойство **`readyState`** не получит значение **`4`**. Когда наша функция обнаружит это значение, следующим своим действием она проверит статус вызова, чтобы убедиться в том, что он имеет значение **`200`**, означающее, что вызов прошел удачно.

>[!info]
>Обратите внимание на то, что на все эти свойства объекта идут ссылки **`this.readyState`**, **`this.status`** и т. д. без использования текущего имени объекта XHR как в ссылках **`XHR.readyState`** или **`XHR.status`**. Это сделано для того, чтобы дать вам возможность просто скопировать и вставить код и чтобы он после этого смог работать с любым именем объекта, поскольку ключевое слово **`this`** всегда ссылается на текущий объект.

Итак, после того как установлено, что **`readyState`** равен `4`, а **`status`** равен `200`, мы берем значение в **`responseText`** и помещаем его во внутренний HTML **`<div>`**, которому присвоили идентификатор информации **`id info`**:

```js
document.getElementById("info").innerHTML = this.responseText
```


### Серверная половина процесса асинхронного обмена данными
---

Теперь мы добрались до PHP-половины этого уравнения, которая показана в **примере 18.2**. Наберите этот код и сохраните его в файле `urlpost.php`.

>**Пример 18.2**. `urlpost.php`
```php
<?php // urlpost.php
  if (isset($_POST['url']))
  {
    echo file_get_contents('http://' . SanitizeString($_POST['url']));
  }

  function SanitizeString($var)
  {
    $var = strip_tags($var);
    $var = htmlentities($var);
    return stripslashes($var);
  }
?>
```

Как видите, этот код невелик по объему и использует неизменно актуальную функцию обезвреживания содержимого строки — **`SanitizeString`**, которая должна применяться ко всем отправляемым в адрес сервера данным. В этом случае необезвреженные данные могут привести к получению пользователем возможностей управления вашим кодом.

В этой программе для загрузки веб-страницы, которая находится по URL-адресу, представленному в переменной **`$_POST['url']`**, применяется PHP-функция **`file_get_contents`**. Эта функция обладает достаточной универсальностью, позволяющей ей загружать все содержимое файла или веб-страницы как с локального, так и с удаленного сервера, — она даже учитывает перемещенные страницы и другие перенаправления.

После набора программы можно будет вызвать в браузере файл `urlpost.html`, и через несколько секунд должна появиться первая страница сайта `news.com`, содержимое которой загружено в **`<div>`**-контейнер, созданный нами для этих целей.

>[!info]
>Защита от перекрестного происхождения делает использование Ajax немного более сложным, чем раньше, потому что при загрузке файлов вы должны указывать все точно и ясно. В этом примере на сервере разработки на локальном хосте вам нужно будет ссылаться на файл, используя его IP-адрес. Так, например, если вы сохранили файлы примера в корневом каталоге документов сервера AMPPS, как описано [[Установка сервера, предназначенного для разработки]], то все файлы будут находиться во вложенной папке под названием 18.

Чтобы протестировать программу, введите в свой браузер следующий текст:

```browser
http://127.0.0.1/18/urlpost.html
```

Произойдет это не так быстро, как при непосредственной загрузке веб-страницы, поскольку данные переносятся дважды: сначала на сервер, а потом с сервера на браузер. Результат должен быть похож на тот, что показан на **рис. 18.2.**

Мы не только добились осуществления асинхронного вызова и получения ответа, возвращенного JavaScript, но и воспользовались способностью PHP объединять совершенно не связанные друг с другом веб-объекты. Кстати, если бы мы попытались найти способ извлечения этой веб-страницы непосредственно через асинхронный вызов (без обращения к PHP-модулю на стороне сервера), у нас ничего бы не вышло, поскольку существуют блоки безопасности, не допускающие кросс-доменного применения технологии асинхронного обмена данными. Поэтому данный небольшой пример показывает также удобное решение весьма актуальной практической задачи.

![[Рис. 18.2. Первая страница сайта news.com, загруженная в div-контейнер.jpg]]
>**Рис. 18.2.** Первая страница сайта news.com, загруженная в **`<div>`**-контейнер


### Использование **`GET`** вместо **`POST`**
---

При отправке любых данных из формы можно выбрать **`GET`**-запросы, сэкономив на этом несколько строк кода. Но у таких запросов есть недостаток: некоторые браузеры могут кэшировать `GET`-запросы, при том что **`POST`**-запросы кэшированию никогда не подвергаются. Кэширование запроса нежелательно, потому что браузер просто-напросто заново отобразит то, что он получил в последний раз, и не станет обращаться к серверу за свежими входными данными. Решить эту проблему можно, применив обходной маневр, заключающийся в добавлении к каждому запросу произвольного параметра, обеспечивающего уникальность каждого запрашиваемого URL-адреса.

В коде **примера 18.3** показано, как можно добиться такого же результата, который был получен при использовании кода **примера 18.1**, но на этот раз применяя в Ajax не **`POST-`**, а **`GET-запрос`**.

>**Пример 18.3**. `urlget.html`
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Пример асинхронного обмена данными</title>
</head>
<body style="text-align: center;">
  <h1>Загрузка веб-страницы в DIV-контейнер</h1>
  <div id="info">Это предложение будет заменено</div>
  <script>
    let nocache = "&nocache=" + Math.random() * 1000000
    let XHR = new XMLHttpRequest()
    XHR.open("GET", "/urlget.php?url=news.com" + nocache, true)
    XHR.send()

    XHR.onreadystatechange = function()
    {
      if (this.readyState == 4 && this.status == 200)
      {
        document.getElementById("info").innerHTML = this.responseText
      }
    }
  </script>
</body>
</html>
```

Различия между этими двумя документами, на которые следует обратить внимание, выделены полужирным шрифтом и состоят в следующем.

- Для **`GET`**-запроса не требуется отправка заголовков.
- Метод open вызывается с использованием **`GET`**-запроса с предоставлением URL- адреса, строка которого содержит символ **`?`**, а за ним следует пара «параметр — значение» — `url=news.com`.
- Вторая пара «параметр — значение» начинается с использования символа **`&`**, за которым для параметра **`nocache`** устанавливается случайное значение из диапазона от `0` до `1 000 000`. Такой прием обеспечивает разное содержимое каждого запрашиваемого URL-адреса, что препятствует обслуживанию запросов из кэша.
- Вызов метода **`send`** теперь не имеет аргументов, потому что через **`POST`**-запрос не передается ничего, что требовало бы этого.

Для сопровождения нового документа необходимо изменить PHP-программу так, чтобы она отвечала на **`GET`**-запрос. Файл `urlget.php`, в котором содержится код программы, показан в **примере 18.4**.

>**Пример 18.4.** `urlget.php`
```php
<?php
  if (isset($_GET['url']))
  {
    echo file_get_contents("http://".sanitizeString($_GET['url']));
  }

  function sanitizeString($var)
  {
    $var = strip_tags($var);
    $var = htmlentities($var);
    return stripslashes($var);
  }
?>
```

Единственная разница между этим кодом и кодом **примера 18.2** заключается в том, что ссылка на массив **`$_POST`** заменена ссылкой на массив **`$_GET`**. Конечный результат вызова `urlget.html` в вашем браузере будет идентичен результату вызова `urlpost.html`.

Чтобы протестировать эту измененную версию программы, введите в браузере следующий запрос, и вы увидите тот же результат, что и раньше, только загруженный с помощью запроса **`GET`**, а не **`POST`**:

```browser
http://127.0.0.1/18/urlget.html
```


### Отправка XML-запросов
---

Хотя создаваемые нами объекты называются объектами **`XMLHttpRequest`**, пока мы обходились без использования XML. Вы смогли убедиться в том, что мы запрашивали с помощью асинхронного запроса весь HTML-документ, но могли бы с таким же успехом запросить текстовую страницу, строку либо число или даже данные электронной таблицы.

Внесем изменения в приведенный ранее пример документа и PHP-программы и настроим их на извлечение данных в формате XML. Для этого рассмотрим сначала PHP-программу `xmlget.php`, показанную в **примере 18.5.**

>**Пример 18.5.** `xmlget.php`
```php
<?php
  if (isset($_GET['url']))
  {
    header('Content-Type: text/xml');
    echo file_get_contents("http://".sanitizeString($_GET['url']));
  }
  function sanitizeString($var)
  {
    $var = strip_tags($var);
    $var = htmlentities($var);
    return stripslashes($var);
  }
?>
```

Эта программа по сравнению с предыдущей подверглась небольшому изменению (которое выделено полужирным шрифтом), чтобы перед возвращением извлеченного документа выводился правильный XML-заголовок. Здесь не выполняются никакие проверки, поскольку предполагается, что вызов кода запросит настоящий XML-документ.

Теперь рассмотрим HTML-документ `xmlget.html`, показанный в **примере 18.6.**

>**Пример 18.6.** `xmlget.html`
```html
<!DOCTYPE html>
<html> <!-- xmlget.html -->
  <head>
    <title>Asynchronous Communication Example</title>
  </head>
  <body>
    <h1>Loading XML data into a DIV</h1>
    <div id='info'>This sentence will be replaced</div>

    <script>
      let out = ''
      let nocache = "&nocache=" + Math.random() * 1000000
      let url = "rss.news.yahoo.com/rss/topstories"
      let XHR = new XMLHttpRequest()

      XHR.open("POST", "/xmlget.php?url=" + url + nocache, true)
      XHR.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
      XHR.send()

      XHR.onreadystatechange = function()
      {
        if (this.readyState == 4 && this.status == 200)
        {
          let titles = this.responseXML.getElementsByTagName('title')

          for (let j = 0 ; j < titles.length ; ++j)
          {
            out += titles[j].childNodes[0].nodeValue + '<br>'
          }
          document.getElementById('info').innerHTML = out
        }
      }
    </script>
  </body>
</html>
```

В этом коде все различия также выделены полужирным шрифтом, чтобы вы могли увидеть, что он очень похож на предыдущие версии, за исключением того, что теперь запрашивается URL-адрес **`rss.news.yahoo.com/rss/topstories`**, по которому находится XML-документ, содержащий поток последних новостей Yahoo! News Top Stories feed.

Другое существенное изменение касается использования свойства **`responseXML`**, которым заменено свойство **`responseText`**. Когда сервер возвращает XMLданные, свойство **`responseText`** возвращает значение **`null`**, а свойство **`responseXML`** будет содержать возвращенные XML-данные.

Но **`responseXML`** не просто содержит строку XML-текста — на самом деле в нем находится полноценный объект XML-документа, который может быть проанализирован с использованием методов и свойств DOM-дерева. Это, к примеру, означает, что к нему можно применить JavaScript-метод **`getElementsByTagName`**.


#### Несколько слов о XML
---

Документ XML, как правило, имеет форму RSS-потока, показанного в **примере 18.7**. Но красота XML заключается в том, что этот тип структуры может быть сохранен внутри DOM-дерева **(рис. 18.3)**, что дает возможность выполнять в нем быстрый поиск:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>RSS-поток</title>
    <link>http://website.com</link>
    <description>RSS-поток website.com </description>
    <pubDate>Понедельник, 10 мая 2027 года, 00:00:00 GMT</pubDate>
    <item>
      <title>Заголовок 1</title>
      <guid>http://website.com/headline1</guid>
      <description>Это заголовок</description> </item>
    <item>
      <title>Заголовок 2</title>
      <guid>http://website.com/headline2</guid>
      <description>Второй заголовок</description>
    </item>
  </channel>
</rss>
```
![[Рис. 18.3. DOM-дерево примера 18.7.jpg]]
   >   **Рис. 18.3.** DOM-дерево **примера 18.7**

Затем, используя метод **`getElementsByTagName`**, можно быстро извлечь значения, связанные с различными тегами, не занимаясь громоздким строчным поиском. Именно это и делается в коде **примера 18.6**, где выдается следующая команда:

```js
let titles = this.responseXML.getElementsByTagName('title')
```

За счет выполнения только этой одной команды все значения элементов **`<title>`** помещаются в массив **`titles`**. После этого остается лишь извлечь их с помощью следующего выражения (где **`j`** было присвоено целочисленное значение, представляющее заголовок, к которому осуществляется доступ):

```js
titles[j].childNodes[0].nodeValue
```

Затем все заголовки добавляются к строковой переменной **`out`**, и поскольку все они уже прошли обработку, результат вставляется в пустой **`<div>`**-контейнер в начале документа.

Напомним, что каждый объект наподобие заголовка является узлом, и таким образом, к примеру, текст заголовка считается узлом внутри заголовка. Но даже получив дочерний узел, вы должны запросить его в виде текста, для чего и предназначен метод **`.nodeValue`**. Кроме того, как и в случае со всеми данными формы, помните, что при запросе XML-данных вы можете использовать метод **`POST`** или **`GET`** — ваш выбор на результат не повлияет.

Чтобы проверить эту XML-программу, введите в браузер следующее сообщение, и вы получите результат, похожий на тот, что показан на **[[#^pic-18-4-extracting-a-news-stream-XML-Yahoo|рис. 18.4]]**.

```browser
http://127.0.0.1/18/xmlget.html
```


#### А зачем вообще использовать XML?
---

Может возникнуть вопрос, а для чего еще можно применять XML, кроме как для извлечения XML-документов в виде RSS-потоков? Проще всего ответить, что пользоваться им вас никто не заставляет, но если вам нужно возвращать структурированные данные своим приложениям, то отправка простых неорганизованных фрагментов текста может превратиться в настоящую проблему, для решения которой потребуется довольно сложная обработка в JavaScript.

Вместо этого можно создать XML-документ и вернуть его вызывающей функции, которая автоматически поместит его в DOM-дерево в виде уже знакомого вам легкодоступного HTML DOM-объекта.

В наши дни в качестве формата обмена данными программисты больше склонны к использованию формата [[JSON]] (см. http://json.org), поскольку он является простым подмножеством JavaScript.

![[Рис. 18.4. Извлечение новостного XML-потока Yahoo! в асинхронном режиме.jpg]]
>**Рис. 18.4.** Извлечение новостного XML-потока Yahoo! в асинхронном режиме ^pic-18-4-extracting-a-news-stream-XML-Yahoo


#### Использование специальных платформ для асинхронного обмена данными
---

Теперь, когда вы узнали о том, как создавать собственные процедуры асинхронного обмена данными, можно будет исследовать некоторые из свободно распространяемых программных продуктов, представляющие собой среду, способную упростить работу с применением этой технологии и предлагающую множество более совершенных функциональных возможностей. В частности, я советую обратить внимание на библиотеку jQuery [[Введение в JQuery]], которая является чрезвычайно востребованной платформой для работы, или на React — вероятно, самый быстро растущий фреймворк. А в следующей главе мы рассмотрим применение стилей к вашему сайту с помощью [[Введение в CSS|CSS]].


## Вопросы
---

- [x] 1. Какой объект должен быть создан для реализации асинхронной связи между веб-сервером и клиентом JavaScript?
- [?] 2. Как можно определить завершение асинхронного вызова?
- [x] 3. Как узнать об успешном завершении асинхронного вызова?
- [/] 4. В каком свойстве объекта **`XMLHttpRequest`** содержится текстовый ответ, возвращенный асинхронным вызовом?
- [/] 5. В каком свойстве объекта **`XMLHttpRequest`** содержится XML-ответ, возвращенный Ajax-вызовом?
- [?] 6. Как указать функцию обратного вызова, предназначенную для обработки ответов асинхронного вызова?
- [x] 7. Какой метод объекта **`XMLHttpRequest`** используется для инициирования асинхронного запроса?
- [?] 8. В чем состоит основное различие между **`GET`**- и **`POST`**-запросом при асинхронном обмене данными?


---