---
date of creation: 2024-06-11T17:47:00
tags:
  - JavaScript
  - JS
  - IT
  - Programming
  - WebDeveloping
  - Web
  - Frontend
  - ProgrammingLanguage
---
---
# Выражения и управление процессом выполнения сценариев в JavaScript


В [[Изучение JavaScript]] были изложены основы JavaScript и DOM. А теперь настало время рассмотреть порядок построения в JavaScript сложных выражений и способов управления процессом выполнения ваших сценариев с помощью условных инструкций.


## Выражения
---

Выражения в JavaScript очень похожи на выражения в PHP. В [[Выражения и управление процессом выполнения программы в PHP]] мы выяснили, что выражение представляет собой сочетание значений, переменных, операторов и функций, в результате вычисления которого получается значение, могущее быть числовым, строковым или логическим (вычисляемым либо как истина — **TRUE**, либо как ложь — **FALSE**).

В **примере 15.1** показаны несколько простых выражений. Код каждой строки выводит буквы от а до d, за которыми следуют двоеточие и результат вычисления выражения. Тег **`<br>`** служит для перехода на новую строку и разделения выводимой информации на четыре строки (в HTML5 допустимо применение как **`<br>`**, так и **`<br />`**, но для краткости я выбрал первый стиль).

>**Пример 15.1.** Четыре примера булевых выражений
```html
<script>
  document.write("a: " + (42 > 3) + "<br>")
  document.write("b: " + (91 < 4) + "<br>")
  document.write("c: " + (8 == 2) + "<br>")
  document.write("d: " + (4 < 17) + "<br>")
</script>
```

Этот код выведет следующую информацию:

```html
a: true
b: false
c: false
d: true
```

Заметьте, что выражения **`a:`** и **`d:`** вычисляются как **`true`**, а выражения **`b:`** и **`c:`** как **`false`**. В отличие от языка PHP (который вывел бы число 1 и пустое место соответственно), JavaScript выводит строки **`true`** и **`false`**.

В JavaScript при проверке значения на истинность или ложность все выражения вычисляются как **`true`**, за исключением следующих, которые вычисляются как **`false`**: самой строки **`false`**, 0, -0, пустой строки, **`null`**, неопределенного значения (undefined) и **`NaN`** (Not a Number — «не число», понятие в вычислительной технике для недопустимых операций с числами с плавающей точкой, таких как деление на нуль).

==Учтите, что, в отличие от PHP, в JavaScript значения **`true`** и **`false`** пишутся в нижнем регистре.== Поэтому из следующих двух инструкций информацию будет отображать только первая, выводя на экран слово **`true`** в нижнем регистре, поскольку вторая инструкция вызовет сообщение об ошибке, где будет сказано, что переменная **`TRUE`** не определена:

```js
if (1 == true) document.write('true') // Истина
if (1 == TRUE) document.write('TRUE') // Приводит к ошибке
```

>[!info]
>Следует помнить, что любые фрагменты кода, которые вам захочется набрать и опробовать, запустив их в HTML-файле, нужно заключать в теги **`<script>`** и **`</script>`**.


### Литералы и переменные
---

Простейшей формой выражения является *литерал*, означающий нечто, вычисляемое само в себя, например число 22 или строка «Нажмите клавишу **Enter**». Выражение может также быть переменной, которая вычисляется в присвоенное ей значение. ==И литералы и переменные относятся к типам выражений, поскольку они возвращают значение.==

В **примере 15.2** показаны три разных литерала и две переменные, и все они возвращают значения, хотя и разных типов.

>**Пример 15.2.** Пять типов литералов
```html
<script>
  myname = "Peter"
  myage  = 24
  document.write("a: " + 42     + "<br>") // Числовой литерал
  document.write("b: " + "Hi"   + "<br>") // Строковый литерал
  document.write("c: " + true   + "<br>") // Литерал константы
  document.write("d: " + myname + "<br>") // Литерал строковой переменной
  document.write("e: " + myage  + "<br>") // Литерал числовой переменной
</script>
```

Как и можно было ожидать, в выводимой информации будут показаны значения, возвращаемые всеми этими литералами:

```output
а: 42
b: Hi
c: true
d: Peter
e: 24
```

Операторы позволяют создавать более сложные выражения, вычисляемые в полезные результаты. При объединении присваивания или управляющей конструкции с выражениями получается *инструкция*.

В **примере 15.3** показано по одной инструкции каждого вида. В первой результат выражения **`366 – day_number`** присваивается переменной **`days_to_new_year`**, а во второй приятное сообщение выводится только в том случае, если выражение **`days_to_new_year`**` < 30` вычисляется как **`true`**.

>**Пример 15.3.** Две простые инструкции JavaScript
```html
<script>
  day_number       = 127  // For example
  days_to_new_year = 366 - day_number
  if (days_to_new_year < 30) document.write("It's nearly New Year")
  else                       document.write("It's a long time to go")
</script>
```


### Операторы
---

JavaScript предлагает большое количество мощных операторов, начиная с арифметических, строковых и логических и заканчивая операторами присваивания, сравнения и т. д. (**табл. 15.1**).

>**Таблица 15.1.** Типы операторов JavaScript
>![[Таблица 15.1. Типы операторов JavaScript.jpg]]
>![[Таблица 15.1. Типы операторов JavaScript 2.jpg]]

Различные типы операторов воспринимают разное количество операндов.

- *Унарные* операторы, к примеру операторы инкремента (**`a++`**) или изменения знака числа (**`-a`**), воспринимают один операнд.
- *Бинарные* операторы, представленные основной массой операторов JavaScript (включая операторы сложения, вычитания, умножения и деления), воспринимают два операнда.
- И один *тернарный* оператор, имеющий форму **`? x : у`** и требующий использования трех операндов. Он является краткой однострочной формой инструкции **`if`**, которая выбирает одно из двух выражений на основе значения третьего выражения.


### Приоритетность операторов
---

Как и в PHP, в JavaScript используется приоритетность операторов, благодаря которой одни операторы в выражении обрабатываются до обработки других операторов и поэтому вычисляются в первую очередь.

В **табл. 15.2** перечислены операторы JavaScript, расположенные по уровню их приоритетности.

>**Таблица 15.2.** Операторы JavaScript, расположенные по уровню их приоритетности (сверху вниз)
![[Таблица 15.2. Операторы JavaScript, расположенные по уровню их приоритетности (сверху вниз).jpg]]
![[Таблица 15.2. Операторы JavaScript, расположенные по уровню их приоритетности (сверху вниз) 2.jpg]]


### Взаимосвязанность
---

Большинство операторов JavaScript обрабатываются в уравнении слева направо. Но для некоторых операторов требуется обработка справа налево. Направление обработки обусловливается *взаимосвязанностью* операторов.

Эта взаимосвязанность вступает в силу в отсутствие явно заданной приоритетности (что, кстати, следует делать всегда, поскольку в результате код становится более читабельным и менее подверженным ошибкам). Рассмотрим, например, следующие операторы присваивания, благодаря которым трем переменным присваивается значение 0:

```js
level = score = time = 0
```

Это множественное присваивание становится возможным только благодаря тому, что самая правая часть выражения вычисляется первой, а затем обработка продолжается справа налево. В **табл. 15.3** перечислены операторы JavaScript и их взаимосвязанность.

>**Таблица 15.3.** Операторы и их взаимосвязанность
>![[Таблица 15.3. Операторы и их взаимосвязанность.jpg]]
>![[Таблица 15.3. Операторы и их взаимосвязанность 2.jpg]]


## Операторы отношения
---

Операторы *отношения* проверяют значения двух операндов и возвращают логический результат, равный либо **`true`**, либо **`false`**. Существует три типа операторов отношения: операторы *равенства*, *сравнения* и *логические*.


### Операторы равенства
---

Оператор равенства имеет вид **`==`** (его не следует путать с оператором присваивания **`=`**). В **примере 15.4** первая инструкция присваивает значение, а вторая проверяет это значение на равенство. В данных условиях на экран ничего не будет выведено, потому что переменной **`month`** присвоено значение *`July`* и его сравнение со значением *`October`* будет неудачным.

>**Пример 15.4.** Присваивание значения и проверка на равенство
```html
<script>
  month = "July"
  if (month == "October") document.write("It's the Fall")
</script>
```

Если два операнда выражения равенства принадлежат к разным типам данных, JavaScript приведет их к тому типу, который имеет для него наибольший смысл. Например, любые строки, полностью состоящие из цифр, при сравнении с числом будут преобразованы в числа. В **примере 15.5** у переменных **`а`** и **`b`** два разных значения (одно из них является числом, а второе — строкой), и поэтому вряд ли стоило ожидать, что какая-нибудь из инструкций **`if`** выведет результат.

>**Пример 15.5.** Операторы равенства и тождественности
```html
<script>
  a = 3.1415927
  b = "3.1415927"
  if (a == b)  document.write("1")
  if (a === b) document.write("2")
</script>
```

Тем не менее если запустить код этого примера, вы увидите, что он выведет цифру 1, это будет означать, что первая инструкция **`if`** была вычислена как **`true`**. Это произошло благодаря тому, что строковое значение переменной b было временно преобразовано в число, и поэтому обе половины уравнения получили числовое значение `3.1415927`.

В отличие от этого, вторая инструкция **`if`** использует оператор тождественности — три знака равенства подряд, который препятствует автоматическому преобразованию типов в JavaScript. Таким образом, в данном случае значения **`а`** и **`b`** считаются разными, поэтому на экран ничего не выводится.

Точно так же как при принудительном задании приоритета операторов, если у вас появятся сомнения, связанные с преобразованиями типов операндов, производимыми JavaScript, для отключения этого поведения можно воспользоваться оператором тождественности.


### Операторы сравнения
---

Используя операторы сравнения, можно проверить не только равенство или неравенство. JavaScript предоставляет в ваше распоряжение также операторы **`>`** (больше), **`<`** (меньше), **`>=`** (больше или равно) и **`<=`** (меньше или равно). Код **примера 15.6** показывает эти операторы в действии.

**Пример 15.6.** Четыре оператора сравнения
```html
<script>
  a = 7; b = 11
  if (a > b)  document.write("a is greater than b<br>")
  if (a < b)  document.write("a is less than b<br>")
  if (a >= b) document.write("a is greater than or equal to b<br>")
  if (a <= b) document.write("a is less than or equal to b<br>")
</script>
```

Если **`а`** равно 7, а **`b`** равно 11, то код этого примера выведет следующую информацию (потому что 7 меньше 11, а также меньше или равно 11):

```output
а меньше b
а меньше или равно b
```


### Логические операторы
---

Логические операторы выдают истинные или ложные результаты, поэтому их также называют *булевыми*. В JavaScript используются три логических оператора (**табл. 15.4**).

Код **примера 15.7** показывает возможности использования этих операторов, при которых возвращаются **`0`**, **`1`** и **`true`**.

>**Таблица 15.4.** Логические операторы JavaScript
>![[Таблица 15.4. Логические операторы JavaScript.jpg]]

**Пример 15.7.** Использование логических операторов
```html
<script>
  a = 1; b = 0
  document.write((a && b) + "<br>")
  document.write((a || b) + "<br>")
  document.write((  !b  ) + "<br>")
</script>
```

Оператору **`&&`** для возвращения значения **`true`** нужно, чтобы оба операнда имели значение **`true`**. Оператору **`||`** для возвращения значения **`true`** необходимо, чтобы любой операнд имел значение **`true`**, а третий оператор применяет к значению переменной **`b`** операцию НЕ, превращая ее значение из **`0`** в **`true`**.

При использовании оператора **`||`** могут возникнуть непредвиденные проблемы, поскольку второй операнд не будет вычисляться, если при вычислении первого будет получен результат **`true`**. В **примере 15.8** функция **`getnext`** никогда не будет вызвана, если переменная **`finished`** имеет значение 1 (это просто примеры, и действие **`getnext`** не имеет отношения к данному объяснению — просто думайте о нем как о функции, которая *что-то* делает при вызове).

>**Пример 15.8.** Инструкция, использующая оператор **`||`**
```html
<script>
  if (finished == 1 || getnext() == 1) done = 1
</script>
```

Если *нужно*, чтобы **`getnext`** была вызвана при каждом выполнении инструкции **`if`**, следует переписать код, как показано в **примере 15.9.**

>**Пример 15.9.** Инструкция **`if...or`**, измененная для гарантированного вызова **`getnext`**
```html
<script>
  gn = getnext()
  if (finished == 1 OR gn == 1) done = 1;
</script>
```

В данном случае код функции **`getnext`** будет выполнен и вернет значение, которое будет сохранено в переменной **`gn`** до выполнения инструкции **`if`**.

В **табл. 15.5** показаны все допустимые варианты использования логических операторов. Следует заметить, что выражение **`!true`** эквивалентно **`false`**, а выражение **`!false`** эквивалентно **`true`**.

>**Таблица 15.5.** Все логические выражения, допустимые в JavaScript
>![[Таблица 15.5. Все логические выражения, допустимые в JavaScript.jpg]]


### Инструкция **`with`**
---

Инструкция **`with`** в предыдущих главах, посвященных PHP, не встречалась, поскольку она имеется только в JavaScript, и хотя вам нужно ее знать, вы не должны ее использовать (см. примечание на следующей странице). Используя эту инструкцию (если вы понимаете, что я под этим подразумеваю), можно упростить некоторые типы инструкций JavaScript, сократив множество ссылок на объект до всего одной ссылки. Предполагается, что ссылки на свойства и методы внутри блока **`with`** должны применяться к указанному объекту.

Рассмотрим код **примера 15.10**, в котором функция **`document.write`** нигде не ссылается на переменную **`string`** по имени.

>**Пример 15.10.** Использование инструкции **`with`**
```html
<script>
  string = "The quick brown fox jumps over the lazy dog"

  with (string)
  {
    document.write("The string is " + length + " characters<br>")
    document.write("In upper case it's: " + toUpperCase())
  }
</script>
```

Даже при том, что в **`document.write`** нет непосредственной ссылки на **`string`**, этот код все равно справляется с выводом следующей информации:

```output
В строке 55 символов
В верхнем регистре: ШУСТРАЯ БУРАЯ ЛИСИЦА ПЕРЕПРЫГИВАЕТ ЧЕРЕЗ ЛЕНИВУЮ СОБАКУ
```

Код примера работает следующим образом: интерпретатор JavaScript распознает, что свойство **`length`** и метод **`toUpperCase`** должны быть применены к какому-то объекту. Поскольку они указаны только сами по себе, интерпретатор предполагает, что они применяются к объекту **`string`**, указанному в инструкции **`with`**.

>[!info]
>Использование **`with`** больше не рекомендуется и даже запрещено в строгом режиме ECMAScript 5. Рекомендуемая альтернатива — назначить объект, к свойствам которого вы хотите получить доступ, временной переменной. Обязательно обратите на это внимание, чтобы при необходимости вы могли обновить код своих коллег, увидев там **`with`**, но сами **`with`** не используйте.


### Использование события **`onerror`**
---

Используя либо событие **`onerror`**, либо сочетание ключевых слов **`try`** и **`catch`**, можно перехватить ошибки JavaScript и самостоятельно справиться с ними.

*Событиями* называются действия, которые могут быть обнаружены JavaScript. Каждый элемент на веб-странице имеет конкретные события, которыми могут быть приведены в действие функции JavaScript. Например, событие щелчка **`onclick`**, принадлежащее элементу **`button`** (кнопка), может быть настроено на вызов функции, которая будет запущена, если пользователь нажмет кнопку. В **примере 15.11** показано, как можно воспользоваться событием **`onError`**.

>**Пример 15.11.** Сценарий, использующий событие **`onerror`**
```html
<script>
  onerror = errorHandler
  document.writ("Welcome to this website") // Преднамеренная ошибка

  function errorHandler(message, url, line)
  {
    out  = "Sorry, an error was encountered.\n\n";
    out += "Error: " + message + "\n";
    out += "URL: "   + url     + "\n";
    out += "Line: "  + line    + "\n\n";
    out += "Click OK to continue.\n\n";
    alert(out);
    return true;
  }
</script>
```

В первой строке сценария событию ошибки предписывается впредь использовать новую функцию **`errorHandler`**. Эта функция принимает три параметра: сообщение, URL-адрес и номер строки, поэтому остается лишь отобразить все это в появляющемся окне метода **`alert`**.

Затем для проверки работы новой функции в коде сценария преднамеренно допускается ошибка: вызывается **`document.writ`** вместо **`document.write`** (не ставится последняя буква «e»). На **рис. 15.1** показан результат запуска этого сценария в браузере. Подобное использование события **`onerror`** может пригодиться при отладке сценария.

![[Рис. 15.1. Использование события onerror с методом alert для вывода информации.jpg]]
>**Рис. 15.1.** Использование события **`onerror`** с методом **`alert`** для вывода                                 информации


### Конструкция **`try...catch`**
---

Технология, в которой применяются ключевые слова **`try`** и **`catch`**, считается более стандартной и гибкой, чем обработка события **`onerror`**, показанная в предыдущем разделе. Эти ключевые слова позволяют перехватывать ошибки для избранного раздела кода, а не для всех сценариев, имеющихся в документе. Но данная технология не позволяет перехватывать синтаксические ошибки, для чего приходится применять обработку события **`onerror`**.

Конструкция **`try...catch`** поддерживается всеми основными браузерами и задействуется в тех случаях, когда нужно перехватить управление при наступлении конкретных условий, о которых известно то, что они могут сложиться в определенной части вашего кода.

Например, в [[Использование технологии асинхронного обмена данными]] будет рассматриваться технология **Ajax**, в которой используется объект **`XMLHttpRequest`**. Поэтому для обеспечения совместимости нужно применять **`try`** и **`catch`**, чтобы перехватить управление при отсутствии этого объекта и задействовать какие-нибудь другие технологии. Как это делается, показано в **примере 15.12.**

>**Пример 15.12.** Перехват ошибки с помощью ключевых слов **try** и **catch**
```html
<script>
  try
  {
    request = new XMLHTTPRequest()
  }
  catch(err)
  {
    // Использование другого метода для создания объекта XMLHTTPRequest
  }
</script>
```

Со словами **`try`** и **`catch`** связано еще одно ключевое слово — **`finally`**. Блок кода, следующий за этим словом, выполняется всегда, независимо от того, возникла или не возникла ошибка при выполнении блока кода под ключевым словом **`try`**. Чтобы воспользоваться этим ключевым словом, нужно после инструкции **`catch`** просто добавить что-нибудь похожее на следующий пример:

```js
finally
{
  alert("Был обнаружен блок кода 'try'.")
}
```


## Условия
---

Условия изменяют процесс выполнения программы. Они позволяют задавать конкретные вопросы и по-разному реагировать на полученные ответы. Существуют три типа условий, не связанных с циклами: инструкция **`if`**, инструкция **`switch`** и оператор **`?`**.


### Инструкция **`if`**
---

Инструкции **`if`** уже использовались в нескольких примерах данной главы. Код внутри этой инструкции выполняется только в том случае, если заданное выражение вычисляется как **`true`**. Многострочные инструкции **`if`** заключаются в фигурные скобки, но, как и в PHP, для однострочных инструкций скобки можно опустить, хотя часто стоит использовать их в любом случае, особенно при написании кода, в котором количество действий внутри оператора **`if`** может меняться по мере разработки. Поэтому допустимы все следующие инструкции:

```js
if (a > 100)
{
  b = 2
  document.write("a больше 100")
}

if (b == 10) document.write("b равно 10")
```


### Инструкция **`else`**
---

Если условие не было соблюдено, то с помощью инструкции **`else`** может быть выполнен альтернативный блок кода:

```js
if (a > 100)
{
  document.write("a больше 100") 
}
else
{
  document.write("a меньше или равно 100")
}
```

В JavaScript, в отличие от PHP, нет инструкции **`elseif`**, но ее отсутствие компенсируется возможностью использования инструкции **`else`**, за которой следует еще одна инструкция **`if`**, чем создается эквивалент инструкции **`else if`**:

```js
if (a > 100)
{
  document.write("a больше 100") 
}
else if(a < 100)
{
  document.write("a меньше 100") 
}
else
{
  document.write("a равно 100")
}
```

За инструкцией **`else`** после новой инструкции **`if`** точно так же может следовать еще одна инструкция **`if`**, и т. д. Несмотря на то что в этих инструкциях использованы фигурные скобки, наличие внутри каждой пары этих скобок всего одной строки кода позволяет переписать предыдущий пример следующим образом:

```js
if (a > 100) document.write("a больше 100")
else if(a < 100) document.write("a меньше 100")
else document.write("a равно 100")
```


### Инструкция **`switch`**
---

Инструкция **`switch`** применяется в том случае, когда одиночная переменная или результат вычисления выражения могут иметь несколько значений, для каждого из которых нужно применить свою функцию. Например, в следующем коде за основу берется система меню PHP, составленная в [[Выражения и управление процессом выполнения программы в PHP]], которая переводится в инструкции JavaScript. Эта система работает путем передачи одного строкового значения, соответствующего пожеланию пользователя, коду основного меню. Предположим, пользователю доступны следующие варианты: **`Home`**, **`About`**, **`News`**, **`Login`** и **`Links`**, — и переменной **`page`** присваивается одно из этих значений, соответствующее тому, что ввел пользователь.

Код, созданный для этого с помощью конструкции **`if...else if...`**, может иметь вид, показанный в **примере 15.13**.

>**Пример 15.13.** Многострочная конструкция **`if...else if...`**
```html
<script>
  if      (page == "Home") document.write("Вы выбрали Home")
  else if (page == "About") document.write("Вы выбрали About")
  else if (page == "News") document.write("Вы выбрали News")
  else if (page == "Login") document.write("Вы выбрали Login")
  else if (page == "Links") document.write("Вы выбрали Links")
</script>
```

А при использовании конструкции **`switch`** код может иметь вид, показанный в **примере 15.14.**

>**Пример 15.14.** Конструкция **`switch`**
```html
<script>
  switch (page)
  {
    case "Home":
      document.write("You selected Home")
      break
    case "About":
      document.write("You selected About")
      break
    case "News":
      document.write("You selected News")
      break
    case "Login":
      document.write("You selected Login")
      break
    case "Links":
      document.write("You selected Links")
      break
  }
</script>
```

Переменная **`page`** здесь присутствует только в самом начале инструкции **`switch`**. После чего совпадения проверяются командой **`case`**. При совпадении выполняется условная инструкция. Разумеется, в настоящей программе здесь будет код для отображения страницы или для перехода на нее, а не простое сообщение пользователю о том, что он выбрал.

>[!info]
>Вы можете также предложить несколько случаев для одного действия. Например:
>```js
>switch (hero_name)
>{
>  case "Superman":
>  case "Batman":
>  case "Wonderwoman":
>    document.write("League of justice")
>    break
>  case "Ironman":
>  case "Captain America":
>  case "Spider Man":
>    document.write("Avengers")
>    break
>}
>```


### Прекращение работы инструкции **`switch`**
---

Рассматривая код **примера 15.14**, можно заметить, что, как и в PHP, команда **`break`** позволяет сценарию прекратить работу инструкции **`switch`** при соблюдении условия. Если вы не хотите, чтобы выполнение всех инструкций, начиная со следующей **`case`**, продолжилось, не забудьте поставить команду **`break`**.


### Действие по умолчанию
---

С помощью ключевого слова **`default`** для инструкции **`switch`** можно определить действие по умолчанию на тот случай, когда не будет выполнено ни одно из условий. В **примере 15.15** показан фрагмент кода, который может быть вставлен в код **примера 15.14.**

>**Пример 15.15.** Инструкция **`default`**, предназначенная для кода **примера 15.14**
```js
default:
  document.write("Нераспознанный выбор") break
```


### Оператор **`?`**
---

Тернарный оператор, состоящий из вопросительного знака (**`?`**), применяемого в сочетании с символом «двоеточие» (**`:`**), является упрощенной формой текста **`if...else`**. Используя этот оператор, можно поставить за вычисляемым выражением знак **`?`** и код, выполняемый в том случае, если выражение вычисляется как **`true`**. После этого кода ставится знак **`:`** и код, который будет выполнен, если выражение будет вычислено как **`false`**.

В **примере 15.16** показан тернарный оператор, используемый для вывода сообщения о том, что значение переменной **`a`** меньше или равно 5, или для вывода другого сообщения, если это утверждение не соответствует действительности.

>**Пример 15.16.** Использование тернарного оператора
```html
<script>
  document.write(
    a <= 5 ?
    "a меньше или равно 5" :
    "a больше 5"
  )
</script>
```

Для более понятного представления этот оператор был разбит на несколько строк, но вы, скорее всего, воспользуетесь его однострочной формой:

```js
size = a <= 5 ? "короткий" : "длинный"
```


## Циклы
---

При рассмотрении циклов нам опять встретится множество параллелей между JavaScript и PHP. В обоих языках поддерживаются циклы **`while`**, **`do...while`** и **`for`**.


### Циклы **`while`**
---

В JavaScript в циклах **`while`** ==сначала проверяется значение выражения, а выполнение инструкций внутри цикла начинается лишь в том случае, если выражение вычисляется как **`true`**==. Если выражение вычисляется как **`false`**, управление переходит к следующей инструкции JavaScript (если таковая имеется).

После завершения итерации цикла выражение опять проверяется на истинность и процесс продолжается до тех пор, пока не наступит момент, когда выражение будет вычислено как **`false`**, или пока выполнение не будет остановлено по какой-нибудь другой причине. Этот цикл показан в **примере 15.17.**

>**Пример 15.17.** Цикл **`while`**
```html
<script>
  counter=0

  while (counter < 5)
  {
    document.write("Counter: " + counter + "<br>")
    ++counter
  }
</script>
```

Этот сценарий выведет следующую информацию:

```output
Счетчик: 0
Счетчик: 1
Счетчик: 2
Счетчик: 3
Счетчик: 4
```

>[!Danger]
>Если бы переменная **`counter`** не увеличивалась на единицу внутри цикла, то вполне возможно, что некоторые браузеры перестали бы откликаться из-за входа в бесконечный цикл и работу со страницей было бы трудно остановить даже нажатием клавиши Esc или кнопки остановки загрузки страницы. Поэтому к циклам в JavaScript нужно относиться с большой осторожностью.


### Циклы **`do...while`**
---

==Когда нужен цикл, в котором еще до того, как будет проверено выражение, должна пройти хотя бы одна итерация, используется цикл== **`do...while`**, который похож на цикл **`while`**, за исключением того, что проверка выражения осуществляется только после каждой итерации цикла. Поэтому для вывода первых семи результатов таблицы умножения на 7 можно воспользоваться кодом, показанным в **примере 15.18.**

>**Пример 15.18.** Цикл **`do...while`**
```html
<script>
  count = 1

  do
  {
    document.write(count + " умножить на 7 равно " + count * 7 + "<br>")
  } while (++count <= 7)
</script>
```

Как и ожидалось, этот цикл выведет следующую информацию:

```output
1 умножить на 7 равно 7
2 умножить на 7 равно 14
3 умножить на 7 равно 21
4 умножить на 7 равно 28
5 умножить на 7 равно 35
6 умножить на 7 равно 42
7 умножить на 7 равно 49
```


### Циклы **`for`**
---

Цикл **`for`** объединяет все лучшие качества организации цикла в одной конструкции, которая позволяет передать каждой инструкции три параметра:

- выражение инициализации;
- выражение условия;
- выражение модификации.

Эти параметры отделяются друг от друга точкой с запятой: **`for`** **`(выражение1, выражение2; выражение3)`**. С началом первой итерации цикла выполняется выражение инициализации. Для кода вывода таблицы умножения на 7 переменная **`count`** будет инициализирована значением 1.

Затем после каждого прохождения цикла будет проверено выражение условия (в данном случае **`count <= 7`**), и новое вхождение в цикл произойдет только в том случае, если выражение условия будет вычислено как **`true`**. И в завершение в конце каждой итерации будет вычислено выражение модификации. В случае с таблицей умножения на 7 значение переменной **`count`** увеличивается на единицу. В **примере 15.19** показан код такого цикла.

>**Пример 15.19.** Использование цикла **`for`**
```html
<script>
  for (count = 1 ; count <= 7 ; ++count)
  {
    document.write(count + " умножить на 7 равно " + count * 7 + "<br>");
  }
</script>
```

Как и в PHP, в первом параметре цикла **`for`** можно присваивать значения сразу нескольким переменным, разделяя выражения запятыми:

```js
for (i = 1, j = 1 ; i < 10 ; i++)
```

Точно так же в последнем параметре можно осуществлять сразу несколько модификаций:

```js
for (i = 1 ; i < 10 ; i++, ––j)
```

Или можно одновременно делать и то и другое:

```js
for (i = 1, j = 1; i < 10; i++, j--)
```


### Прекращение работы цикла
---

Команду **`break`**, о важности использования которой в инструкции **`switch`** вы уже знаете, можно применять и внутри циклов **`for`**. Например, она может пригодиться при поиске совпадений определенного вида. Как только совпадение будет найдено, продолжение поиска станет пустой тратой времени и заставит вашего посетителя ждать его завершения. Использование команды **`break`** показано в **примере 15.20**.

>**Пример 15.20.** Использование команды **`break`** в цикле **`for`**
```html
<script>
  haystack     = new Array()
  haystack[17] = "Иголка"

  for (j = 0 ; j < 20 ; ++j)
  {
    if (haystack[j] == "Иголка")
    {
      document.write("<br>- найдена в элементе " + j)
      break
    }
    else document.write(j + ", ")
  }
</script>
```

Этот сценарий выводит следующую информацию:

```output
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
- найдена в элементе 17
```


### Инструкция **`continue`**
---

==Иногда нужно не выйти из цикла, а пропустить выполнение тех инструкций, которые остались в данной итерации.== В таких случаях можно воспользоваться командой **`continue`**. Ее применение показано в **примере 15.21.**

>**Пример 15.21.** Использование команды **`continue`** в цикле **`for`**
```html
<script>
  haystack     = new Array()
  haystack[4]  = "Needle"
  haystack[11] = "Needle"
  haystack[17] = "Needle"

  for (j = 0 ; j < 20 ; ++j)
  {
    if (haystack[j] == "Needle")
    {
      document.write("<br>- Found at location " + j + "<br>")
      continue
    }

    document.write(j + ", ")
  }
</script>
```

Обратите внимание на то, что второй вызов метода **`document.write`** не нужно помещать в инструкцию **`else`** (как было в предыдущем примере), поскольку если будет найдено совпадение, то в результате выполнения команды **`continue`** данный вызов будет пропущен. Этот сценарий выводит следующую информацию:

```output
0, 1, 2, 3, 
- найдена в элементе 4
5, 6, 7, 8, 9, 10,
- найдена в элементе
11 12, 13, 14, 15, 16,
- найдена в элементе 17
18, 19,
```


### Явное преобразование типов
---

В отличие от PHP, в JavaScript нет явного преобразования типов, осуществляемого с помощью операторов (**`int`**) или (**`float`**). Когда нужно, чтобы значение имело определенный тип данных, используется одна из встроенных функций JavaScript, показанных в **табл. 15.6.**

>**Таблица 15.6.** Функции изменения типа, используемые в JavaScript
>![[Таблица 15.6. Функции изменения типа, используемые в JavaScript.jpg]]

Например, чтобы преобразовать число с плавающей точкой в целое число, можно использовать следующий код (который выводит значение 3):

```js
n = 3.1415927
i = parseInt(n)
document.write(i)
```

Или можно воспользоваться составной формой: `document.write(parseInt(3.1415927))`

На этом рассмотрение выражений и способов управления процессом выполнения сценариев завершается. В следующей главе мы рассмотрим **использование** в JavaScript [[Функции, объекты и массивы в JavaScript]].


## Вопросы
---

- [x] 1. Чем отличается обработка логических значений в PHP от их обработки в JavaScript?
- [x] 2. Какие символы используются для определения имени переменной в JavaScript?
- [x] 3. В чем разница между унарными, бинарными и тернарными операторами?
- [x] 4. Как лучше всего принудительно установить собственный приоритет для оператора?
- [x] 5. В каком случае следует использовать оператор тождественности (**`===`**)?
- [x] 6. Какие две формы выражений считаются самыми простыми?
- [x] 7. Назовите три типа условных инструкций.
- [x] 8. Как в инструкциях **`if`** и **`while`** интерпретируются условные выражения, в которых используются данные, относящиеся к разным типам?
- [x] 9. Почему цикл **`for`** считается мощнее цикла **`while`**?
- [x] 10. Для чего предназначена инструкция **`with`**?

---