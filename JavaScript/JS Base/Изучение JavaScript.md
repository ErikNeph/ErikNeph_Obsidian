---
date of creation: 2024-06-10T21:55:00
tags:
  - JavaScript
  - JS
  - Backend
  - Frontend
  - Developing
  - WebDeveloping
  - IT
  - Programming
  - ProgrammingLanguage
aliases:
  - Изучение JS
---
---
# Изучение JavaScript


JavaScript придает вашим сайтам динамическую функциональность. Когда вы видите, как при прохождении указателя мыши над каким-нибудь элементом браузера что-нибудь выделяется, появляется новый текст, изменяется цветовое оформление или изображение, либо когда вы берете какой-то объект на странице и переносите его на новое место, вы должны понимать, что все это обычно делается с помощью JavaScript (хотя CSS становится все более мощным и может выполнять многие из этих функций). Этот язык предлагает такие эффекты, которых нельзя достичь никакими другими средствами, поскольку он запускается внутри браузера и имеет непосредственный доступ ко всем элементам веб-документа.

Впервые JavaScript появился в браузере Netscape Navigator в 1995 году наряду с добавлением поддержки Java-технологии. Поскольку изначально сложилось неверное представление о том, что JavaScript был побочным продуктом Java, возникло устойчивое заблуждение об их взаимосвязанности. Но такое название было всего лишь удачным маркетинговым ходом, призванным помочь новому языку сценариев получить преимущества за счет той популярности, которой пользовался язык программирования Java.

Когда HTML-элементы веб-страницы обрели более четкое, структурированное определение в так называемой *объектной модели документа* — DOM (Document Object Model), язык JavaScript получил еще большие возможности. Объектная модель документа позволила относительно просто добавлять новый абзац или сфокусироваться на какой-нибудь части текста и внести в нее изменения.

==Поскольку как в JavaScript, так и в PHP поддерживаются многие элементы синтаксиса структурного программирования, используемые в языке программирования C, эти два языка очень похожи друг на друга.== Оба относятся к языкам высокого уровня. Также у них весьма слабая типизация, позволяющая легко приводить переменную к новому типу данных лишь за счет применения ее в новом контексте.

После знакомства с PHP язык JavaScript должен восприниматься еще проще. И его изучение принесет вам несомненное удовольствие, поскольку этот язык является основой технологии асинхронного обмена данными, которая (наряду со свойствами HTML5) предоставляет гибко подстраивающийся пользовательский интерфейс, востребованный в наши дни опытными веб- пользователями.


## JavaScript и текст HTML
---

JavaScript является языком сценариев, который работает исключительно на стороне клиента внутри браузера или под управлением **Node.js**. Для вызова этого языка его код помещается между открывающим и закрывающим HTML-тегами **`<script>`** и **`</script>`**. Типовой документ Hello World, созданный на HTML 4.01 с применением JavaScript, может иметь вид, показанный в **примере 14.1.**

>**Пример 14.1.** Фраза Hello World, отображаемая с помощью JavaScript
```html
<html>
  <head><title>Hello World</title></head>
  <body>
    <script type="text/javascript">
      document.write("Hello World")
    </script>
    <noscript>
      Your browser doesn't support or has disabled JavaScript
    </noscript>
  </body>
</html>
```

>[!info]
>Вам могут встретиться веб-страницы, в которых используется нерекомендуемый в наши дни HTML-тег **`<script language="javascript">`**. В данном примере применяется более современный и предпочтительный тег **`<script type="text/javascript">`**, или же, если хотите, просто сам тег **`<script>`**.

Внутри тегов **`<script>`** находится всего одна строка кода JavaScript, в которой используется команда **`document.write`**, являющаяся эквивалентом PHPкоманды echo или команды print. Как и следовало ожидать, она просто выводит предоставленную ей строку в текущий документ при его отображении на экране.

Можно было также заметить, что, в отличие от PHP, в этой команде отсутствует замыкающая точка с запятой (**`;`**). Причина в том, что в JavaScript действием, эквивалентным действию точки с запятой, обладает символ новой строки. ==Тем не менее если потребуется разместить в одной строке более одной инструкции, то после каждой инструкции, кроме последней, нужно ставить точку с запятой. Разумеется, при желании можете ставить точку с запятой после каждой инструкции. Это нисколько не помешает работе JavaScript.== Лично я предпочитаю не ставить точку с запятой, поскольку она лишняя, поэтому стараюсь избегать методов, которые могут вызвать проблемы. Хотя в конечном счете выбор будет зависеть от коллектива команды, в которой вы работаете, а он чаще всего требует ставить точку с запятой, просто для уверенности. Поэтому если сомневаетесь, просто добавьте точку с запятой.

В этом примере следует также обратить внимание на пару тегов, **`<noscript>`** и **`</noscript>`**. ==Они используются в том случае, когда вам хочется предоставить альтернативный HTML пользователям, на чьих браузерах JavaScript не поддерживается или отключен.== Эти теги применяются по вашему усмотрению и не являются обязательными, но будет лучше, если вы ими воспользуетесь, поскольку предоставить альтернативу в виде статичного HTML тем операциям, для которых применяется JavaScript, обычно не составляет большого труда. Но в последующих примерах, приводимых в данной книге, теги **`<noscript>`** будут опускаться, поскольку основное внимание будет уделяться тому, что можно сделать с использованием JavaScript, а не тому, что можно сделать без него.

>Когда загрузится код **примера 14.1**, на экран браузера с включенным JavaScript, будет выведен следующий текст (**рис. 14.1**):
```browser
Hello World
```
![[Рис. 14.1. Включенный и работающий JavaScript.jpg]]
   >   **Рис. 14.1.** Включенный и работающий JavaScript

А те браузеры, на которых JavaScript отключен, выведут сообщение как на **рис. 14.2**.

![[Рис. 14.2. JavaScript отключен.jpg]]
>                  **Рис. 14.2.** JavaScript отключен


### Использование сценариев в заголовке документа
---

Сценарий можно вставить не только в тело документа, но и в его раздел **`<head>`**, являющийся идеальным местом, если нужно выполнить сценарий при загрузке страницы. Присутствие в этом разделе какого-нибудь очень важного кода и функций обеспечивает также их немедленную готовность к использованию в других разделах, имеющих сценарии, в том документе, который зависит от их применения.

Другой причиной для вставки сценария в заголовок документа может быть способность JavaScript записывать в раздел **`<head>`** такие элементы, как метатеги, поскольку то место, куда вставляется сценарий, становится по умолчанию частью документа, куда он осуществляет вывод информации.


### Устаревшие и нестандартные браузеры
---

Если нужно поддерживать браузеры, не допускающие выполнения сценариев (что в наши дни весьма маловероятно), следует воспользоваться HTML-тегами комментариев (**`<!--`** и **`-->`**), препятствующими их встрече с кодом сценария, который они не должны видеть. В **примере 14.2** показано, как эти теги добавляются к коду сценария.

>**Пример 14.2.** Пример Hello World, измененный в расчете на использование браузеров, не поддерживающих JavaScript
```html
<html>
  <head><title>Hello World</title></head>
  <body>
    <script type="text/javascript"><!--
      document.write("Hello World")
    // -->
    </script>
  </body>
</html>
```

В данном примере открывающий HTML-тег комментария (**`<!--`**) был добавлен сразу же после открывающего тега **`<script>`**, а тег (**`// -->`**), закрывающий комментарий — непосредственно перед тегом **`</script>`**, который закрывает сценарий.

Двойной прямой слеш (**`//`**) используется в JavaScript, чтобы показать, что вся остальная строка является комментарием. Он присутствует здесь для того, чтобы браузеры, поддерживающие JavaScript, проигнорировали следующий за ним тег **`-->`**, а браузеры, не поддерживающие JavaScript, проигнорировали идущие в начале символы **`//`** и обработали тег **`-->`**, закрывая тем самым HTML-комментарий.

Хотя такое решение имеет не самый изящный вид, вам при желании поддерживать устаревшие или нестандартные браузеры нужно лишь запомнить используемые в нем две строки, в которые помещается код JavaScript:

```html
<script type="text/javascript"><!--
  (Здесь должен быть ваш код JavaScript...)
  // -->
</script>
```

Разумеется, пройдет еще несколько лет, и эти комментарии станут не нужны для любых выпускаемых браузеров, но на всякий случай вы должны знать о них.


### Включение файлов JavaScript
---

В дополнение к внесению кода JavaScript непосредственно в HTML-документы вы можете включать в них файлы с кодом JavaScript или со своего сайта, или из любого места в интернете. Для этого используется следующий синтаксис:

```html
<script type="text/javascript" src="script.js"></script>
```

А для извлечения файла из интернета применяется этот синтаксис (здесь мы обойдемся без **`type="text/javascript"`**, поскольку он необязателен):

```html
<script src="http://someserver.com/script.js"></script>
```

В самих файлах сценариев *не должно* быть никаких тегов **`<script>`** или **`</script>`**, поскольку они там не нужны: браузеру и так известно, что будет загружаться файл JavaScript. Применение этих тегов в файлах JavaScript приводит к возникновению ошибки.

Включение файлов сценариев — предпочтительный способ использования на вашем сайте файлов JavaScript, принадлежащих сторонним производителям.

>[!info]
>Параметр **`type="text/javascript"`** можно не указывать, поскольку все современные браузеры по умолчанию предполагают, что сценарий содержит код JavaScript.


### Отладка кода JavaScript
---

При изучении JavaScript очень важно иметь возможность отслеживать набранный код или выявлять не связанные с ним ошибки программирования. В отличие от PHP, который отображает сообщения об ошибках в браузере, JavaScript обрабатывает сообщения об ошибках по-другому, и способ их обработки имеет свои особенности, зависящие от используемого браузера. В **табл. 14.1** перечислены способы доступа к сообщениям об ошибках JavaScript в самых распространенных браузерах.

>**Таблица 14.1.** Доступ к сообщениям об ошибках JavaScript в различных браузерах
![[Таблица 14.1. Доступ к сообщениям об ошибках JavaScript в различных браузерах.jpg]]

Пожалуйста, обращайтесь к документации разработчиков на веб-сайтах соответствующих браузеров, если возникнут вопросы об особенностях их применения.


### Использование комментариев
---

В силу общих наследственных черт, приобретенных у языка программирования C, языки PHP и JavaScript имеют много общего и между собой, в частности в приемах комментирования кода. В первую очередь это касается однострочных комментариев:

```js
// Это комментарий
```

В этой технологии используется пара прямых слешей (**`//`**), информирующая JavaScript о том, что все остальные символы должны быть проигнорированы. А затем наступает черед многострочных комментариев:

```JS
/* Это раздел
многострочного
комментария,
не подвергаемого
интерпретации */
```

Многострочный комментарий начинается с последовательности символов **`/*`** и заканчивается символами **`*/`**. Нужно лишь запомнить, что использовать вложенные многострочные комментарии не допускается, поэтому важно убедиться в отсутствии большого закомментированного участка кода, в котором уже имеются многострочные комментарии.


### Точка с запятой
---

В отличие от PHP, точка с запятой коду JavaScript, имеющему в строке одну инструкцию, не требуется. Поэтому следующая строка вполне имеет право на существование:

```js
x += 10
```

Но при необходимости иметь в строке более одной инструкции их нужно разделить точками с запятой:

```js
x += 10; y -= 5; z = 0
```

Последнюю точку с запятой можно опустить, поскольку последняя инструкция будет завершена символом новой строки.

>[!danger]
>В правилах использования точки с запятой есть исключения. Если пишутся URL-закладки (bookmarklet) JavaScript или инструкция завершается ссылкой на переменную или функцию и первый символ расположенной ниже строки является левой круглой или фигурной скобкой, нужно обязательно поставить точку с запятой, иначе сценарий JavaScript даст сбой. Поэтому при любых сомнениях нужно ставить точку с запятой.


### Переменные
---

В JavaScript нет никаких идентификационных символов переменных, таких как знак доллара (**`$`**) в PHP. Вместо этого в отношении имен переменных действуют следующие правила.

- Имена переменных могут включать только латинские буквы `a–z`, `A–Z`, цифры `0–9`, символ `$` и символ подчеркивания (**`_`**).
- Никакие другие символы, включая пробелы или знаки пунктуации, использовать в именах переменных не допускается.
- Первым в имени переменной может быть символ из диапазонов `a–z`, `A–Z`, символ **`$`** или символ подчеркивания _ (и никаких цифр).
- Имена чувствительны к регистру. Имена `Count`, `count` и `COUNT` принадлежат трем разным переменным.
- Ограничений на длину имени переменной не существует.

И вы наверняка обратили внимание на присутствие в этом перечне символа `$`. JavaScript *допускает* его использование, и *он может быть* первым символом в имени переменной или функции. Такая возможность означает, что благодаря этому можно переносить на JavaScript большие объемы кода PHP значительно быстрее, хотя я не рекомендую его применять в данном качестве.


### Строковые переменные
---

В JavaScript значения строковых переменных должны быть заключены либо в одиночные, либо в двойные кавычки:

```js
greeting = "Привет!"
warning = 'Осторожно!'
```

В строку в двойных кавычках можно включить одиночную кавычку или же в строку в одинарных кавычках можно включить двойную кавычку. Но кавычка того же типа должна быть отключена с помощью символа обратного слеша:

```js
greeting = "\"Привет!\" является приветствием"
warning = '\'Осторожно!\' является предупреждением'
```

Чтобы прочитать значение из строковой переменной, его можно присвоить другой переменной:

```js
newstring = oldstring
```

Или использовать его в функции:

```js
status = "Все системы работают успешно"
document.write(status)
```


### Числовые переменные
---

Создание числовой переменной сводится к простому присваиванию значения, как в следующих примерах:

```js
count = 42
temperature = 98.4
```

Значения числовых переменных точно так же, как и значения строковых переменных, могут быть прочитаны и использованы в выражениях и функциях.


### Массивы
---

Массивы JavaScript очень похожи на массивы в PHP тем, что они могут содержать строковые или числовые данные, а также другие массивы. Чтобы присвоить массиву значения, используется следующий синтаксис (с помощью которого в данном случае создается строковый массив):

```js
toys = ['bat', 'ball', 'whistle', 'puzzle', 'doll']
```

Для создания многомерного массива более мелкие массивы вкладываются в более крупный. Для создания двумерного массива цветных квадратов, расположенных на одной из сторон кубика Рубика (в котором есть следующие цвета: красный (R), зеленый (G), оранжевый (O), желтый (Y), синий (B) и белый (W), — представленные прописными буквами, указанными в скобках), можно воспользоваться таким кодом:

```js
face =
[
  ['R', 'G', 'Y'],
  ['W', 'R', 'O'],
  ['Y', 'W', 'G']
] 
```

Предыдущий пример был отформатирован так, чтобы было понятно, что именно происходит, но его можно переписать и в следующем виде:

```js
face = [['R', 'G', 'Y'], ['W', 'R', 'O'], ['Y', 'W', 'G']]
```

или даже так:

```js
top = ['R', 'G', 'Y']
mid = ['W', 'R', 'O']
bot = ['Y', 'W', 'G']

face = [top, mid, bot]
```

Для доступа к элементу, расположенному в этой матрице во второй сверху и в третьей слева ячейке, нужно воспользоваться следующим кодом (нужно помнить, ==что позиционирование элементов массива начинается с нуля==):

```js
document.write(face[1][2])
```

Эта инструкция выведет букву **O**, означающую оранжевый цвет.

>[!info]
>Массивы JavaScript — это мощная структура, предназначенная для хранения данных, поэтому в [[Функции, объекты и массивы в JavaScript]] они рассматриваются более подробно.


### Операторы
---

Как и в PHP, операторы в JavaScript могут использоваться в математических операциях, для внесения изменений в строки, а также в операциях сравнения и логических операциях (И, ИЛИ и т. д.). Математические операторы JavaScript во многом похожи на обычные арифметические операторы. Например, следующая инструкция выводит число 15:

```js
document.write(13 + 2)
```

Все разнообразие операторов будет рассмотрено в следующих разделах.


### Арифметические операторы
---

Арифметические операторы предназначены для осуществления математических операций. Их можно использовать для выполнения четырех основных операций (сложения, вычитания, умножения и деления), а также для нахождения модулей (остатков от деления) и инкремента (увеличения на единицу) или декремента (уменьшения на единицу) значения (**табл. 14.2**).

>**Таблица 14.2.** Арифметические операторы
![[Таблица 14.2. Арифметические операторы.jpg]]


### Операторы присваивания
---

Эти операторы используются для присваивания значений переменным. Их линейка начинается простым знаком равенства (**`=`**) и продолжается сочетаниями **`+=`**, **`–=`** и т. д. Оператор **`+=`** добавляет значение, находящееся справа, к переменной, находящейся слева, вместо того чтобы целиком заменить значение переменной в левой части. Поэтому если изначально значение переменной **`count`** было 6, то оператор

```js
count += 1
```

установит для нее значение 7 точно так же, как и более привычный оператор присваивания:

```js
count = count + 1
```

В **`табл. 14.3`** перечислены различные операторы присваивания, доступные в JavaScript.

>**Таблица 14.3.** Операторы присваивания![[Таблица 14.3. Операторы присваивания.jpg]]


### Операторы сравнения
---

Операторы *сравнения* обычно используются с такими конструкциями, как инструкция **`if`**, в которой требуется сравнивать два элемента. Например, может потребоваться узнать, достигло ли значение переменной, подвергаемой автоприращению, определенной величины или меньше ли значение другой переменной установленной величины и т. д. (**табл. 14.4**).

>**`Таблица 14.4.`** Операторы сравнения
>![[Таблица 14.4. Операторы сравнения.jpg]]


### Логические операторы
---

У *логических* операторов JavaScript, в отличие от PHP, нет эквивалентов **`and`** и **`or`** для **`&&`** и **`||`** и отсутствует оператор **`xor`** (**табл. 14.5**).

>**Таблица 14.5.** Логические операторы
>![[Таблица 14.5. Логические операторы.jpg]]


### Инкремент, декремент переменной и краткая форма присваивания
---

Следующие используемые в PHP и уже изучавшиеся вами формы инкремента (приращения) и декремента (отрицательного приращения), осуществляемые как после операции сравнения, так и перед ней, поддерживаются также и в JavaScript в качестве краткой формы операторов присваивания:

```js
++x
––y
x += 22
y –= 3
```


### Объединение строк
---

Объединение (конкатенация) строк в JavaScript осуществляется немного иначе, чем в PHP. Вместо оператора **`.`** (точка) используется знак «плюс» (**`+`**):

```js
document.write("y вас " + messages + " сообщения.")
```

Если предположить, что переменной **`messages`** присвоено значение **`3`**, эта строка кода выведет следующую информацию:

```js
У вас 3 сообщения.
```

Оператор **`+=`** точно так же, как и при добавлении значения к числовой переменной, позволяет добавить одну строку к другой:

```js
name = "James" name += " Dean"
```


### Управляющие символы
---

Управляющие символы, пример использования которых вы видели при вставке в строку кавычек, могут применяться также для вставки различных специальных символов: табуляции, новой строки и возврата каретки. В следующем примере символы табуляции используются для разметки заголовка; они включены в строку лишь для иллюстрации использования управляющих символов, поскольку в веб-страницах существуют более подходящие способы разметки:

```js
heading = "Name\tAge\tLocation"
```

**В табл. 14.6** приведены управляющие символы, доступные в JavaScript.

>**Таблица 14.6.** Управляющие символы JavaScript
>![[Таблица 14.6. Управляющие символы JavaScript.jpg]]


### Типизация переменных
---

Как и PHP, JavaScript относится к весьма слабо типизированным языкам. Тип переменной определяется только при присваивании ей значения и может изменяться при появлении переменной в другом контексте. Как правило, о типе переменной волноваться не приходится: язык JavaScript сам определяет, что именно вам нужно, и просто делает это.

Посмотрите на **пример 14.3**, в котором выполняются следующие действия.

1. Переменной n присваивается строковое значение **`"838102050"`**, в следующей строке осуществляется вывод ее значения, а чтобы посмотреть на ее тип, используется инструкция **`typeof`**.
2. Переменной n присваивается значение, получаемое при перемножении чисел 12 345 и 67 890. Это значение также равно **`838102050`**, но оно является числом, а не строкой. Затем определяется и выводится на экран тип переменной.
3. К числу **`n`** добавляется текст, и результат отображается на экране.

>**Пример 14.3.** Установка типа переменной путем присваивания ей значения
```js
<script>
  n = '838102050' // Присваивание 'n' строкового значения
  document.write('n = ' + n + ', и имеет тип ' + typeof n + '<br>')
  n = 12345 * 67890; // Присваивание 'n' числа
  document.write('n = ' + n + ', и имеет тип ' + typeof n + '<br>')
  n += ' плюс текст' // Изменение типа 'n' с числового на строковое
  document.write('n = ' + n + ', и имеет тип ' + typeof n + '<br>')
</script>
```

Этот сценарий выведет следующую информацию:

```js output
n = 838102050 и имеет тип string
n = 838102050 и имеет тип number
n = 838102050 плюс текст и имеет тип string
```

Если в отношении типа переменной есть какие-то сомнения или нужно обеспечить, чтобы переменная относилась к определенному типу, вы можете принудительно привести ее к этому типу, используя операторы, показанные в следующем примере (которые превращают строку в число и число в строку соответственно):

```js
n = "123"
n *= 1  // Превращение 'n' в число

n = 123
n += "" // Превращение 'n' в строку
```

Или вы можете таким же образом использовать следующие функции:

```js
n = "123"
n = parseInt(n)    // Превращение 'n' в целое число 
n = parseFloat(n)  // Превращение 'n' в число с плавающей точкой

n = 123
n = n.toString()   // Превращение 'n' в строку
```

Подробнее о преобразовании типов в JavaScript можно почитать на сайте https://javascript.info/type-conversions. А тип переменной можно всегда определить с помощью инструкции **`typeof`**.


### Функции
---

Как и в PHP, в JavaScript функции используются для выделения фрагментов кода, выполняющих конкретную задачу. Для создания функции ее нужно объявить, как показано в **примере 14.4.**

>**Пример 14.4.** Объявление простой функции
```js
<script>
  function product(a, b)
  {
    return a*b
  }
</script>
```

Эта функция принимает два переданных ей параметра, перемножает их и возвращает произведение.


## Глобальные переменные
---

К *глобальным* относятся переменные, определенные за пределами любых функций (или внутри функций, но без использования ключевого слова **`var`**). Они могут быть определены следующими способами:

```js
    a = 123                   // Глобальная область видимости
var b = 456                   // Глобальная область видимости
if (a == 123) var c = 789     // Глобальная область видимости
```

Независимо от применения ключевого слова **`var`**, если переменная определена за пределами функции, она приобретает глобальную область видимости. Это означает, что к ней может быть получен доступ из любой части сценария.


### Локальные переменные
---

Параметры, переданные функции, автоматически приобретают *локальную* область видимости, то есть к ним можно обращаться только из тела этой функции. Но есть одно исключение. Массивы передаются функции по ссылке, поэтому если вы внесете изменения в любые элементы массива, переданного в качестве параметра, то элементы исходного массива также будут изменены.

Для определения локальной переменной, имеющей область видимости только внутри текущей функции и не переданной ей в качестве параметра, используется ключевое слово **`var`**. В **примере 14.5** показана функция, которая создает одну переменную с глобальной и две переменные — с локальными областями видимости.

>**Пример 14.5.** Функция, создающая переменные с глобальной и локальной областями видимости
```js
<script>
  function test()
  {
	    a = 123               // Global scope
	var b = 456               // Local scope
	if (a == 123) var c = 789 // Local scope
  }
</script>
```

В PHP, чтобы проверить работоспособность установки области видимости, можно воспользоваться функцией **`isset`**. Но в JavaScript такой функции нет, поэтому в **примере 14.6** применяется инструкция **`typeof`**, возвращающая строку **`undefined`**, если переменная не определена.

**Пример 14.6.** Проверка области видимости переменных, определенных в функции **`test`**
```js
<script>
  test()

  if (typeof a != 'undefined') document.write('a = "' + a + '"<br />')
  if (typeof b != 'undefined') document.write('b = "' + b + '"<br />')
  if (typeof c != 'undefined') document.write('c = "' + c + '"<br />')

  function test()
  {
     a     = 123
    var b = 456

    if (a == 123) var c = 789
  }
</script>

```

Этот сценарий выведет только одну строку:

```js
a = "123"
```

Это свидетельствует о том, что, как и предполагалось, глобальная область видимости была определена лишь для одной переменной, потому что для переменных **`b`** и **`c`** установкой перед ними ключевого слова **`var`** была задана локальная область видимости.

Если ваш браузер выведет предупреждение о том, что переменная **`b`** не определена, то при всей своей справедливости оно может быть проигнорировано.


### Использование **`let`** и **`const`**
---

JavaScript теперь предлагает два новых ключевых слова, **`let`** и **`const`**. Ключевое слово **`let`** практически заменяет **`var`**, но у него есть то преимущество, что вы не можете повторно объявить переменную после того, как сделали это с помощью **let**, хотя с помощью **`var`** это возможно.

Дело в том, что повторное объявление переменных с помощью **`var`** приводило к непонятным ошибкам, таким как эта:

```js
var hello = "Приветики"
var counter = 1

if (counter > 0)
{
  var hello = "Как ты?"
}

document.write(hello)
```

Видите, в чем проблема? Поскольку **`counter`** больше 0, так как мы откалибровали его в **`1`**, строка **`hello`** переопределяется как строка «Как ты?», которая затем отображается в документе. Теперь, если вы замените **`var`** на **`let`**, как показано далее, второе объявление будет проигнорировано и будет выведена исходная строка «Приветики»:

```js
let hello = "Приветики"
let counter = 1

if (counter > 0)
{
  let hello = "Как ты?"
}

document.write(hello)
```

Ключевое слово **`var`** имеет либо глобальную область действия, если находится за пределами каких-либо блоков или *функций*, либо область действия функции, и переменные, объявленные с его помощью, инициализируются значением **`undefined`**, а ключевое слово **`let`** имеет глобальную область действия или область действия *блока*, и переменные не инициализируются.

Любая переменная, назначенная с помощью **`let`** и объявленная вне какого-либо блока, имеет область действия в пределах всего документа, а если она объявлена внутри блока, ограниченного **`{}`**, который включает функции, ее область действия ограничена этим блоком и любыми вложенными подблоками. Если вы объявите переменную внутри блока, но попытаетесь получить к ней доступ извне его, то будет возвращена ошибка, как, например, в следующем случае, который завершится неудачей на этапе **`document.write`**, поскольку **`hello`** не будет иметь значения:

```js
let counter = 1

if (counter > 0)
{
  let hello = "Как ты?"
}

document.write(hello)
```

Вы можете использовать **`let`** для объявления переменных с тем же именем, что и ранее объявленные, при условии, что это происходит в новой области действия. В этом случае любое значение, присвоенное переменной в предыдущей области действия, станет недоступным для новой области действия, поскольку новая переменная с тем же именем рассматривается как совершенно отличная от предыдущей. Она имеет область действия только в пределах текущего блока или любых подблоков, если только другой **`let`** не используется для объявления еще одной переменной с тем же именем в подблоке.

Мы рекомендуем избегать повторного использования значимых имен переменных, иначе вы рискуете запутаться. Однако переменные цикла или индекса, такие как **`i`** или другие короткие и простые имена, как правило, могут быть повторно использованы в новых областях, не вызывая никакого хаоса.

Вы можете усилить свой контроль над областью действия, объявив переменную как постоянное значение, то есть такое, которое не может быть изменено. Это будет полезно в случае, если вы создали переменную, которую рассматриваете как постоянную, но объявили ее только с помощью **`var`** или **`let`**, поскольку в вашем коде могут быть случаи, когда вы попытаетесь изменить это значение, что было бы допустимо, но являлось бы ошибкой.

Однако если вы используете ключевое слово **`const`** для объявления переменной и присвоения ей значения, любая попытка изменить значение позже будет запрещена и код остановится с сообщением об ошибке в консоли, аналогичным следующему:

```js
Uncaught TypeError: Assignment to constant variable
```

А такой код приведет именно к этой ошибке:

```js
const hello = "Приветики"
let counter = 1

if (counter > 0)
{
  hello = "Как ты?"
}

document.write(hello)
```

Так же как и **`let`**, объявления **`const`** ограничены областью действия блока (в пределах разделов **`{}`** и любых подблоков), что означает: у вас могут быть постоянные переменные с одинаковым именем, но разными значениями в разных областях фрагмента кода. Тем не менее я настоятельно рекомендую стараться избегать дублирования имен и присваивать любой константе одно-единственное значение в каждой программе, используя новое имя везде, где вам нужна новая постоянная.

Давайте подытожим: ==**`var`** имеет глобальную или функциональную область действия, а **`let`** и **`const`** — глобальную или блочную область действия.== Как **`var`**, так и **`let`** может быть объявлено без инициализации, в то время как **`const`** должна быть инициализирована во время объявления. Ключевое слово **`var`** можно повторно использовать для повторного объявления переменной **`var`**, а **`let`** и **`const`** — нельзя. И наконец, **`const`** не может быть ни повторно объявлена, ни переназначена.

>[!info]
>Возможно, вы предпочтете использовать консоль разработчика с такими тестами, как эти (и в других местах книги), как объяснялось ранее в разделе «Отладка кода JavaScript». В этом случае можете заменить **`document.write`** на **`console.log`**, и вывод будет отображаться в консоли, а не в браузере. Это наилучший вариант и для JavaScript, который будет запускаться после полной загрузки документа, потому что в это время **`document.write`** будет заменять текущий документ, а не добавляться к нему, — вероятно, это совсем не то, что вы хотели бы сделать.


## Объектная модель документа
---

==Разработка JavaScript является очень умной. Вместо того чтобы просто создать еще один язык написания сценариев== (который имел бы на момент создания весьма неплохие усовершенствования), ==его решили построить вокруг уже существующей объектной модели документа HTML, или DOM (Document Object Model)==. Эта модель разбивает части HTML-документа на отдельные объекты, у каждого из которых есть собственные *свойства* и *методы* и каждым из которых можно управлять с помощью JavaScript.

В JavaScript объекты, свойства и методы разделяются с помощью точек (это одна из причин того, что в качестве оператора объединения строк в JavaScript используется знак **`+`**, а не точка). Рассмотрим, к примеру, в качестве объекта с именем **`card`** визитную карточку. Этот объект содержит такие свойства, как имя — **`name`**, адрес —**`address`**, номер телефона — **`phone`** и т. д. В синтаксисе JavaScript эти свойства будут иметь следующий вид:

```js
card.name
card.phone
card.address
```

Его методами будут функции, занимающиеся извлечением, изменением и другими действиями со свойствами. Например, для вызова метода, отображающего свойства объекта **`card`**, можно воспользоваться следующим синтаксисом:

```js
card.display()
```

Взгляните на некоторые из представленных ранее в этой главе примеров и обратите внимание на те из них, в которых применяется инструкция **`document.write`**. Уяснив, что JavaScript основан на работе с объектами, вы поймете, что **`write`** — это метод объекта **`document`**.

Внутри JavaScript выстраивается иерархия из родительских и дочерних объектов. ==Эта иерархия и называется объектной моделью документа== — **DOM** (**рис. 14.3**).

![[Рис. 14.3. Пример иерархии объектов DOM.jpg]]
   >   **Рис. 14.3.** Пример иерархии объектов DOM

На этом рисунке используются уже знакомые вам HTML-теги, иллюстрирующие родительско-дочерние взаимоотношения между различными объектами документа. Например, URL-адрес внутри ссылки является частью тела (**`body`**) HTML-документа. В JavaScript на него можно сослаться следующим образом:

```js
url = document.links.linkname.href
```

Обратите внимание на то, как эта ссылка идет сверху вниз по центральному столбцу. Первая часть, document, ссылается на теги **`<html>`** и **`<body>`**, **`links.linkname`** — на тег **`<a>`**, а **`href`** — на атрибут **`href`**.

  >  **Пример 14.7.** Чтение ссылки на URL-адрес с помощью JavaScript
```html
<html>
  <head>
    <title>Link Test</title>
  </head>
  <body>
    <a id="mylink" href="http://mysite.com">Click me</a><br />
    <script>
      url = document.links.mylink.href
      document.write('The URL is ' + url)
    </script>
  </body>
</html>
```

Обратите внимание на краткую форму тегов script, в которой для экономии времени на набор текста был опущен параметр **`type="text/JavaScript"`**. При желании ради проверки этого (и других примеров) можете также опустить все, кроме тегов **`<script>`** и **`</script>`**. Код этого примера выведет следующую информацию:

```browser
Щелкни 
URL-адрес – http://mysite.com
```

Вторая строка выведенной информации появилась благодаря работе метода **`document.write`**. Обратите внимание на то, как код следует сверху вниз по дереву документа от **`document`** к **`links`**, к **`mylink`** (идентификатору, присвоенному ссылке) и к **`href`** (значению, содержащему URL-адрес назначения).

Есть также краткая форма, работающая не менее успешно, которая начинается со значения, присвоенного атрибуту **`id:mylink.href`**. Поэтому следующую строку:

```js
url = document.links.mylink.href
```

можно заменить строкой

```js
url = mylink.href
```


### Еще одно использование знака **`$`**
---

Как уже упоминалось, символ **`$`** разрешено использовать в именах переменных и функций JavaScript. По этой причине иногда можно встретить код довольно странного вида:

```js
url = $('mylink').href
```

Некоторые изобретательные программисты решили, что метод **`getElementByld`** слишком часто применяется в JavaScript, и написали взамен него свою функцию, показанную в **примере 14.8**, присвоив ей имя **`$`** как в jQuery (хотя в этой библиотеке символ **`$`** используется более широко, чем здесь, о чем можно узнать, прочитав [[Введение в JQuery]]).

>**Пример 14.8.** Функция, заменяющая метод **`getElementByld`**
```html
<script>
function $(id)
{
  return document.getElementById(id)
}
</script>
```

Поэтому как только функция **`$`** будет вставлена в ваш код, синтаксис

```js
$('mylink').href
```

может заменить следующий код:

```js
document.getElementById('mylink').href
```


### Использование DOM
---

На самом деле объект **`links`** является массивом, состоящим из URL-адресов, поэтому на URL **`mylink`** в **примере 14.7** можно спокойно ссылаться во всех браузерах, используя для этого следующий код (поскольку это первая и единственная ссылка):

```js
url = document.links[0].href
```

Если нужно узнать, сколько ссылок содержится во всем документе, можно запросить свойство **`length`** объекта **`links`**:

```js
numlinks = document. links.length
```

Благодаря этому свойству можно извлечь и отобразить все имеющиеся в документе ссылки:

```js
for (j=0 ; j < document.links.length ; ++j)
  document.write(document.links[j].href + '<br>')
```

Длина — **`length`** является свойством каждого массива, а также многих других объектов. Например, можно запросить количество записей в истории вашего браузера:

```js
document.write(history.length)
```

Но чтобы исключить перехват ваших сайтов с помощью истории браузера, в объекте **`history`** хранится только количество сайтов в массиве, и вы не можете прочитать или записать значения, относящиеся к этим сайтам. Но вы можете заменить текущую страницу одной из тех, что хранятся в истории, если знаете, на какой позиции она там находится. Это может пригодиться в тех случаях, когда вам известны конкретные страницы, попавшие в историю при переходах с вашей страницы, или вы просто хотите вернуть браузер назад на одну или несколько страниц, что делается с помощью метода **`go`** объекта **`history`**. Например, чтобы отправить браузер назад на три страницы, нужно выдать следующую команду:

```js
history.go(-3)
```

Для перехода вперед и назад на одну страницу можно воспользоваться также следующими методами:

```js
history.back()
history.forward()
```

Подобным способом можно заменить только что загруженный URL-адрес другим по вашему выбору:

```js
document.location.href = 'http://google.com'
```

Конечно, DOM можно использовать для решения куда более широкого круга задач, чем чтение и модификация ссылок. По мере изучения следующих глав, посвященных JavaScript, знакомство с DOM и с доступом к этой модели станет еще более тесным.


## О функции **`document.write`**
---

При изучении программирования необходимо иметь быстрый и простой способ отображения результатов выражений. В PHP (к примеру) есть инструкции **`echo`** и **`print`**, позволяющие просто отправлять текст браузеру, поэтому при работе с ним отображение результатов дается довольно легко. А в JavaScript имеются следующие варианты такого отображения.


#### Использование **`console.log`**
---

Функция **`console.log`** ==выводит результат вычисления значения любой переданной ей переменной или выражения в консоль текущего браузера.== Это специальный режим, имеющий фрейм или окно, отдельное от окна браузера, куда можно выводить сообщения об ошибках или другие сообщения. Этот режим больше подходит опытным программистам и ==не считается идеальным решением для начинающих, поскольку вывод осуществляется отдельно от веб-содержимого браузера.==


#### Использование **`alert`**
---

Функция **`alert`** ==выводит значения переданных ей переменных или выражений в появляющемся окне, для закрытия которого требуется нажать кнопку.== Конечно, это занятие может быстро надоесть, тем более что есть еще один недостаток, заключающийся в отображении только текущего сообщения и утрате при этом всех предыдущих.


### Запись в элементы
---

У вас есть возможность ввести запись непосредственно в текст HTML-элемента, представляющаяся весьма элегантным решением (и лучшим для производства сайтов), за исключением того, что в данной книге для каждого примера понадобится создавать такой элемент, а также добавлять несколько строк кода для доступа к этому элементу. Это будет мешать усвоению сути примера и сделает его код излишне громоздким и запутанным.


### Использование **`document.write`**
---

Функция **`document.write`** ==записывает значение или результат вычисления выражения в текущую позицию в браузере и поэтому является наиболее удачным вариантом для быстрой демонстрации результатов, поскольку примеры остаются довольно краткими и прилично выглядящими за счет того, что вывод помещается прямо в браузере, сразу же за веб-содержимым и кодом.==

==Возможно, вам приходилось слышать, что некоторые разработчики считают эту функцию небезопасной, поскольку при ее вызове после полностью загруженной страницы она переписывает текущий документ.== Хотя это действительно так, к примерам этой книги данная особенность не имеет никакого отношения, поскольку во всех примерах **`document.write`** используется по первоначальному предназначению — в качестве части процесса создания страницы и вызов функции происходит до полной загрузки и отображения страницы.

Несмотря на то что функция **`document.write`** используется данным образом для простых примеров, я никогда не пользуюсь ею в своем производственном коде (за исключением весьма редких случаев, когда без этого просто не обойтись). Вместо нее я практически всегда использую предыдущий вариант, заключающийся в записи непосредственно в специально подготовленный элемент как в показанных далее более сложных примерах в [[Использование технологии асинхронного обмена данными]] (где для программного вывода происходит обращение к свойству элементов **`innerHTML`**).

Поэтому я прошу запомнить, что вызов функции **`document.write`**, встречающийся в данной книге, используется исключительно для упрощения примера, и я рекомендую, чтобы вы также использовали эту функцию лишь в подобных целях — для получения быстрых тестовых результатов.

С учетом данного предостережения в следующей главе [[Выражения и управление процессом выполнения сценариев в JavaScript]] мы продолжим исследование JavaScript и рассмотрим вопросы управления ходом выполнения программы и написания выражений.


## Вопросы
---

- [x] 1. Какие теги используются для заключения в них кода JavaScript?
- [x] 2. К какой части документа будет по умолчанию добавлена информация, выводимая кодом JavaScript?
- [x] 3. Как в ваши документы может быть включен код JavaScript из другого источника?
- [x] 4. Какая функция JavaScript является эквивалентом PHP-команд echo или print?
- [x] 5. Как можно создать комментарий в JavaScript?
- [x] 6. Какой оператор используется в JavaScript для объединения строк?
- [x] 7. Какое ключевое слово можно применять внутри функции JavaScript для определения переменной, имеющей локальную область видимости?
- [ ] 8. Покажите два метода, работающие на всех браузерах и позволяющие отобразить присвоенный ссылке URL-адрес на основе ID этой ссылки.
- [x] 9. Какие две команды JavaScript заставят браузер загрузить предыдущую страницу, содержащуюся в его массиве **`history`**?
- [ ] 10. Какой командой JavaScript вы воспользуетесь для замены текущего документа главной страницей сайта oreilly.com?

---