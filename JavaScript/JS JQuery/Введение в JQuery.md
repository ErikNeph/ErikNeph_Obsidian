---
date of creation: 2024-06-28T17:26:00
tags:
  - JQuery
  - JS/JQuery
  - Web/Developing
  - Backend
  - IT/JavaScript
  - JavaScript
  - Developing
  - Framework
  - Framework/JS
  - Programming/JS
  - ProgrammingLanguage/JS
Read status: false
aliases:
---
---
# Введение в JQuery
2024-06-28




При всей гибкости и эффективности JavaScript, а также при всем изобилии имеющихся в этом языке встроенных функций и продолжающемся внедрении усовершенствований у вас все же часто сохраняется потребность в дополнительных уровнях кода, позволяющих упростить, к примеру, получение эффектов анимации, обработку событий и применение технологии асинхронного обмена данными, то есть сделать то, чего нельзя достичь применением обычных средств JavaScript или CSS.

Более того, с годами, вследствие различных браузерных войн, то появлялись, то исчезали досаждающие и раздражающие несовместимости браузеров, ярко проявлявшиеся временами на различных платформах и в программах.

В результате этого гарантировать одинаковый внешний вид веб-страниц во всех устройствах порой можно было, только применяя требовавший утомительной разработки код JavaScript, учитывающий все расхождения всей линейки браузеров и их версий, выпущенных за последние годы. Да, многое было сделано для устранения этих различий, но даже сегодня каждый сайт с отзывчивым дизайном, который я создаю, по-прежнему нуждается в исключениях для работы с различными браузерами, если только я не использую платформу, с чем, я уверен, согласятся многие.

Для заполнения пробелов было разработано множество библиотек функций (многие из которых также предоставляли легкую привязку к DOM), предназначенных для сведения к минимуму различий между браузерами и содействия асинхронному обмену данными, а также работе с событиями и анимацией, такие как, например, являющаяся темой этой главы jQuery.

>[!info]
>Иногда решение волнующей вас проблемы простое — на основе JavaScript. Одним из способов проверить, так ли это, является поиск на сайте http://youmightnotneedjquery.com/ — он позволит вам узнать о любых альтернативах jQuery, которые могут быть более простыми в конкретной ситуации.





## Почему же именно jQuery?
---

Используя jQuery, вы получаете не только кросс-браузерную совместимость весьма высокого уровня, но и быстрый и легкий доступ к операциям с HTML и DOM, возможность использования специальных функций для непосредственной работы с CSS, управления событиями, мощные средства для создания профессиональных эффектов и анимации, а также функции для управления асинхронным обменом данными с сервером. Кроме того, jQuery является основой для широкого круга дополнительных модулей и других вспомогательных программ.

Конечно же, использования jQuery вам никто не навязывает, и некоторые борцы за чистоту языка программирования никогда не используют библиотеку, предпочитая создавать собственные специализированные наборы функций (и в этом есть свой резон, например, не нужно будет дожидаться, пока другие люди исправят замеченные вами недоделки, можно будет разрабатывать собственные средства безопасности и т. д.). Но библиотека jQuery уже выдержала проверку временем, и если вы захотите с пользой потратить время на ее изучение и получить возможность делать высококачественные веб-страницы в самые короткие сроки, из этой главы вы узнаете, как можно приступить к использованию этой библиотеки.

>[!info]
>Как бы ни была важна библиотека jQuery, используемая, возможно, на 90 % производственных веб-сайтов, в этой сфере появились и новички, которые привлекли большое внимание и удостоились похвалы. А поскольку технологии меняются быстро, то, понимая jQuery, вам все же необходимо идти в ногу с новыми технологиями, которые могут вытеснить используемые вами в настоящее время. На мой взгляд, React, Angular и Vue — лишь несколько таких технологий, поскольку они предлагают новые, интересные и мощные масштабируемые способы улучшения JavaScript (как и следовало ожидать, они были созданы Facebook, Google и бывшими сотрудниками Google соответственно). Мы не можем заполнить эту книгу информацией о платформах JavaScript, но важно знать об основных из них, поэтому в [[Введение в React]] я решил познакомить вас с React. Я считаю, что это платформа, с которой вы, скорее всего, будете сталкиваться наиболее часто, хотя для полноты картины, возможно, захотите познакомиться и с Angular.



### Включение jQuery
---

Есть два способа включения jQuery в ваши веб-страницы. Можно перейти на сайт jQuery (https://code.jquery.com/jquery/), выбрать нужную версию, загрузить ее на свой веб-сервер и ссылаться на нее из тега **`<script>`** в своих HTML-файлах. Или же можно воспользоваться находящейся в свободном доступе сетью доставки контента — [[Content Delivery Network (CDN)]] и просто указать ссылку на нужную вам версию.

>[!info]
>jQuery выпускается в соответствии с условиями MIT-лицензии, в которой не содержится практически никаких ограничений на ваши дальнейшие действия. Любой проект jQuery можно свободно использовать в любом другом проекте (даже коммерческом) при условии, что заголовок с указанием авторских прав останется нетронутым.


#### Выбор подходящей версии
---

Перед тем как решить, стоит ли загружать jQuery и использовать ее функции непосредственно или же воспользоваться CDN, нужно выбрать версию jQuery. В большинстве случаев выбор очевиден, поскольку вы просто отдадите предпочтение наиболее свежей версии. Но если есть намерение использовать конкретные браузеры или же вы поддерживаете устаревший сайт, работа которого зависит от определенной версии jQuery, то последний выпуск этой библиотеки может вам не подойти.

В отличие от большинства других программных средств, для использования которых вы просто загружаете и устанавливаете самую новую из доступных версий, jQuery со временем совершенствовалась с учетом изменения движущих сил на рынке различных версий браузеров с их свойствами и недочетами.

В то же время в jQuery вносили различные усовершенствования, которые могли изменить работу ее новых версий на тех сайтах, которые были специально адаптированы под конкретную версию (и под все сопутствующие ей особенности).

Разумеется, каждая более новая версия является улучшением предыдущей, и вероятность того, что вносимые усовершенствования коснутся всех основ, постоянно возрастает. Но пока вы полностью не протестируете новую версию и не убедитесь в том, что операции, играющие важную роль для вашего сайта, выполняются точно так же, лучше все же продолжать использовать прежнюю версию.


##### Различные разновидности **jQuery**
---

На данный момент существуют три ветви jQuery: 1.x, 2.x и 3.x, каждая из которых разработана для разных сред.

Версия 1.x была первым стабильным выпуском jQuery. Этот выпуск поддерживает устаревшие браузеры, которые уже больше не поддерживаются даже своими разработчиками. Если ожидается большой наплыв посетителей с устаревшими браузерами, то нужно пользоваться именно этой версией (как уже упоминалось, лучшей, наверное, будет версия 1.12).

С целью повышения общей производительности jQuery и уменьшения размера файла библиотеки в версии 2.x была исключена поддержка Internet Explorer 6–8. Эта версия быстрее и меньше версии 1.x, но не поддерживает устаревшие браузеры. Поскольку компания Microsoft прекратила поддержку Windows XP, можно с уверенностью предположить, что ваши посетители будут пользоваться браузером, совместимым с версией 2.x, если вы не будете располагать иными сведениями.

Если нужна поддержка устаревших браузеров вроде Internet Explorer 6–8, Opera 12.1x или Safari 5.1+, разработчики jQuery рекомендуют воспользоваться версией 1.12. Исчерпывающие подробности поддержки различных версий можно найти по адресу http://jquery.com/browser-support/. В данной редакции книги я остановился на версии 3.5.1.


##### Сжатые или редактируемые
---

Нужно также решить, какую версию jQuery вам хотелось бы использовать: минимальную по размеру (сжатую, чтобы свести к минимуму требуемую полосу пропускания сети и сократить время загрузки) или несжатую (возможно, по причине того, что вам хочется вносить в нее самостоятельные правки, на что вы имеете полное право). Как правило, наиболее удачным выбором считается минимальная по размеру версия, но большинство веб-серверов поддерживают архиватор `gzip`, позволяющий выполнять сжатие и распаковку на лету, поэтому данный вопрос теряет свою актуальность (хотя нужно учесть, что из минимизированной версии, кроме всего прочего, удалены все комментарии).


#### Загрузка
---

На сайте jquery.com/download каждая последняя выпущенная версия jQuery фигурирует в списке как в сжатой, так и в несжатой форме. Все прошлые выпуски можно также найти на веб-сайте https://code.jquery.com/jquery/. Облегченные версии jQuery, попадающиеся на странице загрузки, в целях экономии пространства исключают функции асинхронного обмена данными Ajax, поэтому при необходимости применения данной технологии с использованием jQuery этих версий следует избегать.

Вам остается всего лишь выбрать нужную версию, щелкнуть правой кнопкой мыши на соответствующей ссылке и сохранить версию на своем жестком диске. Оттуда ее можно будет выгрузить на ваш веб-сервер, а затем включить в веб-страницу с помощью **`<script>`**-тегов примерно таким образом (для минимизированной версии выпуска 3.5.1):
```html
<script src='http://myserver.com/jquery-3.5.1.min.js'></script>
```

>[!info]
>Если ранее вам не приходилось пользоваться jQuery (и никаких специальных требований на ее счет у вас не имеется), то загружайте минимизированную версию или же установите показанную в следующем разделе CDN-ссылку на эту библиотеку.


#### Использование сети доставки контента
---

Библиотека jQuery поддерживается несколькими сетями доставки контента (CDN). Если вы пользуетесь одной из них, то можете избавить себя от хлопот, связанных с загрузкой новых версий, и выкладывать их на сервер, просто указав прямые ссылки на URL-адреса, поддерживаемые этими сетями.

Ко всему прочему, эти сети предоставляют свои услуги совершенно бесплатно и обычно используют каналы с высокой пропускной способностью, которые, возможно, являются самыми скоростными на свете. Кроме того, CDN-сети обычно хранят свой контент в нескольких различных географических пунктах и предоставляют требуемый файл с ближайшего к пользователю сервера, гарантируя тем самым наиболее быструю из возможных доставку.

В общем, если вам не нужно вносить изменения в исходный код jQuery (для чего требуется его размещение на ваших собственных веб-серверах) и у ваших пользователей гарантированно имеется живое Интернет-соединение, то скорее всего, наилучшим вариантом будет использование CDN-сетей. Тем более что пользоваться ими довольно просто. Достаточно знать имя нужного файла и используемого для его загрузки корневого каталога CDN. Например, все текущие и предыдущие версии можно получить через CDN-сеть, которая используется библиотекой jQuery, с помощью следующего кода:
```html
<script src='http://code.jquery.com/jquery-3.5.1.min.js'></script>
```

Основной каталог доступен по адресу http://code.jquery.com/, и за ним нужно просто дописать имя нужного для включения файла (в данном случае это jquery-3.5.1.min.js).

Библиотеку jQuery предоставляет в своих сетях как Microsoft, так и Google, поэтому для ее включения можно воспользоваться любым из следующих двух вариантов:
```html
<script 
  src='http://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.5.1.min.js'></script>
<script              src='http://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js'> </script>
```

В случае использования Microsoft CDN в URL-адресе сначала нужно указать основной каталог ajax.aspnetcdn.com/ajax/jQuery/, а за ним — имя требуемого файла.

Но для Google нужно разбить имя файла (например, jquery-3.5.1.min.js) на имя каталога и имя файла таким вот образом: 3.5.1/jquery.min.js. А перед этим поставить строку ajax.googleapis.com/ajax/libs/jquery/.

>[!info]
>Дополнительным преимуществом применения CDN-сетей является то, что ими пользуется большинство других сайтов, поэтому библиотека jQuery может уже находиться в кэше пользовательского браузера и ее, может быть, даже не придется доставлять заново. При практически более чем 90%-ной востребованности jQuery другими сайтами тем самым может быть сэкономлен большой объем ценных сетевых ресурсов и времени.


##### Заказная сборка **jQuery**
---

Если есть настоятельная необходимость свести объем данных, загружаемых веб-страницей, к минимуму, то можно воспользоваться jQuery, создав специальную сборку этой библиотеки, включающую только те функции, которые будут использоваться вашим сайтом. При ее доставке полагаться на CDN-сеть нельзя, но при подобных обстоятельствах вы, наверное, все равно не станете планировать использование этой сети.

Для создания собственной заказной сборки jQuery нужно зайти на сайт projects.jga.me/jquery-builder и выставить флажки возле тех модулей, которые вам нужны, сняв их с ненужных модулей. Затем заказная версия jQuery будет загружена в отдельную вкладку или окно, откуда ее можно будет скопировать и вставить в требуемое место.



## Синтаксис **jQuery**
---

Больше всего людей, ранее не знакомых с jQuery, удивляет символ `$`, который действует как фабричный метод jQuery — основной способ доступа к платформе. Он был выбран из расчета допустимости в JavaScript, краткости и отличия от имен обычной переменной, объекта или функции (метода).

Этим символом обозначается вызов функции jQuery (что также при желании можно сделать). Замысел его использования заключается в сохранении краткости и приятного внешнего вида кода, а также избавлении от излишнего набора текста при каждом обращении к jQuery. Кроме того, при виде этого символа другие, ранее не знакомые с вашим кодом разработчики сразу же понимают, что в коде используется jQuery (или подобная ей библиотека).


### Простой пример
---

В наипростейшем виде обращение к jQuery осуществляется набором символа `$`, за которым следует заключенный в скобки селектор, точка и метод, применяемый к выбранному элементу (или элементам).

Например, для изменения семейства шрифтов всех абзацев на моноширинное можно воспользоваться следующей инструкцией:
```js
$('p').css('font-family', 'monospace')
```

А для добавления границы к элементу `<code>` можно применить такую инструкцию:
```js
$('code').css('border', '1px solid #aaa')
```

Взглянем на часть полноценного **примера 22.1**, где фрагменты, относящиеся к использованию jQuery, выделены полужирным шрифтом.

>**Пример 22.1.** Простой пример применения jQuery
```html
<!DOCTYPE html>
<html lang="en">
 
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <title>Первый пример jQuery</title>
</head> 

<body>
  В jQuery в качестве имен функций используются
  либо <code>$()</code>, либо <code>jQuery()</code>.
  <script>
    $('code').css('border', '1px solid #aaa')
  </script>
</body>

</html>
```

После загрузки этого примера в браузер будет получен результат, показанный на **рис. 22.1**. Разумеется, конкретно эта инструкция просто подменяет собой то, что можно сделать с помощью обычного кода CSS, но я хотел показать синтаксис jQuery, поэтому пока не стал ничего усложнять.

>[!info]
>Еще один способ выдачи этой команды заключается в вызове функции jQuery (которая работает точно так же, как и $):
>
>```js
>jQuery('code').css('border', '1px solid #aaa')
>```

>![[Рис. 22.1. Изменение элементов с помощью jQuery.jpg]]
>**Рис. 22.1.** Изменение элементов с помощью jQuery


#### Как избежать конфликтов библиотек
---

Если наряду с jQuery используются и другие библиотеки, может оказаться, что в них определены собственные функции **`$`**. Для решения данной проблемы можно в отношении этого символа вызвать метод `noConflict`, который освобождает этот символ от управляющей функции, позволяя другим библиотекам воспользоваться им:
```js
$.noConflict()
```

После этого для доступа к jQuery следует вызывать функцию jQuery. Или же символ `$` можно заменить именем объекта по вашему выбору:
```js
jq = $.noConflict()
```

Теперь в тех местах, где прежде применялся символ `$`, для вызова jQuery можно воспользоваться ключевым словом `jq`.

>[!tip]
>Чтобы отличать объекты jQuery и отслеживать их отдельно от объектов стандартных элементов, некоторые разработчики устанавливают символ $ в виде префикса перед любым объектом, созданным с помощью jQuery (что делает их похожими на переменные PHP!).


### Селекторы
---

После того как вы увидели, насколько просто можно включить jQuery в веб-страницу и обратиться к функциям этой библиотеки, перейдем к рассмотрению используемых в ней селекторов, которые (я уверен, что вы будете рады это узнать) работают точно так же, как CSS. По сути, их применение является основой работы большинства функций jQuery.

Вам остается лишь подумать о том, как бы вы оформили стиль одного или нескольких элементов с применением CSS, а затем можете использовать тот же самый селектор (или селекторы) для применения операций jQuery к этим выбранным элементам. Это означает, что вы можете воспользоваться селекторами элементов, селекторами идентификаторов, селекторами классов и любыми их сочетаниями.


#### Метод css
---

Чтобы объяснить применение селекторов в jQuery, сначала посмотрим на один из более фундаментальных методов jQuery, css, с помощью которого можно динамически менять любое свойство CSS. Этому методу передаются два аргумента: имя свойства, к которому осуществляется обращение, и значение, которое к этому свойству применяется:
```js
css('font-family', 'Arial')
```

Как будет показано в следующих разделах, сам по себе этот метод применять невозможно, поскольку его нужно использовать в селекторе jQuery, который выберет один или несколько элементов, чьи свойства должны быть изменены этим методом. В следующем примере содержимому всех **`<р>`**-элементов предписывается отображение с полным выравниванием по ширине:
```js
$('p').css('text-align', 'justify')
```

Метод css можно также использовать для возвращения (а не для установки) вычисленного значения, для чего ему предоставляется только имя свойства (а второй аргумент опускается). В этом случае возвращается значение первого же соответствующего селектору элемента. Например, выполнение следующего кода приведет к возвращению цвета текста того элемента, чей идентификатор (`ID`) имеет значение `elem`, и это значение будет в том же формате, в каком цвет задается при применении метода `rgb`:
```js
color = $('#elem').css('color')
```

Следует помнить, что возвращаемое значение является вычисленным. Иными словами, jQuery будет вычислять и возвращать значение, используемое браузером на момент вызова метода, а не то исходное значение, которое могло быть присвоено свойству посредством таблицы стилей или любым другим способом.

Следовательно, если текст, к примеру, показан синим цветом, значением, присвоенным переменной `color` в предыдущей инструкции, будет `rgb(0, 0, 255)`, даже если цвет изначально был установлен с использованием имени цвета `blue` или с использованием строк шестнадцатеричных чисел `#00f` или `#0000ff`. Но это вычисленное значение всегда будет в форме, которая может быть снова назначена элементу (или любому другому элементу) при использовании в качестве второго аргумента метода css.

>[!danger]
>К любым вычисленным размерам, возвращаемым этим методом, нужно относиться осмотрительно, поскольку в зависимости от текущих установок свойства `box-sizing` ([[Продвинутая стилизация страниц с помощью CSS3]]) они могут быть, а могут и не быть именно тем, что вы ожидаете получить. Когда нужно получить или установить значения ширины и высоты без учета значения свойства `box-sizing`, следует использовать методы `width` и `height` (и родственные им), рассматриваемые в разделе «Изменение размеров изображения» далее.


##### Селектор элемента
---

Для выбора элемента, обрабатываемого с помощью jQuery, нужно просто указать его имя внутри круглых скобок, следующих за символом `$` (или за именем функции jQuery). Например, если нужно изменить цвет фона всех элементов `<blockquote>`, можно воспользоваться следующей инструкцией:
```js
$('blockquote').css('background', 'lime')
```


##### Селектор идентификатора
---

Ссылаться на элементы можно также по их идентификаторам (ID), если перед именем идентификатора поместить символ `#`. Следовательно, чтобы, к примеру, добавить границу к элементу с идентификатором `advert`, можно воспользоваться такой инструкцией:
```js
$('#advert').css('border', '3px dashed red')
```


##### Селектор класса
---

Можно также воздействовать на группу элементов в соответствии с используемым ею классом. Например, для подчеркивания всех элементов, применяющих класс `new`, можно воспользоваться следующей инструкцией:
```js
$('.new').css('text-decoration', 'underline')
```


#### Сочетание селекторов
---

Как и при использовании CSS, селекторы можно сочетать друг с другом, составляя единый jQuery-выбор, для чего, как в следующем примере, применяются запятые:
```js
$('blockquote, #advert, .new').css('font-weight', 'bold')
```

В **примере 22.2** все типы селекторов собраны вместе, а инструкции jQuery выделены полужирным шрифтом. Результат выполнения кода примера показан на **рис. 22.2**.

>**Пример 22.2.** Использование jQuery с различными селекторами
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Второй пример jQuery</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <blockquote>При всей гибкости и эффективности JavaScript, а также
    при всем изобилий имеющихся в этом языке встроенных функций все же
    сохраняеться потребность в дополнительных уровнях кода, позваляющих
    упростить, к примеру, получение эффектов анимации, обработку           событий и применение технологий асинхронного обмена данными, то        есть сделать то, чего нельзя достичь применением обычных средств       JavaScript или CSS.
  </blockquote>
  <div id="advert">Это реклама</div>
  <p>Это мой <span class="new">новый</span> сайт</p>
  <script>
    $('blockquote').css('background', 'lime')
    $('#advert').css('border', '3px dashed red')
    $('.new').css('text-decoration', 'underline')
    $('blockquote, #advert, .new').css('font-weight', 'bold')
  </script>
</body> 

</html>
```
>![[Рис. 22.2. Воздействие сразу на несколько элементов.jpg]]
>**Рис. 22.2.** Воздействие сразу на несколько элементов


#### Обработка событий
---

Если бы библиотека jQuery умела только подменять CSS-стили, толку от нее было бы маловато, и она, конечно же, способна на гораздо большее. Продолжим исследование и посмотрим, как она обрабатывает события.

Как вы, наверное, помните, большинство событий инициируется действиями пользователя: при прохождении указателя мыши над элементом, щелчке кнопкой мыши или нажатии клавиши. Но существуют и другие события, которые могут инициироваться, к примеру, по завершении загрузки документа.

Прикрепить ваш собственный код к этим событиям с помощью jQuery не составит труда, причем сделано это будет безопасным способом, не блокирующим для другого кода получение такого же доступа к ним. Вот, к примеру, как можно заставить код jQuery откликнуться на щелчок на элементе:

```js
$('#clickme').click(function()
{
  $('#result').html('You clicked the button!')
})
```

Когда будет сделан щелчок на элементе с идентификатором **`clickme`**, свойство **`innerHTML`** элемента со значением ID, равным **`result`**, будет обновлено с использованием jQuery-функции **`html`**.

Конкретизация замысла, результат которой можно увидеть на **рис. 22.3**, показана в **примере 22.3**.

>[!danger]
>Объекты jQuery, созданные с помощью метода **`$`** либо метода jQuery, не являются аналогами объектов JavaScript, созданных с помощью **`getElementById`**. В обычном коде JavaScript можно использовать такие инструкции, как **`object = document.getElementById('result')`**, за которыми, к примеру, следует инструкция **`object.innerHTML = 'something'`**. Но в предыдущем примере код **`$('#result').innerHTML`** работать не будет, поскольку **`innerHTML`** не является свойством объекта jQuery. Следовательно, для достижения требуемого результата нужно использовать jQuery-метод `html`.

>**Пример 22.3.** Обработка события
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События jQuery</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>

</head>

<body>
  <button id="clickme">Нажмите меня</button>
  <p id="result">Я - абзац</p>
  <script>
    $("#clickme").click(function(){
      $("#result").html("Вы нажали кнопку!")
    })
  </script> 

</body> 

</html>
```
>[!danger]
>При обращении к событию с помощью jQuery префикс on, который нужно использовать в стандартном JavaScript, следует опустить. Поэтому, к примеру, название события `onmouseover` превращается в jQuery в имя функции `mouseover`, `onclick` приобретает вид `click` и т. д.

>![[Рис. 22.3. Обработка события click.jpg]]
>**Рис. 22.3.** Обработка события `click`


#### Ожидание готовности документа
---

Поскольку тому, что достигается средствами jQuery, мы во многом обязаны весьма тесной связи этой библиотеки с объектной моделью документа — DOM, вам, прежде чем воздействовать на какие-либо части страницы, скорее всего, придется дождаться ее загрузки. Без jQuery это может быть выполнено с помощью события onload, но есть более эффективный кросс-браузерный jQuery-метод под названием `ready`, который можно вызвать для включения в работу в самый ранний из возможных моментов времени, даже раньше, чем наступит событие `onload`. ==Это означает, что jQuery может начать работать на странице намного быстрее и с минимальными задержками для пользователя.==

Чтобы воспользоваться этой возможностью, поместите свой код jQuery внутрь следующей структуры:
```js
$('document').ready(function()
{
  // Сюда нужно поместить ваш код
})
```

Теперь код будет ждать готовности документа и только после этого будет вызван методом `ready`. На самом деле можно набрать еще меньший объем кода и воспользоваться более краткой версией, показанной в **примере 22.4**.

>**Пример 22.4.** Наименьший по объему код охватывающей функции, запускаемой по готовности документа (своеобразный аналог метода `ready`)
```js
$(function()
{
  // Сюда нужно поместить ваш код
})
```

>[!danger] Остерегайтесь!
>Можно использовать альтернативный подход: помещать код JavaScript в конец каждой HTML-страницы, чтобы он выполнялся только после загрузки всего документа. Есть и менее существенное преимущество: поскольку приоритет в загрузке отдается содержимому веб-страницы, у пользователя от работы с такой страницей складывается более благоприятное впечатление.
>
>Единственная ситуация, при которой размещение сценариев в самом конце страницы может вызвать возражение, связана с тем, что документ выглядит как готовый к работе, но фактически он к ней еще не готов, или с тем, что все внешние таблицы стилей еще не загружены (реально определить это можно только тестированием), что вводит пользователей в заблуждение относительно возможности работы с документом до того, как к этому будет готов ваш сценарий. В таких случаях применяйте функцию `ready`, и все будет в порядке. Если же у вас есть сомнения, поместите свой сценарий в конец страницы и добавьте его jQuery-вызовы в функцию `ready`, и тогда вы возьмете все самое лучшее от обоих вариантов.

Если выработать привычку добавлять свои jQuery-инструкции в одну из этих двух структур, то не придется сталкиваться с тем типом ошибок, которые могут выдаваться при попытке слишком раннего обращения к DOM.


### Функции и свойства событий
---

До сих пор был показан только метод события `ready`, но в jQuery имеется несколько десятков методов событий и связанных с событиями свойств, к которым можно обратиться (их так много, что подробно рассмотреть здесь весь арсенал не представляется возможным). Но рассматриваемые далее функции и свойства относятся к наиболее востребованным и позволят вам начать их использовать в большинстве проектов. Всестороннее описание всех доступных событий можно найти на сайте api.jquery.com/category/events.



#### События `blur` и `focus`
---

Событие `blur` ==инициируется, когда фокус убирается с элемента, заставляя этот элемент выглядеть потерявшим фокус, и оно является хорошим партнером для события== `focus`. Для добавления обработчика к событию могут использоваться методы `blur` и `focus`. Если же в круглых скобках при вызове метода будут опущены все аргументы, он будут инициировать событие.

В **примере 22.5** показаны четыре поля ввода, и первое из них благодаря вызову метода `focus`, применяемого к элементу с идентификатором `first`, сразу же получает фокус. Затем ко всем элементам `input` добавляются два обработчика. Обработчик события `focus` устанавливает для этих элементов желтый фон, когда они получают фокус, а обработчик события `blur` устанавливает для них светло-серый фон, когда фокус с них убирается (у них теряется).

>**Пример 22.5.** Использование событий `focus` и `blur`
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: blur</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <h2>Щелкните в пределах и за пределах этих полей</h2>
  <input id="first"> <input><input> <input>
  <script>
    $('#first').focus()
    $('input').focus(function() { $(this).css('background', '#ff0')})
    $('input') .blur(function() { $(this).css('background', '#aaa')})
  </script>
</body>

</html>
```

>[!info] На заметку!
>Между закрывающей скобкой метода и оператором-точкой, используемым для прикрепления к нему еще одного метода, разрешается включать пробельные символы (и после точки тоже), что я и сделал в предыдущем примере, чтобы выровнять по правому краю имена событий `focus` и `blur`, находящиеся друг под другом, чтобы все остальные части инструкций также выстроились в столбец.

На **рис. 22.4** показано, как с помощью этого кода любым полям ввода, у которых когда-либо был фокус, придается светло-серый цвет фона. Если у одного из полей в данный момент имеется фокус, цвет его фона становится желтым, а не посещённые поля по-прежнему имеют белый цвет фона.

>![[Рис. 22.4. Прикрепление обработчиков к событиям blur и focus.jpg]]
>**Рис. 22.4.** Прикрепление обработчиков к событиям `blur` и `focus`


#### Ключевое слово **`this`**
---

Этот пример также служит иллюстрацией применения ключевого слова `this`. При вызове события объекту `this` передается элемент, в отношении которого это событие было инициировано, и теперь этот объект может быть передан методу `$` для обработки. Или же, поскольку он является стандартным объектом JavaScript (а не объектом `jQuery`), он может быть использован в качестве такого объекта. Поэтому если хотите, можете заменить следующий код:

```js
$(this).css('background', '#ff0')
```

вот этим кодом:

```js
this.style.background = '#ff0'
```


#### События **`click`** и **`dblclick`**
---

Событие **`click`** ранее уже рассматривалось, но есть также событие, предназначенное для обработки двойных щелчков. Чтобы воспользоваться любым из них, нужно прикрепить метод события к селектору jQuery, а в качестве его аргумента предоставить jQuery-метод, который будет запущен, когда это событие произойдет:

```js
$('.myclass')   .click( function() { $(this).slideUp() }) $('.myclass').dblclick( function() { $(this).hide() })
```

Здесь я решил использовать безымянные функции, но при желании вместо них можно воспользоваться функциями с именами (но не забудьте, что предоставить нужно только имя функции без круглых скобок, в противном случае она будет вызвана несвоевременно). Объекту `this` будет передано то, что и ожидалось, и он станет доступен именованной функции:

```js
$('.myclass').click(doslide)
function doslide()
{
  $(this).slideUp()
}
```

Подробное описание методов **`slideUp`** и **`hide`** дается в разделе «Специальные эффекты» далее. А сейчас просто попробуйте запустить код **примера 22.6** и сделайте одинарный либо двойной щелчок на кнопках, чтобы посмотреть, как часть из них исчезают с применением анимации (при использовании **`slideUp`**), а другие просто исчезают (при использовании **`hide`**). Результат работы кода показан на **рис. 22.5**.

>**Пример 22.6.** Прикрепления к событиям `click` и `dblclick`
```html
<!DOCTYPE html>
<html lang="ru">
  
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: click и dblclick</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <h2>Сделайте на кнопках одинарный и двойной щелчок</h2>
  <button class="myclass">Кнопка 1</button>
  <button class="myclass">Кнопка 2</button>
  <button class="myclass">Кнопка 3</button>
  <button class="myclass">Кнопка 4</button>
  <button class="myclass">Кнопка 5</button>
  <script>
    $('.myclass')   .click(function() {$(this).slideUp()})
    $('.myclass').dblclick(function() {$(this).hide()})
  </script>
</body> 

</html>
```

>![[Рис. 22.5. На кнопке 3 был сделан одинарный щелчок, и она ускользнула вверх.jpg]]
>**Рис. 22.5.** На кнопке 3 был сделан одинарный щелчок, и она ускользнула вверх


#### Событие **`keypress`**
---

Периодически возникает потребность в более тщательном контроле работы пользователя на клавиатуре, в особенности при обработке сложных форм или написании игр. В таких случаях можно воспользоваться методом **keypress**, который может быть прикреплен к любому элементу, воспринимающему клавиатурный ввод, например к полю ввода или даже самому документу.

В **примере 22.7** метод прикреплен к документу, чтобы перехватывать все нажатия клавиш, и результат его запуска показан на **рис. 22.6.**

>**Пример 22.7.** Перехват нажатия клавиш
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: keypress</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <h2>Нажмите какие-нибудь клавиши</h2>
  <div id="result"></div>
  <script>
    $(document).keypress(function(event){
      key = String.fromCharCode(event.which)
      if (key >= 'a' && key <= 'z' ||
          key >= "A" && key <= 'Z' ||
          key >= "0" && key <= '9')
      {
        $('#result').html('Вы нажали: ' + key)
        event.preventDefault()
      }
    })
  </script>
</body>  

</html>
```

>![[Рис. 22.6. Обработка событий нажатия клавиш.jpg]]
>**Рис. 22.6.** Обработка событий нажатия клавиш

В этом примере следует обратить внимание на ряд особенностей, которые нужно учитывать при написании собственных обработчиков действий на клавиатуре. К примеру, поскольку браузеры возвращают для этого события разные значения, свойство **`which`** объекта `event` нормализуется библиотекой jQuery, чтобы все браузеры возвращали одни и те же коды символов. Это делается для того, чтобы можно было определить, какая клавиша была нажата.

Но значение в свойстве **`which`**, будучи кодом символа, является числом, которое можно превратить в отдельную букву, пропустив его через код **`String.fromCharCode`**. Вам этого делать не нужно, поскольку вы легко можете в своем коде откликаться на ASCII-значения. Но данный метод пригодится, когда нужно будет работать с символами.

Когда в блоке **`if`** нажатая клавиша будет распознана, код примера вставляет для производства соответствующего эффекта простую инструкцию в свойство **`innerHTML`** элемента **`<div>`**, у которого имеется идентификатор (**`ID`**) со значением `result`.

>[!danger]
>Это тот самый пример, в котором не следует использовать функцию **`document.write`**, поскольку на момент нажатия клавиши пользователем документ должен быть полностью загружен. Если **`document.write`** будет вызван для показа информации до того, как это произойдет, будет стерт весь документ. При таких обстоятельствах, как объяснялось в разделе «О функции **`document.write`**» [[Изучение JavaScript]], лучше вести запись в HTML-элемент, то есть воспользоваться неразрушающим способом предоставления пользователю обратной связи.


### Деликатное программирование
---

Ожидая пользовательского ввода, нужно решить, на какие значения следует откликаться, после чего игнорировать все остальные значения на тот случай, если к ним должен получить доступ какой-нибудь другой обработчик событий. Это будет примером деликатности, проявляемой по отношению к любой другой полезной программе, которая может находиться в рабочем состоянии (и к самому основному браузеру). Например, в предыдущем примере был выбран прием только символов в диапазонах a–z, A–Z и 0–9, а все остальные символы были проигнорированы.

Есть два способа пропуска прерываний клавиатуры к другим обработчикам (или отказа им в обработке этих прерываний). Во-первых, ничего не делать, тогда при выходе из вашего кода другие обработчики также будут все видеть и смогут реагировать на те же нажатия клавиш. Но это может привести к путанице в том случае, если из-за одного нажатия клавиши произойдет сразу несколько действий.

Альтернативный вариант применяется в том случае, если вам не нужно, чтобы событие инициировало работу других обработчиков, тогда в отношении объекта `event` можно вызвать метод **`preventDefault`**, который не допустит «всплытия» события на уровень других обработчиков.

>[!danger]
>Помещая в код вызов метода `preventDefault`, нужно проявлять особую осмотрительность, поскольку если этот вызов находится за пределами той части кода, в которой ведется обработка нажатий клавиш, это создаст препятствие для всплытия всех остальных клавиатурных событий и вы можете заблокировать пользователя от использования браузера (или как минимум от использования некоторых его возможностей).


#### Событие **`mousemove`**
---

Наиболее часто осуществляется перехват событий, связанных с использованием мыши. Щелчки кнопками мыши уже рассматривались, а теперь посмотрим на прикрепление кода к событиям перемещения указателя мыши.

Полагаю, настало время перейти к демонстрации более интересных примеров, и в **примере 22.8** я объединил простейшую программу рисования, использующую jQuery, с холстом HTML5. Хотя до [[Холсты в HTML5]] все особенности холста рассматриваться не будут, волноваться не стоит, поскольку код очень простой.

>**Пример 22.8.** Перехват событий перемещения указателя мыши и нажатия ее кнопок
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: обработка действий с мышью</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <style>
    #pad {
      background: #def;
      border: 1px solid #aaa;
    }
  </style>
</head> 

<body>
  <canvas id="pad" width="480" height="360"></canvas>
  <script>
    canvas = $('#pad')[0]
    context = canvas.getContext("2d")
    peandown = false
    $('#pad').mousemove(function(event){
      var xpos = event.pageX - canvas.offsetLeft
      var ypos = event.pageY - canvas.offsetTop
  
      if (peandown) context.lineTo(xpos, ypos)
      else context.moveTo(xpos, ypos)

      context.stroke()
    }) 
    $('#pad').mousedown(function(){peandown = true})
    $('#pad').mouseup(function(){peandown = false})
  </script>
</body>

</html>
```

На рис. 22.7 показано, как этот очень простой набор инструкций может использоваться для рисования линий (что может пригодиться тем, у кого есть талант к рисованию). Вот как это работает. Сначала путем ссылки на первый (с нулевым индексом) элемент селектора jQuery программа создает объект canvas:
```js
canvas = $('#pad')[0]
```

Это один из способов быстрого получения объекта jQuery и извлечения стандартного объекта элемента JavaScript. Другой способ предусматривает использование метода get:
```js
canvas = $(,#padI).get(0)
```

>![[Рис. 22.7. Перехват событий перемещения указателя мыши и нажатия ее кнопок.jpg]]
>**Рис. 22.7.** Перехват событий перемещения указателя мыши и нажатия ее кнопок

Оба способа взаимозаменяемы, но при использовании метода **`get`** есть одно преимущество: если ему не передать аргументы, он вернет все объекты элементов узла из объекта jQuery в виде массива.

В [[Холсты в HTML5]] будет рассказано, что холст всегда создается для использования специального объекта **`context`**, который сейчас и будет определен:
```js
context = canvas.getContext("2d")
```

Нужно инициализировать еще кое-что, создав булеву переменную под названием **`pendown`** (перо опущено), которая будет использоваться для отслеживания состояния кнопки мыши (с исходным значением **`false`**, поскольку перо пока что поднято):
```js
pendown = false
```

После этого холст canvas (с идентификатором pad) получает свое событие **`mousemove`**, перехватываемое показанной далее безымянной функцией, благодаря которой происходят три набора действий:
```js
$('#pad').mousemove(function(event)
{
  ...
})
```

Сначала локальным переменным **`xpos`** и **`ypos`** (они являются локальными благодаря применению ключевых слов **`var`**, хотя сейчас вместо них лучше использовать **`let`**) присваиваются значения, представляющие собой позицию указателя мыши в области холста.

Эти значения берутся из свойств jQuery `pageX` и `pageY`, которые ссылаются на смещение указателя мыши от верхнего левого угла соответствующего документа. Поэтому, так как сам холст немного смещен с этой позиции, значения смещения холста canvas (в свойствах **`offsetLeft`** и **`offsetTop`**) вычитаются соответственно из **`pageX`** и **`pageY`**:

```js
var xpos = event.pageX – canvas.offsetLeft
var ypos = event.pageY – canvas.offsetTop
```

Теперь, когда нам известно, где находится указатель мыши по отношению к холсту, в следующих двух строках кода тестируется значение переменной **`pendown`**. Если оно равно **`true`**, значит, была нажата кнопка мыши, и поэтому вызывается метод **`lineTo`** для рисования линии в текущей позиции. В противном случае перо поднято, и поэтому вызывается метод **`moveTo`**, для того чтобы просто обновить значения текущей позиции:

```js
if (pendown) context.lineTo(xpos, ypos)
else context.moveTo(xpos, ypos)
```

Затем вызывается метод **`stroke`** для применения той команды рисования, которая только что была вызвана по отношению к холсту. Эти пять строк — все, что нужно для управления рисованием, но следует по-прежнему отслеживать состояние кнопки мыши, и поэтому завершающие две строки кода перехватывают события **`mousedown`** и **`mouseup`**, устанавливая для **`pendown`** значение **`true`** при нажатии кнопки мыши и **`false`** при ее освобождении:

```js
$('#pad').mousedown(function() { pendown = true } )
$('#pad') .mouseup(function() { pendown = false } )
```

В этом примере показано сочетание работающих вместе трех разных обработчиков событий для создания полезной программы, использующей как локальные переменные для внутренних выражений, так и глобальные переменные, где объект или состояние чего-либо должны быть сделаны доступными нескольким функциям.


#### Другие события, связанные с мышью
---

События **`mouseenter`** и **`mouseleave`** инициируются при прохождении указателя мыши над элементом или при выходе его за границы элемента. Позиционные значения не предоставляются, поскольку предполагается, что вам просто требуется принять логическое решение о том, что делать при выдаче одного из этих событий.

В **примере 22.9** к этим событиям прикреплены две безымянные функции, которые, как показано на **рис. 22.8**, изменяют соответствующим образом HTML-код элемента.

>**Пример 22.9.** Определения входа указателя в границы элемента и выхода за их пределы
```html
<!DOCTYPE html>
<html>

  <head>
    <meta charset="UTF-8">
    <title>События: дальнейшая обработка событий мыши</title>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  </head>

  <body>
    <h2 id="test">Проведи надо мной указатели мыши</h2>
    <script>
      $('#test').mouseenter(function() {$(this).html('Эй, прекрати                                                          щекотать!')})
      $('#test').mouseleave(function() {$(this).html('Куда же ты                                                            подевался?')})
    </script>
  </body>

</html>
```

>![[Рис. 22.8. Определение момента входа указателя мыши в границы элемента.jpg]]
>**Рис. 22.8.** Определение момента входа указателя мыши в границы элемента и выхода за их пределы

Когда указатель мыши входит в границы выбранного элемента, обновляется свойство элемента **`innerHTML`** (посредством вызова метода `html`). Затем, когда указатель мыши снова оказывается за границами элемента, происходит еще одно обновление HTML-кода элемента.


##### Альтернативные методы работы с мышью
---

В jQuery доступны и другие функции, связанные с событиями мыши и охватывающие широкий диапазон возможных обстоятельств. Подробное описание всех этих функций можно найти по адресу api.jquery.com/category/events/mouse-events.

К примеру, для получения таких же результатов, как и при выполнении кода из предыдущего раздела, можно воспользоваться следующими альтернативными методами **`mouseover`** и **`mouseout`**:

```js
$('#test').mouseover(function() {$(this).html('Cut it out!')}) $('#test').mouseout(function() {$(this).html('Try it this time...')})
```

Или же, чтобы связать два обработчика с помощью одной функции, можно воспользоваться методом **`hover`**:

```js
$('#test').hover(function() {$(this).html('Cut it out!')})
                 function() {$(this).html('Try it this time...')})
```

Если планируется получение совокупного эффекта от применения **`mouseover`** и **`mouseout`**, то вполне логично будет воспользоваться методом **`hover`**, но есть еще один способ, позволяющий получить такой же результат, который называется *выстраиванием цепочки* (и объясняется чуть позже в разделе «Выстраивание цепочки методов»):

```js
$('#test').mouseover(function() {$(this).html('Cut it out!')})
          .mouseout(function() {$(this).html('Try it this time...')})
```

==Здесь оператор-точка в начале второй инструкции прикрепляет ее к первой инструкции, создавая тем самым цепочку методов.==

>[!info]
>В предыдущих примерах показан способ перехвата щелчка кнопкой мыши, перемещения указателя мыши и события клавиатуры, в силу чего они больше всего подходят для сред настольных компьютеров, на которые в первую очередь и нацелено применение библиотеки jQuery. Но существует также версия jQuery для мобильных устройств под названием [[Введение в jQuery Mobile|jQuery Mobile]], обеспечивающая управление обработкой всех событий прикосновений, которые вам только могут потребоваться (и многое другое), и доступная по адресу http://jquerymobile.com/.


#### Событие **`submit`**
---

При отправке формы может понадобиться выполнение различных проверок на наличие ошибок во введенных данных перед отправкой их на сервер. Как показано в **примере 22.10**, одним из способов получения такой возможности является перехват события **`submit`**, происходящего в форме. На **рис. 22.9** показан результат загрузки документа с последующей отправкой формы с одним или двумя незаполненными полями.

>**Пример 22.10.** Перехват события **`submit`**, происходящего в форме
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: submit</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <form id="form">
    Имя: <input id="fname" type="text" name="fname"><br>
    Фамилия: <input id="lname" type="text" name="lname"><br>
    <input type="submit">
  </form>
  <script>
    $('#form').submit(function(){
      if ($('#fname').val() == '' || $('#lname').val() == '')
      {
        alert('Пожалуйста введите имя фамилию.')
        return false
      }
    })
  </script>
</body>  

</html>
```

>![[Рис. 22.9. Проверка пользовательского ввода после отправки.jpg]]
>**Рис. 22.9.** Проверка пользовательского ввода после отправки

Основной частью этого примера является код, в котором к событию прикрепляется безымянная функция:
```js
$('#form').submit(function()
```

и где значения двух полей ввода проверяются на их заполнение:
```js
if ($('#fname').val() == '' ||
    $('#lname').val() == '')
```

Здесь для получения значения свойства `value` каждого поля используется **jQuery-метод** `val`. Этот прием выглядит лучше, чем использование **`$('#fname')[0]`** (как в **примере 22.8**) для получения доступа к DOM-объекту с последующим добавлением к нему свойства `value` для чтения значения поля:
```js
$('#fname')[0].value.
```

В данном примере при возвращении значения `false` в случае незаполненности одного или нескольких полей обычный процесс отправки прекращается. Чтобы разрешить отправку, нужно, чтобы было возвращено значение `true` или вообще не возвращалось никакое значение.


## Специальные эффекты
---

В чем действительно преуспела библиотека jQuery, так это в создании спецэффектов. Можно, конечно, воспользоваться переходами CSS3, но их динамическое управление из JavaScript не всегда настолько же простое, а с использованием jQuery все сведется к выбору одного или нескольких элементов с последующим применением к ним одного или нескольких эффектов.

Основными доступными эффектами являются исчезновение и появление, постепенное проявление и растворение, скольжение, а также анимация, которые могут использоваться по одному, все вместе согласованно по времени или друг за другом. Поддерживаются также обратные вызовы, представляющие собой функции или методы, вызываемые только один раз по завершении операции.

В следующем разделе дается описание ряда наиболее полезных jQuery-эффектов, каждым из которых поддерживаются три аргумента.

- *Продолжительность* (*Duration*). Когда предоставляется это значение, эффект будет наблюдаться в течение назначенного времени, которое может быть задано в миллисекундах или же строками **fast** (быстро) или **slow** (медленно).
- *Изменение скорости выполнения эффекта* (*Easing*). В библиотеке jQuery только два варианта изменения скорости: **swing** (с ускорением) и **linear** (линейное изменение). По умолчанию используется вариант **swing**, который задает более естественное изменение скорости эффекта, чем **linear**. Дополнительные варианты изменения скорости выполнения эффекта можно найти в таких дополнительных модулях, как jQuery UI, который можно увидеть на сайте http://jqueryui.com/easing/.
- *Функция обратного вызова* (*Callback*). Если предоставлена функция обратного вызова, она будет вызвана сразу же после завершения работы метода создания эффекта.

Это означает, что в случае отсутствия предоставляемых аргументов метод вызывается немедленно и в очередь анимации не попадает.

К примеру, метод **`hide`** можно вызвать несколькими способами:

```js
$('#object').hide()
$('#object').hide(1000)
$('#object').hide('fast')
$('#object').hide('linear')
$('#object').hide('slow', 'linear')
$('#object').hide(myfunction)
$('#object').hide(333, myfunction)
$('#object').hide(200, 'linear', function() { alert('Finished!') } )
```

Как будет показано в разделе «Выстраивание цепочки методов» далее, можно прикрепить вызовы функций (с аргументами) друг к другу, а затем они будут анимированы в порядке очереди как в следующем примере, где элемент сначала исчезнет, а затем появится снова:

```js
$('#object').hide(1000).show(1000)
```

Многими этими методами поддерживаются и другие, менее востребованные аргументы, подробное описание которых (а также других поддерживаемых методов создания эффектов) можно найти по адресу http://api.jquery.com/category/effects.


### Исчезновение и появление
---

Наверное, простейшим эффектом можно считать исчезновение и появление элемента в ответ на действия пользователя. В предыдущем разделе говорилось, что методам **`hide`** и **`show`** можно вообще не предоставлять никаких аргументов или же предоставлять различные аргументы, а по умолчанию, когда им ничего не предоставлено, результатом станет мгновенное исчезновение или появление элемента.

Когда аргументы предоставляются, эти два метода одновременно изменяют свойства элемента **`width`**, **`height`** и **`opacity`** до тех пор, пока их значения не достигнут нуля при использовании метода **`hide`** или исходных установок — при использовании метода **`show`**. После полного исчезновения элемента метод **`hide`** присваивает его свойству **`display`** значение none, а метод show после полного появления элемента снова присваивает этому свойству ранее назначенное ему значение.

Испытать работу методов **`hide`** и **`show`** позволит код **примера 22.11**, а результат можно увидеть на **рис. 22.10**.

>**Пример 22.11.** Исчезновение и появление элемента
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Эффекты: hide и show</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <button id="hide">Спрятать</button>
  <button id="show">Показать</button>
  <p id="text">Щелкните на кнопки Спрятать и Показать</p>
  <script>
    $('#hide').click(function () { $('#text').hide('slow', 'linear') })
    $('#show').click(function () { $('#text').show('slow', 'linear') })
  </script>
</body>

</html>
```
>![[Рис. 22.10. Элемент в процессе появления.jpg]]
>**Рис. 22.10.** Элемент в процессе появления


### Метод **`toggle`**
---

Альтернативой вызову обоих методов, как **`hide`**, так и **`show`**, может стать вызов метода **`toggle`**, который позволяет заменить предыдущий пример кодом из **примера 22.12**.

>**Пример 22.12**. Использование метода **`toggle`**
```html
<!DOCTYPE html>
<html>

  <head>
    <title>Effects: toggle</title>
    <script src='jquery-3.5.1.min.js'></script>
  </head>

  <body>
    <button id='toggle'>Toggle</button>
    <p id='text'>Click the Toggle button</p>
    <script>
      $('#toggle').click(function() { $('#text').toggle('slow', 'linear') })
    </script>
  </body>

</html>
```

Методу **`toggle`** передаются точно такие же аргументы, что и методам **`hide`** и **`show`**, но он отслеживает внутреннее состояние элемента, зная таким образом, что нужно делать — заставлять элемент исчезнуть или появиться.

>[!info]
>В jQuery имеются четыре основных метода, устанавливающих либо одно, либо другое состояние и предлагающих для упрощения программирования версии переключения. Кроме **`toggle`**, имеются методы **`fadeToggle`**, **`slideToggle`** и **`toggleClass`**, которые будут рассмотрены в данной главе.


### Проявление и растворение
---

Проявлением и растворением управляют четыре метода: **`fadeIn`**, **`fadeOut`**, **`fadeToggle`** и **`fadeTo`**. Теперь вы уже имеете представление о том, как работает jQuery, и сможете разобраться в том, что первые три метода похожи, соответственно, на методы **`show`**, **`hide`** и **`toggle`**.

Но последний метод имеет некоторые отличия: ему можно указывать значение непрозрачности (**`opacity`**) от 0 до 1, до которого элемент (или элементы) должен проявиться.

В **примере 22.13** представлены четыре кнопки, позволяющие проверить в действии каждый из этих методов. Результат показан на **рис. 22.11**.

>**Пример 22.13**. Четыре метода проявления и растворения
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Эффекты: Проявления и Растоворения</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <button id="fadeout">Растворить</button>
  <button id="fadein">Проявить</button>
  <button id="fadetoggle">Переключить состояние</button>
  <button id="fadeto">Растворить на 50 %</button>
  <p id="text">Щелкните на кнопках, расположенных вверху</p>
  <script>
    $('#fadeout').click(function() { $('#text').fadeOut('slow') })
    $('#fadein').click(function() { $('#text').fadeIn('slow') })
    $('#fadetoggle').click(function(){ $('#text').fadeToggle('slow') })
    $('#fadeto').click(function() { $('#text').fadeTo('slow', 0.5) })
  </script>
</body>

</html>
```
>![[Рис. 22.11. Текст проявился, став прозрачным на 50 %.jpg]]
>**Рис. 22.11.** Текст проявился, став прозрачным на 50 %


### Скольжение элементов вверх и вниз
---

Еще один способ, заставляющий элементы исчезать и появляться снова, заключается в постепенном изменении их высоты с целью имитации ускользания элементов за границу и выскальзывания из-под этой границы. Для достижения этих эффектов доступны три метода jQuery: **`slideDown`**, **`slideUp`** и **`slideToggle`**. Они работают по тем же принципам, что и предыдущие, в чем можно убедиться, запустив на выполнение код **примера 22.14.** А результат можно увидеть на **рис. 22.12.**

>![[Рис. 22.12. Выдвижение абзаца.jpg]]
>**Рис. 22.12.** Выдвижение абзаца
>
>**Пример 22.14.** Использование методов ускользания и выскальзывания
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Эффекты: скольжение</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <button id="slideup">Скольжение вверх</button>
  <button id="slidedown">Скольжение вниз</button>
  <button id="slidetoggle">Переключение состояния</button>
  <div id="para" style="background:#def">
    <h2>From A Tale of Two Cities - By Charles Dickens</h2>
    <p>It was the best of times, it was the worst of times, it was the        age of wisdom, it was the age of foolishness, it was the epoch         of belief, it was the epoch of incredulity, it was the season          of Light, it was the season of Darkness, it was the spring of          hope, it was the winter of despair, we had everything before           us, we had nothing before us, we were all going direct to              Heaven, we were all going direct the other way - in short, the         period was so far like the present period, that some of its            noisiest authorities insisted on its being received, for good          or for evil, in the superlative degree of comparison only
    </p>
  </div>
  <script>
    $('#slideup').click(function() { $('#para').slideUp('slow') })
    $('#slidedown').click(function() { $('#para').slideDown('slow') })
    $('#slidetoggle').click(function(){$('#para').slideToggle('slow')})
  </script>
</body>

</html>
```

Эти методы хорошо подходят для работы с меню и подменю, пункты которых нужно динамически открывать и закрывать в соответствии с тем разделом, на котором пользователь сделал щелчок.


### Анимация
---

А теперь мы можем приступить к весьма забавному занятию — практическому перемещению элементов по окну браузера. Но для этого, поскольку исходное значение свойства **`static`** не даст нам их перемещать, следует не забыть сначала задать значения свойствам элементов **`position`** (позиционирование), исходя из вариантов **`relative`** (относительное), **`fixed`** (фиксированное) или **`absolute`** (абсолютное).

Чтобы применить к элементу эффект анимации, нужно всего лишь предоставить методу **`animate`** перечень свойств CSS (исключая цвета). В отличие от ранее рассмотренных методов создания эффектов, анимация требует предварительного предоставления перечня свойств, после чего можно предоставить любые аргументы продолжительности, изменения скорости выполнения и обратной функции.

Например, для анимации отскакивающего мячика можно воспользоваться кодом из **примера 22.15**, результат работы которого показан на **рис. 22.13.**

>**Пример 22.15.** Создание анимации отскакивающего мячика
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Эффекты: анимация</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <style>
    #ball {
      position: relative;
    }
    #box {
      width: 640px;
      height: 480px;
      background: green;
      border: 1px solid #444;
    }
  </style>
</head>
  
<body>
  <div id="box">
    <img src="ball.png" id="ball">
  </div>
  <script>
    bounce()

    function bounce() {
      $('#ball')
        .animate({ left: '270px', top: '380px' }, 'slow', 'linear')
        .animate({ left: '540px', top: '190px' }, 'slow', 'linear')
        .animate({ left: '270px', top: '0px' }, 'slow', 'linear')
        .animate({ left: '0px', top: '190px' }, 'slow', 'linear')
    }
  </script>
</body>
  
</html>
```

В **`<style>`**-разделе этого примера для свойства **`position`** мячика установлено значение, позволяющее задавать позиции относительно контейнера, в котором он находится. В роли контейнера выступает **`<div>`**-элемент, которому заданы граница и зеленый фон.

Затем в **`<script>`**-раздел помещена функция под названием **`bounce`**, объединяющая четыре вызова метода **`animate`**.

Обратите внимание на то, что имена свойств, подвергаемых эффектам анимации (в данном примере это **`left`** и **`top`**), предоставляются без кавычек и отделяются от значений, до которых они должны быть изменены (например **`'270px'`**), двоеточиями, иными словами, они записываются в форме ассоциативных массивов.

>![[Рис. 22.13. Мячик, отскакивающий от границ окна браузера.jpg]]
>**Рис. 22.13.** Мячик, отскакивающий от границ окна браузера

Вместо абсолютных значений можно также задавать относительные, используя для этого операторы `+=` и `–=`. Так, к примеру, следующий код позволит применить к мячику эффект анимации, заключающийся в его перемещении вправо и вверх на 50 пикселов относительно текущей позиции:

```js
.animate( { left:'+=50px', top:'-=50px' }, 'slow', 'linear')
```

Для обновления значения свойства можно даже применять строковые значения **`hide`**, **`show`** и **`toggle`**:

```js
.animate( { height:'hide', width:'toggle' }, 'slow', 'linear')
```

>[!danger] Внимание
>Если нужно изменить значение каких-либо CSS-свойств, имена которых пишутся через дефис и не передаются в кавычках (как **`height`** и **`width`** в предыдущем примере), сначала эти имена следует преобразовать в формат слитного написания без дефиса, когда вторая часть имени начинается с прописной буквы (так называемый формат горбатого регистра). Например, для применения эффекта анимации к свойству элемента **`left-margin`** следует предоставить имя **`leftMargin`**. Но если предоставлять имя с дефисом внутри строки (например: **`css('font-weight', 'bold')`**, преобразовывать его в горбатый регистр не нужно.


#### Выстраивание цепочки методов
---

Благодаря выстраиванию методов в цепочку при передаче этим jQuery-методам аргументов происходит последовательный запуск методов. Таким образом, каждый из этих методов вызывается только после того, как закончит выполняться эффект анимации предыдущего метода. Но любые методы, вызываемые без аргументов, будут запускаться сразу же, без промедлений и без эффекта анимации.

После загрузки кода **примера 22.15** в браузер эффект анимации стартует с однократного вызова функции **`bounce`**, вызывающей отскок мячика от нижней, правой и верхней границ его контейнера. Затем мячик возвращается в середину левой границы. Если еще раз посмотреть на имеющуюся в этом примере функцию **`bounce`**, можно увидеть в ней четыре выстроенных в цепочку вызова функции **`animate`**.


#### Использование обратного вызова функции
---

В его нынешнем виде предыдущий пример завершает свою работу после выполнения четырех эффектов анимации, но для многократного запуска эффекта анимации после его завершения можно воспользоваться функцией обратного вызова. Поэтому я решил поместить анимацию в именованную функцию.

При использовании анимации в функции **`bounce`** остается только лишь указать ее имя, выделенное в примере полужирным шрифтом, в качестве имени функции обратного вызова для четырех анимаций в группе, чтобы заставить эффект анимации повторяться бесконечно:

```js
.animate( { left:'0px', top :'190px' }, 'slow', 'linear', bounce)
```

Используя метод **`animate`**, можно получить эффект анимации многих CSSсвойств с существенным исключением в отношении цветовых решений. Но с применением дополнительного модуля jQuery UI, который добавляет способность создания очень привлекательных эффектов цветовых изменений (наряду со многими другими интересными эффектами), возможны даже эффекты анимации цвета. Подробности можно найти по адресу http://jqueryui.com.


### Остановка анимации
---

Для остановки еще не завершенной анимации или завершения выполнения цепочки анимации используется несколько способов. Например, с помощью метода **`clearQueue`** можно очистить все сохраненные в очереди эффекты анимации, с помощью метода **`stop`** — моментально остановить любую выполняемую в данный момент анимацию, а с помощью метода **`finish`** — остановить текущую запущенную анимацию и удалить всю анимацию, выстроенную в очередь.

Превратим предыдущий пример в своеобразную игру, предусмотрев возможность обработки щелчка на мяче, чтобы при выдаче события такого щелчка анимация прекращалась. Для этого нужно под функцией **`bounce`** добавить следующую строку кода:

```js
$('#ball').click(function() { $(this).finish() })
```

Если вам удастся щелкнуть на мяче, метод **`finish`** остановит текущую анимацию, очистит очередь и заставит проигнорировать любые функции обратного вызова, то есть мячик застынет на месте.

Дополнительные сведения об управлении очередями jQuery можно найти по адресу http://api.jquery.com/queue, где также можно будет узнать, как управлять содержимым очередей напрямую для получения именно тех эффектов, которые вам нужны.


## Работа с DOM
---

Поскольку библиотека jQuery слишком тесно привязана к DOM, то в силу необходимости в примерах данной главы уже использовались некоторые имеющиеся в ней методы доступа к DOM-объектам, например **`html`** и **`val`**. А теперь подробно рассмотрим все DOM-методы, чтобы выяснить, к чему именно можно получить доступ с помощью jQuery и как это сделать.

В **примере 22.3** было показано использование метода **`html`** для изменения принадлежащего элементу свойства **`innerHTML`**. Этот метод может использоваться либо для установки кода в HTML-документ, либо для извлечения этого кода из документа. В **примере 22.16** (в котором код jQuery выделен полужирным шрифтом) показан способ извлечения HTML-содержимого из элемента. Результат выполнения кода примера показан на **рис. 22.14.**

>**Пример 22.16.** Вывод в окне оповещения HTML-содержимого элемента
```html
<!DOCTYPE html>
<html>
  <head>
    <title>The DOM: html & text</title>
    <script src='jquery-3.5.1.min.js'></script>
  </head>
  <body>
    <h2>Example Document</h2>
    <p id='intro'>This is an example document</p>
    <script>
      alert($('#intro').html())
    </script>
  </body>
</html>
```

Если при вызове этого метода не указывать никаких аргументов, результатом станет считывание, а не установка HTML-содержимого элемента.

>![[Рис. 22.14. Извлечение и отображение HTML-содержимого элемента.jpg]]
>**Рис. 22.14.** Извлечение и отображение HTML-содержимого элемента


### Разница между методами **`text`** и **`html`**
---

При работе с [[XML|XML-документами]] метод **`html`** использовать нельзя, поскольку он просто не будет работать (он разработан исключительно для использования с HTML). Но для получения аналогичных результатов (в XML- или HTMLдокументах) можно воспользоваться методом **`text`**:

```js
text = $('#intro').text()
```

Разница между методами заключается просто в том, что **`html`** принимает содержимое за HTML, а **`text`** принимает его за текст. К примеру, предположим, что вам нужно присвоить элементу следующую строку:

```js
<a href='http://google.com'>Посетите Google</a>
```

Если присваивать ее HTML-элементу с помощью метода **`html`**, DOM-модель будет обновлена с получением нового **`<а>`**-элемента и ссылка станет реагировать на щелчки. Но если сделать то же самое в отношении XML- или HTML-документа с помощью метода **`text`**, то сначала эта строка будет нейтрализована с превращением кода в текст (например, путем превращения таких HTML-символов, как **`<`**, в комбинацию символов **`&lt`**; и т. д.), а затем уже вставлена в элемент, то есть к DOM-модели элементы добавляться не будут.


### Методы **`val`** и **`attr`**
---

Есть еще два метода для работы с содержимым элементов. Прежде всего, как показано в **примере 22.10**, в котором считывались значения полей имени и фамилии, с помощью метода **`val`** можно устанавливать и получать значение элемента ввода. Для установки значения нужно просто предоставить его методу в качестве аргумента:

```js
$('#password').val('mypass123')
```

С помощью метода **`attr`**, как показано в **примере 22.17**, в котором ссылка на сайт Google полностью заменяется ссылкой на сайт Yahoo!, можно получить и установить атрибуты элементов.

>**Пример 22.17.** Изменение атрибутов с помощью метода **`attr`**
```html
<!DOCTYPE html>
<html lang="ru"> 

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM: attr</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>
  
<body>
  <h2>Пример документа</h2>
  <p><a href="http://google.com" id="link" title="Google">Посетите        Google</a></p>
  <script>
    $('#link').text("Посетите Yahoo!")
    $('#link').attr( {href: 'http://yahoo.com', title: 'Yahoo!'} )
    alert("Новый код HTML:\n" + $("p").html())
  </script>
</body>  

</html>
```

В первой jQuery-инструкции используется метод **`text`**, позволяющий изменить текст внутри элемента **`<a>`**, а вторая инструкция соответствующим образом путем предоставления данных в форме ассоциативного массива изменяет значения атрибутов **`href`** и **`title`**. Третья инструкция с помощью метода **`alert`** открывает окно оповещения, в которое выводит содержимое измененного элемента, предварительно извлеченное с помощью метода **`html`** ([[#^22-15-picture|**рис. 22.15**]]).

Можно также считать значение атрибута:

```js
url = $('#link').attr('href')
```


### Добавление и удаление элементов
---

Метод **`html`**, конечно, позволяет вставлять элементы в DOM, но он подходит только для создания дочерних элементов отдельно взятого элемента. Поэтому в jQuery предоставляется ряд методов для работы с любой частью DOM.

К таким методам относятся **`append`**, **`prepend`**, **`after`**, **`before`**, **`remove`** и **`empty`**, по одному из вариантов использования которых включает в себя **пример 22.18.**

>![[Рис. 22.15. Теперь ссылка полностью изменена.jpg]]
>**Рис. 22.15.** Теперь ссылка полностью изменена
^22-15-picture


>**Пример 22.18**. Добавление и удаление элементов
```html
<!DOCTYPE html>
<html lang="ru">  

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Изменение DOM</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>
  
<body>
  <h2>Пример документа</h2>
  <a href="http://google.com" title="Google">Посетите Google</a>
  <code>
    Это раздел кода
  </code>
    <p>
      <button id="a">Удалить изображение</button>
      <button id="b">Очистить цитату</button>
    </p>
    <img src="ball.png" id="ball">
    <blockquote id="quote" style="border: 1px dotted #444; height:                  20px;">
      Тест
    </blockquote>
  <script>
    $('a').prepend('Ссылка: ')
    $('[href^="http"]').append(' <img src="link.png">')
    $('code').before('<hr>').after('<hr>')
    $('#a').click(function() { $('#ball').remove() })
    $('#b').click(function() { $('#quote').empty() })
  </script>
</body>

</html>
```

На **рис. 22.16** показан результат применения методов **`prepend`**, **`append`**, **`before`** и **`after`** к некоторым элементам.

>![[Рис. 22.16. Документ с разнообразными элементами.jpg]]
>**Рис. 22.16.** Документ с разнообразными элементами

Метод **`prepend`** был использован для вставки строки **Ссылка:** перед внутренним текстом или HTML-кодом всех **`<а>`**-элементов:

```js
$('a').prepend('Ссылка: ')
```

Затем для выбора всех элементов, имеющих атрибут **`href`**, начинающийся с **`http`**, был использован селектор атрибутов. Строка **`http`**, появляющаяся в начале URL (поскольку используется оператор **`^=`**), обозначает ссылки, не являющиеся относительными, то есть относящиеся к абсолютным. В данном случае к концу внутреннего текста или HTML-кода всех соответствующих элементов добавляется значок внешней ссылки:

```js
$("[href^='http']").append(" <img src='link.png'>")
```

>[!danger]
>Оператор `^=` задает соответствие лишь с началом строки. Если бы использовался только один оператор `=`, выбирались бы только целые строки с соответствующим значением. Более подробно селекторы CSS рассматриваются в главах [[Введение в CSS|введение в CSS]] и [[Продвинутая стилизация страниц с помощью CSS3]].

Далее для помещения одноуровневых элементов (имеющих общего родителя) либо перед заданным элементом, либо после него используются выстроенные в цепочку методы **`before`** и **`after`**. В данном случае я решил добавить элемент **`<hr>`** как до, так и после элементов **`<code>`**:

```js
$('code').before('<hr>').after('<hr>')
```

Затем к паре кнопок я добавил небольшую реакцию на действия пользователя. При щелчке на первой кнопке с помощью метода **`remove`** удаляется элемент **`<img>`**, в котором содержится изображение мячика:

```js
$('#a').click(function() { $('#ball').remove() } )
```

>[!info]
>Теперь изображения в DOM больше нет, в чем можно убедиться, если щелкнуть правой кнопкой мыши и выбрать Inspect Element в большинстве основных браузеров.

И наконец, при нажатии второй кнопки к элементу **`<blockquote>`** применяется метод **`empty`**, который просто-напросто опустошает содержимое элемента в DOM:

```js
$('#b').click(function() { $('#quote').empty() } )
```


### Динамическое применение классов
---

Иногда было бы неплохо изменить класс, применяемый к элементу, или, может быть, просто добавить класс к элементу или удалить его из того или иного элемента. Предположим, к примеру, что у нас есть класс под названием **`read`**, который используется для придания стиля прочитанным постам блога. Добавить класс к посту можно просто с помощью метода **`addClass`**:

```js
$('#post23').addClass('read')
```

За один вызов можно добавить сразу несколько классов, разделив их названия пробелами:

```js
$('#post23').addClass('read liked')
```

А что делать, если пользователь решил снова пометить пост как непрочитанный, возможно, чтобы не забыть чуть позже прочитать его еще раз? В таком случае придется воспользоваться методом **`removeClass`**:

```js
$('#post23').removeClass('read')
```

При этом на все остальные классы, использующиеся этим постом, не будет оказано никакого влияния.

При поддержке возможности постоянного добавления или удаления класса проще, наверное, будет воспользоваться методом **`toggleClass`**:

```js
$('#post23').toggleClass('read')
```

Тогда, если пост еще не использовал класс, он будет добавлен, а если использовал — удален.


## Работа с размерами
---

Работа с размерами всегда считалась в веб-разработке далеко не самой легкой задачей, поскольку различные браузеры склонны к использованию несколько различающихся значений. Одной из весьма сильных сторон библиотеки jQuery является приложение больших усилий к нормализации этих типов значений, чтобы во всех основных браузерах ваши страницы выглядели полностью соответствующими вашим замыслам.

Размеры бывают трех типов: ширина и высота элемента, внутренняя ширина и высота, внешняя ширина и высота. Рассмотрим их по очереди.


### Методы **`width`** и **`height`**
---

Оба метода, как **`width`**, так и **`height`**, могут получать ширину или высоту первого элемента, соответствующего селектору, или устанавливать ширину или высоту всех соответствующих селектору элементов. Например, для получения ширины элемента с идентификатором **`elem`** можно воспользоваться следующей инструкцией:

```js
width = $('#elem').width()
```

Значение, возвращаемое переменной **`width`**, будет числовым, что отличается от CSS-значения, возвращаемого после вызова метода **`css`**, как в следующей инструкции, в результате выполнения которой возвращается (к примеру) значение **`230px`**, а не просто число **`230`**:

```js
width = $('#elem').css('width')
```

Можно получить ширину как текущего окна, так и документа:

```js
width = $(window).width()
width = $(document).width()
```

>[!danger]
>Когда библиотеке jQuery передаются объекты окна или документа, получить их ширину или высоту с помощью метода css невозможно. Вместо него нужно воспользоваться методами **`width`** или **`height`**.

Возвращаемое значение не зависит от установок свойства **`box-sizing`** (см. [[Продвинутая стилизация страниц с помощью CSS3]]). Если нужно взять в расчет значение свойства **`box-sizing`**, необходимо, как показано в следующей инструкции, воспользоваться вместо этого методом **`css`** с аргументом **`width`** (но если вы собираетесь продолжить работу с возвращенными значениями, не забудьте удалить символы **`px`**, которые будут добавлены после числовой части):

```js
width = $('#elem').css('width')
```

Точно так же легко можно устанавливать значения. Например, для установки размеров всех элементов, задействующих класс **`box 100 × 100`** пикселов, можно воспользоваться следующей инструкцией:

```js
$('.box').width(100).height(100)
```

В **примере 22.19** эти действия объединены в одну программу, результат выполнения которой показан на **рис. 22.17**.

>**Пример 22.19.** Получение и установка размеров элементов
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Dimensions</title>
    <script src='jquery-3.5.1.min.js'></script>
  </head>
  <body>
    <p>
      <button id='getdoc'>Get document width</button>
      <button id='getwin'>Get window width</button>
      <button id='getdiv'>Get div width</button>
      <button id='setdiv'>Set div width to 150 pixels</button>
    </p>
    <div id='result' style='width:300px; height:50px; background:#def;'></div>
    <script>
      $('#getdoc').click(function()
      {
        $('#result').html('Document width: ' + $(document).width())
      } )

      $('#getwin').click(function()
      {
        $('#result').html('Window width: ' + $(window).width())
      } )

      $('#getdiv').click(function()
      {
        $('#result').html('Div width: ' + $('#result').width())
      } )

      $('#setdiv').click(function()
      {
        $('#result').width(150)
        $('#result').html('Div width: ' + $('#result').width())
      } )
    </script>
  </body>
</html>
```

>![[Рис. 22.17. Получение и установка размеров элементов.jpg]]
>**Рис. 22.17.** Получение и установка размеров элементов

В начале раздела **`<body>`** объявляются четыре кнопки: три для получения отчета о ширине документа, окна и элемента **`<div>`**, который появляется под кнопками, и одна для установки нового значения ширины div-контейнера. В разделе **`<script>`** находятся четыре jQuery-инструкции, первые три из которых просто извлекают ширину заданных объектов, а затем сообщают о полученных значениях, записывая их в HTML-код div-контейнера.

Последняя инструкция состоит из двух частей: первая часть сокращает ширину **`<div>`**-элемента до 150 пикселов, а затем вторая часть выводит новое значение ширины div-контейнера, извлекая его с помощью метода **`width`**, чтобы гарантировать отображение вычисленного значения.

>[!danger]
>При изменении масштаба страницы (его увеличении или уменьшении) пользователем это событие в любом основном браузере ничем не отмечается, то есть никакого способа, позволяющего его достоверно обнаружить кодом JavaScript, не существует. Поэтому jQuery не может взять масштабирование в расчет при применении или возвращении значений размеров. Следовательно, в подобной ситуации можно получить непредсказуемые результаты.


### Методы **`innerWidth`** и **`innerHeight`**
---

Зачастую возникает необходимость взять в расчет также границы, отступы и другие свойства, работающие с размерами, и поэтому вы можете воспользоваться для возвращения ширины и высоты первого элемента, соответствующего селектору, *включая* отступы, но *не включая* границы, методами **`innerWidth`** и **`innerHeight`**.

Например, следующая инструкция вернет значение свойства **`innerWidth`**, включающего отступы, имеющиеся у элемента с идентификатором **`elem`**:

```js
iwidth = $('#elem').innerWidth()
```


### Методы **`outerWidth`** и **`outerHeight`**
---

Для возвращения размеров элемента, включая не только отступы, но и границы, можно вызвать методы **`outerWidth`** и **`outerHeight`**:

```js
owidth = $('#elem').outerWidth()
```

Если в возвращаемое значение нужно *также* включить еще и поля, то при вызове любого из этих методов можно передать ему значение **`true`**:

```js
owidth = $('#elem').outerWidth(true)
```

>[!danger]
>Значения, возвращенные любыми методами **`inner...`** или **`outer...`**, не обязательно должны быть целыми числами и иногда могут иметь дробную составляющую. Изменение масштаба страницы пользователем этими методами не обнаруживается, и их нельзя использовать в отношении объектов окон или документов, для которых нужно применять методы **`width`** или **`height`**.


## Обход объектов DOM
---

Если обратиться к разделу [[Изучение JavaScript|Изучение JS]], рассказывающему об объектной модели документа — [[DOM|Document Object Model]] (DOM), можно вспомнить, что все вебстраницы во многом конструктивно напоминают большие семьи. В них имеются родительские и дочерние объекты, одноуровневые объекты, у которых общий родительский объект, объекты-предки, которые старше родительских объектов, и объекты-потомки, которые младше дочерних объектов, и даже элементы, чьи родственные отношения могут рассматриваться в качестве двоюродных сестер, тетей и т. д. Например, в следующем фрагменте кода **`<li>`**-элементы являются дочерними по отношению к **`<ul>`**-элементу, который, в свою очередь, является родительским для **`<li>`**-элементов:

```html
<ul>
  <li>Элемент 1</li>
  <li>Элемент 2</li>
  <li>Элемент 3</li>
</ul>
```

И так же как и в семьях, существует множество способов ссылки на HTMLэлементы, например с помощью абсолютного указания или путем указания, начинающегося с уровня окна и идущего далее вниз (по принципу, известному как *обход объектов* DOM). Кроме того, для ссылок на элементы можно воспользоваться родственными отношениями между одним и другим элементами. На самом деле весь вопрос заключается в том, что будет разумнее конкретно для вашего проекта.

Например, если нужно добиться наибольшей автономности веб-страницы, чтобы получить больше шансов на возможность вырезать и вставлять элементы в другие веб-документы без необходимости изменения вставляемого HTML, разумнее будет ссылаться на близлежащие элементы, применяя относительную адресацию. Но какой бы из способов вы ни выбрали, jQuery предлагает широкий диапазон функций, помогающих осуществлять конкретную адресацию элементов.


### Родительские элементы
---

Чтобы обратиться к непосредственному родителю элемента, нужно воспользоваться методом **`parent`**:

```js
my_parent = $('#elem').parent()
```

Независимо от типа элемента **`elem`**, объект **`my_parent`** теперь будет содержать jQuery-объект, ссылающийся на его родительский элемент. На самом же деле, поскольку селектор может ссылаться на несколько элементов, этот вызов приведет к возвращению объекта, ссылающегося на список родительских элементов (хотя в списке может быть всего одна запись), по одной ссылке для каждого соответствующего элемента.

Так как у родителя может быть много детей, вы можете поинтересоваться, будет ли этим методом возвращено больше элементов, чем имеется родителей. Возьмем предыдущий фрагмент кода с тремя **`<li>`**-элементами. Если применить следующий код:

```js
my_parent = $('li').parent()
```

возникнет вопрос: будут ли возвращены три родительских элемента (поскольку будет найдено три соответствия), даже если имеется всего один родительский **`<ul>`**-элемент? Ответ будет отрицательным, поскольку библиотека jQuery достаточно интеллектуальна, чтобы распознать все дубликаты и провести фильтрацию. Если для проверки запросить количество возвращенных элементов, будет возвращен результат 1:

```js
alert($('li').parent().length)
```

Инициируем какие-либо изменения при нахождении соответствий селектору, например изменим значение свойства **`font-weight`** родительского элемента в предыдущем фрагменте кода на **`bold`**:

```js
$('li').parent().css('font-weight', 'bold')
```


#### Использование фильтра
---

Дополнительно методу **`parent`** может быть передан селектор, чтобы отфильтровать те родительские элементы, к которым должно быть применено желаемое изменение. В качестве иллюстрации в **примере 22.20** имеются три небольших списка и две jQuery-инструкции.

>**Пример 22.20**. Обращение к родительским элементам
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Обход DOM: Parent</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <ul>
    <li>Элемент 1</li>
    <li>Элемент 2</li>
    <li>Элемент 3</li>
  </ul>
  <ul class="memo">
    <li>Элемент 1</li>
    <li>Элемент 2</li>
    <li>Элемент 3</li>
  </ul>
  <ul>
    <li>Элемент 1</li>
    <li>Элемент 2</li>
    <li>Элемент 3</li>
  </ul>
  <script>
    $('li').parent().css('font-weight', 'bold')
    $('li').parent('.memo').css('list-style-type', 'circle')
  </script>
</body>

</html>
```

Все три списка совершенно одинаковы, за исключением того, что у среднего в элементе **`<ul>`** используется класс **`memo`**. В разделе **`<script>`** первая инструкция применяет значение **`bold`** к свойству **`font-weight`** всех элементов, являющихся родительскими для элементов **`<li>`**. В данном случае ее выполнение приводит к тому, что все **`<ul>`**-элементы отображаются полужирным шрифтом.

Вторая инструкция похожа на первую, но в ней методу **`parent`** вдобавок ко всему передается имя класса **`memo`**, поэтому будет выбран только тот родительский элемент, у которого есть такой класс. Затем вызывается метод **`css`**, чтобы установить для свойства **`list-style-type`** выбранного списка значение **`circle`**. Результат выполнения этих двух инструкций показан на **рис. 22.18.**

>![[Рис. 22.18. Обращение к родительским элементам с фильтром и без фильтра.jpg]]
>**Рис. 22.18.** Обращение к родительским элементам с фильтром и без фильтра


### Выбор всех элементов-прародителей
---

Только что были рассмотрены способы выбора непосредственных родительских элементов, но с помощью метода **`parents`** можно выбрать и предков вплоть до корневого элемента **`<html>`**. Но зачем это может понадобиться? К примеру, чтобы обратиться к первому **`<div>`**-элементу, расположенному вверх по цепочке прародителей, с целью придания ему стилевого оформления в соответствии с каким-либо развитием событий, произошедшим в отношении какого-либо элемента где-нибудь ниже по цепочке.

Тип выбора может быть несколько изощреннее, чем тот, который имело бы смысл применить в обычных условиях, но вас он вполне устроит, когда возникнет подобная необходимость. Вот как можно было бы продолжить реализацию данного замысла:

```js
$('#elem').parents('div').css('background', 'yellow')
```

Вообще-то результат может быть не совсем тот, которого вы добивались, поскольку выбраны будут все **`<div>`**-элементы в цепочке прародителей, а в ней могут быть те, которые располагаются еще выше, изменять стиль которых вам совсем не хотелось. Для подобных случаев можно применить дополнительную фильтрацию выбора, воспользовавшись вместо предыдущего метода методом **`parentsUntil`**.

Метод **`parentsUntil`** совершает обход вверх по цепочке прародителей точно так же, как и метод **`parents`**, но останавливается на первом элементе, который соответствует фильтру выбора (в данном случае это **`<div>`**-элемент). То есть этот метод можно использовать точно так же, как и метод в предыдущем примере, будучи уверенными в том, что будет выбран наиболее соответствующий вашему желанию элемент:

```js
$('#elem').parentsUntil('div').css('background', 'yellow')
```

Чтобы понять разницу между этими двумя методами, посмотрите код **примера 22.21**, в котором имеются два набора вложенных элементов, у каждого из которых один родительский **`<div>`**-элемент. Затем в разделе **`<script>`** находятся по одному примеру вызова методов **`parents`** и **`parentsUntil`**.

>**Пример 22.21.** Использование методов **`parents`** и **`parentsUntil`**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>DOM Traversal: Parents</title>
    <script src='jquery-3.5.1.min.js'></script>
  </head>
  <body>
    <div>
      <div>
        <section>
          <blockquote>
            <ul>
              <li>Item 1</li>
              <li id='elem'>Item 2</li>
              <li>Item 3</li>
            </ul>
          </blockquote>
        </section>
      </div>
      <div>
        <section>
          <blockquote>
            <ul>
              <li>Item 1</li>
              <li>Item 2</li>
              <li>Item 3</li>
            </ul>
          </blockquote>
        </section>
      </div>
    </div>
    <script>
      $('#elem').parents('div')     .css('background',                     'yellow')
      $('#elem').parentsUntil('div').css('text-decoration',                'underline')
    </script>
  </body>
</html>
```

На **рис. 22.19** можно увидеть, что первая jQuery-инструкция установила желтый цвет фона для всего содержимого. Дело в том, что при использовании метода parents дерево прародителей было пройдено вверх вплоть до элемента **`<html>`** и были выбраны оба встреченных на пути **`<div>`**-элемента (тот, что содержит список **`<li>`**-элементов, выделенный полужирным шрифтом, с идентификатором **`elem`**, и его родительский **`<div>`**-элемент, в котором содержатся оба набора вложенных элементов).

>![[Рис. 22.19. Сравнение методов parents и parentsUntil.jpg]]
>**Рис. 22.19.** Сравнение методов **`parents`** и **`parentsUntil`**

А во второй инструкции используется метод **`parentsUntil`**, поэтому выбор останавливается на первом же встреченном **`<div>`**-элементе. Это означает, что применение стиля подчеркивания касается только ближайшего родительского **`<div>`**-элемента, в котором содержится **`<li>`**-элемент с идентификатором **`elem`**. До внешнего **`<div>`**-элемента установка не доходит, и поскольку он не получает данного стилевого оформления, второй список с подчеркиванием не выводится.


### Дочерние элементы
---

Для обращения к дочерним элементам используется метод **`children`**:

```js
my_children = $('#elem').children()
```

Как и у метода **`parent`**, его действие распространяется только на один уровень вниз, и в результате возвращается список, либо не содержащий ссылок на объекты, либо содержащий одну соответствующую ссылку или более. Методу можно также передавать аргумент фильтра для выбора среди дочерних элементов:

```js
li_children = $('#elem').children('li')
```

В результате выполнения этого кода будут выбраны только те дочерние элементы, которые являются **`<li>`**-элементами.

Чтобы углубиться в поколения, нужно воспользоваться методом **`find`**, являющимся противоположностью метода **`parents`**:

```js
li_descendants = $('#elem').find('li')
```

Но, в отличие от **`parents`**, методу **`find`** нужно предоставить селектор, используемый в качестве фильтра, если же нужно выбрать всех потомков, можно воспользоваться универсальным селектором:

```js
all_descendants = $('#elem').find('*')
```


### Одноуровневые элементы
---

Для выбора одноуровневых элементов доступен более широкий диапазон методов, начинающийся с метода **`siblings`**.

Метод **`siblings`** возвращает все соответствующие элементы, являющиеся дочерними по отношению к одному и тому же родителю, за исключением элемента, используемого для выбора. Таким образом, применительно к следующему фрагменту кода, если ведется поиск одноуровневых элементов для `<li>`элемента с идентификатором **`two`**, будут возвращены только первый и третий `<li>`-элементы:

```html
<ul>
  <li>Item 1</li>
  <li id='two'>Item 2</li>
  <li>Item 3</li>
</ul>
```

Например, следующая инструкция приведет к выводу на экран первого и третьего из одноуровневых элементов полужирным шрифтом:

```js
$('#two').siblings().css('font-weight', 'bold')
```

Чтобы сузить круг возвращаемых одноуровневых элементов, с методом siblings можно применять фильтр. Например, для выбора только тех одноуровневых элементов, которые используют класс new, можно воспользоваться следующей инструкцией:

```js
$('#two').siblings('.new').css('font-weight', 'bold')
```


### Выбор следующих и предыдущих элементов
---

Когда нужен более жесткий контроль над выбором одноуровневых элементов, можно с помощью методов **`next`** и **`prev`** и их расширенных версий сузить круг возвращаемых элементов еще больше. Например, для ссылки на элемент, непосредственно следующий за выбранным элементом, можно воспользоваться такой инструкцией (которая установит для соответствующих элементов или элемента отображение полужирным шрифтом):

```js
$('#new').next().css('font-weight', 'bold')
```

Применительно к следующему фрагменту кода со щедро расставленными пробелами идентификатор **`new`** имеет третий элемент, и поэтому возвращается четвертый элемент:

```html
<ul>
  <li >Элемент 1</li>
  <li >Элемент 2</li>
  <li id='new'>Элемент 3</li>
  <li >Элемент 4</li>
  <li >Элемент 5</li>
</ul>
```

Пока ничего сложного нам не попадалось. А что делать, если нужно получить ссылку на *все* одноуровневые элементы, следующие за конкретно заданным элементом? Это можно сделать с помощью метода **`nextAll`** (который применительно к предыдущему фрагменту кода придаст стилевое оформление последним двум элементам):

```js
$('#new').nextAll().css('font-weight', 'bold')
```

При вызове метода **`nextAll`** ему также можно предоставлять фильтр, чтобы выбирать соответствующие элементы, как в следующей инструкции, которая задаст стилевое оформление только тем одноуровневым элементам, которые применяют класс **`info`**: (но в предыдущем фрагменте кода нет элементов, имеющих такой класс, поэтому инструкция, запущенная в отношении этого фрагмента, ни к какому результату не приведет):

```js
$('#new').nextAll('.info').css('font-weight', 'bold')
```

Или же рассмотрим случай применения следующего фрагмента кода, в котором у одного элемента имеется идентификатор **`new`**, а у другого — **`old`**:

```html
<ul>
  <li >Элемент 1</li>
  <li id='new' >Элемент 2</li>
  <li >Элемент 3</li>
  <li id='old' >Элемент 4</li>
  <li >Элемент 5</li>
</ul>
```

Теперь есть возможность выбрать только одноуровневые элементы, следующие за тем элементом, у которого имеется идентификатор **`new`**, и доходящие до элемента с идентификатором **`old`**, исключая сам этот элемент (в данном случае стилевое оформление получит третий элемент):

```js
$('#new').nextUntil('#old').css('font-weight', 'bold')
```

Если методу **`nextUntil`** аргументы не передаются, он ведет себя точно так же, как и метод **`nextAll`**, возвращая все следующие одноуровневые элементы. Методу **`nextUntil`** можно передать и второй аргумент, чтобы он действовал в качестве фильтра для выбора из элементов, соответствующих указанному селектору:

```js
$('#new').nextUntil('#old', '.info').css('font-weight', 'bold')
```

В этой инструкции стилевое оформление получат только те элементы, которые используют класс **`info`**, а таких элементов в предыдущем фрагменте кода нет, следовательно, никаких действий предпринято не будет.

Абсолютно то же самое можно сделать в группе одноуровневых элементов в обратном направлении, используя методы **`prev`**, **`prevAll`** и **`prevUntil`**.


## Использование jQuery без селекторов
---

Существуют также два jQuery-метода, предназначенные для использования со стандартными объектами JavaScript и существенно упрощающие работу с ними. Это похожие друг на друга, но все же имеющие небольшие различия методы **`$.each`** и **`$.map`**.


### Метод **`$.each`**
---

Используя метод **`$.each`**, можно осуществить последовательный перебор элементов массивов или подобных массивам объектов путем простого прикрепления к функции, вызываемой для каждой итерации. В **примере 22.25** показан массив из имен и видов домашних животных (названный **`pets`**), из которого должен быть извлечен другой массив (названный **`guineapigs`**), содержащий только имена морских свинок.

>**Пример 22.25.** Вызов метода **`$.each`**
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Использование метода each</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head> 

<body>
  <div id="info"></div>
  <script>
    pets = {
      Scratchy: 'Guinea Pig',
      Squeeky: 'Guinea Pig',
      Fluffy: 'Rabbit',
      Thumper: 'Rabbit',
      Snoopy: 'Dog',
      Tiddles: 'Cat'
    }

    guinea_pigs = []
    $.each(pets, function (name, type) {
      if (type == 'Guinea Pig') guinea_pigs.push(name)
    })
    $('#info').html("Имена морских свинок: " + guinea_pigs.join(" & "))
  </script>
</body>

</html>
```

Для выполнения поставленной задачи методу **`$.each`** передается массив и безымянная функция для его обработки. Функция получает два аргумента, индекс в массиве (называемый **`name`**) и содержимое каждого элемента (называемое **`type`**).

Затем значение, имеющееся в **`type`**, проверяется на предмет того, не содержит ли оно строку **`Guinea Pig`**, и если содержит, значение, имеющееся в name, вставляется в массив **`guineapigs`**. По завершении содержимое массива **`guineapigs`** выводится на экран путем записи его в **`<div>`**-элемент с идентификатором **`info`**. Чтобы отделить элементы массива друг от друга, используется JavaScript-метод **`join`** с символом **`&`** в качестве разделителя. В результате загрузки примера в браузер на экране будет просто отображен текст Имена морских свинок: `Scratchy` **`&`** `Squeаky`.