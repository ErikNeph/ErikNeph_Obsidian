---
date of creation: 2024-06-28T17:26:00
tags:
  - JQuery
  - JS/JQuery
  - Web/Developing
  - Backend
  - IT/JavaScript
  - JavaScript
  - Developing
  - Framework
  - Framework/JS
  - Programming/JS
  - ProgrammingLanguage/JS
Read status: false
aliases:
---
---
# Введение в JQuery
2024-06-28




При всей гибкости и эффективности JavaScript, а также при всем изобилии имеющихся в этом языке встроенных функций и продолжающемся внедрении усовершенствований у вас все же часто сохраняется потребность в дополнительных уровнях кода, позволяющих упростить, к примеру, получение эффектов анимации, обработку событий и применение технологии асинхронного обмена данными, то есть сделать то, чего нельзя достичь применением обычных средств JavaScript или CSS.

Более того, с годами, вследствие различных браузерных войн, то появлялись, то исчезали досаждающие и раздражающие несовместимости браузеров, ярко проявлявшиеся временами на различных платформах и в программах.

В результате этого гарантировать одинаковый внешний вид веб-страниц во всех устройствах порой можно было, только применяя требовавший утомительной разработки код JavaScript, учитывающий все расхождения всей линейки браузеров и их версий, выпущенных за последние годы. Да, многое было сделано для устранения этих различий, но даже сегодня каждый сайт с отзывчивым дизайном, который я создаю, по-прежнему нуждается в исключениях для работы с различными браузерами, если только я не использую платформу, с чем, я уверен, согласятся многие.

Для заполнения пробелов было разработано множество библиотек функций (многие из которых также предоставляли легкую привязку к DOM), предназначенных для сведения к минимуму различий между браузерами и содействия асинхронному обмену данными, а также работе с событиями и анимацией, такие как, например, являющаяся темой этой главы jQuery.

>[!info]
>Иногда решение волнующей вас проблемы простое — на основе JavaScript. Одним из способов проверить, так ли это, является поиск на сайте http://youmightnotneedjquery.com/ — он позволит вам узнать о любых альтернативах jQuery, которые могут быть более простыми в конкретной ситуации.





## Почему же именно jQuery?
---

Используя jQuery, вы получаете не только кросс-браузерную совместимость весьма высокого уровня, но и быстрый и легкий доступ к операциям с HTML и DOM, возможность использования специальных функций для непосредственной работы с CSS, управления событиями, мощные средства для создания профессиональных эффектов и анимации, а также функции для управления асинхронным обменом данными с сервером. Кроме того, jQuery является основой для широкого круга дополнительных модулей и других вспомогательных программ.

Конечно же, использования jQuery вам никто не навязывает, и некоторые борцы за чистоту языка программирования никогда не используют библиотеку, предпочитая создавать собственные специализированные наборы функций (и в этом есть свой резон, например, не нужно будет дожидаться, пока другие люди исправят замеченные вами недоделки, можно будет разрабатывать собственные средства безопасности и т. д.). Но библиотека jQuery уже выдержала проверку временем, и если вы захотите с пользой потратить время на ее изучение и получить возможность делать высококачественные веб-страницы в самые короткие сроки, из этой главы вы узнаете, как можно приступить к использованию этой библиотеки.

>[!info]
>Как бы ни была важна библиотека jQuery, используемая, возможно, на 90 % производственных веб-сайтов, в этой сфере появились и новички, которые привлекли большое внимание и удостоились похвалы. А поскольку технологии меняются быстро, то, понимая jQuery, вам все же необходимо идти в ногу с новыми технологиями, которые могут вытеснить используемые вами в настоящее время. На мой взгляд, React, Angular и Vue — лишь несколько таких технологий, поскольку они предлагают новые, интересные и мощные масштабируемые способы улучшения JavaScript (как и следовало ожидать, они были созданы Facebook, Google и бывшими сотрудниками Google соответственно). Мы не можем заполнить эту книгу информацией о платформах JavaScript, но важно знать об основных из них, поэтому в [[Введение в React]] я решил познакомить вас с React. Я считаю, что это платформа, с которой вы, скорее всего, будете сталкиваться наиболее часто, хотя для полноты картины, возможно, захотите познакомиться и с Angular.



### Включение jQuery
---

Есть два способа включения jQuery в ваши веб-страницы. Можно перейти на сайт jQuery (https://code.jquery.com/jquery/), выбрать нужную версию, загрузить ее на свой веб-сервер и ссылаться на нее из тега **`<script>`** в своих HTML-файлах. Или же можно воспользоваться находящейся в свободном доступе сетью доставки контента — [[Content Delivery Network (CDN)]] и просто указать ссылку на нужную вам версию.

>[!info]
>jQuery выпускается в соответствии с условиями MIT-лицензии, в которой не содержится практически никаких ограничений на ваши дальнейшие действия. Любой проект jQuery можно свободно использовать в любом другом проекте (даже коммерческом) при условии, что заголовок с указанием авторских прав останется нетронутым.


#### Выбор подходящей версии
---

Перед тем как решить, стоит ли загружать jQuery и использовать ее функции непосредственно или же воспользоваться CDN, нужно выбрать версию jQuery. В большинстве случаев выбор очевиден, поскольку вы просто отдадите предпочтение наиболее свежей версии. Но если есть намерение использовать конкретные браузеры или же вы поддерживаете устаревший сайт, работа которого зависит от определенной версии jQuery, то последний выпуск этой библиотеки может вам не подойти.

В отличие от большинства других программных средств, для использования которых вы просто загружаете и устанавливаете самую новую из доступных версий, jQuery со временем совершенствовалась с учетом изменения движущих сил на рынке различных версий браузеров с их свойствами и недочетами.

В то же время в jQuery вносили различные усовершенствования, которые могли изменить работу ее новых версий на тех сайтах, которые были специально адаптированы под конкретную версию (и под все сопутствующие ей особенности).

Разумеется, каждая более новая версия является улучшением предыдущей, и вероятность того, что вносимые усовершенствования коснутся всех основ, постоянно возрастает. Но пока вы полностью не протестируете новую версию и не убедитесь в том, что операции, играющие важную роль для вашего сайта, выполняются точно так же, лучше все же продолжать использовать прежнюю версию.


##### Различные разновидности **jQuery**
---

На данный момент существуют три ветви jQuery: 1.x, 2.x и 3.x, каждая из которых разработана для разных сред.

Версия 1.x была первым стабильным выпуском jQuery. Этот выпуск поддерживает устаревшие браузеры, которые уже больше не поддерживаются даже своими разработчиками. Если ожидается большой наплыв посетителей с устаревшими браузерами, то нужно пользоваться именно этой версией (как уже упоминалось, лучшей, наверное, будет версия 1.12).

С целью повышения общей производительности jQuery и уменьшения размера файла библиотеки в версии 2.x была исключена поддержка Internet Explorer 6–8. Эта версия быстрее и меньше версии 1.x, но не поддерживает устаревшие браузеры. Поскольку компания Microsoft прекратила поддержку Windows XP, можно с уверенностью предположить, что ваши посетители будут пользоваться браузером, совместимым с версией 2.x, если вы не будете располагать иными сведениями.

Если нужна поддержка устаревших браузеров вроде Internet Explorer 6–8, Opera 12.1x или Safari 5.1+, разработчики jQuery рекомендуют воспользоваться версией 1.12. Исчерпывающие подробности поддержки различных версий можно найти по адресу http://jquery.com/browser-support/. В данной редакции книги я остановился на версии 3.5.1.


##### Сжатые или редактируемые
---

Нужно также решить, какую версию jQuery вам хотелось бы использовать: минимальную по размеру (сжатую, чтобы свести к минимуму требуемую полосу пропускания сети и сократить время загрузки) или несжатую (возможно, по причине того, что вам хочется вносить в нее самостоятельные правки, на что вы имеете полное право). Как правило, наиболее удачным выбором считается минимальная по размеру версия, но большинство веб-серверов поддерживают архиватор `gzip`, позволяющий выполнять сжатие и распаковку на лету, поэтому данный вопрос теряет свою актуальность (хотя нужно учесть, что из минимизированной версии, кроме всего прочего, удалены все комментарии).


#### Загрузка
---

На сайте jquery.com/download каждая последняя выпущенная версия jQuery фигурирует в списке как в сжатой, так и в несжатой форме. Все прошлые выпуски можно также найти на веб-сайте https://code.jquery.com/jquery/. Облегченные версии jQuery, попадающиеся на странице загрузки, в целях экономии пространства исключают функции асинхронного обмена данными Ajax, поэтому при необходимости применения данной технологии с использованием jQuery этих версий следует избегать.

Вам остается всего лишь выбрать нужную версию, щелкнуть правой кнопкой мыши на соответствующей ссылке и сохранить версию на своем жестком диске. Оттуда ее можно будет выгрузить на ваш веб-сервер, а затем включить в веб-страницу с помощью **`<script>`**-тегов примерно таким образом (для минимизированной версии выпуска 3.5.1):
```html
<script src='http://myserver.com/jquery-3.5.1.min.js'></script>
```

>[!info]
>Если ранее вам не приходилось пользоваться jQuery (и никаких специальных требований на ее счет у вас не имеется), то загружайте минимизированную версию или же установите показанную в следующем разделе CDN-ссылку на эту библиотеку.


#### Использование сети доставки контента
---

Библиотека jQuery поддерживается несколькими сетями доставки контента (CDN). Если вы пользуетесь одной из них, то можете избавить себя от хлопот, связанных с загрузкой новых версий, и выкладывать их на сервер, просто указав прямые ссылки на URL-адреса, поддерживаемые этими сетями.

Ко всему прочему, эти сети предоставляют свои услуги совершенно бесплатно и обычно используют каналы с высокой пропускной способностью, которые, возможно, являются самыми скоростными на свете. Кроме того, CDN-сети обычно хранят свой контент в нескольких различных географических пунктах и предоставляют требуемый файл с ближайшего к пользователю сервера, гарантируя тем самым наиболее быструю из возможных доставку.

В общем, если вам не нужно вносить изменения в исходный код jQuery (для чего требуется его размещение на ваших собственных веб-серверах) и у ваших пользователей гарантированно имеется живое Интернет-соединение, то скорее всего, наилучшим вариантом будет использование CDN-сетей. Тем более что пользоваться ими довольно просто. Достаточно знать имя нужного файла и используемого для его загрузки корневого каталога CDN. Например, все текущие и предыдущие версии можно получить через CDN-сеть, которая используется библиотекой jQuery, с помощью следующего кода:
```html
<script src='http://code.jquery.com/jquery-3.5.1.min.js'></script>
```

Основной каталог доступен по адресу http://code.jquery.com/, и за ним нужно просто дописать имя нужного для включения файла (в данном случае это jquery-3.5.1.min.js).

Библиотеку jQuery предоставляет в своих сетях как Microsoft, так и Google, поэтому для ее включения можно воспользоваться любым из следующих двух вариантов:
```html
<script 
  src='http://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.5.1.min.js'></script>
<script              src='http://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js'> </script>
```

В случае использования Microsoft CDN в URL-адресе сначала нужно указать основной каталог ajax.aspnetcdn.com/ajax/jQuery/, а за ним — имя требуемого файла.

Но для Google нужно разбить имя файла (например, jquery-3.5.1.min.js) на имя каталога и имя файла таким вот образом: 3.5.1/jquery.min.js. А перед этим поставить строку ajax.googleapis.com/ajax/libs/jquery/.

>[!info]
>Дополнительным преимуществом применения CDN-сетей является то, что ими пользуется большинство других сайтов, поэтому библиотека jQuery может уже находиться в кэше пользовательского браузера и ее, может быть, даже не придется доставлять заново. При практически более чем 90%-ной востребованности jQuery другими сайтами тем самым может быть сэкономлен большой объем ценных сетевых ресурсов и времени.


##### Заказная сборка **jQuery**
---

Если есть настоятельная необходимость свести объем данных, загружаемых веб-страницей, к минимуму, то можно воспользоваться jQuery, создав специальную сборку этой библиотеки, включающую только те функции, которые будут использоваться вашим сайтом. При ее доставке полагаться на CDN-сеть нельзя, но при подобных обстоятельствах вы, наверное, все равно не станете планировать использование этой сети.

Для создания собственной заказной сборки jQuery нужно зайти на сайт projects.jga.me/jquery-builder и выставить флажки возле тех модулей, которые вам нужны, сняв их с ненужных модулей. Затем заказная версия jQuery будет загружена в отдельную вкладку или окно, откуда ее можно будет скопировать и вставить в требуемое место.



## Синтаксис **jQuery**
---

Больше всего людей, ранее не знакомых с jQuery, удивляет символ `$`, который действует как фабричный метод jQuery — основной способ доступа к платформе. Он был выбран из расчета допустимости в JavaScript, краткости и отличия от имен обычной переменной, объекта или функции (метода).

Этим символом обозначается вызов функции jQuery (что также при желании можно сделать). Замысел его использования заключается в сохранении краткости и приятного внешнего вида кода, а также избавлении от излишнего набора текста при каждом обращении к jQuery. Кроме того, при виде этого символа другие, ранее не знакомые с вашим кодом разработчики сразу же понимают, что в коде используется jQuery (или подобная ей библиотека).


### Простой пример
---

В наипростейшем виде обращение к jQuery осуществляется набором символа `$`, за которым следует заключенный в скобки селектор, точка и метод, применяемый к выбранному элементу (или элементам).

Например, для изменения семейства шрифтов всех абзацев на моноширинное можно воспользоваться следующей инструкцией:
```js
$('p').css('font-family', 'monospace')
```

А для добавления границы к элементу `<code>` можно применить такую инструкцию:
```js
$('code').css('border', '1px solid #aaa')
```

Взглянем на часть полноценного **примера 22.1**, где фрагменты, относящиеся к использованию jQuery, выделены полужирным шрифтом.

>**Пример 22.1.** Простой пример применения jQuery
```html
<!DOCTYPE html>
<html lang="en">
 
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <title>Первый пример jQuery</title>
</head> 

<body>
  В jQuery в качестве имен функций используются
  либо <code>$()</code>, либо <code>jQuery()</code>.
  <script>
    $('code').css('border', '1px solid #aaa')
  </script>
</body>

</html>
```

После загрузки этого примера в браузер будет получен результат, показанный на **рис. 22.1**. Разумеется, конкретно эта инструкция просто подменяет собой то, что можно сделать с помощью обычного кода CSS, но я хотел показать синтаксис jQuery, поэтому пока не стал ничего усложнять.

>[!info]
>Еще один способ выдачи этой команды заключается в вызове функции jQuery (которая работает точно так же, как и $):
>
>```js
>jQuery('code').css('border', '1px solid #aaa')
>```

>![[Рис. 22.1. Изменение элементов с помощью jQuery.jpg]]
>**Рис. 22.1.** Изменение элементов с помощью jQuery


#### Как избежать конфликтов библиотек
---

Если наряду с jQuery используются и другие библиотеки, может оказаться, что в них определены собственные функции **`$`**. Для решения данной проблемы можно в отношении этого символа вызвать метод `noConflict`, который освобождает этот символ от управляющей функции, позволяя другим библиотекам воспользоваться им:
```js
$.noConflict()
```

После этого для доступа к jQuery следует вызывать функцию jQuery. Или же символ `$` можно заменить именем объекта по вашему выбору:
```js
jq = $.noConflict()
```

Теперь в тех местах, где прежде применялся символ `$`, для вызова jQuery можно воспользоваться ключевым словом `jq`.

>[!tip]
>Чтобы отличать объекты jQuery и отслеживать их отдельно от объектов стандартных элементов, некоторые разработчики устанавливают символ $ в виде префикса перед любым объектом, созданным с помощью jQuery (что делает их похожими на переменные PHP!).


### Селекторы
---

После того как вы увидели, насколько просто можно включить jQuery в веб-страницу и обратиться к функциям этой библиотеки, перейдем к рассмотрению используемых в ней селекторов, которые (я уверен, что вы будете рады это узнать) работают точно так же, как CSS. По сути, их применение является основой работы большинства функций jQuery.

Вам остается лишь подумать о том, как бы вы оформили стиль одного или нескольких элементов с применением CSS, а затем можете использовать тот же самый селектор (или селекторы) для применения операций jQuery к этим выбранным элементам. Это означает, что вы можете воспользоваться селекторами элементов, селекторами идентификаторов, селекторами классов и любыми их сочетаниями.


#### Метод css
---

Чтобы объяснить применение селекторов в jQuery, сначала посмотрим на один из более фундаментальных методов jQuery, css, с помощью которого можно динамически менять любое свойство CSS. Этому методу передаются два аргумента: имя свойства, к которому осуществляется обращение, и значение, которое к этому свойству применяется:
```js
css('font-family', 'Arial')
```

Как будет показано в следующих разделах, сам по себе этот метод применять невозможно, поскольку его нужно использовать в селекторе jQuery, который выберет один или несколько элементов, чьи свойства должны быть изменены этим методом. В следующем примере содержимому всех **`<р>`**-элементов предписывается отображение с полным выравниванием по ширине:
```js
$('p').css('text-align', 'justify')
```

Метод css можно также использовать для возвращения (а не для установки) вычисленного значения, для чего ему предоставляется только имя свойства (а второй аргумент опускается). В этом случае возвращается значение первого же соответствующего селектору элемента. Например, выполнение следующего кода приведет к возвращению цвета текста того элемента, чей идентификатор (`ID`) имеет значение `elem`, и это значение будет в том же формате, в каком цвет задается при применении метода `rgb`:
```js
color = $('#elem').css('color')
```

Следует помнить, что возвращаемое значение является вычисленным. Иными словами, jQuery будет вычислять и возвращать значение, используемое браузером на момент вызова метода, а не то исходное значение, которое могло быть присвоено свойству посредством таблицы стилей или любым другим способом.

Следовательно, если текст, к примеру, показан синим цветом, значением, присвоенным переменной `color` в предыдущей инструкции, будет `rgb(0, 0, 255)`, даже если цвет изначально был установлен с использованием имени цвета `blue` или с использованием строк шестнадцатеричных чисел `#00f` или `#0000ff`. Но это вычисленное значение всегда будет в форме, которая может быть снова назначена элементу (или любому другому элементу) при использовании в качестве второго аргумента метода css.

>[!danger]
>К любым вычисленным размерам, возвращаемым этим методом, нужно относиться осмотрительно, поскольку в зависимости от текущих установок свойства `box-sizing` ([[Продвинутая стилизация страниц с помощью CSS3]]) они могут быть, а могут и не быть именно тем, что вы ожидаете получить. Когда нужно получить или установить значения ширины и высоты без учета значения свойства `box-sizing`, следует использовать методы `width` и `height` (и родственные им), рассматриваемые в разделе «Изменение размеров изображения» далее.


##### Селектор элемента
---

Для выбора элемента, обрабатываемого с помощью jQuery, нужно просто указать его имя внутри круглых скобок, следующих за символом `$` (или за именем функции jQuery). Например, если нужно изменить цвет фона всех элементов `<blockquote>`, можно воспользоваться следующей инструкцией:
```js
$('blockquote').css('background', 'lime')
```


##### Селектор идентификатора
---

Ссылаться на элементы можно также по их идентификаторам (ID), если перед именем идентификатора поместить символ `#`. Следовательно, чтобы, к примеру, добавить границу к элементу с идентификатором `advert`, можно воспользоваться такой инструкцией:
```js
$('#advert').css('border', '3px dashed red')
```


##### Селектор класса
---

Можно также воздействовать на группу элементов в соответствии с используемым ею классом. Например, для подчеркивания всех элементов, применяющих класс `new`, можно воспользоваться следующей инструкцией:
```js
$('.new').css('text-decoration', 'underline')
```


#### Сочетание селекторов
---

Как и при использовании CSS, селекторы можно сочетать друг с другом, составляя единый jQuery-выбор, для чего, как в следующем примере, применяются запятые:
```js
$('blockquote, #advert, .new').css('font-weight', 'bold')
```

В **примере 22.2** все типы селекторов собраны вместе, а инструкции jQuery выделены полужирным шрифтом. Результат выполнения кода примера показан на **рис. 22.2**.

>**Пример 22.2.** Использование jQuery с различными селекторами
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Второй пример jQuery</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <blockquote>При всей гибкости и эффективности JavaScript, а также
    при всем изобилий имеющихся в этом языке встроенных функций все же
    сохраняеться потребность в дополнительных уровнях кода, позваляющих
    упростить, к примеру, получение эффектов анимации, обработку           событий и применение технологий асинхронного обмена данными, то        есть сделать то, чего нельзя достичь применением обычных средств       JavaScript или CSS.
  </blockquote>
  <div id="advert">Это реклама</div>
  <p>Это мой <span class="new">новый</span> сайт</p>
  <script>
    $('blockquote').css('background', 'lime')
    $('#advert').css('border', '3px dashed red')
    $('.new').css('text-decoration', 'underline')
    $('blockquote, #advert, .new').css('font-weight', 'bold')
  </script>
</body> 

</html>
```
>![[Рис. 22.2. Воздействие сразу на несколько элементов.jpg]]
>**Рис. 22.2.** Воздействие сразу на несколько элементов


#### Обработка событий
---

Если бы библиотека jQuery умела только подменять CSS-стили, толку от нее было бы маловато, и она, конечно же, способна на гораздо большее. Продолжим исследование и посмотрим, как она обрабатывает события.

Как вы, наверное, помните, большинство событий инициируется действиями пользователя: при прохождении указателя мыши над элементом, щелчке кнопкой мыши или нажатии клавиши. Но существуют и другие события, которые могут инициироваться, к примеру, по завершении загрузки документа.

Прикрепить ваш собственный код к этим событиям с помощью jQuery не составит труда, причем сделано это будет безопасным способом, не блокирующим для другого кода получение такого же доступа к ним. Вот, к примеру, как можно заставить код jQuery откликнуться на щелчок на элементе:

```js
$('#clickme').click(function()
{
  $('#result').html('You clicked the button!')
})
```

Когда будет сделан щелчок на элементе с идентификатором **`clickme`**, свойство **`innerHTML`** элемента со значением ID, равным **`result`**, будет обновлено с использованием jQuery-функции **`html`**.

Конкретизация замысла, результат которой можно увидеть на **рис. 22.3**, показана в **примере 22.3**.

>[!danger]
>Объекты jQuery, созданные с помощью метода **`$`** либо метода jQuery, не являются аналогами объектов JavaScript, созданных с помощью **`getElementById`**. В обычном коде JavaScript можно использовать такие инструкции, как **`object = document.getElementById('result')`**, за которыми, к примеру, следует инструкция **`object.innerHTML = 'something'`**. Но в предыдущем примере код **`$('#result').innerHTML`** работать не будет, поскольку **`innerHTML`** не является свойством объекта jQuery. Следовательно, для достижения требуемого результата нужно использовать jQuery-метод `html`.

>**Пример 22.3.** Обработка события
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События jQuery</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>

</head>

<body>
  <button id="clickme">Нажмите меня</button>
  <p id="result">Я - абзац</p>
  <script>
    $("#clickme").click(function(){
      $("#result").html("Вы нажали кнопку!")
    })
  </script> 

</body> 

</html>
```
>[!danger]
>При обращении к событию с помощью jQuery префикс on, который нужно использовать в стандартном JavaScript, следует опустить. Поэтому, к примеру, название события `onmouseover` превращается в jQuery в имя функции `mouseover`, `onclick` приобретает вид `click` и т. д.

>![[Рис. 22.3. Обработка события click.jpg]]
>**Рис. 22.3.** Обработка события `click`


#### Ожидание готовности документа
---

Поскольку тому, что достигается средствами jQuery, мы во многом обязаны весьма тесной связи этой библиотеки с объектной моделью документа — DOM, вам, прежде чем воздействовать на какие-либо части страницы, скорее всего, придется дождаться ее загрузки. Без jQuery это может быть выполнено с помощью события onload, но есть более эффективный кросс-браузерный jQuery-метод под названием `ready`, который можно вызвать для включения в работу в самый ранний из возможных моментов времени, даже раньше, чем наступит событие `onload`. ==Это означает, что jQuery может начать работать на странице намного быстрее и с минимальными задержками для пользователя.==

Чтобы воспользоваться этой возможностью, поместите свой код jQuery внутрь следующей структуры:
```js
$('document').ready(function()
{
  // Сюда нужно поместить ваш код
})
```

Теперь код будет ждать готовности документа и только после этого будет вызван методом `ready`. На самом деле можно набрать еще меньший объем кода и воспользоваться более краткой версией, показанной в **примере 22.4**.

>**Пример 22.4.** Наименьший по объему код охватывающей функции, запускаемой по готовности документа (своеобразный аналог метода `ready`)
```js
$(function()
{
  // Сюда нужно поместить ваш код
})
```

>[!danger] Остерегайтесь!
>Можно использовать альтернативный подход: помещать код JavaScript в конец каждой HTML-страницы, чтобы он выполнялся только после загрузки всего документа. Есть и менее существенное преимущество: поскольку приоритет в загрузке отдается содержимому веб-страницы, у пользователя от работы с такой страницей складывается более благоприятное впечатление.
>
>Единственная ситуация, при которой размещение сценариев в самом конце страницы может вызвать возражение, связана с тем, что документ выглядит как готовый к работе, но фактически он к ней еще не готов, или с тем, что все внешние таблицы стилей еще не загружены (реально определить это можно только тестированием), что вводит пользователей в заблуждение относительно возможности работы с документом до того, как к этому будет готов ваш сценарий. В таких случаях применяйте функцию `ready`, и все будет в порядке. Если же у вас есть сомнения, поместите свой сценарий в конец страницы и добавьте его jQuery-вызовы в функцию `ready`, и тогда вы возьмете все самое лучшее от обоих вариантов.

Если выработать привычку добавлять свои jQuery-инструкции в одну из этих двух структур, то не придется сталкиваться с тем типом ошибок, которые могут выдаваться при попытке слишком раннего обращения к DOM.


### Функции и свойства событий
---

До сих пор был показан только метод события `ready`, но в jQuery имеется несколько десятков методов событий и связанных с событиями свойств, к которым можно обратиться (их так много, что подробно рассмотреть здесь весь арсенал не представляется возможным). Но рассматриваемые далее функции и свойства относятся к наиболее востребованным и позволят вам начать их использовать в большинстве проектов. Всестороннее описание всех доступных событий можно найти на сайте api.jquery.com/category/events.



#### События `blur` и `focus`
---

Событие `blur` ==инициируется, когда фокус убирается с элемента, заставляя этот элемент выглядеть потерявшим фокус, и оно является хорошим партнером для события== `focus`. Для добавления обработчика к событию могут использоваться методы `blur` и `focus`. Если же в круглых скобках при вызове метода будут опущены все аргументы, он будут инициировать событие.

В **примере 22.5** показаны четыре поля ввода, и первое из них благодаря вызову метода `focus`, применяемого к элементу с идентификатором `first`, сразу же получает фокус. Затем ко всем элементам `input` добавляются два обработчика. Обработчик события `focus` устанавливает для этих элементов желтый фон, когда они получают фокус, а обработчик события `blur` устанавливает для них светло-серый фон, когда фокус с них убирается (у них теряется).

>**Пример 22.5.** Использование событий `focus` и `blur`
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: blur</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <h2>Щелкните в пределах и за пределах этих полей</h2>
  <input id="first"> <input><input> <input>
  <script>
    $('#first').focus()
    $('input').focus(function() { $(this).css('background', '#ff0')})
    $('input') .blur(function() { $(this).css('background', '#aaa')})
  </script>
</body>

</html>
```

>[!info] На заметку!
>Между закрывающей скобкой метода и оператором-точкой, используемым для прикрепления к нему еще одного метода, разрешается включать пробельные символы (и после точки тоже), что я и сделал в предыдущем примере, чтобы выровнять по правому краю имена событий `focus` и `blur`, находящиеся друг под другом, чтобы все остальные части инструкций также выстроились в столбец.

На **рис. 22.4** показано, как с помощью этого кода любым полям ввода, у которых когда-либо был фокус, придается светло-серый цвет фона. Если у одного из полей в данный момент имеется фокус, цвет его фона становится желтым, а не посещённые поля по-прежнему имеют белый цвет фона.

>![[Рис. 22.4. Прикрепление обработчиков к событиям blur и focus.jpg]]
>**Рис. 22.4.** Прикрепление обработчиков к событиям `blur` и `focus`


#### Ключевое слово **`this`**
---

Этот пример также служит иллюстрацией применения ключевого слова `this`. При вызове события объекту `this` передается элемент, в отношении которого это событие было инициировано, и теперь этот объект может быть передан методу `$` для обработки. Или же, поскольку он является стандартным объектом JavaScript (а не объектом jQuery), он может быть использован в качестве такого объекта. Поэтому если хотите, можете заменить следующий код:

```js
$(this).css('background', '#ff0')
```

вот этим кодом:

```js
this.style.background = '#ff0'
```


#### События **`click`** и **`dblclick`**
---

Событие **`click`** ранее уже рассматривалось, но есть также событие, предназначенное для обработки двойных щелчков. Чтобы воспользоваться любым из них, нужно прикрепить метод события к селектору jQuery, а в качестве его аргумента предоставить jQuery-метод, который будет запущен, когда это событие произойдет:

```js
$('.myclass')   .click( function() { $(this).slideUp() }) $('.myclass').dblclick( function() { $(this).hide() })
```

Здесь я решил использовать безымянные функции, но при желании вместо них можно воспользоваться функциями с именами (но не забудьте, что предоставить нужно только имя функции без круглых скобок, в противном случае она будет вызвана несвоевременно). Объекту `this` будет передано то, что и ожидалось, и он станет доступен именованной функции:

```js
$('.myclass').click(doslide)
function doslide()
{
  $(this).slideUp()
}
```

Подробное описание методов **`slideUp`** и **`hide`** дается в разделе «Специальные эффекты» далее. А сейчас просто попробуйте запустить код **примера 22.6** и сделайте одинарный либо двойной щелчок на кнопках, чтобы посмотреть, как часть из них исчезают с применением анимации (при использовании **`slideUp`**), а другие просто исчезают (при использовании **`hide`**). Результат работы кода показан на **рис. 22.5**.

>**Пример 22.6.** Прикрепления к событиям `click` и `dblclick`
```html
<!DOCTYPE html>
<html lang="ru">
  
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: click и dblclick</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <h2>Сделайте на кнопках одинарный и двойной щелчок</h2>
  <button class="myclass">Кнопка 1</button>
  <button class="myclass">Кнопка 2</button>
  <button class="myclass">Кнопка 3</button>
  <button class="myclass">Кнопка 4</button>
  <button class="myclass">Кнопка 5</button>
  <script>
    $('.myclass')   .click(function() {$(this).slideUp()})
    $('.myclass').dblclick(function() {$(this).hide()})
  </script>
</body> 

</html>
```

>![[Рис. 22.5. На кнопке 3 был сделан одинарный щелчок, и она ускользнула вверх.jpg]]
>**Рис. 22.5.** На кнопке 3 был сделан одинарный щелчок, и она ускользнула вверх


#### Событие **`keypress`**
---

Периодически возникает потребность в более тщательном контроле работы пользователя на клавиатуре, в особенности при обработке сложных форм или написании игр. В таких случаях можно воспользоваться методом **keypress**, который может быть прикреплен к любому элементу, воспринимающему клавиатурный ввод, например к полю ввода или даже самому документу.

В **примере 22.7** метод прикреплен к документу, чтобы перехватывать все нажатия клавиш, и результат его запуска показан на **рис. 22.6.**

>**Пример 22.7.** Перехват нажатия клавиш
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: keypress</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>

<body>
  <h2>Нажмите какие-нибудь клавиши</h2>
  <div id="result"></div>
  <script>
    $(document).keypress(function(event){
      key = String.fromCharCode(event.which)
      if (key >= 'a' && key <= 'z' ||
          key >= "A" && key <= 'Z' ||
          key >= "0" && key <= '9')
      {
        $('#result').html('Вы нажали: ' + key)
        event.preventDefault()
      }
    })
  </script>
</body>  

</html>
```

>![[Рис. 22.6. Обработка событий нажатия клавиш.jpg]]
>**Рис. 22.6.** Обработка событий нажатия клавиш

В этом примере следует обратить внимание на ряд особенностей, которые нужно учитывать при написании собственных обработчиков действий на клавиатуре. К примеру, поскольку браузеры возвращают для этого события разные значения, свойство **`which`** объекта `event` нормализуется библиотекой jQuery, чтобы все браузеры возвращали одни и те же коды символов. Это делается для того, чтобы можно было определить, какая клавиша была нажата.

Но значение в свойстве **`which`**, будучи кодом символа, является числом, которое можно превратить в отдельную букву, пропустив его через код **`String.fromCharCode`**. Вам этого делать не нужно, поскольку вы легко можете в своем коде откликаться на ASCII-значения. Но данный метод пригодится, когда нужно будет работать с символами.

Когда в блоке **`if`** нажатая клавиша будет распознана, код примера вставляет для производства соответствующего эффекта простую инструкцию в свойство **`innerHTML`** элемента **`<div>`**, у которого имеется идентификатор (**`ID`**) со значением `result`.

>[!danger]
>Это тот самый пример, в котором не следует использовать функцию **`document.write`**, поскольку на момент нажатия клавиши пользователем документ должен быть полностью загружен. Если **`document.write`** будет вызван для показа информации до того, как это произойдет, будет стерт весь документ. При таких обстоятельствах, как объяснялось в разделе «О функции **`document.write`**» [[Изучение JavaScript]], лучше вести запись в HTML-элемент, то есть воспользоваться неразрушающим способом предоставления пользователю обратной связи.


### Деликатное программирование
---

Ожидая пользовательского ввода, нужно решить, на какие значения следует откликаться, после чего игнорировать все остальные значения на тот случай, если к ним должен получить доступ какой-нибудь другой обработчик событий. Это будет примером деликатности, проявляемой по отношению к любой другой полезной программе, которая может находиться в рабочем состоянии (и к самому основному браузеру). Например, в предыдущем примере был выбран прием только символов в диапазонах a–z, A–Z и 0–9, а все остальные символы были проигнорированы.

Есть два способа пропуска прерываний клавиатуры к другим обработчикам (или отказа им в обработке этих прерываний). Во-первых, ничего не делать, тогда при выходе из вашего кода другие обработчики также будут все видеть и смогут реагировать на те же нажатия клавиш. Но это может привести к путанице в том случае, если из-за одного нажатия клавиши произойдет сразу несколько действий.

Альтернативный вариант применяется в том случае, если вам не нужно, чтобы событие инициировало работу других обработчиков, тогда в отношении объекта `event` можно вызвать метод **`preventDefault`**, который не допустит «всплытия» события на уровень других обработчиков.

>[!danger]
>Помещая в код вызов метода `preventDefault`, нужно проявлять особую осмотрительность, поскольку если этот вызов находится за пределами той части кода, в которой ведется обработка нажатий клавиш, это создаст препятствие для всплытия всех остальных клавиатурных событий и вы можете заблокировать пользователя от использования браузера (или как минимум от использования некоторых его возможностей).


#### Событие **`mousemove`**
---

Наиболее часто осуществляется перехват событий, связанных с использованием мыши. Щелчки кнопками мыши уже рассматривались, а теперь посмотрим на прикрепление кода к событиям перемещения указателя мыши.

Полагаю, настало время перейти к демонстрации более интересных примеров, и в **примере 22.8** я объединил простейшую программу рисования, использующую jQuery, с холстом HTML5. Хотя до [[Холсты в HTML5]] все особенности холста рассматриваться не будут, волноваться не стоит, поскольку код очень простой.

>**Пример 22.8.** Перехват событий перемещения указателя мыши и нажатия ее кнопок
```html
<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>События: обработка действий с мышью</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <style>
    #pad {
      background: #def;
      border: 1px solid #aaa;
    }
  </style>
</head> 

<body>
  <canvas id="pad" width="480" height="360"></canvas>
  <script>
    canvas = $('#pad')[0]
    context = canvas.getContext("2d")
    peandown = false
    $('#pad').mousemove(function(event){
      var xpos = event.pageX - canvas.offsetLeft
      var ypos = event.pageY - canvas.offsetTop
  
      if (peandown) context.lineTo(xpos, ypos)
      else context.moveTo(xpos, ypos)

      context.stroke()
    }) 
    $('#pad').mousedown(function(){peandown = true})
    $('#pad').mouseup(function(){peandown = false})
  </script>
</body>

</html>
```

На рис. 22.7 показано, как этот очень простой набор инструкций может использоваться для рисования линий (что может пригодиться тем, у кого есть талант к рисованию). Вот как это работает. Сначала путем ссылки на первый (с нулевым индексом) элемент селектора jQuery программа создает объект canvas:
```js
canvas = $('#pad')[0]
```

Это один из способов быстрого получения объекта jQuery и извлечения стандартного объекта элемента JavaScript. Другой способ предусматривает использование метода get:
```js
canvas = $(,#padI).get(0)
```

>![[Рис. 22.7. Перехват событий перемещения указателя мыши и нажатия ее кнопок.jpg]]
>**Рис. 22.7.** Перехват событий перемещения указателя мыши и нажатия ее кнопок

Оба способа взаимозаменяемы, но при использовании метода **`get`** есть одно преимущество: если ему не передать аргументы, он вернет все объекты элементов узла из объекта jQuery в виде массива.

В [[Холсты в HTML5]] будет рассказано, что холст всегда создается для использования специального объекта **`context`**, который сейчас и будет определен:
```js
context = canvas.getContext("2d")
```

Нужно инициализировать еще кое-что, создав булеву переменную под названием **`pendown`** (перо опущено), которая будет использоваться для отслеживания состояния кнопки мыши (с исходным значением **`false`**, поскольку перо пока что поднято):
```js
pendown = false
```

После этого холст canvas (с идентификатором pad) получает свое событие **`mousemove`**, перехватываемое показанной далее безымянной функцией, благодаря которой происходят три набора действий:
```js
$('#pad').mousemove(function(event)
{
  ...
})
```

Сначала локальным переменным **`xpos`** и **`ypos`** (они являются локальными благодаря применению ключевых слов **`var`**, хотя сейчас вместо них лучше использовать **`let`**) присваиваются значения, представляющие собой позицию указателя мыши в области холста.

Эти значения берутся из свойств jQuery `pageX` и `pageY`, которые ссылаются на смещение указателя мыши от верхнего левого угла соответствующего документа. Поэтому, так как сам холст немного смещен с этой позиции, значения смещения холста canvas (в свойствах **`offsetLeft`** и **`offsetTop`**) вычитаются соответственно из **`pageX`** и **`pageY`**:

```js
var xpos = event.pageX – canvas.offsetLeft
var ypos = event.pageY – canvas.offsetTop
```

Теперь, когда нам известно, где находится указатель мыши по отношению к холсту, в следующих двух строках кода тестируется значение переменной **`pendown`**. Если оно равно **`true`**, значит, была нажата кнопка мыши, и поэтому вызывается метод **`lineTo`** для рисования линии в текущей позиции. В противном случае перо поднято, и поэтому вызывается метод **`moveTo`**, для того чтобы просто обновить значения текущей позиции:

```js
if (pendown) context.lineTo(xpos, ypos)
else context.moveTo(xpos, ypos)
```

Затем вызывается метод **`stroke`** для применения той команды рисования, которая только что была вызвана по отношению к холсту. Эти пять строк — все, что нужно для управления рисованием, но следует по-прежнему отслеживать состояние кнопки мыши, и поэтому завершающие две строки кода перехватывают события **`mousedown`** и **`mouseup`**, устанавливая для **`pendown`** значение **`true`** при нажатии кнопки мыши и **`false`** при ее освобождении:

```js
$('#pad').mousedown(function() { pendown = true } )
$('#pad') .mouseup(function() { pendown = false } )
```

В этом примере показано сочетание работающих вместе трех разных обработчиков событий для создания полезной программы, использующей как локальные переменные для внутренних выражений, так и глобальные переменные, где объект или состояние чего-либо должны быть сделаны доступными нескольким функциям.


#### Другие события, связанные с мышью
---

События **`mouseenter`** и **`mouseleave`** инициируются при прохождении указателя мыши над элементом или при выходе его за границы элемента. Позиционные значения не предоставляются, поскольку предполагается, что вам просто требуется принять логическое решение о том, что делать при выдаче одного из этих событий.

В **примере 22.9** к этим событиям прикреплены две безымянные функции, которые, как показано на **рис. 22.8**, изменяют соответствующим образом HTML-код элемента.

>**Пример 22.9.** Определения входа указателя в границы элемента и выхода за их пределы
```html
<!DOCTYPE html>
<html>

  <head>
    <meta charset="UTF-8">
    <title>События: дальнейшая обработка событий мыши</title>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  </head>

  <body>
    <h2 id="test">Проведи надо мной указатели мыши</h2>
    <script>
      $('#test').mouseenter(function() {$(this).html('Эй, прекрати                                                          щекотать!')})
      $('#test').mouseleave(function() {$(this).html('Куда же ты                                                            подевался?')})
    </script>
  </body>

</html>
```
