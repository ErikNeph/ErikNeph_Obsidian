---
date of creation: 2024-07-15T16:24:00
tags:
  - HTML
  - HTML5
  - Properties
  - Web
  - Web/HTML
  - IT
  - IT/WEB
read status: true
aliases:
  - другие свойства HTML5
---
---
# Другие свойства HTML5


В этой последней главе из тех, что посвящены HTML5, будут рассмотрены вопросы использования геолокации, локального хранилища и продемонстрированы приемы перетаскивания. Также мы поговорим о том, как настраивать и использовать веб-процессы и задействовать обмен сообщениями между документами.

Строго говоря, большинство из этих свойств (как и многое другое в HTML5) реально не является расширениями HTML, поскольку доступ к ним осуществляется с помощью JavaScript, а не с помощью разметки HTML. Это просто технологии, которые были добавлены разработчиками браузеров и которым было дано общее удобное название HTML5.

Но это означает, что для их правильного применения вам нужно иметь полное представление о [[Изучение JavaScript|JavaScript]].


## Геолокация и служба GPS
---

[[GPS]] (Global Positioning System) состоит из множества спутников, находящихся на земной орбите, с точно известными позициями. Когда устройство, применяющее GPS, устанавливает связь со спутниками, различия во времени прихода сигналов от них позволяют устройству точно определить свое местоположение. Поскольку скорость света (а следовательно, и радиоволн) — известная постоянная величина, время, затрачиваемое сигналом на то, чтобы добраться от спутника до устройства GPS, показывает расстояние до этого спутника.

С учетом разной задержки сигналов от разных спутников, для которых имеются точные сведения об их орбитальном местоположении в любой заданный момент времени, простое триангуляционное вычисление дает устройству сведения о его позиции относительно спутников с точностью до нескольких метров или даже выше.

Во многих мобильных устройствах, таких как телефоны или планшетные компьютеры, имеются модули GPS, и они могут предоставить информацию о местоположении устройства. Но в одних устройствах таких чипов нет, в других они могут быть выключены, а третьи могут использоваться внутри помещений, будучи закрытыми от спутников GPS, и поэтому не смогут получать какие-либо сигналы. В таких случаях для попытки определения местоположения устройства можно применять дополнительные технологии.

>[!danger]
>Следует также предупредить о защите информации при применении геолокации, особенно если используемое приложение в рамках своей работы передает координаты вашего устройства на сервер. У любого приложения с функциями геолокации должна быть явно выраженная политика соблюдения конфиденциальности. Кстати, с технической точки зрения геолокация фактически не относится к стандарту HTML5. Это автономная функция, определенная консорциумом W3C/WHATWG, но по мнению большинства, она считается частью HTML5.


### Другие методы определения местоположения
---

Если ваше устройство подключено к мобильной сети, но не имеет встроенного GPS, его местоположение можно определить по сигналам, полученным от нескольких базовых станций (местоположение которых известно достаточно точно), с которыми устройство может обменяться данными.

Если есть несколько базовых станций, местоположение может быть получено почти с такой же точностью, как и от GPS. Но если станция только одна, то для определения приблизительного радиуса вокруг нее можно использовать уровень сигнала, а получившаяся окружность представит район, в котором вы, скорее всего, находитесь. Точность определения вашего местоположения будет варьировать от двух-трех километров до нескольких десятков метров.

При отсутствии и этой возможности вам помогут точки доступа Wi-Fi, чьи позиции известны в диапазоне работы вашего устройства. Поскольку у всех точек доступа имеются уникальные идентификационные адреса, называемые [[MAC-адрес |MAC-адресами]] (Media Access Control), можно получить достаточно хорошие приблизительные данные о местоположении, возможно, в пределах одной-двух улиц. Этот тип информации собирают машины просмотра улиц Google Street View Vehicles (от применения некоторых из них со временем пришлось отказаться из-за потенциального нарушения прав на соблюдение конфиденциальности данных).

Если и этой возможности не окажется, можно будет запросить IP-адрес вашего устройства и воспользоваться им как грубым индикатором вашего местоположения. Но чаще всего предоставляется место основного коммутатора, принадлежащего вашему Интернет-провайдеру, которое может быть удалено от вас на десятки и даже сотни километров. На самый крайний случай ваш [[IP-адрес]] может (в большинстве случаев) уточнить страну, а иногда и регион, в котором вы находитесь.

>[!info]
>IP-адреса часто применяются медиакомпаниями для территориальных ограничений по проигрыванию их контента. Но можно очень просто настроить прокси-серверы, использующие перенаправленный IP-адрес (на территории, которая блокирует доступ извне) для извлечения и передачи контента через блокаду непосредственно «иностранному» браузеру. Прокси-серверы также часто применяют для скрытия реального IP-адреса пользователя или для обхода цензурных ограничений. Они могут совместно применяться многими пользователями, к примеру, через точки подключения Wi-Fi. Поэтому если вы определили чье-то местонахождение по IP-адресу, нельзя быть абсолютно уверенными в идентификации правильного региона или даже страны и эту информацию нужно воспринимать только как предположение.


### Геолокация и HTML5
---

В [[Введение в HTML5|HTML5 немного базы]] я коротко описал имеющуюся в HTML5 геолокацию. Теперь настало время взглянуть на нее пристальнее, как показано в **примере 28.1.**

>**Пример 28.1.** Вывод карты с учетом местоположения пользователя
```html
<!DOCTYPE html>
<html> <!-- geolocation.html -->
  <head>
    <title>Geolocation Example</title>
  </head>
  <body>
    <script>
      if (typeof navigator.geolocation == 'undefined')
         alert("Geolocation not supported.")
      else
        navigator.geolocation.getCurrentPosition(granted, denied)

      function granted(position)
      {
        var lat = position.coords.latitude
        var lon = position.coords.longitude
        
        alert("Permission Granted. You are at location:\n\n"
          + lat + ", " + lon +
          "\n\nClick 'OK' to load Google Maps with your location")

        window.location.replace("https://www.google.com/maps/@"
          + lat + "," + lon + ",8z")
      }

      function denied(error)
      {
        var message

        switch(error.code)
        {
          case 1: message = 'Permission Denied'; break;
          case 2: message = 'Position Unavailable'; break;
          case 3: message = 'Operation Timed Out'; break;
          case 4: message = 'Unknown Error'; break;
        }

        alert("Geolocation Error: " + message)
      }
    </script>
  </body>
</html>
```

Пройдемся по этому коду и посмотрим, как он работает, начиная с раздела **`<head>`**, в котором выводится заголовок. Раздел документа **`<body>`** составлен полностью из кода JavaScript, который тут же запускается с исследования свойства **`navigator.geolocation`**. Если возвращается значение **`undefined`**, то геолокация браузером не поддерживается и появляется окно предупреждения об ошибке.

В противном случае вызывается метод **`getCurrentPosition`**, которому передаются имена двух функций: **`granted`** и **`denied`** ==(не забывайте, что, передавая только лишь имена функций, мы передаем реальный код функции, а не результат ее вызова, который передавался бы в том случае, если бы к именам функций примыкали скобки):==
```js
navigator.geolocation.getCurrentPosition(granted, denied)
```

Эти функции появляются в сценарии чуть позже и предназначены для обработки двух возможных вариантов разрешения на предоставление данных о местоположении: разрешено (**`granted`**) или отказано (**`denied`**).

Первой следует функция **`granted`**, и вход в нее осуществляется, только если к данным может быть получен доступ. В таком случае переменным **`lat`** и **`lon`** присваиваются значения, возвращаемые выполняемыми в браузере процедурами геолокации.

Затем появляется окно уведомления со сведениями о текущем местоположении пользователя. Когда пользователь нажимает кнопку **`OK`**, окно уведомления закрывается, и текущая веб-страница заменяется страницей одной из карт Google Maps. Этой странице передаются широта и долгота, возвращенные из вызова геолокации, и для нее используется увеличение поля видимости (zoom) с установленным значением **`8`**. Можно задать другой уровень увеличения, изменив в конце вызова **`window.location.replace`** значение **`8z`** на другое числовое значение, заканчивающееся буквой **`z`**.

Вывод на экран карты достигается вызовом метода **`window.location.replace`**. Результат показан на **рис. 28.1.**

>![[Рис. 28.1. Интерактивная карта, выведенная с учетом местоположения пользователя.jpg]]
>**Рис. 28.1.** Интерактивная карта, выведенная с учетом местоположения пользователя

Если в разрешении отказано (или возникла другая проблема), функцией `denied` будет выведено сообщение об ошибке, для чего ею будет показано свое собственное окно уведомления, информирующее пользователя о возникшей ошибке:

```js
switch(error.code)
{
  case 1: message = 'Permission Denied'; break;
  case 2: message = 'Position Unavailable'; break;
  case 3: message = 'Operation Timed Out'; break;
  case 4: message = 'Unknown Error'; break;
}

alert("Geolocation Error: " + message)
```

В предыдущих редакциях этой книги для встраивания карты непосредственно в веб-страницу использовалось обращение к Google Maps API, но теперь этот сервис требует от вас самих предоставления уникального ключа API, и для пользования сервисом в определенном объеме требуется оплата. Поэтому теперь в примере просто создается ссылка на Google Maps. Если же требуется вставить Google Maps в ваши веб-страницы или веб-приложения, все необходимые сведения можно найти на сайте https://developers.google.com/maps/. Разумеется, существует также множество других инструментальных средств вывода карт на страницу, например Bing Maps (https://www.bing.com/maps) и OpenStreetMap (https://www.openstreetmap.org), у которых имеются доступные вам API.

>[!info]
>Когда браузер запрашивает у хоста данные геолокации, он спрашивает разрешение у пользователя, которое тот может дать или не дать. Отказ приводит к состоянию «Доступ запрещен», когда же пользователь дал разрешение, но хост-система не в состоянии определить его местонахождение, возникает состояние «Позиция недоступна», а когда есть разрешение пользователя и хост пытается получить его позицию, но время выполнения запроса истекает, складывается ситуация «Время ожидания операции истекло».
>
>Существует еще одно условие возникновения ошибки, при котором разные сочетания платформ и браузеров позволяют пользователю отклонить диалог запроса разрешения без предоставления этого разрешения или отказа в его предоставлении, в результате чего приложение на время ожидания обратного вызова «зависает».


## Локальное хранилище
---

Cookie являются неотъемлемой частью современного интернета, потому что позволяют сайтам сохранять на каждой пользовательской машине небольшие фрагменты информации, которые могут применяться для отслеживания действий пользователя. Теперь это не воспринимается столь же зловеще, как звучит, поскольку в большинстве случаев проводимое отслеживание помогает пользователям, сохраняя имена и пароли, избавляться от необходимости регистрироваться на сайтах и в таких социальных сетях, как Twitter, Facebook и т. д.

Cookie позволяют также сохранять на локальной машине ваши предпочтения при обращении к сайту (вместо того, чтобы хранить эти предпочтения на сервере сайта) или могут использоваться для отслеживания наполнения товарной корзины при формировании заказа на сайте электронной торговли.

Конечно, они также могут использоваться более агрессивно — для отслеживания того, какие сайты посещаются чаще всего, составляя представление о ваших интересах, что позволит эффективнее направлять рекламу. Вот почему Европейский союз ввел положение о том, что «требуется предварительное информированное согласие на хранение информации, расположенной на конечном оборудовании пользователя, или на доступ к такой информации» (http://ec.europa.eu/ipg/basics/legal/cookies/index_en.htm).

Теперь подумайте с точки зрения веб-разработчика, насколько полезно может быть хранение данных на пользовательских устройствах, особенно если у вас небольшой ресурс компьютерных серверов и дискового пространства. Например, можно создавать браузерные веб-приложения и службы для редактирования текстовых документов, электронных таблиц и графических изображений, сохраняя все данные удаленно на пользовательских компьютерах, выдерживая закупочный бюджет своего сервера как можно ниже.

С пользовательской точки зрения подумайте, насколько быстрее может загружаться документ локально по сравнению с загрузкой из интернета, особенно при медленном подключении. Кроме того, вам будет намного спокойнее, если вы будете знать, что на сайте не хранятся копии ваших документов. Разумеется, полную безопасность сайта или веб-приложения гарантировать невозможно, и вы никогда не будете работать над сугубо конфиденциальными документами, используя программы (или оборудование), которые могут входить в Сеть.

В отношении документов, носящих сугубо личный характер, таких как семейные фотографии, возможно, будет комфортнее пользоваться веб-приложением, которое хранит данные локально, а не на внешнем сервере.


### Использование локального хранилища
---

Самая большая проблема при использовании [[cookie]] заключается в том, что в каждом из них можно хранить максимум 4 Кбайт данных. Cookie также должны курсировать в обоих направлениях при каждой перезагрузке страницы. И, если только ваш сервер не использует шифрование на уровне передачи данных [[TLS (Transport Layer Security)|Transport Layer Security (TLS)]], являющееся более безопасным потомком [[SSL (Secure Sockets Layer)|SSL-шифрования (Secure Sockets Layer)]], при каждой передаче cookie путешествуют в открытом виде.

==Но с появлением HTML5 у вас появляется доступ к намного более объемному локальному хранилищу (обычно, в зависимости от браузера, между 5 и 10 Мбайт на каждый домен), которое сохраняет информацию между загрузками страницы и посещениями сайта (даже после выключения и включения компьютера).== Кроме того, данные локального хранилища не отправляются на сервер при каждой загрузке страницы, и он может быть очищен пользователем, ведь, как правило, вы хотите сохранить данные и на серверах, иначе пользователь может обнаружить, что его данные исчезли, и расстроиться, даже если он очистил данные сам.

Эти данные хранятся в парах «ключ — значение». Ключ является именем, присваиваемым для ссылки на данные, а значение может содержать любой тип данных, но сохраняется в виде строки. Все данные для текущего домена уникальны, и из соображений безопасности любое локальное хранилище, созданное сайтами из других доменов, обособляется от текущего локального хранилища, которое становится недоступным любому домену, отличающемуся от того, что сохраняет данные.


#### Объект **`localStorage`**
---

==Доступ к локальному хранилищу можно получить с помощью объекта ==`localStorage`. Чтобы проверить доступность этого объекта, запрашивается его тип, позволяющий понять, был ли он определен:

```js
if (typeof localStorage == 'undefined') {
  // Локальное хранилище недоступно, нужно сообщить об этом          // пользователю и завершить работу. Или же вместо этого            // предложить сохранить данные на веб-сервере?
}
```

Можно ли обойтись без доступа к локальному хранилищу, будет зависеть от предполагаемых целей его использования, поэтому код, помещаемый в инструкцию **`if`**, зависит от вас.

Убедившись в доступности локального хранилища, можно приступить к его использованию с помощью методов **`setItem`** и **`getItem`** объекта **`localStorage`**:

```js
localStorage.setItem('loc', 'USA')
localStorage.setItem('lan', 'English')
```

Чтобы впоследствии просмотреть эти данные, необходимо передать ключ методу **`getItem`**:

```js
loc = localStorage.getItem('loc')
lan = localStorage.getItem('lan')
```

В отличие от сохранения и чтения cookie, эти методы можно вызвать в любое время, без необходимости предварительной отправки веб-сервером каких-нибудь заголовков. Сохраненные значения будут оставаться в локальном хранилище до тех пор, пока не будут уничтожены следующим образом:

```js
localStorage.removeItem('loc')
localStorage.removeItem('lan')
```

Или же можно полностью уничтожить локальное хранилище для текущего домена, вызвав метод **`clear`**:

```js
localStorage.clear()
```

В **примере 28.2** предыдущие примеры объединены в один документ, показывающий текущие значения двух ключей в появляющемся окне предупреждения, которое изначально будет иметь значение **`null`**. Затем ключи и значения сохраняются в локальном хранилище, извлекаются из него и заново показываются, на этот раз имея присвоенные значения. И наконец, ключи удаляются, а затем предпринимается попытка повторного извлечения значений, но возвращаемые значения снова равны **`null`**.

Второе из этих предупреждений продемонстрировано на **рис. 28.2.**

>![[Рис. 28.2. Чтение из локального хранилища двух ключей и их значений.jpg]]
>**Рис. 28.2.** Чтение из локального хранилища двух ключей и их значений

>**Пример 28.2**. Получение, установка и удаление данных локального хранилища
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Local Storage</title>
  </head>
  <body>
    <script>
      if (typeof localStorage == 'undefined')
      {
        alert("Local storage is not available")
      }
      else
      {
        loc = localStorage.getItem('loc')
        lan = localStorage.getItem('lan')
        alert("The current values of 'loc' and 'lan' are\n\n" +
          loc + " / " + lan + "\n\nClick OK to assign values")

        localStorage.setItem('loc', 'USA')
        localStorage.setItem('lan', 'English')
        loc = localStorage.getItem('loc')
        lan = localStorage.getItem('lan')
        alert("The current values of 'loc' and 'lan' are\n\n" +
          loc + " / " + lan +  "\n\nClick OK to clear values")

        localStorage.removeItem('loc')
        localStorage.removeItem('lan')
        loc = localStorage.getItem('loc')
        lan = localStorage.getItem('lan')
        alert("The current values of 'loc' and 'lan' are\n\n" +
          loc + " / " + lan)
      }
    </script>
  </body>
</html>
```

>[!tip]
>В локальное хранилище можно включать данные практически любого типа и сколько угодно пар «ключ — значение» вплоть до достижения доступного лимита хранения для вашего домена.


## Рабочие веб-процессы
---

*Рабочие веб-процессы* запускают на выполнение фоновые задания и хорошо подходят для длительных вычислений, которым не следует мешать пользователям заниматься другими делами. Чтобы воспользоваться рабочим веб-процессом, можно создать разделы кода JavaScript, запускаемые в фоновом режиме. В этом коде не должны устанавливаться и отслеживаться прерывания, как это приходится делать заданиям в некоторых асинхронных системах. Вместо этого при наличии чего-то, о чем нужно сообщить, ваш фоновый процесс связывается с основным кодом JavaScript путем выдачи события.

Это означает, что решать, как наиболее эффективно распределить отрезки времени, будет интерпретатор JavaScript, а вашему коду останется только позаботиться о связи с фоновой задачей при наличии передаваемой информации.

В **примере 28.3** показывается, как рабочие веб-процессы можно настроить на вычисление повторяющейся задачи в фоновом режиме: в данном случае на вычисление простых чисел.

>**Пример 28.3.** Настройка рабочего веб-процесса и обмен данными с ним
```html
<!DOCTYPE html>
<html> <!-- webworkers.html -->
  <head>
    <title>Web Workers</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    Current highest prime number:
    <span id='result'>0</span>

    <script>
      if (!!window.Worker)
      {
        var worker = new Worker('worker.js')

        worker.onmessage = function (event)
        {
          O('result').innerText = event.data;
        }
      }
      else
      {
        alert("Web workers not supported")
      }
    </script>
  </body>
</html>
```

В этом примере сначала создается элемент **`<span>`** с идентификатором **`result`**, в который будут помещены выходные данные от рабочего веб-процесса. Затем в разделе **`<script>`** с помощью пары операторов **НЕ (!!)** тестируется **`window. Worker`**. В результате, если метод **`Worker`** существует, возвращается логическое значение **`true`**, в противном случае возвращается **`false`**. Если это значение не равно **`true`**, то сообщение, выводимое в разделе **`else`**, предупреждает нас о том, что рабочие веб-процессы недоступны.

В противном случае вызовом метода **`Worker`** создается новый объект **`worker`**, которому передается имя файла **`worker.js`**. Затем к безымянной функции, которая помещает любые переданные ей сценарием **`worker.js`** сообщения в свойство  **`innerText`** ранее созданного элемента **`<span>`**, прикрепляется событие **`onmessage`** нового объекта **`worker`**.

Код самого рабочего веб-процесса сохраняется в файле **`worker.js`**, который приведен в **примере 28.4**.

>**Пример 28.4.** Рабочий веб-процесс **`worker.js`**
```js
var n = 1  

search: while (true)
{
  n += 1

  for (var i = 2; i <= Math.sqrt(n); i += 1)
  {
    if (n % i == 0) continue search
  }
  
  postMessage(n)
}
```

В этом файле переменной **`n`** присваивается значение **`1`**. Затем запускается бесконечный цикл с увеличением значения **`n`** на единицу и проверкой значения «в лоб» на принадлежность к простым числам. При этом тестируются все значения от **`1`** до корня квадратного из **`n`** для проверки, делится ли **`n`** на них без остатка. Если сомножитель будет найден, то команда **`continue`** тут же останавливает лобовую атаку, поскольку число не является простым, и начинает обработку снова в отношении следующего более высокого значения **`n`**.

Но если все возможные сомножители будут протестированы и не будет найден результат с нулевым остатком, то n должно быть простым числом, следовательно, его значение передается функции **`postMessage`**, отправляющей сообщение событию **`onmessage`** объекта, который установил этот рабочий веб-процесс.

Результат выглядит следующим образом:

```html
Текущее самое большое простое число: 30477191
```

Чтобы остановить выполнение рабочего веб-процесса, нужно вызвать метод **`terminate`** объекта **`worker`**:

```js
worker.terminate()
```

>[!info]
>Если нужно остановить выполнение процесса в данном конкретном примере, в адресной строке браузера можно ввести такой код:
>```js
>javascript:worker.terminate()
>```
>Следует также заметить, что из-за способа решения в Chrome вопросов безопасности использовать рабочие веб-процессы в отношении файловой системы невозможно, их можно запускать только с веб-сервера (или запускать файлы из localhost на таких серверах разработки, как AMPPS, подробно рассмотренный в [[Установка сервера, предназначенного для разработки]]).

У рабочих веб-процессов имеется ряд ограничений, связанных с соблюдением мер безопасности, о которых следует знать.

- Рабочие веб-процессы запускаются в своем собственном независимом контексте JavaScript и не имеют непосредственного доступа к чему-либо в любом другом контексте выполнения кода, включая основной поток JavaScript или другие рабочие веб-процессы.
- Обмен данными между контекстами рабочих веб-процессов осуществляется посредством рассылки веб-сообщений (**`postMessage`**).
- Поскольку у рабочих веб-процессов доступа к контексту основного кода JavaScript не имеется, они не могут вносить изменения в DOM. Единственными DOM-методами, доступными рабочим процессам, являются **`atob`**, **`btoa`**, **`clearInterval`**, **`clearTimeout`**, **`dump`**, **`setInterval`** и **`setTimeout`**.
- Рабочие веб-процессы ограничены политикой единого домена, поэтому без прохождения методов безопасного обмена данными между сайтами загрузить рабочий веб-процесс из другого домена, кроме исходного, невозможно.


## Перетаскивание
---

Как показано в **примере 28.5**, поддержку перетаскивания на веб-странице можно легко организовать, добавив обработчики для событий **`ondragstart`**, **`ondragover`** и **`ondrop`**.

>**Пример 28.5.** Объекты перетаскивания
```html
<!DOCTYPE HTML>
<html> <!-- draganddrop.html -->
  <head>
    <title>Drag and Drop</title>
    <script src='OSC.js'></script>
    <style>
      #dest {
        background:lightblue;
        border    :1px solid #444;
        width     :320px;
        height    :100px;
        padding   :10px;
      }
    </style>
  </head>
  <body>
    <div id='dest' ondrop='drop(event)' ondragover='allow(event)'>     </div><br>
    Drag the images below into the above element<br><br>

    <img id='source1' src='image1.png' draggable='true'                     ondragstart='drag(event)'>
    <img id='source2' src='image2.png' draggable='true'                     ondragstart='drag(event)'>
    <img id='source3' src='image3.png' draggable='true'                     ondragstart='drag(event)'>

    <script>
      function allow(event)
      {
        event.preventDefault()
      }

      function drag(event)
      {
        event.dataTransfer.setData('image/png', event.target.id)
      }

      function drop(event)
      {
        event.preventDefault()
        var data=event.dataTransfer.getData('image/png')
        event.target.appendChild(O(data))
      }
    </script>
  </body>
</html>
```

После указания тегов **`html`**, **`title`** и загрузки файла `OSC.js` в этом документе задается стиль **`<div>`**-элементу с идентификатором **`dest`**. Для него устанавливается цвет фона, граница, размеры и отступы.

Затем в разделе **`<body>`** создается **`<div>`**-элемент и объявляются события **`ondrop`** и **`ondragover`** с прикрепленными к ним функциями-обработчиками **`drop`** и **`allow`**. После этого следует текст, а за ним выводятся три изображения, у которых для их свойств **`draggable`** установлено значение **`true`**, а к событию **`ondragstart`** каждого из них прикрепляется функция **`drag`**.

В разделе **`<script>`** функция **`allow`**, выполняющая роль обработчика события, просто предотвращает для перетаскивания выполнение действия по умолчанию (запрещая его). Функция **`drag`**, выполняющая такую же роль, вызывает метод **`setData`** объекта **`dataTransfer`**, передавая ему MIME-тип **`image/png`** и **`target.id`** события. Объект **`dataTransfer`** содержит перетаскиваемые данные в ходе самой операции перетаскивания.

И наконец, функция **`drop`**, выполняющая роль обработчика события, также перехватывает действие по умолчанию, разрешая завершить перетаскивание, а затем извлекает содержимое перетаскиваемого объекта из объекта **`dataTransfer`**, передавая при этом MIME-тип объекта. Затем освобождаемые после перетаскивания данные присоединяются к цели (к **`<div>`**-элементу с идентификатором **`dest`**), используя его метод **`appendChild`**.

Если проверить работу этого примера, можно будет перетаскивать изображения в **`<div>`**-элемент, где они и будут оставаться (**`рис. 28.3`**). Изображения не могут быть перетащены никуда, кроме элементов, к которым прикреплены обработчики событий **`drop`** и **`allow`**.

Можно прикрепить и другие события, включающие **`ondragenter`** (для запуска в тех случаях, когда при операции перетаскивания происходит вход указателя мыши в элемент), **`ondragleavefor`** (для запуска в тех случаях, когда указатель мыши покидает элемент) и **`ondragendfor`** (для запуска в тех случаях, когда операция перетаскивания завершается). Эти события можно использовать, к примеру, для изменения внешнего вида указателя мыши в ходе таких операций.


## Обмен сообщениями между документами
---

Вы уже видели обмен сообщениями немного ранее, в разделе о рабочих веб-процессах. Но в подробности там я не вдавался, поскольку веб-процессы не относились к основной рассматриваемой теме и сообщения в любом случае передавались одному и тому же документу. Однако по вполне понятным соображениям безопасности обмен сообщениями между документами должен применяться осмотрительно, то есть если вы планируете его использование, необходимо понимать, как он работает.

До появления HTML5 разработчики браузеров запрещали междокументное выполнение сценариев, но наряду с блокировкой потенциальных вредоносных сайтов запрещалась и связь между вполне законными страницами, что вынудило осуществлять взаимодействия любого рода посредством асинхронного обмена данными и сторонних веб-серверов, приводя к неоправданным сложностям и неудобствам при создании и поддержке.

Но теперь веб-обмен сообщениями позволяет сценариям взаимодействовать, преодолевая эти границы при соблюдении разумных ограничительных мер безопасности, направленных на предотвращение вредоносных попыток взлома. Это достигается путем использования метода **`postMessage`**, позволяющего отправлять простые текстовые сообщения от одного домена другому, но неизменно в одном браузере.

Для этого требуется, чтобы JavaScript сначала приобрел объект **`window`** получаемого документа, допуская отправку сообщений различным окнам, тегам **`frame`** или **`iframe`**, непосредственно связанным с документом отправителя. Событие полученного сообщения имеет следующие атрибуты:

- **`data`** — входящее сообщение;
- **`origin`** — происхождение отправителя документа, включая схему, имя хоста и порт;
- **`source`** — исходное окно отправителя документа.

Как показано в **примере 28.6**, код для отправки сообщений представляет собой одну инструкцию, в которую передается отправляемое сообщение и домен, к которому оно относится.

>**Пример 28.6.** Отправка веб-сообщений в **`iframe`**
```html
<!DOCTYPE HTML>
<html>
  <head>
    <title>Web Messaging (a)</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    <iframe id='frame' src='07.html' width='360' height='75'></iframe>

    <script>
      count = 1

      setInterval(function()
      {
        O('frame').contentWindow.postMessage('Message ' + count++,          '*')
      }, 1000)   
    </script>
  </body>
</html>
```

Здесь, как обычно, используется файл `OSC.js`, чтобы можно было взять из него функцию **`O`**. Затем создается элемент **`<iframe>`** с идентификатором **`frame`**, который загружает код **примера 28.7** (**example26-7.html**). После этого в разделе **`<script>`** переменной **`count`** присваивается начальное значение **`1`** и устанавливается интервал в одну секунду для повторяющейся отправки строки **`'Message'`** (с использованием метода **`postMessage`**) наряду с текущим значением счетчика, значение которого после этого увеличивается на единицу. Вызов **`postMessage`** прикреплен к свойству **`contentWindow`** объекта **`iframe`**, а не к самому объекту **`iframe`**. Это важно, потому что обмен веб-сообщениями требует, чтобы сообщения отправлялись в окно, а не в объект в окне.

>**Пример 28.7.** Получение сообщений от другого документа
```html
<!DOCTYPE HTML>
<html>
  <head>
    <title>Web Messaging (b)</title>
    <style>
      #output {
        font-family:"Courier New";
        white-space:pre;
      }
    </style>
    <script src='OSC.js'></script>
  </head>
  <body>
    <div id='output'>Received messages will display here</div>
    <script>
      window.onmessage = function(event)
      {
        O('output').innerHTML =
          '<b>Origin:</b> ' + event.origin + '<br>' +
          '<b>Source:</b> ' + event.source + '<br>' +
          '<b>Data:</b>   ' + event.data
      }
    </script>
  </body>
</html>
```

В этом примере производятся незначительные стилевые настройки, делающие вывод более выразительным, затем создается **`<div>`**-элемент с идентификатором **`output`**, в который будет помещено содержимое полученного сообщения. В разделе **`<script>`** находится одна безымянная функция, прикрепленная к событию **`onmessage`** объекта **`window`**. В этой функции, как показано на **рис. 28.4**, выводятся на экран значения свойств **`event.origin`**, **`event.source`** и **`event.data`**.

>![[Рис. 28.4. На данный момент iframe получил 29 сообщений.jpg]]
>**Рис. 28.4.** На данный момент iframe получил 29 сообщений

Обмен веб-сообщениями работает только между доменами, поэтому его нельзя протестировать, загружая файлы из файловой системы, и нужно воспользоваться веб-сервером (например, стеком AMPPS, предложенным в [[Установка сервера, предназначенного для разработки]]). На **`рис. 28.4`** показано, что источником является http://localhost, поскольку эти примеры запущены на локальном сервере, предназначенном для разработки. Источником является объект **`window`**, а текущим сообщением — Message 29.

Чтобы запустить это самостоятельно, просто загрузите **`06.html`** в браузер при помощи **`localhost://`**, а не из файловой системы, и он будет общаться с **`07.html`**, не требуя его загрузки, потому что он вставлен в **`iframe`**.

На данный момент **пример 28.6** нельзя признать полностью безопасным, так как в качестве значения домена, переданного **`postMessage`**, используется групповой символ **`*`**:
```js
O('frame').contentWindow.postMessage('Message ' + count++, '*')
```

Чтобы направить сообщения только тем документам, источником которых является конкретный домен, этот параметр можно изменить. В данном случае значение http://localhost обеспечит отправку сообщений только тем документам, которые были загружены с локального сервера:
```js
O('frame').contentWindow.postMessage('Message ' + count++,           'http://localhost')
```

Более того, в подобных условиях прослушивающая программа выводит абсолютно все получаемые сообщения. Такое положение дел также не отличается высоким уровнем безопасности, поскольку вредоносные документы, присутствующие в браузере, могут осуществить попытку отправки сообщений, к которым, если не предпринять мер защиты, может быть получен доступ со стороны неосмотрительно написанного кода, прослушивающего сообщения. Но вы можете ограничить круг сообщений, на которые реагирует прослушивающий код, воспользовавшись инструкцией **`if`**:

```js
window.onmessage = function(event)
{
  if (event.origin) == 'http://localhost')
  {

    O('output').innerHTML =
		'<b>Origin:</b> ' + event.origin + '<br>'
		+ '<b>Source:</b> ' + event.source + '<br>'
		+ '<b>Data:</b> ' + event.data
  }
}
```

Как правило, значения **`origin`** и **`source`** пользователю не показываются, они используются лишь для проверок, связанных с обеспечением безопасности. Но в этих примерах они видны, чтобы помочь вам провести эксперименты с обменом веб-сообщениями и разобраться в том, что происходит. С помощью этого метода документы в появляющихся окнах и других вкладках могут обмениваться данными, не прибегая к использованию **`iframes`**.

>[!danger]
>Если для сайта, с которым ведется работа, всегда используется надлежащий домен, ваш обмен веб-сообщениями будет безопаснее. Тем не менее следует помнить, что поскольку сообщения отправляются в открытом виде, в отношении некоторых браузеров или их дополнительных модулей могут быть сомнения насчет защищенности этой разновидности обмена данными. Тогда одним из способов повышения безопасности будет использование системы шифрования для всех ваших веб-сообщений, а также рассмотрение вопроса введения собственных двусторонних протоколов связи для проверки подлинности каждого сообщения.


## Другие теги HTML5
---

В HTML5 появилось несколько других новых тегов, внедренных во все основные браузеры, это: **`<article>`**, **`<aside>`**, **`<details>`**, **`<figcaption>`**, **`<figure>`**, **`<footer>`**, **`<header>`**, **`<hgroup>`**, **`<mark>`**, **`<menuitem>`**, **`<meter>`**, **`<nav>`**, **`<output>`**, **`<progress>`**, **`<rp>`**, **`<rt>`**, **`<ruby>`**, **`<section>`**, **`<summary>`**, **`<time>`** и **`<wbr>`**. Дополнительную информацию об этих и других тегах HTML5 можно получить по адресу https:// tinyurl.com/htmltaglist.

На этом введение в HTML5 завершается. Теперь в вашем распоряжении имеется множество новых эффективных средств, придающих сайтам еще больше динамичности и привлекательности. В заключительной главе будет показано, как можно собрать воедино все описанные в книге различные технологии для создания небольшого сайта социальной сети.


## Вопросы
---

- [x] 1. Какой метод нужно вызвать для запроса геолокационных данных у браузера?
- [x] 2. Как определить, поддерживает ли браузер локальное хранилище?
- [x] 3. Какой метод можно вызвать, чтобы удалить все данные локального хранилища для текущего домена?
- [x] 4. Какой способ считается наилучшим для связи рабочих веб-процессов с основной программой?
- [x] 5. Каким образом можно воспрепятствовать запуску рабочего веб-процесса?
- [?] 6. Как предотвратить действие по умолчанию, не позволяющее перетаскивание для событий, и в результате обеспечить поддержку операций перетаскивания?
- [x] 7. Как сделать обмен сообщениями между документами более безопасным?


---