---
date of creation: 2024-07-15T11:55:00
tags:
  - HTML
  - HTML5
  - IT
  - IT/WEB
  - Developing
  - Web
  - Web/HTML
read status: true
aliases:
---
---
# Холсты в HTML5


Хотя новым веб-технологиям в HTML5 даются обобщенные названия, все они не являются простыми HTML-тегами и свойствами. Это также относится к элементам canvas (холст). Да, холст создается с помощью тега **`<canvas>`**, и ему могут быть предоставлены ширина и высота, и их можно немного изменять с помощью CSS, но для записи в холст (или для чтения из него) нужно использовать JavaScript.

Хорошо, что для этого нужны лишь минимальные знания JavaScript и реализовать задуманное весьма просто. Кроме того, в [[Доступ к CSS из JavaScript]] я уже предоставлял вам набор из трех готовых к использованию функций (в файле `OSC.js`), с помощью которых доступ к таким объектам, как холсты, существенно упрощается. Итак, углубимся в эту тему и приступим к использованию нового тега **`<canvas>`**.


## Создание холста и доступ к нему
---

В [[Введение в HTML5]] показывалось, как нарисовать простую окружность для отображения японского флага, я повторно использую это в **примере 26.1.** Теперь посмотрим, что именно происходит.

>**Пример 26.1.** Отображение японского флага с помощью холста
```html
<!DOCTYPE html>
<html>
  <head>
    <title>The HTML5 Canvas</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    <canvas id='mycanvas' width='320' height='240'>
      This is a canvas element given the ID <i>mycanvas</i>
      This text is only visible in non-HTML5 browsers
    </canvas>
    <script>
      canvas            = O('mycanvas')
      context           = canvas.getContext('2d')
      context.fillStyle = 'red'
      S(canvas).border  = '1px solid black'

      context.beginPath()
      context.moveTo(160, 120)
      context.arc(160, 120, 70, 0, Math.PI * 2, false)
      context.closePath()
      context.fill()
    </script>
  </body>
</html>
```

Естественно, сначала помещается объявление **`<! DOCTYPE html>`**, чтобы сообщить браузеру о том, что документ будет использовать HTML5. После этого выводится заголовок и загружаются три функции, находящиеся в файле `OSC.js`.

В теле документа определяется элемент **`canvas`**, которому дается идентификатор **`mycanvas`**, и задаются ширина и высота 320 × 240 пикселов. Текст холста, как уже говорилось в предыдущей главе, не будет появляться в браузерах, поддерживающих элемент холста, он будет виден в окнах устаревших браузеров, не поддерживающих холсты.

Затем следует раздел JavaScript, в котором задаются стили и прорисовки холста. Начало создания объекта **`canvas`** обозначено вызовом функции **`O`** в отношении элемента **`canvas`**. Как вы помните, в результате этого вызывается функция **`document.getElementById`**, и, следовательно, это лишь более короткий способ ссылки на элемент.

Все это вы уже видели раньше, а затем следует нечто новое:
```js
context = canvas.getContext('2d')
```

Команда вызывает метод **`getContext`** нового, только что созданного объекта **`canvas`**, запрашивая двумерный доступ к холсту путем передачи значения **`2d`**.

>[!danger]
>Если нужно отобразить на холсте трехмерную графику, можно либо провести математические вычисления самостоятельно и «подделать» ее в режиме отображения двумерной графики, либо воспользоваться библиотекой [[WebGL]] (основанной на технологии OpenGL ES), и в этом случае нужно будет для нее создать переменную **`context`** путем вызова метода **`canvas.getContext('webgl')`**. Для более подробного рассмотрения данного вопроса здесь нет места, но отличное руководство имеется на https://webglfundamentals.org. Кроме того, можно обратиться к библиотеке **`Three.jsJavaScript`** (https://threejs.org/), в которой также используется **WebGL**.

Вооружившись данным содержимым в контексте объекта, мы начнем выдавать последующие команды рисования, установив для свойства **`fillStyle`** этого контекста значение **`red`**:
```js
context.fillStyle = 'red'
```

Затем вызывается функция **`S`** для установки свойству **`border`** объекта **`canvas`** значения однопиксельной сплошной черной линии для очертания изображения флага:
```js
S(canvas).border = '1px solid black'
```

После того как все будет готово, открывается путь контекста и позиция рисования перемещается к точке с координатами (160, 120):

```js
context.beginPath()
context.moveTo(160, 120)
```

Затем рисуется дуга с центром, имеющим данные координаты. Ее радиус 70 пикселов, она начинается с угла 0° (что является правым краем окружности, если смотреть прямо на нее) и продолжается по всей окружности в радианах, определяемых значением 2π:
```js
context.arc(160, 120, 70, 0, Math.PI * 2, false)
```

Последнее значение **`false`** служит признаком направления рисования дуги по часовой стрелке а значение **`true`** было бы признаком рисования, осуществляемого против часовой стрелки.

И наконец, мы закрываем путь и осуществляем его заливку, используя предопределенное значение в свойстве **`fillStyle`**, которое мы несколькими строками ранее установили в **`red`**:
```js
context.closePath() context.fill ()
```

Результат загрузки этого документа в браузер показан в предыдущей главе на **[[Введение в HTML5#^89304c|рис. 25.1]]**.


### Функция **`toDataURL`**
---

При создании изображения на холсте иногда требуется получить его копию, возможно, для его повторения на веб-странице, для сохранения в локальном хранилище или для выкладки на веб-сервер. В частности, удобство копирования предопределено невозможностью сохранения пользователем изображения с холста путем его перетаскивания.

Чтобы проиллюстрировать, как это делается, к предыдущему примеру было добавлено несколько строк кода (выделенных полужирным шрифтом в **примере 26.2**). Здесь создается новый элемент **`<img>`** с идентификатором **`myimage`**, ему дается сплошная черная граница, а затем в элемент **`<img>`** копируется изображение холста (**рис. 26.1**).

>**Пример 26.2.** Копирование изображения холста
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Copying a Canvas</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    <canvas id='mycanvas' width='320' height='240'>
      This is a canvas element given the ID <i>mycanvas</i>
      This text is only visible in non-HTML5 browsers
    </canvas>

    <img id='myimage'>

    <script>
      canvas            = O('mycanvas')
      context           = canvas.getContext('2d')
      context.fillStyle = 'red'
      S(canvas).border  = '1px solid black'

      context.beginPath()
      context.moveTo(160, 120)
      context.arc(160, 120, 70, 0, Math.PI * 2, false)
      context.closePath()
      context.fill()

      S('myimage').border = '1px solid black'
      O('myimage').src    = canvas.toDataURL()
    </script>
  </body>
</html>
```
>![[Рис. 26.1. Изображение справа скопировано с холста, показанного слева.jpg]]
>**Рис. 26.1.** Изображение справа скопировано с холста, показанного слева

Если вы проверите этот код в работе, то заметите, что при отсутствии возможности перетаскивания изображения холста, показанного слева, правостороннее изображение можно перетаскивать. Его также можно сохранить в локальном хранилище или выложить на веб-сервер, используя соответствующий код JavaScript (а с серверной стороны — код PHP).


#### Указание типа изображения
---

При создании изображения из холста можно указать тип того изображения, которое требуется вывести за пределы холста, выбирая из [[JPEG]] (файлы с расширением .`jpg` или `.jpeg`) либо [[PNG]] (файлы с расширением `.png`). По умолчанию используется тип PNG (`'image/png'`), но если по каким-то причинам вам нужен JPEG, следует изменить вызов `toDataURL`. Одновременно с этим можно указать степень сжатия в диапазоне от 0 (для самого низкого качества) до 1 (для самого высокого качества). В следующем коде используется степень сжатия 0.4, позволяющая сгенерировать подходящее изображение, которое будет неплохо выглядеть при небольшом размере файла:

```js
O('myimage').src = canvas.toDataURL('image/jpeg', 0.4)
```

>[!danger]
>Следует учесть, что метод **`toDataURL`** применяется к объекту холста, а не к любому контексту, созданному из этого объекта.

Теперь, когда вы знаете, как создаются изображения холста с их последующим копированием или использованием в каком-нибудь другом качестве, настало время посмотреть на отдельные доступные команды рисования, начиная с команд, относящихся к прямоугольникам.


#### Метод **`fillRect`**
---

==Существуют три разных метода, вызываемых для рисования прямоугольников==, первым из которых является **`fillRect`**. Чтобы им воспользоваться, нужно просто предоставить левую верхнюю координату вашего прямоугольника, а за ней ширину и высоту в пикселах:

```js
context.fillRect(20, 20, 600, 200)
```

По умолчанию прямоугольник будет залит черным цветом, но можно воспользоваться любым другим оттенком, выдав команду, похожую на следующую, где аргументом может послужить любой приемлемый CSS-цвет, указанный по названию или по значению:

```js
context.fillStyle = 'blue'
```


#### Метод **`clearRect`**
---

Можно также нарисовать прямоугольник, в котором все его цветовые значения (красная, зеленая, синяя составляющие и альфа-прозрачность) установлены в **`0`**, как в следующем примере кода, где используется тот же порядок координат и аргументы ширины и высоты:

```js
context.clearRect(40, 40, 560, 160)
```

После применения метода **`clearRect`** новый прозрачный прямоугольник удалит все цвета из закрываемой им области, оставив только любой исходный CSS-цвет, который был применен к элементу холста.


#### Метод **`strokeRect`**
---

Когда нужен лишь контур прямоугольника, можно обратиться к команде, похожей на показанную ниже, в которой будет использована установка по умолчанию на черный цвет или же выбранный цвет обводки:

```js
context.strokeRect(60, 60, 520, 120)
```

Для смены цвета можно сначала выдать команду, подобную следующей, предоставив ей в качестве аргумента любой приемлемый CSS-цвет:

```js
context.strokeStyle = 'green'
```


#### Сочетание всех этих команд
---

В **примере 26.3** предыдущие команды рисования прямоугольников объединены для вывода изображения, приведенного на **рис. 26.2**.

>**Пример 26.3.** Рисование нескольких прямоугольников
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Drawing Rectangles</title>
    <script src='OSC.js'></script>
  </head>
  <body>
    <canvas id='mycanvas' width='640' height='240'></canvas>

    <script>
      canvas               = O('mycanvas')
      context              = canvas.getContext('2d')
      S(canvas).background = 'lightblue'
      context.fillStyle    = 'blue'
      context.strokeStyle  = 'green'

      context.fillRect(  20, 20, 600, 200)
      context.clearRect( 40, 40, 560, 160)
      context.strokeRect(60, 60, 520, 120)
    </script>
  </body>
</html>
```
>![[Рис. 26.2. Рисование концентрических прямоугольников.jpg]]
>**Рис. 26.2.** Рисование концентрических прямоугольников

Чуть позже в данной главе будет показано, как можно внести последующие изменения в вывод, изменив тип и ширину обводки, но сначала обратимся к изменению заливки с применением градиентов (которые были представлены в разделе «Градиенты» [[Введение в CSS]]).


#### Метод **`createLinearGradient`**
---

Есть два разных способа применения градиента для заливки, но проще всего это сделать с помощью метода **`createLinearGradient`**. Нужно указать начальные и конечные координаты **`x`** и **`y`** относительно холста (а не заливаемого объекта). Это позволяет добиться большей утонченности.

Например, можно указать, что градиент начинается с самого левого края и заканчивается в самом правом краю холста, но применяется только в области, определенной командой заливки, что и сделано в **примере 26.4**.

>**Пример 26.4.** Применение градиентной заливки
```js
gradient = context.createLinearGradient(0, 80, 640,80) gradient.addColorStop(0, 'white')
gradient.addColorStop(1, 'black')
context.fillStyle = gradient
context.fillRect(80, 80, 480,80)
```

В этом примере создается градиентная заливка объекта по имени **`gradient`**, для чего используется метод **`createLinearGradient`** объекта **`context`**. Стартовая позиция (0, 80) находится на полпути вниз от левого края холста, а конечная позиция (640, 80) находится на полпути вниз от правого края холста.

Для создания своего собственного градиента нужно определить направление его распространения, а затем указать две точки, представляющие стартовую и конечную позиции. Независимо от того, какие значения будут предоставлены для этих точек, градиент будет выполнять плавный переход в указанном направлении, даже если точки находятся за пределами области заливки. После этого предоставляются две цветовые опорные точки, а именно: самым первым цветом градиента указывается белый, а самым последним — черный. Затем градиент будет плавно переходить между этими цветами по всему холсту слева направо.

После того как объект **`gradient`** готов, он применяется к свойству **`fillStyle`** объекта **`context`**, чтобы им мог воспользоваться завершающий вызов метода **`fillRect`**. В этом вызове заливка применяется только к центральной прямоугольной области холста, поэтому хотя градиент простирается с самого левого края к самому правому краю холста, отображаемая часть простирается лишь с 80 пикселов вовнутрь и вниз от верхнего левого угла на ширину 480 и глубину 80 пикселов. Результат (при добавлении кода к коду предыдущего примера) показан на **рис. 26.3**.

>![[Рис. 26.3. У центрального прямоугольника имеется горизонтальная градиентная заливка.jpg]]
>**Рис. 26.3.** У центрального прямоугольника имеется горизонтальная градиентная заливка

Указывая для градиента различные стартовые и конечные позиции, можно придать ему наклон для распространения в любом направлении, как показано в **примере 26.5** и отображено на **рис. 26.4.**

>**Пример 26.5.** Различные градиенты под разными углами и с разными цветами
```js
gradient = context.createLinearGradient(0, 0, 160, 0)
gradient.addColorStop(0, 'white')
gradient.addColorStop(1, 'black')
context.fillStyle = gradient
context.fillRect(20, 20, 135, 200)

gradient = context.createLinearGradient(0, 0, 0, 240) gradient.addColorStop(0, 'yellow')
gradient.addColorStop(1, 'red')
context.fillStyle = gradient
context.fillRect(175, 20, 135, 200)

gradient = context.createLinearGradient(320, 0, 480, 240) gradient.addColorStop(0, 'green')
gradient.addColorStop(1, 'purple')
context.fillStyle = gradient
context.fillRect(330, 20, 135, 200)

gradient = context.createLinearGradient(480, 240, 640, 0) gradient.addColorStop(0, 'orange')
gradient.addColorStop(1, 'magenta')
context.fillStyle = gradient
context.fillRect(485, 20, 135, 200)

```
>![[Рис. 26.4. Подборка различных линейных градиентов.jpg]]
>**Рис. 26.4.** Подборка различных линейных градиентов

В этом примере я решил поместить градиенты непосредственно в верхнюю часть заливаемых областей, чтобы более ясно показать максимальные отклонения по цвету с начала до конца.